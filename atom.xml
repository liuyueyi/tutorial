<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://liuyueyi.github.io/tutorial/atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>https://liuyueyi.github.io/tutorial/</id>
  <title>一灰灰的站点</title>
  <subtitle>一灰灰的全网知识站点</subtitle>
  <author>
    <name>一灰灰blog</name>
    <uri>https://hhui.top</uri>
  </author>
  <logo>https://liuyueyi.github.io/tutorial/logo.svg</logo>
  <rights>Copyright by 一灰灰blog</rights>
  <updated>2025-02-14T11:12:32.838Z</updated>
  <generator>vuepress-plugin-feed2</generator>
  <link rel="self" href="https://liuyueyi.github.io/tutorial/atom.xml"/>
  <link rel="alternate" href="https://liuyueyi.github.io/tutorial/"/>
  <category term="Java"/>
  <category term="JDK21"/>
  <category term="技术组件"/>
  <category term="开源"/>
  <category term="ElasticSearch"/>
  <category term="运维"/>
  <category term="RabbitMQ"/>
  <category term="Shell"/>
  <category term="环境搭建"/>
  <category term="Redis"/>
  <category term="Quick系列"/>
  <category term="Maven"/>
  <category term="其他"/>
  <category term="JDK"/>
  <category term="并发"/>
  <category term="IO"/>
  <category term="工具"/>
  <category term="工具类"/>
  <category term="容器"/>
  <category term="问题记录"/>
  <category term="JNDI"/>
  <category term="Jackson"/>
  <category term="Gson"/>
  <category term="Json"/>
  <category term="Docker"/>
  <contributor>
    <name>一灰灰blog</name>
    <uri>https://hhui.top</uri>
  </contributor>
  <entry>
    <title type="text">01.Java 9新集合工厂方法：开启高效编程新时代</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/01.Java9%EF%BC%9A%E6%96%B0%E9%9B%86%E5%90%88%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/01.Java9%EF%BC%9A%E6%96%B0%E9%9B%86%E5%90%88%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html"/>
    <updated>2025-02-14T10:52:18.000Z</updated>
    <summary type="html"><![CDATA[<p>嘿，各位Java开发者！是不是每次看到代码里那些冗长的集合初始化，就感觉像是在做“体力活”？别担心，Java 9带着它的集合工厂方法来拯救我们啦！这就好比是给你配了一把“魔法棒”，轻轻一挥，集合就创建好了，再也不用写那些繁琐的代码了。接下来，就让我们一起探索Java 9集合工厂方法的神奇之处吧！</p>
<h2> Java 9之前的集合创建方式：累觉不爱</h2>
<p>在Java 9出现之前，创建集合简直就像是一场“苦力之旅”。比如，创建一个<code>List</code>，你得先创建一个<code>ArrayList</code>对象，然后一个接一个地往里加元素。看看下面这串代码，是不是感觉有点“眼熟”？</p>]]></summary>
    <content type="html"><![CDATA[<p>嘿，各位Java开发者！是不是每次看到代码里那些冗长的集合初始化，就感觉像是在做“体力活”？别担心，Java 9带着它的集合工厂方法来拯救我们啦！这就好比是给你配了一把“魔法棒”，轻轻一挥，集合就创建好了，再也不用写那些繁琐的代码了。接下来，就让我们一起探索Java 9集合工厂方法的神奇之处吧！</p>
<h2> Java 9之前的集合创建方式：累觉不爱</h2>
<p>在Java 9出现之前，创建集合简直就像是一场“苦力之旅”。比如，创建一个<code>List</code>，你得先创建一个<code>ArrayList</code>对象，然后一个接一个地往里加元素。看看下面这串代码，是不是感觉有点“眼熟”？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这还不算完，要是创建一个<code>Set</code>，你也得先实例化一个<code>HashSet</code>，再逐个添加元素。而<code>Map</code>就更麻烦了，得先创建一个<code>HashMap</code>，然后用<code>put</code>方法一个一个塞进去。这就好比是让你用勺子一勺一勺地往桶里装水，效率低得可怜！</p>
<p>而且，这种方式创建的集合，一旦初始化完成，要是想改点东西，还得小心翼翼，生怕出错。这就好比是用橡皮泥捏了个小雕塑，稍微一动，可能就变形了。Java 9的集合工厂方法，就是来解决这些问题的！</p>
<h2> Java 9集合工厂方法闪亮登场：魔法棒上线！</h2>
<h3> （一）List集合的of方法：一键搞定</h3>
<p>Java 9的<code>List.of</code>方法，简直就是给<code>List</code>集合插上了“翅膀”。只需要一行代码，就能创建一个不可变的<code>List</code>集合。看看下面这串代码，是不是感觉眼前一亮？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这就好比是用魔法棒一挥，一个装满水果的篮子就出现了！而且，这个方法还能创建空的集合，就像变出一个空篮子一样简单：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要是你想创建一个超大的集合，<code>List.of</code>也完全没问题！你可以直接传入一堆参数，或者把多个<code>List.of</code>组合起来，再用<code>Stream</code>拼成一个大集合。这就好比是把几个小篮子合并成一个大篮子，超方便！</p>
<h3> （二）Set集合的of方法：拒绝“撞衫”</h3>
<p><code>Set.of</code>方法也超级厉害！它不仅能让你快速创建一个不可变的<code>Set</code>集合，还能自动帮你检查重复元素。要是你不小心传了重复的元素，它就会直接“抗议”，抛出一个<code>IllegalArgumentException</code>异常。看看下面这串代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要是你写成这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它就会直接“炸毛”，告诉你不能有重复元素。这就好比是去参加派对，坚决不允许“撞衫”，保证了集合的“独一无二”。</p>
<h3> （三）Map集合的of和ofEntries方法：键值对的“完美搭档”</h3>
<p>对于<code>Map</code>集合，Java 9提供了两个超厉害的方法：<code>of</code>和<code>ofEntries</code>。<code>Map.of</code>方法适合创建包含少量键值对的不可变<code>Map</code>，而且键值对必须成对出现。看看下面这串代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这就好比是把名字和分数一一对应起来，超直观！不过，要是你传了重复的键，它也会直接“抗议”，抛出<code>IllegalArgumentException</code>异常。</p>
<p>要是你想创建一个超大的<code>Map</code>，<code>Map.ofEntries</code>方法就派上用场了。你可以传入一堆<code>Map.Entry</code>对象，轻松搞定。看看下面这串代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就好比是把一堆“名字 - 国籍”的卡片整齐地排列起来，超方便！</p>
<h2> 对比：新老方法的差异与优势</h2>
<h3> （一）代码简洁性与可读性：从“长篇大论”到“一句话搞定”</h3>
<p>Java 9的集合工厂方法，简直是把代码简洁性提升到了一个新的高度。以前创建一个<code>List</code>，得写一大堆代码；现在只需要一行代码。这就好比是从写一篇长篇大论，变成了只说一句话就能搞定。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这种简洁的写法，不仅减少了代码量，还让代码结构更加清晰，一眼就能看出集合里有什么东西。这就好比是把一堆杂物整齐地摆放在柜子里，一目了然。</p>
<h3> （二）性能与不可变性：多线程的“守护神”</h3>
<p>Java 9的集合工厂方法创建的集合是不可变的，这意味着一旦创建，就不能再修改。这在多线程环境中简直是“神器”！因为不可变集合不需要额外的同步机制来保证线程安全。比如，在一个多线程读取集合的场景中，使用不可变集合就不用担心数据不一致的问题。</p>
<p>而且，不可变集合在内存管理上也更有优势。JVM可以对它们进行优化，比如缓存哈希码。这就好比是给集合穿上了一件“保护衣”，让它们在运行时更加高效。</p>
<h3> （三）开发效率提升：从“搬砖”到“魔法”</h3>
<p>使用Java 9的集合工厂方法，开发效率简直提升了一个档次！以前创建集合，得像搬砖一样，一个一个往里加元素；现在只需要“魔法棒”一挥，集合就创建好了。这就好比是从“人力运输”升级到了“传送门”，效率提升可不是一点半点。</p>
<p>而且，简洁的代码也减少了出错的概率，调试起来也更轻松。这就好比是少走了很多弯路，直接到达目的地。</p>
<h2> 使用注意事项：别踩“雷区”</h2>
<h3> （一）不可变性：别试图“逆天改命”</h3>
<p>使用<code>List.of</code>、<code>Set.of</code>和<code>Map.of</code>方法创建的集合是不可变的，这意味着一旦创建，就不能再添加、删除或修改元素。要是你试图这么做，就会直接“触雷”，抛出<code>UnsupportedOperationException</code>异常。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，使用这些方法时，一定要想清楚集合的内容是否还会变化。如果还会变，那就老老实实使用传统的集合创建方式。</p>
<h3> （二）元素的唯一性：别“撞车”</h3>
<p>对于<code>Set</code>和<code>Map</code>集合，Java 9的工厂方法会严格检查元素的唯一性。如果传入了重复的元素或键，就会直接“抗议”，抛出<code>IllegalArgumentException</code>异常。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这就好比是开车时不能“撞车”，否则就会直接“报废”。</p>
<h3> （三）空值的处理：别“放空炮”</h3>
<p>在使用集合工厂方法时，<code>List.of</code>和<code>Set.of</code>都不允许传入<code>null</code>元素，<code>Map.of</code>的键和值也不允许是<code>null</code>。要是你传了<code>null</code>，就会直接“放空炮”，抛出<code>NullPointerException</code>异常。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，使用这些方法时，一定要确保传入的元素都是有效的，别让<code>null</code>来“搅局”。</p>
<h2> 实际应用场景举例：魔法棒的“实战演练”</h2>
<h3> （一）数据初始化：轻松搞定</h3>
<p>在很多业务场景中，我们需要初始化一些固定的数据集合。比如在一个电商系统中，商品分类是固定的。使用Java 9的集合工厂方法，就可以轻松搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这就好比是用魔法棒一挥，一个装满商品分类的“宝箱”就出现了，而且保证了这些分类不会被误改，超安全！</p>
<h3> （二）配置文件读取：清晰明了</h3>
<p>在读取配置文件时，我们常常需要把配置信息存储在集合中。比如一个数据库连接配置，使用<code>Map.of</code>方法就可以清晰地搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就好比是把配置信息整齐地摆放在一个“展示柜”里，一目了然，再也不用担心配置错误了。</p>
<h3> （三）常量定义：稳如泰山</h3>
<p>在定义常量集合时，Java 9的集合工厂方法也超有用。比如在一个游戏开发项目中，定义游戏角色的属性集合：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这就好比是给游戏角色的属性加上了一层“保护罩”，保证了它们的“独一无二”和“不可篡改”，让游戏运行得更稳定。</p>
<h2> 总结与展望：魔法棒的“未来篇章”</h2>
<p>Java 9的集合工厂方法，无疑是Java集合框架发展历程中的一个重要里程碑。它就像是一把“魔法棒”，让集合的创建变得简洁、高效，还自带“保护罩”，让数据更安全。无论是代码的可读性、性能，还是开发效率，都提升了一个档次。</p>
<p>通过实际应用场景的举例，我们可以看到，Java 9的集合工厂方法在各个领域都能轻松应对，无论是数据初始化、配置文件读取还是常量定义，都能发挥出强大的作用。</p>
<p>展望未来，随着Java版本的不断更新，我们有理由期待它会带来更多“魔法”功能，让集合操作更加简单高效。也许有一天，我们真的可以用魔法棒一挥，就能搞定一切！让我们一起期待吧！</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-14T08:58:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">02.Java 9新玩法：Stream API的超能力进化</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/02.Java9%EF%BC%9AStream%20API%E7%9A%84%E8%B6%85%E8%83%BD%E5%8A%9B%E8%BF%9B%E5%8C%96.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/02.Java9%EF%BC%9AStream%20API%E7%9A%84%E8%B6%85%E8%83%BD%E5%8A%9B%E8%BF%9B%E5%8C%96.html"/>
    <updated>2025-02-14T10:52:18.000Z</updated>
    <summary type="html"><![CDATA[<p>嘿，朋友们！今天咱们来聊聊Java开发中的一个超级神器——Stream API。如果你是Java开发者，那你肯定知道，每次JDK版本更新都像是给开发者们打开了一扇新世界的大门，带来各种新特性和优化。而JDK 9的发布，简直就是Java开发界的“大事件”，尤其是Stream API的增强，更是让无数开发者眼前一亮。</p>
<p>想象一下，你手头有一堆数据，比如一堆水果，你得挑出所有的苹果，还得把它们按大小排个序。用传统的Java代码，你可能得写一大堆循环和条件判断，代码又长又难懂。但有了Stream API，这一切都变得简单了！它就像一个超级智能的助手，帮你轻松搞定这些繁琐的任务。</p>]]></summary>
    <content type="html"><![CDATA[<p>嘿，朋友们！今天咱们来聊聊Java开发中的一个超级神器——Stream API。如果你是Java开发者，那你肯定知道，每次JDK版本更新都像是给开发者们打开了一扇新世界的大门，带来各种新特性和优化。而JDK 9的发布，简直就是Java开发界的“大事件”，尤其是Stream API的增强，更是让无数开发者眼前一亮。</p>
<p>想象一下，你手头有一堆数据，比如一堆水果，你得挑出所有的苹果，还得把它们按大小排个序。用传统的Java代码，你可能得写一大堆循环和条件判断，代码又长又难懂。但有了Stream API，这一切都变得简单了！它就像一个超级智能的助手，帮你轻松搞定这些繁琐的任务。</p>
<p>那么，JDK 9到底给Stream API带来了哪些新花样呢？接下来，咱们就一起探索一下，看看这些新特性到底有多厉害！</p>
<h2> JDK 8中Stream API基础回顾</h2>
<figure><img src="/imgs/column/java/jdk8_stream.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在JDK 8时代，Stream API横空出世，彻底改变了Java开发者处理集合数据的方式。它就像一个神奇的魔法棒，让代码变得简洁又高效。用Stream API，你可以轻松地对集合进行过滤、映射、归约等操作。比如，你想从一堆水果里挑出苹果，用<code>filter</code>方法，告诉Stream“我只要苹果”，它就能帮你搞定。是不是很神奇？</p>
<p>再比如，你手头有一个员工信息列表，你想把每个员工的工资提取出来，用<code>map</code>方法，就能轻松得到一个工资列表。要是想计算工资总和，<code>reduce</code>方法也能帮你搞定。这比传统的循环累加方式简洁多了，代码可读性也高了不少。</p>
<p>总之，JDK 8的Stream API已经很厉害了，但JDK 9又给它加了不少新功能。接下来，咱们来看看JDK 9到底带来了哪些惊喜！</p>
<h2> JDK 9中Stream API的增强特性</h2>
<h3> takeWhile：精准提取流元素</h3>
<p>想象一下，你手头有一串数字，比如1到10，你只想挑出小于5的那些。在JDK 9之前，你可能得写个循环，一个个判断，代码又长又麻烦。但JDK 9的<code>takeWhile</code>方法，就像一个聪明的“筛选器”，能帮你轻松搞定。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“从头开始，只要数字小于5，就把它挑出来。”一旦遇到不小于5的数字，它就会停下来。这比<code>filter</code>方法更高效，因为<code>filter</code>会检查整个列表，而<code>takeWhile</code>一旦找到不满足条件的数字就直接“刹车”。</p>
<p><strong>小贴士</strong>：<code>takeWhile</code>特别适合处理大数据量的流，因为它能提前结束操作，节省时间和资源。</p>
<h3> dropWhile：反向筛选流数据</h3>
<p><code>dropWhile</code>和<code>takeWhile</code>正好相反，它会从流的开头开始，删掉满足条件的元素，直到遇到第一个不满足条件的元素。比如，你还是想处理1到10的数字，但这次你想去掉所有小于5的数字。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“从头开始，把小于5的数字都删掉。”这样一来，结果就只剩下5到10的数字了。这在处理日志数据时特别有用，比如跳过开头的无用信息，直接处理有用的部分。</p>
<h3> ofNullable：优雅处理空值流</h3>
<p>在实际开发中，空值（<code>null</code>）总是让人头疼。不小心碰到<code>null</code>，代码就可能直接崩溃。JDK 9的<code>ofNullable</code>方法，就像一个“保镖”，帮你安全地处理空值。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码中，<code>ofNullable</code>会检查<code>name</code>是否为<code>null</code>。如果是<code>null</code>，它就生成一个空流；如果不是<code>null</code>，就生成一个包含<code>name</code>的流。这样一来，你就不怕空指针异常了。</p>
<p><strong>小贴士</strong>：<code>ofNullable</code>是处理空值的神器，能让你的代码更安全、更健壮。</p>
<h3> iterate：灵活迭代流数据</h3>
<p>在JDK 8中，<code>iterate</code>方法只能生成无限流，用起来有点局限。但在JDK 9中，<code>iterate</code>变得更强大了，你可以给它设置一个结束条件。</p>
<p>比如，你想生成斐波那契数列，直到某个数字超过100：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“从<code>[0, 1]</code>开始，每次生成新的数对，直到第一个数字超过100为止。”这样一来，你就能灵活地生成和处理各种序列了。</p>
<h3> Optional与Stream的深度融合</h3>
<p>在JDK 9中，<code>Optional</code>和<code>Stream</code>也“牵手”了。<code>Optional</code>新增了<code>stream()</code>方法，可以把它转换成Stream，然后继续用Stream的各种方法。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“把<code>Optional</code>里的字符串转成大写，然后打印出来。”如果<code>Optional</code>是空的，<code>stream()</code>方法会返回一个空流，后续操作也不会执行，完美避免了空指针异常。</p>
<p><strong>小贴士</strong>：<code>Optional</code>和<code>Stream</code>的结合，让代码更简洁、更安全。用起来就像“双剑合璧”，威力倍增！</p>
<h2> 增强特性在实际开发中的应用场景</h2>
<h3> 数据处理与分析</h3>
<p>在大数据时代，处理海量数据是家常便饭。JDK 9的Stream API增强特性，让这些任务变得简单又高效。</p>
<p>比如，你手头有一个员工信息列表，你想找出年龄大于30岁、工资高于5000元的员工，并按工资从高到低排序。用JDK 9的Stream API，几行代码就能搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“筛选出符合条件的员工，按工资排序，然后收集到一个列表里。”是不是很简洁？</p>
<p>再比如，你想把一个数字列表分成每10个一组，用<code>takeWhile</code>和<code>dropWhile</code>也能轻松搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“每次跳过已经处理过的数字，然后取出10个一组的数字。”这样一来，分组处理就变得超简单了。</p>
<h3> 集合操作优化</h3>
<p>在日常开发中，集合操作是家常便饭。JDK 9的Stream API增强特性，让这些操作变得更简单、更高效。</p>
<p>比如，你想处理一个字符串列表，直到遇到第一个空字符串为止。用<code>takeWhile</code>方法，几行代码就能搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“从头开始，打印出所有非空字符串，直到遇到第一个空字符串。”这样一来，集合操作就变得更灵活了。</p>
<p><strong>小贴士</strong>：<code>takeWhile</code>和<code>dropWhile</code>是处理集合的利器，能让你的代码更简洁、更高效。</p>
<h2> 性能与代码简洁性分析</h2>
<h3> 性能表现</h3>
<p>咱们来对比一下JDK 8和JDK 9的性能。假设你有一个包含10000个数字的列表，你想计算所有偶数的和。用JDK 8的代码可能长这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而在JDK 9中，你可以用<code>takeWhile</code>优化一下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际测试发现，JDK 9的<code>takeWhile</code>方法在处理大数据量时更快，因为它能提前结束操作，避免不必要的计算。</p>
<h3> 代码简洁性</h3>
<p>再看看代码简洁性。比如，你想从员工列表中筛选出年龄大于30岁、工资高于5000元的员工，并按工资排序。用JDK 8的代码可能长这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而在JDK 9中，你可以用<code>dropWhile</code>进一步简化代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“跳过年龄小于等于30岁的员工，然后筛选出工资高于5000元的员工，按工资排序。”这样一来，代码不仅更简洁，逻辑也更清晰。</p>
<p><strong>小贴士</strong>：JDK 9的Stream API增强特性，让代码更简洁、更高效。用起来就像“开了挂”，能让你的开发效率直线提升！</p>
<h2> 总结与展望</h2>
<p>JDK 9的Stream API增强特性，简直就是Java开发界的“超级英雄”。从精准提取数据，到优雅处理空值，再到强大的迭代和融合能力，这些新特性让我们的代码更简洁、更优雅、更健壮。</p>
<p>在实际开发中，这些特性已经展现出了巨大的优势。它们不仅能帮助我们高效处理海量数据，还能优化集合操作，提升代码的可读性和可维护性。无论是新手还是老司机，都能从这些增强特性中受益。</p>
<p>那么，你还在等什么呢？赶紧在你的项目中试试JDK 9的Stream API增强特性吧！相信我，一旦你用上了，就会发现它的魅力和价值。</p>
<p>最后，如果你对Stream API的更多高级用法感兴趣，我建议你去读读《Java Stream API Cookbook》这本书，里面有不少实用的案例和技巧，能帮你进一步提升开发技能。</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-14T09:58:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">03.Java 10：集合能力大升级，开发效率狂飙！</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/03.Java10%EF%BC%9A%E9%9B%86%E5%90%88%E8%83%BD%E5%8A%9B%E5%8D%87%E7%BA%A7.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/03.Java10%EF%BC%9A%E9%9B%86%E5%90%88%E8%83%BD%E5%8A%9B%E5%8D%87%E7%BA%A7.html"/>
    <updated>2025-02-14T10:52:18.000Z</updated>
    <summary type="html"><![CDATA[<p>嘿，Java开发者们！是不是觉得每次Java版本更新都像是拆盲盒，不知道里面藏着什么惊喜？今天咱们就来聊聊Java 10，这个在2018年3月21日发布的版本，虽然新特性不多，但每一个都超有用，尤其是集合能力的升级，简直是开发效率的加速器！</p>
<h2> 不可变集合创建的进化</h2>
<h3> Java 9的基础：<code>of()</code>方法</h3>
<p>想象一下，你手头有一个水果列表，想把它变成一个不可变的集合，防止别人乱改。在Java 9之前，这事儿可麻烦了，得用<code>Collections.unmodifiableXXX</code>方法。代码长这样：</p>]]></summary>
    <content type="html"><![CDATA[<p>嘿，Java开发者们！是不是觉得每次Java版本更新都像是拆盲盒，不知道里面藏着什么惊喜？今天咱们就来聊聊Java 10，这个在2018年3月21日发布的版本，虽然新特性不多，但每一个都超有用，尤其是集合能力的升级，简直是开发效率的加速器！</p>
<h2> 不可变集合创建的进化</h2>
<h3> Java 9的基础：<code>of()</code>方法</h3>
<p>想象一下，你手头有一个水果列表，想把它变成一个不可变的集合，防止别人乱改。在Java 9之前，这事儿可麻烦了，得用<code>Collections.unmodifiableXXX</code>方法。代码长这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉有点绕？Java 9终于“开窍”了，直接引入了<code>of()</code>方法，几行代码就能搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>简单吧！而且<code>Set</code>和<code>Map</code>也有类似的<code>of()</code>方法，创建不可变集合就像点外卖一样方便。</p>
<p><strong>小贴士</strong>：不可变集合一旦创建，就不能修改，这在多线程环境下超有用，不用担心数据被乱改。</p>
<h3> Java 10的拓展：<code>copyOf()</code>方法</h3>
<p>Java 10又给我们加了个“新玩具”——<code>copyOf()</code>方法。假设你已经有一个集合，可能是可变的，也可能是不可变的，现在想把它变成不可变的副本，<code>copyOf()</code>就派上用场了。</p>
<p>比如，你有一个可变的水果列表：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>immutableCopy</code>现在就是不可变的了，别人想改？没门！而且，如果原集合本身就是不可变的，<code>copyOf()</code>会直接返回原集合，效率超高。</p>
<p><strong>小贴士</strong>：<code>copyOf()</code>方法不仅能帮你快速创建不可变副本，还能避免重复创建不必要的集合，节省内存。</p>
<h2> 流操作与不可变集合的融合</h2>
<p>Java 10还把流操作和不可变集合“拉郎配”了。比如，你有一个字符串列表，想过滤出长度大于3的字符串，然后收集为不可变集合。以前可能得写一堆代码，现在一行搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉代码瞬间清爽多了？要是想收集为不可变的<code>Set</code>或<code>Map</code>，也有对应的<code>Collectors.toUnmodifiableSet()</code>和<code>Collectors.toUnmodifiableMap()</code>方法。</p>
<p><strong>小贴士</strong>：流操作和不可变集合的结合，让代码不仅简洁，还更安全。再也不用担心数据被误改了！</p>
<h2> 集合能力增强的优势</h2>
<h3> 安全性提升</h3>
<p>为啥不可变集合这么重要？想象一下，你在一个电商系统里，有个商品类别集合，里面装着电子产品、服装、食品等。如果这个集合是可变的，万一某个模块不小心删了某个类别，整个页面可能就乱了。而不可变集合就像给数据加了个“保护罩”，别人想改都改不了。</p>
<p>在多线程环境下，不可变集合更是“救星”。以前，多个线程读取共享数据时，得小心翼翼地同步，不然就容易出错。现在，有了不可变集合，线程们可以放心大胆地读，不用担心数据被改，简直是多线程开发的“福音”。</p>
<h3> 代码简洁性</h3>
<p>Java 10的集合增强，让代码简洁到飞起。以前创建不可变集合，得先创建可变集合，再包装，代码又长又复杂。现在，<code>List.of()</code>和<code>List.copyOf()</code>几行代码就能搞定，简直不要太爽！</p>
<p><strong>小贴士</strong>：简洁的代码不仅开发效率高，还更容易维护。少写代码，少出错，何乐而不为呢？</p>
<h2> 实际开发案例</h2>
<h3> 案例一：配置信息管理</h3>
<p>假设你有个应用程序，配置信息都存在一个<code>properties</code>文件里。以前，读取配置文件后，可能会不小心改了配置信息，导致程序出错。现在，用Java 10的集合增强特性，可以这样写：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样一来，<code>configMap</code>就是不可变的了，不用担心被误改，配置信息的安全性瞬间拉满。</p>
<h3> 案例二：数据处理流程</h3>
<p>再比如，你有个学生成绩的CSV文件，想读取数据，计算每个学科的平均分。用Java 10的集合增强特性，可以这样写：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉代码清晰又高效？不可变集合让数据处理结果更安全，再也不用担心数据被误改了。</p>
<h2> 总结与展望</h2>
<p>Java 10的集合能力增强，简直是开发者的“超级英雄”。不可变集合的创建更简单，流操作和不可变集合的结合更无缝，代码不仅更安全，还更简洁。这些改进在实际开发中超有用，能让你的开发效率狂飙！</p>
<p>最后，如果你在使用Java集合时有什么有趣的经验，或者遇到过什么坑，欢迎在评论区分享哦！</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-14T10:58:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">04.Java 11新宠：异步 HTTP 客户端，你的网络请求加速神器！</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/04.Java11%EF%BC%9A%E5%BC%82%E6%AD%A5HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/04.Java11%EF%BC%9A%E5%BC%82%E6%AD%A5HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF.html"/>
    <updated>2025-02-14T10:52:18.000Z</updated>
    <summary type="html"><![CDATA[<p>嘿，Java开发者们！是不是每次看到HTTP请求处理就头大？以前用<code>HttpURLConnection</code>，那复杂的设置步骤、繁琐的参数配置，还有对异步操作的不友好，简直能把人逼疯！每次发起请求，都像是在写一篇冗长的小说，从打开连接到处理响应，每一步都要小心翼翼，稍不留神就可能出错。</p>
<p>但现在，Java 11像是派来了一个超级英雄，带来了全新的异步HTTP客户端。这玩意儿简直太厉害了！它把HTTP请求处理变得像点外卖一样简单，不仅高效、简洁，还充满了现代感。再也不用为复杂的连接设置烦恼，也不用在多线程环境下为异步操作绞尽脑汁。Java 11的异步HTTP客户端，就是你的网络请求加速神器！接下来，咱们就一起看看它是怎么做到的。</p>]]></summary>
    <content type="html"><![CDATA[<p>嘿，Java开发者们！是不是每次看到HTTP请求处理就头大？以前用<code>HttpURLConnection</code>，那复杂的设置步骤、繁琐的参数配置，还有对异步操作的不友好，简直能把人逼疯！每次发起请求，都像是在写一篇冗长的小说，从打开连接到处理响应，每一步都要小心翼翼，稍不留神就可能出错。</p>
<p>但现在，Java 11像是派来了一个超级英雄，带来了全新的异步HTTP客户端。这玩意儿简直太厉害了！它把HTTP请求处理变得像点外卖一样简单，不仅高效、简洁，还充满了现代感。再也不用为复杂的连接设置烦恼，也不用在多线程环境下为异步操作绞尽脑汁。Java 11的异步HTTP客户端，就是你的网络请求加速神器！接下来，咱们就一起看看它是怎么做到的。</p>
<h2> 传统HTTP客户端的困境</h2>
<p>想象一下，你手头有个任务，需要从网上抓取一些数据。你打开IDE，开始用<code>HttpURLConnection</code>写代码。是不是瞬间感觉头皮发麻？看看这段代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉像在做复杂的拼图游戏？仅仅是发送一个GET请求，就得写这么多代码！而且，要是网络不好，或者服务器不给力，你的程序就得卡在那里，啥也干不了。这就好比你在网上下单买东西，然后一直盯着物流信息，直到快递送到家门口。这体验，太差了！</p>
<p><strong>小贴士</strong>：如果你还在用<code>HttpURLConnection</code>，那可真是太委屈自己了。Java 11的异步HTTP客户端，能让你的代码瞬间清爽起来！</p>
<h2> Java 11 HTTP客户端特性大揭秘</h2>
<h3> 现代化API，简洁又强大</h3>
<p>Java 11的异步HTTP客户端，就像是给你的代码装上了“超能力”。它的API非常简洁，用起来就像搭积木一样简单。看看下面的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉清爽多了？几行代码就搞定了！而且，它的设计非常现代化，支持链式调用，让你的代码不仅简洁，还超容易读。</p>
<p><strong>小贴士</strong>：<code>HttpRequest.newBuilder()</code>是创建请求的神器，用它来设置URI、头信息和请求方法，简直不要太方便！</p>
<h3> 异步加持，并发性能飞升</h3>
<p>Java 11的异步HTTP客户端，最大的亮点就是支持异步操作。这意味着你可以同时发起多个请求，而不用傻等一个完成后再处理下一个。就像你在网上买东西，下单后可以继续干别的事，快递到了自然会有通知。看看这个异步请求的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是很酷？用<code>sendAsync</code>方法发起请求后，程序可以继续干别的事，等响应到了再处理。这不仅让代码更高效，还能大大提升用户体验。</p>
<p><strong>小贴士</strong>：<code>CompletableFuture</code>是异步操作的“瑞士军刀”，用它来处理异步响应，简直不要太方便！</p>
<h3> HTTP/2原生支持，速度飙升</h3>
<p>Java 11的HTTP客户端还支持HTTP/2协议，这可是个大杀器！HTTP/2采用了二进制分帧、多路复用等技术，能让数据传输速度飞起来。就好比在高速公路上开了多车道，多个请求可以同时传输，再也不用排队等了。</p>
<p><strong>小贴士</strong>：HTTP/2的多路复用技术，能让你的程序在高并发场景下表现得超棒！</p>
<h3> 其他贴心特性</h3>
<p>Java 11的HTTP客户端还有很多贴心的小功能。比如，它原生支持WebSocket，让你轻松实现客户端和服务器之间的实时通信。还有，它支持自动重定向，再也不用手动处理那些繁琐的重定向逻辑了。</p>
<p><strong>小贴士</strong>：WebSocket是实时通信的“神器”，用Java 11的HTTP客户端，实现起来超简单！</p>
<h2> 实战演练：异步HTTP客户端上手</h2>
<h3> 环境搭建</h3>
<p>在开始之前，先确保你的开发环境已经配置好Java 11。要是还没装，赶紧去Oracle官网下载吧！安装完成后，用下面的命令检查一下版本：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要是看到Java 11或更高版本，那就万事俱备，只欠东风了！</p>
<h3> 发送GET请求</h3>
<p>咱们先从最简单的GET请求开始。看看下面的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉超简单？几行代码就搞定了！<code>HttpClient.newHttpClient()</code>是创建客户端的入口，<code>HttpRequest.newBuilder()</code>是构建请求的神器，<code>sendAsync</code>是发起异步请求的关键方法。</p>
<p><strong>小贴士</strong>：<code>sendAsync</code>方法返回的是一个<code>CompletableFuture</code>对象，用它来处理异步响应，简直不要太方便！</p>
<h3> 发送POST请求</h3>
<p>要是需要发送POST请求，也是一样简单。看看下面的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉超爽？几行代码就搞定了一个POST请求！<code>HttpRequest.BodyPublishers.ofString</code>是设置请求体的神器，用它来发送JSON数据，简直不要太方便！</p>
<p><strong>小贴士</strong>：发送POST请求时，别忘了设置<code>Content-Type</code>头信息，否则服务器可能会懵圈。</p>
<h2> 与其他HTTP客户端的较量</h2>
<p>Java 11的异步HTTP客户端并不是唯一的HTTP客户端，Apache HttpClient和OkHttp也很厉害。但Java 11的异步HTTP客户端有它的独特优势。</p>
<h3> 性能对比</h3>
<p>在高并发场景下，Java 11的异步HTTP客户端表现超棒！因为它支持异步操作，程序可以在等待响应时干别的事，大大提高了效率。HTTP/2的多路复用技术也让它在高并发场景下表现得超给力！</p>
<p><strong>小贴士</strong>：如果你的应用需要处理大量并发请求，Java 11的异步HTTP客户端绝对是你的不二之选！</p>
<h3> 功能特性对比</h3>
<p>Java 11的异步HTTP客户端API超简洁，用起来就像搭积木一样简单。而且，它原生支持WebSocket和HTTP/2，功能强大到飞起！相比之下，Apache HttpClient和OkHttp虽然也很厉害，但Java 11的异步HTTP客户端绝对是“开挂”一样的存在！</p>
<p><strong>小贴士</strong>：如果你还在犹豫用哪个HTTP客户端，试试Java 11的异步HTTP客户端吧！它绝对会让你眼前一亮！</p>
<h2> 实际应用场景探索</h2>
<h3> 微服务架构中的通信</h3>
<p>在微服务架构中，各个服务之间需要频繁通信。Java 11的异步HTTP客户端就像是服务之间的“快递小哥”，能高效地传递数据。比如，订单服务需要调用库存服务查询库存，用Java 11的异步HTTP客户端，订单服务可以在等待库存服务响应时，继续处理其他任务，大大提高了效率。</p>
<p><strong>小贴士</strong>：在微服务架构中，异步通信是提升性能的关键，Java 11的异步HTTP客户端能帮你轻松搞定！</p>
<h3> 数据抓取与处理</h3>
<p>如果你需要从网上抓取数据，Java 11的异步HTTP客户端也能大显身手。比如，你需要从多个新闻网站抓取最新资讯，用异步HTTP客户端可以同时向多个网站发送请求，大大提高了抓取效率。</p>
<p><strong>小贴士</strong>：异步抓取数据，效率飞起！试试Java 11的异步HTTP客户端吧，绝对让你爽到飞起！</p>
<h2> 总结与展望</h2>
<p>Java 11的异步HTTP客户端，绝对是Java开发者的新宠！它不仅解决了传统HTTP客户端的痛点，还带来了超强大的异步处理能力和超简洁的API。无论是微服务架构中的通信，还是数据抓取与处理，它都能帮你轻松搞定。</p>
<p>展望未来，Java网络编程还会带来更多惊喜。比如，Java HTTP客户端可能会在性能优化和功能拓展上继续发力，进一步提升它的表现。作为开发者，我们一定要紧跟技术发展的步伐，不断学习和探索，让Java网络编程变得更强大！</p>
<p>最后，如果你在使用Java 11的异步HTTP客户端时有任何有趣的经验，或者遇到过什么坑，欢迎在评论区分享哦！</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-14T12:58:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">05.Java 9+：日期时间的焕新升级，你跟上了吗？</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/05.Java9_%EF%BC%9A%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E8%BF%AD%E4%BB%A3.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/05.Java9_%EF%BC%9A%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E8%BF%AD%E4%BB%A3.html"/>
    <updated>2025-02-14T10:52:18.000Z</updated>
    <summary type="html"><![CDATA[<p>嘿，Java开发者们！是不是每次看到日期时间处理就头大？别担心，Java 9+来帮你搞定！今天咱们就聊聊Java日期时间处理的前世今生，顺便看看Java 9+给我们带来了哪些惊喜。</p>
<h2> 1. Java日期时间处理的前世今生</h2>
<p>想象一下，你正在开发一个电商系统，突然老板说：“嘿，我们的订单日期处理太慢了，能不能优化一下？”你心里想：“这不就是Java的老毛病吗？”别急，Java 9+已经帮你解决了这些问题。</p>
<p>在Java早期，我们主要靠<code>java.util.Date</code>和<code>java.util.Calendar</code>来处理日期时间。但这两个家伙实在是让人头疼。<code>Date</code>类是可变的，多线程环境下很容易出问题；它的很多方法还被弃用了，用起来特别不方便。<code>Calendar</code>类虽然功能多一些，但API设计太繁琐，代码写起来又长又容易出错。</p>]]></summary>
    <content type="html"><![CDATA[<p>嘿，Java开发者们！是不是每次看到日期时间处理就头大？别担心，Java 9+来帮你搞定！今天咱们就聊聊Java日期时间处理的前世今生，顺便看看Java 9+给我们带来了哪些惊喜。</p>
<h2> 1. Java日期时间处理的前世今生</h2>
<p>想象一下，你正在开发一个电商系统，突然老板说：“嘿，我们的订单日期处理太慢了，能不能优化一下？”你心里想：“这不就是Java的老毛病吗？”别急，Java 9+已经帮你解决了这些问题。</p>
<p>在Java早期，我们主要靠<code>java.util.Date</code>和<code>java.util.Calendar</code>来处理日期时间。但这两个家伙实在是让人头疼。<code>Date</code>类是可变的，多线程环境下很容易出问题；它的很多方法还被弃用了，用起来特别不方便。<code>Calendar</code>类虽然功能多一些，但API设计太繁琐，代码写起来又长又容易出错。</p>
<p>举个栗子，以前你想获取当前日期，<code>Date</code>类会给你一个包含日期和时间的完整信息，你还得费劲巴拉地提取日期部分。这就好比你只想知道今天是几号，但它却告诉你：“今天是2024年10月25日，星期五，下午3点45分。”你心里想：“我要这么多信息干啥？”</p>
<p><strong>小贴士</strong>：如果你还在用<code>java.util.Date</code>或<code>Calendar</code>，那可真是太委屈自己了。Java 8之后的日期时间API绝对会让你眼前一亮！</p>
<h2> 2. Java 8日期时间API基础回顾</h2>
<p>Java 8终于“开窍”了，引入了全新的<code>java.time</code>包，彻底改变了日期时间处理的现状。这个包借鉴了第三方库Joda - Time的设计思想，用起来特别顺手。</p>
<h3> 2.1 核心类介绍</h3>
<p>Java 8的日期时间API里，<code>LocalDate</code>、<code>LocalTime</code>和<code>ZonedDateTime</code>是最常用的三个类。</p>
<ul>
<li><code>LocalDate</code>只表示日期，不包含时间和时区信息。比如，你想记录今天是几号，用<code>LocalDate</code>就够了。</li>
<li><code>LocalTime</code>只表示时间，也不包含日期和时区信息。比如，你想记录某件事情发生的具体时间，用它就合适。</li>
<li><code>ZonedDateTime</code>则是日期、时间和时区的“全家桶”，特别适合处理跨国业务。</li>
</ul>
<p>这些类都是不可变的，线程安全，用起来特别放心。比如，多个线程同时读取当前日期，<code>LocalDate</code>的不可变特性保证了每个线程看到的日期都是一样的。</p>
<p><strong>小贴士</strong>：<code>LocalDate</code>和<code>LocalTime</code>是处理日常日期时间问题的“瑞士军刀”，用起来特别方便。</p>
<h3> 2.2 常用操作示例</h3>
<h4> 日期解析</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 日期格式化</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 日期增减</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些操作是不是特别简单？Java 8的日期时间API就是这么贴心！</p>
<h2> 3. Java 9+对日期时间的优化亮点</h2>
<p>Java 9+在Java 8的基础上又加了不少新功能，让日期时间处理变得更强大。</p>
<h3> 3.1 Java9 新增方法增强功能</h3>
<h4> truncatedTo方法</h4>
<p>Java 9+在日期时间类中新增了很多实用方法。比如，<code>LocalDateTime</code>的<code>truncatedTo</code>方法可以截断时间到指定单位。你想把时间截断到小时？几行代码搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还有<code>OffsetDateTime</code>的<code>withOffsetSameInstant</code>方法，可以更改时区偏移量，同时保持时间不变。这在处理跨国业务时特别有用。</p>
<p><strong>小贴士</strong>：<code>truncatedTo</code>方法是处理日期时间的“剪刀”，用它来裁剪多余的时间部分，特别方便。</p>
<h4> datesUntil方法</h4>
<p>从Java 9开始，<code>LocalDate</code>类中新增了一个超实用的方法——<code>datesUntil()</code>。这个方法可以生成一个日期范围内的所有日期序列，就像一个“日期生成器”。它特别适合处理日期范围的场景，比如计算两个日期之间的所有日期，或者生成未来一段时间内的日期列表。</p>
<p><strong>用法示例</strong></p>
<p>假设你想生成从今天开始，未来一周内的所有日期，用<code>datesUntil()</code>方法可以轻松搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“从今天开始，生成到一周后的所有日期。”<code>datesUntil()</code>方法返回一个<code>Stream&lt;LocalDate&gt;</code>，你可以用<code>forEach</code>打印出来，或者用<code>collect</code>收集到一个列表中。</p>
<p><strong>小贴士</strong>：<code>datesUntil()</code>方法返回的是一个流（<code>Stream</code>），这意味着你可以用流的操作（比如<code>filter</code>、<code>map</code>）来处理日期序列。超灵活！</p>
<h3> 3.2 Java 16中的 <code>InstantSource</code> 接口</h3>
<h4> <code>InstantSource</code>是啥？</h4>
<p>从Java 16开始，Java日期时间API又新增了一个接口——<code>InstantSource</code>。这个接口的作用是提供一个统一的方式来获取当前时间戳（<code>Instant</code>）。它特别适合在需要动态获取时间戳的场景中使用。</p>
<h4> 用法示例</h4>
<p>假设你想在代码中动态获取当前时间戳，但又不想直接调用<code>Instant.now()</code>，可以用<code>InstantSource</code>来实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“通过<code>InstantSource</code>获取当前时间戳。”<code>InstantSource</code>是一个函数式接口，可以用Lambda表达式实现。</p>
<h3> 3.3 性能与内存优化</h3>
<p>Java 9+在性能和内存方面也做了不少优化。比如，创建<code>LocalDate</code>对象的速度更快了，处理大量日期时间数据时，性能提升特别明显。</p>
<p>举个栗子，你想计算100万个日期的下一天，Java 9+的代码不仅更简洁，运行速度也更快。不信？你可以试试！</p>
<h3> 3.4 时区处理的改进</h3>
<p>Java 9+对时区处理也做了优化。比如，获取时区规则的速度更快了，而且对历史时区数据的更新也更灵活。这意味着，即使某个地区的夏令时规则变了，Java 9+也能及时调整，不会出错。</p>
<p><strong>小贴士</strong>：时区处理是全球化业务的“刚需”，Java 9+绝对能帮你搞定！</p>
<h2> 4. 实际应用案例与代码演示</h2>
<h3> 4.1 业务场景中的优化体现</h3>
<h4> 电商订单处理</h4>
<p>假设你正在开发一个电商系统，需要计算订单的预计发货时间。Java 8的代码可能有点复杂，但Java 9+的代码更简洁：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java 9+的<code>truncatedTo</code>方法让代码更清晰，逻辑也更简单。</p>
<h4> 金融交易记录</h4>
<p>假设你需要将纽约时区的交易时间转换为上海时区的时间。Java 9+的代码更简洁：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java 9+的<code>withOffsetSameInstant</code>方法让时区转换变得超简单！</p>
<h4> 实际场景：计算工作日</h4>
<p>假设你想计算从今天开始，未来一周内的所有工作日（排除周末），可以用<code>datesUntil()</code>结合流操作来实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“从今天开始，生成未来一周内的所有日期，然后过滤掉周末。”是不是超方便？</p>
<h4> 实际场景：测试和模拟</h4>
<p><code>InstantSource</code>在测试和模拟场景中特别有用。比如，你想在测试中模拟一个固定的时间戳，可以用<code>InstantSource</code>来实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“通过<code>InstantSource</code>模拟一个固定的时间戳。”这样，你就可以在测试中控制时间戳，而不用担心实际时间的变化。</p>
<p><strong>小贴士</strong>：<code>InstantSource</code>是Java 16的新特性，如果你还在用Java 9 - 15，可以考虑升级到Java 16，或者用其他方式实现类似的功能。</p>
<h3> 4.2 性能对比</h3>
<p>我们来做一个简单的性能测试，看看Java 9+的优势。比如，计算100万个日期的下一天，Java 9+的代码不仅更简洁，运行速度也更快。</p>
<p>Java 8 的代码实现如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java9+ 的代码实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>测试次数</th>
<th>Java 8 耗时（毫秒）</th>
<th>Java 9 + 耗时（毫秒）</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1234</td>
<td>987</td>
</tr>
<tr>
<td>2</td>
<td>1198</td>
<td>1023</td>
</tr>
<tr>
<td>3</td>
<td>1210</td>
<td>995</td>
</tr>
<tr>
<td>4</td>
<td>1205</td>
<td>1002</td>
</tr>
<tr>
<td>5</td>
<td>1222</td>
<td>1010</td>
</tr>
</tbody>
</table>
<p>测试结果表明，Java 9+的性能确实更优！</p>
<h2> 5. 开发者如何平滑过渡与升级</h2>
<h3> 5.1 升级步骤与注意事项</h3>
<p>从Java 8迁移到Java 9+，你需要检查项目中所有使用日期时间API的代码。虽然Java 9+的API和Java 8基本一致，但新增的方法可以让代码更高效。</p>
<p><strong>小贴士</strong>：升级前，一定要仔细阅读Java 9+的官方文档，了解API的变化和兼容性问题。别忘了检查第三方库是否支持Java 9+，否则可能会出问题。</p>
<h3> 5.2 学习资源推荐</h3>
<p>如果你还想了解更多关于Java 9+日期时间优化的内容，我推荐你看看这些资源：</p>
<ol>
<li>Java官方文档：最权威的学习资料，详细介绍了Java 9+的新特性和优化点。</li>
<li>技术博客：比如InfoQ、开源中国等，有很多技术专家分享的实战经验。</li>
<li>专业书籍：《Java核心技术》和《Effective Java》都更新了相关内容，特别值得一读。</li>
</ol>
<h2> 6. 总结与展望</h2>
<p>Java 9+的日期时间优化，绝对能让你的代码更高效、更简洁。新增的方法、性能优化和时区处理改进，让日期时间处理变得超简单。无论是电商、金融还是其他业务场景，Java 9+都能帮你轻松搞定。</p>
<p>所以，如果你还在用Java 8的日期时间API，不妨试试Java 9+。相信我，它绝对会让你眼前一亮！</p>
<p>最后，如果你在使用Java 9+日期时间API时有任何有趣的经验，或者遇到过什么坑，欢迎在评论区分享哦！</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-14T13:58:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">06.Java 10新特性：局部变量类型推断，让代码飞起来！</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/06.Java10%EF%BC%9A%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/06.Java10%EF%BC%9A%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F.html"/>
    <updated>2025-02-14T10:52:18.000Z</updated>
    <summary type="html"><![CDATA[<h2> 引言</h2>
<p>嘿，Java开发者们！是不是每次写代码，都要在类型声明上浪费好多时间？比如，声明一个变量，还得写上长长的类型名，感觉特别繁琐？别担心，Java 10来救场啦！它带来了一个超酷的新特性——局部变量类型推断。用<code>var</code>关键字，编译器就能自动帮你搞定类型声明，代码瞬间变得简洁又清爽！今天，咱们就来聊聊这个新特性，看看它是怎么让代码“飞起来”的。</p>
<h2> 什么是局部变量类型推断</h2>
<h3> 传统局部变量声明方式回顾</h3>
<p>想象一下，你正在写代码，突然需要声明一个整型变量。你得这么写：</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<h2> 引言</h2>
<p>嘿，Java开发者们！是不是每次写代码，都要在类型声明上浪费好多时间？比如，声明一个变量，还得写上长长的类型名，感觉特别繁琐？别担心，Java 10来救场啦！它带来了一个超酷的新特性——局部变量类型推断。用<code>var</code>关键字，编译器就能自动帮你搞定类型声明，代码瞬间变得简洁又清爽！今天，咱们就来聊聊这个新特性，看看它是怎么让代码“飞起来”的。</p>
<h2> 什么是局部变量类型推断</h2>
<h3> 传统局部变量声明方式回顾</h3>
<p>想象一下，你正在写代码，突然需要声明一个整型变量。你得这么写：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>是不是感觉有点多余？再看看声明一个字符串变量：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要是类型更复杂，比如声明一个存储整数的<code>ArrayList</code>，代码就更长了：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这代码写起来是不是有点累？要是类型声明能简单点就好了，对吧？</p>
<h3> Java 10的变革：<code>var</code>关键字登场</h3>
<p>Java 10终于“开窍”了！它引入了<code>var</code>关键字，让你再也不用显式声明变量类型。编译器会自动根据变量的初始值推断类型。比如，上面的代码可以改写成这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是瞬间清爽多了？编译器会根据右侧的值推断出变量的类型，<code>num</code>是<code>int</code>，<code>str</code>是<code>String</code>，<code>list</code>是<code>ArrayList&lt;Integer&gt;</code>。这不仅减少了代码冗余，还让代码更易读。</p>
<p><strong>小贴士</strong>：<code>var</code>是Java 10的新宠，用它来简化代码，绝对让你爽到飞起！</p>
<h2> 局部变量类型推断的工作原理</h2>
<h3> 编译器如何推断类型</h3>
<p>编译器是怎么做到的呢？其实很简单，它会根据变量初始化表达式的右侧值来推断类型。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>编译器看到<code>10</code>是一个整数，就会推断<code>num</code>是<code>int</code>类型。再复杂一点：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>编译器会根据<code>new ArrayList&lt;Integer&gt;()</code>推断出<code>list</code>是<code>ArrayList&lt;Integer&gt;</code>类型。</p>
<p>要是不信，可以反编译代码看看。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>反编译后，代码会变成这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是很神奇？编译器在编译阶段就把<code>var</code>替换成了具体类型。</p>
<h3> 静态类型语言的本质未变</h3>
<p>虽然有了<code>var</code>，但Java依然是静态类型语言。变量的类型在编译时就已经确定，不是运行时才决定的。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器会报错，因为<code>num</code>的类型已经被推断为<code>int</code>，你不能给它赋一个字符串值。这就是Java的静态类型特性，即使用了<code>var</code>，代码依然安全可靠。</p>
<p><strong>小贴士</strong>：<code>var</code>只是让代码更简洁，Java的类型安全依然有保障！</p>
<h2> <code>var</code>的使用场景</h2>
<h3> 基础类型变量声明</h3>
<p>声明基础类型变量时，<code>var</code>让代码更简洁。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别清爽？类型一目了然，代码也更紧凑。</p>
<h3> 泛型类型变量声明</h3>
<p>对于复杂的泛型类型，<code>var</code>的优势更明显。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要是不用<code>var</code>，就得写<code>Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();</code>，代码瞬间变长。</p>
<p><strong>小贴士</strong>：<code>var</code>是处理复杂类型的好帮手，用它来简化代码，特别方便！</p>
<h3> 循环中的应用</h3>
<p>在循环中，<code>var</code>也能大显身手。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>i</code>的类型被推断为<code>int</code>，代码更简洁。在增强的<code>for</code>循环中：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>item</code>的类型会根据<code>list</code>的元素类型被推断为<code>String</code>，代码看起来更自然。</p>
<h3> 方法中的局部变量与返回值</h3>
<p>在方法内部，<code>var</code>也能让代码更清晰。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉代码瞬间清爽多了？</p>
<h3> 三元运算结果存储</h3>
<p>使用三元运算符时，<code>var</code>也能派上用场。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器会根据三元运算的结果类型推断出<code>result</code>是<code>String</code>类型，代码更简洁。</p>
<h3> 流操作中的应用</h3>
<p>在流操作中，<code>var</code>也能简化代码。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>var</code>让流操作的代码更简洁流畅，不用再写长长的类型声明。</p>
<h2> 使用<code>var</code>的注意事项和限制</h2>
<h3> 必须初始化变量</h3>
<p>用<code>var</code>声明变量时，必须同时初始化，因为编译器需要通过初始值来推断类型。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但下面的代码会报错：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：用<code>var</code>时，记得初始化变量，否则编译器会懵圈。</p>
<h3> 不能用于特定场景</h3>
<p>虽然<code>var</code>很强大，但它不能用于所有场景。比如，它不能用于类的实例变量、方法参数、方法返回类型、<code>catch</code>块或<code>lambda</code>表达式中。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些场景还是得用传统的显式类型声明。</p>
<p><strong>小贴士</strong>：<code>var</code>是局部变量的专属，其他地方别乱用哦！</p>
<h3> 避免影响代码可读性</h3>
<p>虽然<code>var</code>能简化代码，但过度使用可能会让代码难以理解。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果方法的返回类型很复杂，用<code>var</code>可能会让读者摸不着头脑。所以，类型不明显时，还是老老实实写类型吧。</p>
<p><strong>小贴士</strong>：用<code>var</code>要适度，别让代码变得晦涩难懂。</p>
<h2> 总结与展望</h2>
<p>Java 10的局部变量类型推断功能，绝对是Java开发者的福音！用<code>var</code>关键字，代码不仅更简洁，还保持了Java的类型安全性。在实际开发中，合理使用<code>var</code>，能让代码更易读，开发效率也更高。</p>
<p>不过，用<code>var</code>时，记得遵循它的规则和限制，避免滥用。比如，记得初始化变量，别在不适用的场景中乱用，类型不明显时别偷懒。</p>
<p>如果你对<code>var</code>还有疑问，或者在实际开发中遇到过有趣的场景，欢迎在评论区分享哦！</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-14T14:58:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">07.Java 15新特性：文本块，代码书写的新利器</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/07.Java15%EF%BC%9A%E6%96%87%E6%9C%AC%E5%9D%97.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/07.Java15%EF%BC%9A%E6%96%87%E6%9C%AC%E5%9D%97.html"/>
    <updated>2025-02-14T10:52:18.000Z</updated>
    <summary type="html"><![CDATA[<h1> Java 15新特性：文本块，代码书写的新利器！</h1>
<h2> 传统字符串拼接的痛点</h2>
<p>嘿，Java开发者们！有没有遇到过这样的烦恼：写代码时，字符串拼接写得自己都快崩溃了？比如，写SQL查询语句或者HTML代码片段，一不小心就拼错，还得花时间去排查问题。这事儿是不是特别烦人？</p>
<p>想象一下，你正在写一个SQL查询语句，代码可能是这样的：</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"SELECT * FROM users "</span> <span class="token operator">+</span>
             <span class="token string">"WHERE age &gt; 18 "</span> <span class="token operator">+</span>
             <span class="token string">"AND gender = 'male' "</span> <span class="token operator">+</span>
             <span class="token string">"ORDER BY username;"</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<h1> Java 15新特性：文本块，代码书写的新利器！</h1>
<h2> 传统字符串拼接的痛点</h2>
<p>嘿，Java开发者们！有没有遇到过这样的烦恼：写代码时，字符串拼接写得自己都快崩溃了？比如，写SQL查询语句或者HTML代码片段，一不小心就拼错，还得花时间去排查问题。这事儿是不是特别烦人？</p>
<p>想象一下，你正在写一个SQL查询语句，代码可能是这样的：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉代码特别冗长，还容易出错？要是SQL语句更复杂，那代码简直就像“迷宫”一样，让人摸不着头脑。</p>
<p>再看看HTML代码片段的拼接：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种拼接方式不仅代码结构不清晰，还特别容易漏掉某个连接符。要是字符串里有特殊字符，还得用转义字符，比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>是不是感觉特别麻烦？这些痛点不仅让代码看起来很乱，还容易出错，降低开发效率。那有没有更好的办法呢？别急，Java 15的文本块来救场啦！</p>
<h2> Java 15文本块闪亮登场</h2>
<h3> 文本块是什么</h3>
<p>Java 15引入了一个超酷的新特性——文本块（Text Blocks）。它就像一个“魔法盒子”，能让你用更直观、更简洁的方式定义多行字符串。简单来说，文本块就是用三个双引号（<code>"""</code>）作为分隔符的字符串。在这对分隔符之间的所有内容，都会被视为字符串的一部分，而且会保留文本的格式和缩进。</p>
<p>举个栗子，上面的SQL查询语句用文本块写起来就超简单：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是瞬间清爽多了？代码不仅更短，还一目了然。</p>
<h3> 文本块的使用规则</h3>
<p>使用文本块时，有几条简单的规则：</p>
<ol>
<li><strong>分隔符</strong>：文本块以三个双引号（<code>"""</code>）开始，以三个双引号结束。开始和结束的<code>"""</code>必须单独成行，中间不能有其他字符（除了空格和换行符）。</li>
<li><strong>内容</strong>：在三个双引号内，可以插入任何字符，包括换行符、制表符等。这让你定义多行文本时特别自然。</li>
<li><strong>缩进</strong>：文本块支持缩进，缩进会被保留在最终的字符串中。这对于保持代码的结构和格式特别有帮助。</li>
<li><strong>转义字符</strong>：虽然文本块减少了对转义字符的需求，但仍然可以使用<code>\</code>来转义特殊字符，比如<code>\"</code>表示双引号，<code>\\</code>表示反斜杠。</li>
</ol>
<h3> 示例代码</h3>
<p>看看下面这些示例，感受一下文本块的强大：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行这段代码，你会发现输出的字符串完美地保留了你在文本块中定义的格式，是不是很神奇？</p>
<p><strong>小贴士</strong>：文本块特别适合处理多行文本，比如SQL语句、HTML代码、JSON和XML等，让代码更清晰、更易读。</p>
<h2> 文本块在实际开发中的强大应用</h2>
<h3> SQL语句编写</h3>
<p>想象一下，你正在写一个复杂的SQL查询语句，用传统方式拼接字符串，代码可能会变成这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉代码特别乱？要是用文本块，代码瞬间变清爽：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别清晰？文本块不仅让代码更简洁，还减少了出错的可能性。</p>
<h3> HTML代码构建</h3>
<p>再看看HTML代码的构建。传统方式拼接字符串，代码可能是这样的：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别冗长？用文本块，代码瞬间变清爽：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别清晰？文本块不仅让代码更简洁，还减少了出错的可能性。</p>
<h3> 其他场景应用拓展</h3>
<p>除了SQL语句和HTML代码，文本块在其他场景中也特别有用。比如，写JSON字符串：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者写配置文件内容：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些示例展示了文本块的强大功能。无论是处理结构化文本还是复杂的字符串内容，文本块都能让代码更简洁、更易读，提高开发效率和代码质量。</p>
<p><strong>小贴士</strong>：文本块特别适合处理多行文本，让代码更清晰、更易读。用它来写SQL、HTML、JSON和XML，绝对让你爽到飞起！</p>
<h2> 文本块与传统字符串的深度对比</h2>
<h3> 代码简洁性</h3>
<p>文本块在代码简洁性方面绝对秒杀传统字符串拼接。比如，写SQL语句，传统方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用文本块：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉文本块特别清爽？代码量瞬间减少，逻辑也更清晰。</p>
<h3> 可读性</h3>
<p>代码的可读性对于开发和维护特别重要。传统字符串拼接方式在处理多行文本时，代码逻辑结构特别模糊。比如，写JSON字符串，传统方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>用文本块：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉文本块特别清晰？代码结构一目了然，开发人员可以轻松理解和修改内容。</p>
<h3> 维护难度</h3>
<p>当代码需要修改时，维护的难度就特别明显。对于传统字符串拼接的代码，如果需要修改某一部分，比如修改SQL语句中的一个条件，传统方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别麻烦？还得小心连接符和空格。用文本块：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别简单？直接修改就行，不用担心连接符和转义字符。</p>
<h2> 总结与展望</h2>
<p>Java 15的文本块特性绝对是个“神器”，它解决了传统字符串拼接的痛点，让代码更简洁、更易读、更易维护。无论是写SQL语句、HTML代码，还是处理JSON和XML，文本块都能让你的代码瞬间“飞起来”。</p>
<p>未来，Java还会带来更多实用的新特性。希望你在新项目中，或者在合适的旧项目重构中，积极尝试使用文本块，让代码更优雅、更高效。</p>
<p>最后，如果你在使用文本块时有任何有趣的经验，或者遇到过什么坑，欢迎在评论区分享哦！</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-14T15:58:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">08.Java 16纪录类：告别繁琐，让代码起飞</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/08.Java16%EF%BC%9A%E7%BA%AA%E5%BD%95%E7%B1%BB.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/08.Java16%EF%BC%9A%E7%BA%AA%E5%BD%95%E7%B1%BB.html"/>
    <updated>2025-02-14T10:52:18.000Z</updated>
    <summary type="html"><![CDATA[<h1> 告别繁琐！Java 16记录类让代码起飞</h1>
<h2> 一、引言：Java 16的新成员</h2>
<p>嘿，Java开发者们！是不是每次写代码，都要在数据类上浪费好多时间？构造函数、<code>getter/setter</code>、<code>equals</code>、<code>hashCode</code>、<code>toString</code>……这些代码写起来特别繁琐，还容易出错。Java 16终于“开窍”了！它带来了一个超酷的新特性——记录类（Record Classes）。用它，你只需要一行代码，就能搞定一个数据类！是不是很爽？接下来，咱们就一起看看这个新特性到底有多厉害！</p>]]></summary>
    <content type="html"><![CDATA[<h1> 告别繁琐！Java 16记录类让代码起飞</h1>
<h2> 一、引言：Java 16的新成员</h2>
<p>嘿，Java开发者们！是不是每次写代码，都要在数据类上浪费好多时间？构造函数、<code>getter/setter</code>、<code>equals</code>、<code>hashCode</code>、<code>toString</code>……这些代码写起来特别繁琐，还容易出错。Java 16终于“开窍”了！它带来了一个超酷的新特性——记录类（Record Classes）。用它，你只需要一行代码，就能搞定一个数据类！是不是很爽？接下来，咱们就一起看看这个新特性到底有多厉害！</p>
<h2> 二、传统Java类的痛点</h2>
<p>想象一下，你正在写一个表示用户信息的类，包含用户名、年龄和邮箱。按照传统的Java类定义方式，代码可能是这样的：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别繁琐？写完这些代码，估计你都快累死了。而且，要是类的属性变了，你还得挨个修改这些方法，维护成本特别高。</p>
<p><strong>小贴士</strong>：传统Java类的痛点就是代码繁琐、容易出错、维护成本高。Java 16的记录类就是来解决这些问题的！</p>
<h2> 三、记录类初体验</h2>
<h3> （一）基本语法与定义</h3>
<p>Java 16的记录类简直是“代码减负神器”。用它定义数据类，只需要一行代码！比如，上面的<code>User</code>类用记录类来写，就变成了这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>是不是瞬间清爽多了？记录类会自动帮你生成构造函数、访问器方法、<code>equals</code>、<code>hashCode</code>和<code>toString</code>方法。你再也不用写那些繁琐的代码了！</p>
<h3> （二）自动生成的方法</h3>
<h4> 构造函数</h4>
<p>记录类会自动生成一个构造函数，参数和属性顺序一致。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 访问器方法</h4>
<p>记录类会为每个属性生成访问器方法，方法名和属性名一样。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是特别简洁？再也不用写那些冗长的<code>getUsername()</code>方法了。</p>
<h4> equals和hashCode方法</h4>
<p>记录类的<code>equals</code>和<code>hashCode</code>方法会自动比较所有属性值。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> toString方法</h4>
<p>记录类的<code>toString</code>方法会返回一个包含所有属性值的字符串。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类自动生成的方法，让你的代码不仅简洁，还功能完整。再也不用担心忘记写某个方法了！</p>
<h2> 四、记录类的特性深度剖析</h2>
<h3> （一）不可变性</h3>
<p>记录类的实例是不可变的，这意味着一旦对象被创建，属性值就不能被修改。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>不可变性的好处特别多。首先，代码更安全，不用担心属性被误改；其次，在多线程环境下，不可变对象天生就是线程安全的，不用担心数据一致性问题。</p>
<p><strong>小贴士</strong>：不可变性是记录类的核心特性之一，它让代码更安全、更可靠。</p>
<h3> （二）构造器的奥秘</h3>
<h4> 标准构造器</h4>
<p>记录类会自动生成一个标准构造器，参数和属性顺序一致。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 紧凑构造器</h4>
<p>记录类还支持紧凑构造器，可以省略形参列表和字段赋值语句。比如，你可以在这里加一些参数校验：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：紧凑构造器让你在创建对象时进行必要的校验，同时保持代码简洁。</p>
<h3> （三）成员声明规则</h3>
<h4> 字段声明</h4>
<p>记录类中只能声明静态变量，不能声明实例变量。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 方法声明</h4>
<p>记录类中可以声明实例方法和静态方法，但不能声明抽象方法或原生方法。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类的成员声明规则既保证了不可变性，又提供了足够的扩展能力。</p>
<h3> （四）实现接口</h3>
<p>记录类可以实现接口，这让你可以在保持简洁的同时，扩展更多的功能。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类实现接口，让你的代码更灵活，应用场景更广泛。</p>
<h2> 五、实际应用场景</h2>
<h3> （一）数据传输对象（DTO）</h3>
<p>在企业级开发中，DTO是一种常用的设计模式。以前，定义一个DTO类需要写一大堆代码，现在用记录类，一行代码搞定！比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在Spring MVC中，你可以这样接收前端数据：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类作为DTO，代码简洁，不可变性还保证了数据的安全性。</p>
<h3> （二）配置项表示</h3>
<p>记录类特别适合表示配置项。比如，加载数据库配置信息：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类的不可变性确保了配置在运行期间不会被误改，提高了系统的稳定性。</p>
<h3> （三）日志记录</h3>
<p>记录类也可以用来表示日志条目。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在业务代码中：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类的不可变性和自动生成的<code>toString</code>方法，让日志记录更安全、更清晰。</p>
<h2> 六、与其他技术的结合</h2>
<h3> （一）Lombok对比</h3>
<p>Lombok是一个流行的Java库，通过注解自动生成样板代码。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然Lombok也很方便，但记录类是Java语言层面的解决方案，不需要额外依赖。而且，记录类的代码更简洁，访问器方法更直观。</p>
<p><strong>小贴士</strong>：记录类和Lombok都能减少样板代码，但记录类更简洁、更安全。</p>
<h3> （二）在Spring框架中的应用</h3>
<h4> Spring Boot配置类</h4>
<p>记录类可以简化Spring Boot的配置类。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 数据访问层</h4>
<p>记录类也可以和Spring Data JPA结合。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类和Spring框架结合，让你的代码更简洁、更高效。</p>
<h2> 七、总结与展望</h2>
<p>Java 16的记录类绝对是Java开发者的“减负神器”。它不仅减少了样板代码，还让代码更安全、更易读。不可变性、自动生成的方法、灵活的构造器……这些特性让记录类在数据传输、配置管理、日志记录等多个场景中都能大显身手。</p>
<p>未来，Java语言还会不断进化，记录类也可能会带来更多惊喜。如果你还在用Java 16及以上版本，不妨大胆尝试记录类，相信它会给你带来全新的编程体验！</p>
<p>最后，如果你在使用记录类时有任何有趣的经验，或者遇到过什么坑，欢迎在评论区分享哦！</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-14T16:58:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">09.Java 16 密封类：代码安全与可维护性的新利器</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/09.Java16%EF%BC%9A%E5%AF%86%E5%B0%81%E7%B1%BB.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/09.Java16%EF%BC%9A%E5%AF%86%E5%B0%81%E7%B1%BB.html"/>
    <updated>2025-02-14T10:52:18.000Z</updated>
    <summary type="html"><![CDATA[<h1> 解锁Java 16密封类：代码安全与可维护性的新利器</h1>
<h2> 一、Java 16那些事儿</h2>
<p>嘿，Java爱好者们！2021年3月16日，Java 16像是一位带着宝藏的探险家，突然闯进了我们的编程世界。它带来了17个新特性，从语言到库，从性能优化到各种小惊喜，每个都像是给开发者准备的礼物🎁。其中，密封类（Sealed Classes）作为第二次预览特性，特别亮眼，就像夜空中最闪亮的星星✨。</p>
<p>想象一下，你正在写代码，突然发现某个类被继承得乱七八糟，继承体系完全失控。是不是特别烦？Java 16的密封类就是来解决这个问题的。它能给类的继承体系“上锁”，让继承变得可控。接下来，咱们就一起看看这个“秩序守护者”到底有多厉害！</p>]]></summary>
    <content type="html"><![CDATA[<h1> 解锁Java 16密封类：代码安全与可维护性的新利器</h1>
<h2> 一、Java 16那些事儿</h2>
<p>嘿，Java爱好者们！2021年3月16日，Java 16像是一位带着宝藏的探险家，突然闯进了我们的编程世界。它带来了17个新特性，从语言到库，从性能优化到各种小惊喜，每个都像是给开发者准备的礼物🎁。其中，密封类（Sealed Classes）作为第二次预览特性，特别亮眼，就像夜空中最闪亮的星星✨。</p>
<p>想象一下，你正在写代码，突然发现某个类被继承得乱七八糟，继承体系完全失控。是不是特别烦？Java 16的密封类就是来解决这个问题的。它能给类的继承体系“上锁”，让继承变得可控。接下来，咱们就一起看看这个“秩序守护者”到底有多厉害！</p>
<h2> 二、密封类初印象</h2>
<h3> （一）密封类是啥</h3>
<p>在Java里，类的继承就像家族传承。但如果家族成员随便加入，就会乱成一团。密封类就是给这个家族传承加上“锁”的存在。它用<code>sealed</code>关键字修饰，通过<code>permits</code>子句列出允许继承的子类，从而控制继承体系。</p>
<p>举个栗子，假设你正在写一个图形绘制系统，有一个<code>Shape</code>类作为所有图形的基类。正常情况下，你只希望<code>Circle</code>（圆形）和<code>Rectangle</code>（矩形）能继承它。这时候，就可以把<code>Shape</code>类定义为密封类，并在<code>permits</code>子句中列出<code>Circle</code>和<code>Rectangle</code>。其他类就无法随意继承<code>Shape</code>类了，继承体系瞬间变得清晰又稳定。</p>
<h3> （二）密封类语法大揭秘</h3>
<p>密封类的语法其实很简单，就像给类加上了一个“允许继承名单”。定义一个密封类的语法如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>子类在继承密封类时，需要根据需求使用不同的关键字来声明：</p>
<ul>
<li><code>final</code>关键字修饰的子类：表示这个子类不能再被继承，就像家族的分支到这儿就结束了。比如：</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>sealed</code>关键字修饰的子类：表示这个子类仍然是密封的，还可以继续限制自己的子类。比如：</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>non - sealed</code>关键字修饰的子类：表示这个子类打破了密封限制，恢复成普通类，可以被任意类继承。比如：</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：密封类的语法就像给类的继承体系画了一张“家谱图”，让你一眼就能看清楚谁可以继承谁。</p>
<h2> 三、密封类的超能力</h2>
<h3> （一）控制继承结构</h3>
<p>想象一下，你的代码就像一个精心规划的家族树，每个分支都清晰明确。密封类就像是家族树的规划师，能严格控制类的继承结构。</p>
<p>比如，在一个图形绘制系统中，<code>Shape</code>类作为所有图形的基类，定义了一些通用属性和方法。如果不使用密封类，任何类都可以继承<code>Shape</code>类，继承体系可能会变得混乱。但有了密封类，你可以明确指定哪些类可以继承它，比如<code>Circle</code>和<code>Rectangle</code>。这样一来，其他类就无法随意继承<code>Shape</code>类，继承体系瞬间变得清晰又稳定。</p>
<p><strong>小贴士</strong>：密封类让继承体系变得可控，就像给家族树画了一道“安全线”，防止乱七八糟的分支出现。</p>
<h3> （二）提升代码安全性</h3>
<p>密封类不仅能控制继承结构，还能提升代码的安全性。想象一下，你的代码就像一个城堡，而密封类就是坚固的城墙，能有效防止恶意子类的入侵。</p>
<p>比如，在一个权限管理系统中，有一个<code>Permission</code>类用于验证用户权限。如果不使用密封类，恶意子类可能会继承<code>Permission</code>类并重写验证方法，导致权限验证失效。但如果你把<code>Permission</code>类定义为密封类，并只允许一些受信任的子类继承它，就能防止恶意子类的出现，确保权限验证逻辑的安全性。</p>
<p><strong>小贴士</strong>：密封类就像给代码加了一把“安全锁”，只有经过授权的子类才能进入继承体系。</p>
<h3> （三）增强代码可维护性</h3>
<p>在大型项目中，代码的可维护性就像城市的交通规划一样重要。密封类就像是城市交通的指示牌，能让代码结构更清晰，便于理解和维护。</p>
<p>比如，在一个企业级应用中，有一个<code>BusinessObject</code>类作为业务对象的基类。如果你把它定义为密封类，并且只允许几个特定的业务对象类继承它，比如<code>Customer</code>和<code>Order</code>，其他开发者在查看代码时就能一眼明白这个继承体系的结构，快速定位和修改相关代码。</p>
<p><strong>小贴士</strong>：密封类让代码结构更清晰，就像一个整洁的书架，每本书都放在合适的位置，方便你快速找到需要的信息。</p>
<h2> 四、密封类实战演练</h2>
<h3> （一）简单示例走一波</h3>
<p>理论讲了这么多，是不是有点懵？别急，咱们来看一个简单的代码示例。</p>
<p>假设你正在写一个图形绘制系统，有一个<code>Shape</code>类作为所有图形的基类，它有两个子类：<code>Circle</code>（圆形）和<code>Rectangle</code>（矩形）。用密封类来实现，代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们可以在测试类中使用这些类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是特别简单？密封类让代码结构清晰，逻辑一目了然。</p>
<h3> （二）复杂场景也不怕</h3>
<p>在实际项目中，密封类的应用场景往往更复杂。比如，你正在开发一个2D游戏，游戏中有不同类型的角色，每个角色都有自己的行为和属性。可以用密封类来组织这些角色，代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在游戏场景中，可以这样使用这些角色类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是特别清晰？密封类让代码结构一目了然，逻辑清晰，维护起来也特别方便。</p>
<h2> 五、避坑指南</h2>
<h3> （一）常见错误及解决</h3>
<p>使用密封类时，可能会遇到一些常见的坑。别怕，咱们来一一解决！</p>
<h4> 子类未按规定修饰</h4>
<p>如果子类没有使用<code>final</code>、<code>sealed</code>或<code>non - sealed</code>关键字修饰，编译器会报错。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决方法：根据需求，为子类添加合适的修饰关键字。比如，如果<code>Circle</code>类不需要再被继承，可以用<code>final</code>修饰：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 未在permits子句中列出子类</h4>
<p>如果密封类的<code>permits</code>子句中没有列出允许继承的子类，其他类即使符合条件也无法继承该密封类。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决方法：在密封类的<code>permits</code>子句中明确列出允许继承的子类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 子类不在同一包中</h4>
<p>如果允许子类扩展密封类，那么子类必须和密封类定义在同一个包中。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决方法：将子类<code>Circle</code>移动到与密封类<code>Shape</code>相同的包中。</p>
<h3> （二）注意事项要牢记</h3>
<h4> 密封类与其他特性的结合使用</h4>
<p>密封类可以和Java的其他特性结合使用，比如模式匹配、泛型、注解等。但在结合使用时，需要注意它们之间的相互影响和兼容性。比如，泛型类型参数的声明和使用需要保持一致，否则可能会出现编译错误。</p>
<h4> 密封类的性能影响</h4>
<p>虽然密封类本身不会对性能产生显著的负面影响，但过度使用可能会让代码变得复杂，影响扩展性和灵活性。所以，使用密封类时，要根据具体需求合理权衡。</p>
<h2> 六、密封类与其他特性的梦幻联动</h2>
<h3> （一）和模式匹配的默契配合</h3>
<p>密封类和模式匹配就像是一对默契十足的搭档，能让代码变得更加简洁高效。</p>
<p>比如，在一个图形绘制系统中，你有一个密封类<code>Shape</code>和它的子类<code>Circle</code>、<code>Rectangle</code>和<code>Square</code>。现在需要一个方法来描述不同形状的信息。如果不使用密封类和模式匹配，代码可能是这样的：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码看起来特别繁琐，还容易出错。但如果使用密封类和模式匹配，代码就变得简洁明了：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是特别清爽？密封类和模式匹配的结合，让代码不仅简洁，还更安全。</p>
<h3> （二）与其他特性的协同作战</h3>
<p>密封类不仅能和模式匹配配合，还能和访问修饰符、泛型、注解等其他特性一起使用，打造出更强大的代码。</p>
<p>比如，你可以用自定义注解标记密封类的子类，然后在运行时通过反射读取这些注解信息，实现动态行为。或者，你可以定义一个泛型密封类，用于表示不同类型的数据集合，同时限制只有特定的子类可以继承它。</p>
<p><strong>小贴士</strong>：密封类和其他特性的结合，就像给你的代码加上了“超级外挂”，让代码更强大、更灵活。</p>
<h2> 七、总结与展望</h2>
<p>Java 16的密封类就像是一把“继承控制钥匙”，能让你在管理类的继承结构时更加得心应手。它不仅能控制继承体系，还能提升代码的安全性和可维护性。在实际项目中，密封类已经展现出了它的强大魅力，无论是在简单的图形绘制系统，还是复杂的游戏开发场景中，都能帮助你更好地组织代码。</p>
<p>如果你还在用Java 16及以上版本，不妨大胆尝试密封类，相信它会给你带来全新的编程体验。同时，也可以期待Java在未来的版本中，继续完善和扩展与密封类相关的特性。</p>
<p>最后，如果你在使用密封类时有任何有趣的经验，或者遇到过什么坑，欢迎在评论区分享哦！</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-14T17:58:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">10.JDK 21新特性揭秘：字符串模板，Java编程的华丽升级</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/10.Java21%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/10.Java21%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF.html"/>
    <updated>2025-02-14T10:52:18.000Z</updated>
    <summary type="html"><![CDATA[<p>嘿，各位Java开发者们！是不是每天都在和那些繁琐的代码打交道，感觉有点疲惫了？别担心，JDK 21带着它的新特性来拯救我们啦！今天，咱们就来聊聊其中最让人眼前一亮的字符串模板（<code>String Templates</code>）。这玩意儿可真是给Java字符串操作这块“老古董”注入了一股新鲜血液，让咱们处理字符串的时候能轻松不少。别着急，接下来我带你一起走进JDK 21字符串模板的奇妙世界，保证让你眼前一亮！</p>
<h2> 传统字符串拼接的“囧境”</h2>
<p>在深入了解字符串模板之前，咱们先来回顾一下传统字符串拼接方式的那些“囧事”，相信你在日常开发中肯定没少遇到。</p>]]></summary>
    <content type="html"><![CDATA[<p>嘿，各位Java开发者们！是不是每天都在和那些繁琐的代码打交道，感觉有点疲惫了？别担心，JDK 21带着它的新特性来拯救我们啦！今天，咱们就来聊聊其中最让人眼前一亮的字符串模板（<code>String Templates</code>）。这玩意儿可真是给Java字符串操作这块“老古董”注入了一股新鲜血液，让咱们处理字符串的时候能轻松不少。别着急，接下来我带你一起走进JDK 21字符串模板的奇妙世界，保证让你眼前一亮！</p>
<h2> 传统字符串拼接的“囧境”</h2>
<p>在深入了解字符串模板之前，咱们先来回顾一下传统字符串拼接方式的那些“囧事”，相信你在日常开发中肯定没少遇到。</p>
<h3> （一）繁琐的加号拼接</h3>
<p>在Java里，用<code>+</code>号拼接字符串是最基础的方式。可一旦拼接的变量多了，代码就像“面条”一样，又长又乱，读起来费劲得很。比如，我们要拼接用户的个人信息：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码虽然能实现功能，但你看看，这代码量，这可读性，简直让人头疼！而且，每用一次+号拼接，就会创建一个新的<code>String</code>对象，性能开销大得很，简直是在“拖累”程序。</p>
<h3> （二）StringBuilder的无奈</h3>
<p>为了解决<code>+</code>号拼接的性能问题，我们通常会用<code>StringBuilder</code>。它通过可变的字符序列来避免频繁创建新的字符串对象，从而提高性能。不过，<code>StringBuilder</code>的代码结构也比较复杂。还是上面的例子，用<code>StringBuilder</code>来实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看看，使用<code>StringBuilder</code>时，得先创建对象，再调用多次<code>append</code>方法，最后还得调用<code>toString</code>方法转换为<code>String</code>类型。对于简单的字符串拼接场景，这操作是不是太“繁琐”了？简直就是“小题大做”。</p>
<h3> （三）格式化方法的痛点</h3>
<p>除了上述两种方式，我们还会用<code>String.format</code>和<code>MessageFormat</code>来进行字符串格式化拼接。但它们也有问题，比如将格式字符串与参数分离，这导致代码理解和维护起来超级困难。以<code>String.format</code>为例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然代码看起来简洁一些，但格式字符串里的占位符和后面的参数对应关系不够直观。当参数多或者格式字符串复杂时，很容易出错，也不利于代码维护。这就好比是“盲人摸象”，一不小心就容易“摸错地方”。</p>
<h2> JDK 21字符串模板闪亮登场</h2>
<p>好啦，传统方式的问题咱们都清楚了，那JDK 21中的字符串模板到底能给我们带来哪些惊喜呢？别急，这就来揭开它的神秘面纱。</p>
<h3> （一）特性简介</h3>
<p>字符串模板是JDK 21引入的一个预览特性，它允许我们在字符串中直接嵌入变量和表达式，从而简化字符串的拼接过程，提高代码的可读性和可维护性。这有点类似于<code>Python中</code>的<code>f-string</code>和<code>JavaScript</code>中的模板字符串，熟悉这两种语言的小伙伴肯定能轻松上手。</p>
<h3> （二）基本语法展示</h3>
<p>在JDK 21中，字符串模板用STR处理器和反引号“`”来定义。基本语法如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，<code>STR</code>是模板处理器，<code>\{name}</code>是嵌入的表达式，<code>name</code>的值会在运行时被替换到字符串中。运行这段代码，输出结果就是<code>Hello, 张三!</code>。是不是感觉比传统的字符串拼接方式简洁多了？简直就是“清爽版”的代码。</p>
<h3> （三）多行字符串的优雅处理</h3>
<p>在处理多行字符串时，字符串模板的优势就更明显了。比如，我们要拼接一个<code>HTML</code>字符串：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用字符串模板，我们可以像写普通的<code>HTML</code>代码一样来拼接字符串，再也不用担心繁琐的<code>+</code>号和转义字符了。这就好比是从“手写时代”直接跨越到了“打印时代”，清晰又方便。</p>
<p>同样，在拼接<code>JSON</code>字符串时，字符串模板也能让代码更加简洁明了：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出的<code>json</code>字符串就是：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> （四）表达式嵌入的强大功能</h3>
<p>字符串模板不仅支持嵌入变量，还支持嵌入各种表达式，比如算术运算、方法调用等。这可真是太厉害了！比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果就是两数之和为：<code>30</code>。再比如，我们有一个获取当前时间的方法<code>getCurrentTime()</code>，可以这样在字符串模板中调用：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果类似于当前时间是：<code>2024-10-22T15:30:00.123</code>，具体时间根据实际运行情况而定。</p>
<p>通过这种方式，我们可以轻松地将方法的返回值嵌入到字符串中，让代码更加简洁高效。这就好比是给代码“插上了翅膀”，让它能更灵活地“飞翔”。</p>
<h2> 深入探索字符串模板的用法</h2>
<h3> （一）自定义处理器的实现</h3>
<p>除了<code>JDK 21</code>自带的<code>STR</code>、<code>FMT</code>等模板处理器，我们还可以通过实现<code>StringTemplate.Processor</code>接口来自定义模板处理器，以满足特定的业务需求。比如，我们想实现一个自定义处理器，把字符串里的所有字母都变成大写。实现步骤如下：</p>
<ol>
<li>实现<code>StringTemplate.Processor</code>接口，并重写<code>process</code>方法。</li>
<li>在<code>process</code>方法中，获取模板中的片段和值，进行自定义处理。</li>
<li>返回处理后的结果。</li>
</ol>
<p>示例代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用自定义处理器的示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行上述代码，输出结果就是学习 <code>JAVA 很有趣</code>。</p>
<p>通过自定义处理器，我们可以根据具体的业务需求对字符串模板进行灵活处理，大大提高了字符串处理的灵活性和扩展性。</p>
<p>这就好比是给代码“量身定制”了一套“外衣”，让它能更好地适应各种场景。</p>
<h3> （二）与其他Java特性的融合</h3>
<p>字符串模板还可以和<code>Java</code>的其他特性，比如<code>lambda</code>表达式、流操作等，结合使用，发挥出更强大的功能。</p>
<p><strong>1.与lambda表达式结合</strong></p>
<p>我们可以在字符串模板的表达式中使用<code>lambda</code>表达式，实现一些复杂的逻辑处理。比如，我们有一个列表，需要把列表里的元素拼接成一个字符串，而且每个元素之间用逗号隔开，同时对每个元素进行一些处理（比如首字母大写）：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们使用了流操作对列表里的每个元素进行首字母大写处理，然后用<code>Collectors.joining</code>方法把处理后的元素拼接成一个字符串，最后把结果嵌入到字符串模板中。运行结果就是水果列表：<code>Apple, Banana, Cherry</code>。通过这种方式，我们可以把<code>字符串模板</code>和<code>lambda表达式</code>、<code>流操作</code>结合起来，实现复杂的数据处理和字符串生成。这就好比是把不同的“食材”放在一起“烹饪”，做出了一道“美味大餐”。</p>
<p><strong>2.与流操作结合</strong></p>
<p>字符串模板和流操作的结合还体现在对字符串的分割和处理上。比如，我们有一个多行字符串，想把它按行分割，然后对每一行进行一些操作（比如去除行首空格），最后再拼接成一个新的字符串：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们使用<code>lines</code>方法把多行字符串转换为流，然后用<code>map</code>方法对每一行进行去除行首空格的操作，最后用<code>Collectors.joining</code>方法把处理后的行重新拼接成一个字符串，并嵌入到字符串模板中。</p>
<p>运行结果就是处理后的字符串：<code>line1\nline2\nline3</code>。</p>
<p>通过把字符串模板和流操作结合，我们可以更加高效地处理字符串数据，提高代码的可读性和可维护性。这就好比是给字符串做了一次“美容”，让它变得更加“整洁”。</p>
<h2> 使用字符串模板的注意事项</h2>
<h3> （一）预览特性的局限性</h3>
<p>需要注意的是，字符串模板在JDK 21中还是一个预览特性。</p>
<p>这意味着它可能会在未来的 Java 版本中发生变化，甚至有可能被移除。</p>
<p>在生产环境中使用时，一定要谨慎考虑兼容性问题。</p>
<p>如果你的项目需要长期稳定运行，并且对 JDK 版本的升级比较敏感，那么在使用字符串模板之前，要充分评估其潜在风险。</p>
<p>比如，某些依赖库可能不支持 JDK 21 的预览特性，这可能会导致项目在编译或运行时出现问题。</p>
<p>在编译和运行包含字符串模板的代码时，需要添加<code>--enable-preview</code>参数来启用预览特性。</p>
<p>例如，使用命令行编译时，要这样写：<code>javac --enable-preview --source 21 YourClass.java</code>；运行时则使用<code>java --enable-preview YourClass</code>。</p>
<h3> （二）性能与资源考量</h3>
<p>虽然字符串模板让代码看起来清爽多了，但在某些情况下，咱们也得注意它的“小脾气”。比如，在循环里频繁创建模板字符串，那可就有点“得不偿失”了。为啥呢？每次创建模板字符串，都要进行解析和求值操作，这可是要消耗<code>CPU</code>和内存资源的。要是循环次数太多，那性能可就“一落千丈”了。</p>
<p>举个例子，想象一下你在厨房里，每次做饭都要重新洗菜、切菜，那效率得多低啊！所以，如果在循环中用到字符串模板，建议把不变的部分提前准备好，放在循环外面。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>prefix</code>是不变的部分，放在循环外面，这样就避免了每次循环都重复解析和求值<code>prefix</code>，效率一下子就上来了。</p>
<p>另外，如果处理的字符串特别大，或者模板里嵌入的表达式特别复杂，那内存可就“吃不消”了。想象一下，你在一个小房间里堆满了杂物，很快就没地方站了。所以，处理大数据量的字符串时，一定要合理设计表达式，避免不必要的内存开销。</p>
<h3> （三）错误处理策略</h3>
<p>用字符串模板的时候，难免会遇到一些“小插曲”，比如表达式求值失败。这就像是你在做一道复杂的菜，突然发现某个调料用完了，那可就麻烦了。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>divide(10, 0)</code>会抛出<code>ArithmeticException</code>异常，因为除数不能为0。不过别担心，我们用<code>try-catch</code>块把它“抓住”，然后进行相应的错误处理，这样程序就不会因为异常而“崩溃”了。</p>
<p>要是模板字符串的语法不对，比如反引号不匹配、表达式格式错误，编译器会像“警察叔叔”一样，及时提醒你。所以在写代码的时候，一定要仔细检查模板字符串的语法，确保它“规规矩矩”的。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些错误在编译的时候就会被发现，所以一定要根据编译器的提示及时修改代码，不然程序可就“跑不起来”了。</p>
<p>通过这些注意事项，咱们就能更好地驾驭字符串模板这个“新伙伴”，让它在项目中发挥最大的作用，同时避免一些常见的“坑”。</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-14T18:01:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">11.JDK 21虚拟线程：Java并发编程的革新利器</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/11.Java21%EF%BC%9A%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/11.Java21%EF%BC%9A%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B.html"/>
    <updated>2025-02-14T10:56:38.000Z</updated>
    <summary type="html"><![CDATA[<h2> 一、引言：并发编程的新曙光</h2>
<p>嘿，各位Java开发者！是不是每次面对高并发场景，都感觉像是在打一场硬仗？传统线程就像是一群“老炮儿”，虽然经验丰富，但在高并发的战场上，它们的“腿脚”越来越不灵便了。想象一下，你的服务器被成千上万的请求“围攻”，每个请求都要派一个线程去处理。传统线程的创建和销毁成本高得吓人，而且占用的内存资源比“吃货”还多！这就像是在战场上派出了大量装备沉重、行动迟缓的士兵，不仅耗费巨大，还容易陷入混乱。</p>
<p>别担心，JDK 21带着虚拟线程来“救场”啦！虚拟线程就像是从天而降的“超级英雄”，专门来解决传统线程在高并发场景下的“疲软”问题。接下来，咱们就一起揭开虚拟线程的神秘面纱，看看它是怎么在高并发的战场上大显身手的！</p>]]></summary>
    <content type="html"><![CDATA[<h2> 一、引言：并发编程的新曙光</h2>
<p>嘿，各位Java开发者！是不是每次面对高并发场景，都感觉像是在打一场硬仗？传统线程就像是一群“老炮儿”，虽然经验丰富，但在高并发的战场上，它们的“腿脚”越来越不灵便了。想象一下，你的服务器被成千上万的请求“围攻”，每个请求都要派一个线程去处理。传统线程的创建和销毁成本高得吓人，而且占用的内存资源比“吃货”还多！这就像是在战场上派出了大量装备沉重、行动迟缓的士兵，不仅耗费巨大，还容易陷入混乱。</p>
<p>别担心，JDK 21带着虚拟线程来“救场”啦！虚拟线程就像是从天而降的“超级英雄”，专门来解决传统线程在高并发场景下的“疲软”问题。接下来，咱们就一起揭开虚拟线程的神秘面纱，看看它是怎么在高并发的战场上大显身手的！</p>
<h2> 二、虚拟线程是什么</h2>
<p>虚拟线程的调度主要包含三个核心部分：虚拟线程（Virtual Threads）、平台线程（Platform Threads）和调度器（Scheduler）。</p>
<ol>
<li><strong>虚拟线程池：</strong></li>
</ol>
<ul>
<li>这是一个包含大量虚拟线程的集合。每个虚拟线程代表一个轻量级的执行单元，它们可以由用户代码创建并提交到执行器中等待执行。虚拟线程之间是平等的，它们的栈空间较小，创建和销毁的开销也很低。</li>
</ul>
<ol start="2">
<li><strong>平台线程池：</strong></li>
</ol>
<ul>
<li>平台线程是与操作系统内核线程一一对应的线程，数量相对较少。平台线程负责执行虚拟线程中的实际任务，它们是系统资源的实际使用者。</li>
</ul>
<ol start="3">
<li><strong>调度器：</strong></li>
</ol>
<ul>
<li>调度器是整个系统的核心，负责将虚拟线程分配到可用的平台线程上执行。</li>
<li>调度器会根据虚拟线程的状态（如就绪、阻塞等）和平台线程的负载情况进行智能调度。</li>
<li>当一个虚拟线程遇到阻塞操作（如 I/O 操作）时，调度器会将该虚拟线程暂停，并将平台线程分配给其他就绪的虚拟线程；当阻塞操作完成后，调度器会将该虚拟线程重新加入到就绪队列中，等待再次分配到平台线程执行。</li>
</ul>
<ol start="4">
<li><strong>阻塞与唤醒机制：</strong></li>
</ol>
<ul>
<li>当虚拟线程进行 I/O 等阻塞操作时，会触发阻塞信号，调度器将其标记为阻塞状态并让出平台线程；</li>
<li>当阻塞操作完成，会有唤醒信号，调度器将其重新标记为就绪状态等待调度。</li>
</ul>
<p><strong>虚拟线程调度的基本流程：</strong></p>
<p>虚拟线程进入调度器，调度器将其分配到平台线程执行，当平台线程上的虚拟线程遇到阻塞操作时通知调度器，调度器再去唤醒其他就绪的虚拟线程执行。</p>
<figure><img src="/imgs/column/java/jdk21_virtual_thread_00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>虚拟线程，简单来说，就是由JVM管理的轻量级线程。它就像是线程世界里的“小精灵”，和传统的平台线程（也就是我们平常用的普通线程，由操作系统管理）有着天壤之别。传统的平台线程和操作系统线程是一一对应的，就好比一个萝卜一个坑，每个平台线程都要占用操作系统的一套资源，包括内存空间、内核数据结构等。而虚拟线程则是一群“小精灵”共享少量的“坑位”（平台线程），它们的创建和销毁成本极低，几乎可以忽略不计，就像在游戏里创建和删除一个虚拟角色一样轻松。</p>
<p>在调度方面，平台线程由操作系统内核负责调度，每次上下文切换都要陷入内核态，这个过程复杂又耗时。而虚拟线程则由JVM在用户态进行调度，JVM就像一个聪明的“小管家”，能够高效地安排这些“小精灵”的工作，大大减少了上下文切换的开销。打个比方，平台线程的调度就像是大公司里层层汇报的工作流程，效率低下；而虚拟线程的调度则像是创业团队里的扁平化管理，沟通高效，决策迅速。</p>
<p>在资源占用上，一个平台线程通常需要占用1MB左右的栈空间，这在高并发场景下是一笔巨大的开销。而虚拟线程的栈空间非常小，只有几十KB甚至更小，这使得我们可以在一个JVM中轻松创建数百万个虚拟线程，极大地提升了系统的并发处理能力。可以想象，平台线程是豪华的独栋别墅，占用大量空间资源；而虚拟线程则是精致的公寓，小巧玲珑，能够在有限的空间里容纳更多的“住户”。</p>
<h2> 三、虚拟线程的优势</h2>
<h3> （一）资源高效利用</h3>
<p>虚拟线程在资源利用方面，就像是一个精打细算的“小管家”，有着独特的优势。传统线程创建时，需要向操作系统申请一系列资源，包括内存空间用于线程栈，这就好比为每个“大管家”分配一个豪华大别墅，开销巨大。而且，操作系统对线程数量的管理能力有限，当创建的传统线程数量过多时，系统资源会被迅速耗尽，就像一个城市里突然涌入过多需要豪华别墅的人，城市资源根本无法承受，最终导致系统崩溃。</p>
<p>而虚拟线程则截然不同，它的创建和管理开销极低，几乎可以忽略不计。因为虚拟线程并不直接对应操作系统线程，它们共享少量的操作系统线程（也就是前面提到的“坑位”），就像多个“小管家”合住在一个经济实惠的公寓里，大大节省了资源。这使得在Java应用中可以轻松创建数百万个虚拟线程，而不会对系统资源造成过大压力。例如，在一个高并发的电商系统中，每一个商品查询请求都可以分配一个虚拟线程来处理，即使在促销活动期间，大量请求涌入，系统也能轻松应对，不会因为线程资源不足而出现卡顿或崩溃的情况。</p>
<h3> （二）高并发性能提升</h3>
<p>当面对高并发场景时，虚拟线程的表现堪称惊艳，就像一位超级英雄，能够轻松应对各种挑战。我们以Web服务器处理大量并发请求为例，在传统线程模型下，每一个请求都需要创建一个传统线程来处理。随着并发请求数量的增加，线程数量也会急剧上升，线程之间的上下文切换变得频繁，这就好比一个繁忙的十字路口，车辆过多导致交通堵塞，每个线程真正用于处理任务的时间被大大压缩，系统的响应速度变慢，吞吐量也随之降低。</p>
<p>而虚拟线程采用的是用户态调度，由JVM高效管理。当一个虚拟线程执行I/O操作（比如读取数据库数据、接收网络请求数据等）时，它会暂时让出执行权，JVM调度器会立即安排其他可运行的虚拟线程执行任务，就像一个高效的交通调度员，能够合理安排车辆通行，避免交通堵塞。这样一来，在高并发场景下，虚拟线程能够充分利用CPU资源，大大提高了系统的并发处理能力和吞吐量。有研究表明，在处理大量I/O密集型任务时，使用虚拟线程的系统吞吐量相比传统线程可以提升数倍甚至数十倍。例如，在一个处理大量并发网络请求的Web服务器中，使用虚拟线程后，每秒能够处理的请求数量从原来的数千个提升到了数万个，响应时间也从几百毫秒缩短到了几十毫秒，极大地提升了用户体验。</p>
<h3> （三）简化编程模型</h3>
<p>虚拟线程的出现，还为开发者带来了一个巨大的福音——简化编程模型，就像为复杂的编程世界带来了一张简洁明了的地图。在传统的并发编程中，为了实现高效的并发处理，开发者常常需要使用复杂的异步编程模型，如回调机制、Future模式等。这些模型虽然能够实现并发功能，但代码结构复杂，可读性差，就像一个迷宫，让人容易迷失方向。而且，在异步编程中，处理多个任务之间的依赖关系和错误处理也非常棘手，需要开发者花费大量的时间和精力去调试和维护。</p>
<p>而虚拟线程支持同步编程模型，开发者可以像编写普通单线程代码一样编写并发代码，不需要过多地关注线程的创建、销毁和调度等细节，就像在熟悉的道路上行驶，轻松自在。例如，在使用虚拟线程处理多个数据库查询任务时，开发者可以依次编写每个查询操作，就像在单线程环境下一样，而不需要像传统异步编程那样，将每个查询操作封装成回调函数，然后处理回调之间的嵌套关系。这样不仅降低了编程的难度，还提高了代码的可读性和可维护性，让开发者能够更加专注于业务逻辑的实现，提高开发效率。</p>
<h3> (四) 对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>平台线程</th>
<th>虚拟线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建数量</td>
<td>数千级</td>
<td><strong>百万级</strong></td>
</tr>
<tr>
<td>内存消耗</td>
<td>默认1MB/线程</td>
<td><strong>~200字节/线程</strong></td>
</tr>
<tr>
<td>上下文切换</td>
<td>内核参与</td>
<td><strong>JVM优化</strong></td>
</tr>
<tr>
<td>编程模型</td>
<td>回调地狱风险</td>
<td><strong>同步代码风格</strong></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>高吞吐</strong>：轻松支撑10万+并发连接</li>
<li><strong>低资源消耗</strong>：创建百万虚拟线程仅需几百MB内存</li>
<li><strong>代码简化</strong>：用同步代码实现异步性能，避免回调地狱</li>
<li><strong>兼容性</strong>：与现有Thread API、调试工具（如jstack）完全兼容</li>
</ol>
<h2> 四、应用场景与示例</h2>
<h3> （零）基本使用示例</h3>
<p>基本使用姿势有下面两种</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如使用虚拟线程实现归并排序</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明：</strong></p>
<ul>
<li>使用虚拟线程并行化归并排序的递归任务。</li>
<li>每个子任务（<code>mergeSort</code>）都在独立的虚拟线程中执行。</li>
<li>通过<code>Future</code>获取子任务结果，并合并（<code>merge</code>）排序后的数组。</li>
</ul>
<h3> （一）高并发网络服务</h3>
<p>在高并发网络服务场景中，Web服务器是一个典型的例子。想象一下，你的Web服务器就像一个繁忙的接待大厅，每天要接待成千上万的访客（并发请求）。传统的做法是为每个访客安排一个专门的接待人员（传统线程），但随着访客数量的增加，接待人员的数量也需要不断增加，这不仅成本高昂，而且管理起来非常困难。而虚拟线程就像是一群训练有素的兼职接待员，他们可以迅速响应访客的需求，并且占用的资源极少。</p>
<p>下面是一个简单的Web服务器使用虚拟线程处理并发请求的代码示例，我们使用Java的HttpServer类来创建一个简单的Web服务器，并对比传统线程池的处理方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们创建了两个Web服务器，一个使用虚拟线程处理请求，另一个使用固定大小为10的传统线程池处理请求。通过模拟处理请求的耗时操作（<code>Thread.sleep(100)</code>），可以直观地感受到虚拟线程在高并发场景下的优势。</p>
<p>在实际测试中，如果使用工具（如Apache JMeter）模拟大量并发请求，可以发现使用虚拟线程的Web服务器能够处理更多的并发请求，响应速度更快，吞吐量更高。因为虚拟线程的创建和切换开销极低，能够迅速响应新的请求，而传统线程池由于线程数量有限，在高并发情况下容易出现线程阻塞，导致请求处理速度变慢。</p>
<h3> （二）I/O密集型任务</h3>
<p>在I/O密集型任务中，文件读取和数据库查询是常见的场景。以文件读取为例，假设你需要从一个大型文件中读取数据并进行处理，每个读取操作都可能需要等待磁盘I/O完成，这期间线程会被阻塞。</p>
<p>传统线程在这种情况下，会占用大量的系统资源，并且由于线程阻塞，CPU资源无法得到充分利用。而虚拟线程就像是一群聪明的小助手，它们在等待I/O操作完成的过程中，会主动让出CPU资源，让其他任务得以执行。</p>
<p>下面是一个文件读取的示例代码，展示虚拟线程在I/O密集型任务中的应用：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们分别使用虚拟线程和传统线程来读取一个大型文件，并模拟对每一行数据的处理（<code>Thread.sleep(10)</code>）。可以看到，使用虚拟线程时，由于它在I/O阻塞时能够迅速挂起并释放资源，使得系统能够同时处理多个文件读取任务，大大提高了资源利用率和处理效率。而传统线程在读取文件时，如果遇到I/O阻塞，整个线程就会被阻塞，无法进行其他操作，导致CPU资源浪费。</p>
<p>再以数据库查询为例，假设我们有一个电商系统，需要查询商品信息。在高并发情况下，传统线程池可能会因为线程阻塞而导致查询效率低下。而使用虚拟线程，每个查询请求都可以分配一个虚拟线程，在等待数据库响应的过程中，虚拟线程可以被挂起，JVM可以调度其他虚拟线程执行任务，从而提高系统的并发处理能力和响应速度。例如，使用JDBC进行数据库查询时，代码可以这样写：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们分别使用虚拟线程和传统线程进行数据库查询，并模拟对查询结果的处理（<code>Thread.sleep(10)</code>）。可以看出，虚拟线程在处理I/O密集型的数据库查询任务时，能够有效减少线程阻塞时间，提高系统的并发处理能力和资源利用率。</p>
<h2> 五、使用方法与注意事项</h2>
<h3> （一）创建和启动虚拟线程</h3>
<p>在Java中，创建和启动虚拟线程非常简单，就像搭建一个简易的积木模型。我们可以使用<code>Thread</code>和<code>Thread.Builder APIs</code>来创建虚拟线程，就像挑选合适的积木块。例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们通过<code>Thread.ofVirtual().start()</code>方法创建并启动了一个虚拟线程，该线程执行一个简单的打印任务，输出当前线程的信息。这里的<code>Thread.ofVirtual()</code>就像是一个特殊的积木挑选器，专门用于挑选虚拟线程这块“积木”，而<code>start()</code>方法则是将这块“积木”搭建起来，让它开始工作。</p>
<p>我们还可以使用Thread.Builder来设置虚拟线程的一些属性，比如线程名称，就像给积木涂上不同的颜色进行标记：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们创建了一个名为MyVirtualThread的虚拟线程，通过Thread.Builder设置了线程名称，使我们在调试和管理线程时更容易识别。</p>
<p>除了上述方法，我们还可以使用Executors来创建虚拟线程。Executors就像是一个专业的积木搭建工具，它提供了<code>newVirtualThreadPerTaskExecutor</code>方法，为每个任务启动一个新的虚拟线程：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们使用<code>Executors.newVirtualThreadPerTaskExecutor</code>创建了一个ExecutorService，然后通过<code>submit</code>方法提交了10个任务，每个任务都会在一个新的虚拟线程中执行。这里的<code>Executors.newVirtualThreadPerTaskExecutor</code>就像是一个自动化的积木搭建助手，它会自动为每个任务搭建一个虚拟线程“积木”，并让它们开始工作。</p>
<h3> （二）使用建议</h3>
<p>在使用虚拟线程时，我们有一些实用的建议，就像驾驶汽车时需要遵循的规则。</p>
<p>首先，<strong>无需池化虚拟线程。</strong></p>
<ul>
<li>因为虚拟线程的创建和销毁开销极低，就像使用一次性餐具一样，用完即弃也不会造成太大的浪费。如果对虚拟线程进行池化，反而会增加不必要的管理复杂度，就像在一个小房间里摆放过多的家具，显得杂乱无章。</li>
</ul>
<p>其次，<strong>要尽量避免阻塞虚拟线程。</strong></p>
<ul>
<li>虽然虚拟线程对阻塞操作进行了优化，但长时间阻塞虚拟线程仍然会影响系统的并发处理能力。这就像是在一条繁忙的道路上，如果有一辆车长时间停在路中间，就会导致交通堵塞。例如，在进行I/O操作时，应该尽量使用非阻塞的I/O API，或者将阻塞操作放在单独的线程池中处理，避免阻塞虚拟线程。</li>
</ul>
<p>另外，<strong>虽然虚拟线程很轻量级，但也不能无节制地创建。</strong></p>
<ul>
<li>大量创建虚拟线程仍然会消耗一定的系统资源，就像在一个仓库里堆放过多的货物，会占用大量的空间。因此，在使用虚拟线程时，应根据系统的实际情况，合理控制其数量，避免资源浪费。例如，在一个Web服务器中，根据服务器的硬件配置和预计的并发请求数量，设置一个合适的虚拟线程上限，既能充分利用虚拟线程的优势，又能保证系统的稳定运行。</li>
</ul>
<h3> （三）注意事项</h3>
<p>在享受虚拟线程带来的便利时，我们也不能忽视一些注意事项，就像在享受美食时要注意食物的卫生。虚拟线程虽然强大，但它并不适用于所有场景。</p>
<p>对于计算密集型任务，由于这类任务主要依赖CPU进行大量的计算，而虚拟线程的优势在于减少线程上下文切换开销，对于CPU计算能力的提升并没有帮助，所以传统线程池可能更适合。例如，在进行复杂的数学计算、图像渲染等任务时，使用传统线程池可以更好地利用CPU资源，提高计算效率。</p>
<p>同时，我们还需要关注第三方库的兼容性问题。有些第三方库可能没有对虚拟线程进行优化，或者直接依赖于操作系统线程的特性，在虚拟线程中使用时可能会出现意想不到的问题。这就像是在一辆改装过的汽车上安装不匹配的零件，可能会影响汽车的正常行驶。因此，在使用第三方库时，要查看其文档，确认是否支持虚拟线程，或者进行充分的测试，确保在虚拟线程环境下能够正常工作。</p>
<p>此外，由于虚拟线程数量庞大，传统的线程监控和调试工具可能难以管理大量的虚拟线程。在调试和监控时，我们需要更好的支持工具。这就像是在一个大城市里，传统的交通指挥方式可能无法应对大量的车辆，需要更先进的交通管理系统。例如，使用一些专门针对虚拟线程的监控工具，能够实时监控虚拟线程的运行状态、资源消耗等信息，帮助我们及时发现和解决问题。</p>
<h2> 六、展望与总结</h2>
<p>虚拟线程的出现，无疑是Java并发编程领域的一次重大飞跃，它为我们打开了一扇通往高效、便捷编程世界的大门。就像在黑暗中点亮了一盏明灯，为高并发场景下的Java开发指明了新的方向。</p>
<p>它以极低的资源消耗和出色的并发处理能力，让我们能够轻松应对海量并发请求，大大提升了系统的性能和稳定性。在Web服务、I/O密集型任务等众多场景中，虚拟线程都展现出了巨大的优势，为开发者提供了更强大的工具和更高效的解决方案。</p>
<p>随着Java 21的发布，虚拟线程将逐渐走进更多开发者的视野，成为Java开发中的重要利器。它不仅会改变我们编写并发代码的方式，还将推动Java生态系统的进一步发展和创新。无论是大型企业级应用，还是小型创业项目，都能从虚拟线程中受益。</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-14T18:11:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">12.Java 21 结构化并发：开启并发编程新篇章</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/12.Java21%EF%BC%9A%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/12.Java21%EF%BC%9A%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91.html"/>
    <updated>2025-02-14T10:52:18.000Z</updated>
    <summary type="html"><![CDATA[<h1> Java 21结构化并发：开启并发编程新篇章</h1>
<h2> Java并发编程演进之路</h2>
<p>嘿，Java开发者们！还记得刚学Java时写并发代码的痛苦吗？那时，我们得继承<code>Thread</code>类或实现<code>Runnable</code>接口，手动管理线程的创建与销毁。代码繁琐不说，一旦涉及大量线程，管理起来更是让人崩溃！比如，你可能写过这样的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyThread is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyRunnable is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyThread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> runnableThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        runnableThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<h1> Java 21结构化并发：开启并发编程新篇章</h1>
<h2> Java并发编程演进之路</h2>
<p>嘿，Java开发者们！还记得刚学Java时写并发代码的痛苦吗？那时，我们得继承<code>Thread</code>类或实现<code>Runnable</code>接口，手动管理线程的创建与销毁。代码繁琐不说，一旦涉及大量线程，管理起来更是让人崩溃！比如，你可能写过这样的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别复杂？每次写线程都得小心翼翼，生怕出错。</p>
<p>后来，Java引入了线程池，这无疑是一大进步！线程池可复用线程，降低了线程创建和销毁的开销，代码也简洁了许多。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>线程池虽解决了不少问题，但在复杂并发场景下仍显不足。例如，线程的生命周期管理不够直观，错误处理繁琐。当同时发起多个网络请求时，手动管理每个线程的执行结果会让代码瞬间变得混乱。</p>
<p><strong>小贴士</strong>：传统并发编程中，线程管理如同“走钢丝”，稍有不慎就会出错。</p>
<h2> 结构化并发：概念与核心原理</h2>
<h3> 结构化并发是什么</h3>
<p>想象一下，你正在开发一个电商系统，需要同时处理多个任务，如查询商品信息、计算订单总价、验证用户支付信息等。这些任务相互独立，却又同属处理订单这个大任务。要是能有一种方式，将这些任务有序组织起来，那该多好？</p>
<p>Java 21的结构化并发正是为此而生！它把并发任务组织成清晰的层次结构，类似一棵树，每个任务都可有自己的子任务。如此一来，任务间的关系一目了然，管理也变得轻松便捷。</p>
<p>举个例子，假设开发一个电商订单处理系统，处理订单的任务可拆分为以下子任务：</p>
<ol>
<li>查询商品信息。</li>
<li>计算订单总价。</li>
<li>验证用户支付信息。</li>
</ol>
<p>这些子任务都隶属于处理订单这个父任务，形成清晰的任务层次结构，任务关系清晰，管理方便。</p>
<h3> 核心原理剖析</h3>
<h4> 任务层次结构</h4>
<p>结构化并发将任务构建成层次分明的结构，如同树状，每个任务可包含多个子任务，子任务又能有自己的子任务。这种结构让任务间的关系清晰明了，便于管理和调度。</p>
<h4> 结果处理规则</h4>
<p>在结构化并发里，子任务的结果只会返回给直接启动它们的父任务，不会随意传递给其他无关任务。这确保了任务间的数据流动有序且可预测。</p>
<h4> 生命周期绑定</h4>
<p>子任务的生命周期不能超过其父任务。一旦父任务结束，所有未完成的子任务会被自动取消，有效避免了线程泄漏和资源浪费。</p>
<h4> 任务的协作与控制</h4>
<p>父任务能依据子任务的执行情况，灵活决定是否继续执行其他子任务，或提前结束整个任务。这种协作与控制机制使并发任务的执行更高效、更智能。</p>
<p><strong>小贴士</strong>：结构化并发就像给并发任务戴上了“紧箍咒”，让它们的执行更可控、更可预测。</p>
<h2> Java 21结构化并发特性深度解析</h2>
<h3> 上下文关联的任务创建</h3>
<p>在Java 21的结构化并发中，上下文关联的任务创建是一项关键特性。它允许我们在特定代码块或作用域内创建并发任务，这些任务会自动与创建它们的上下文关联。当上下文结束时，相关任务会被自动清理，比如取消未完成的任务、收集任务执行结果等，极大地简化了任务管理的复杂性。</p>
<p>举个例子，假设开发一个Web应用程序，处理用户请求时需并发获取多个数据源的数据。使用Java 21的结构化并发，可这样实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此例中，我们在<code>try - with - resources</code>语句块中创建了<code>StructuredTaskScope.ShutdownOnFailure</code>对象<code>scope</code>，它定义了任务执行的上下文。在该上下文中，通过<code>scope.fork()</code>方法创建了<code>userTask</code>和<code>orderTask</code>两个并发任务，分别用于获取用户信息和订单信息。当<code>try - with - resources</code>语句块结束时，<code>scope</code>会自动清理所有相关任务，确保无任务遗漏或泄漏。</p>
<p><strong>小贴士</strong>：<code>StructuredTaskScope</code>是结构化并发的核心API之一，如同任务的“大管家”，帮你管理任务的生命周期和结果。</p>
<h3> 更好的异常传播机制</h3>
<p>在并发编程中，异常处理一直是个难题。传统并发编程里，当一个并发任务抛出异常时，异常的传播和处理较为复杂，尤其是任务在不同线程中执行时，很难确保异常能被正确捕获和处理。</p>
<p>Java 21的结构化并发提供了更优的异常传播机制，使并发任务中的异常能得到更有效的管理。若一个子任务抛出异常，该异常会自动传播到其父任务，且整个任务结构会根据异常情况进行相应处理。</p>
<p>举个例子：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此例中，<code>task1</code>有可能抛出<code>RuntimeException</code>。当<code>task1</code>抛出异常时，<code>task2</code>会被自动取消，异常会传播到<code>scope.join()</code>处，通过<code>throwIfFailed()</code>方法抛出，最终被<code>catch</code>块捕获并处理。这样，我们就能在统一的地方处理并发任务中的异常，大幅提升了代码的健壮性和可维护性。</p>
<p><strong>小贴士</strong>：结构化并发的异常处理机制就像给并发任务装上了“安全气囊”，让异常处理更简单、更可靠。</p>
<h3> 简化并发控制的API</h3>
<p>Java 21的结构化并发提供了一系列更高级别的API，这些API极大地简化了并发控制的复杂性，让我们能更便捷地协调并发任务，减少手动同步和锁的使用，使并发逻辑更简洁清晰。</p>
<p>举个例子：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此例中，我们使用<code>StructuredTaskScope</code>创建了5个并发任务。通过<code>scope.fork()</code>方法可轻松启动每个任务，无需手动管理线程的创建和启动。<code>scope.join()</code>方法会等待所有任务完成，<code>throwIfFailed()</code>方法会检查是否有任务失败并抛出异常。最后，通过<code>scope.subtasks()</code>方法可获取每个任务的执行结果。这种方式让并发任务的控制和管理变得简单直观，大大减少了手动编写同步和锁代码的工作量。</p>
<p><strong>小贴士</strong>：<code>StructuredTaskScope</code>的API就像并发任务的“瑞士军刀”，让并发控制更简单、更高效。</p>
<h3> 与虚拟线程的完美融合</h3>
<p>Java 21引入的虚拟线程是一种轻量级线程实现，其创建和销毁开销极小，能在一个操作系统线程上运行大量虚拟线程，显著提升系统的并发处理能力。结构化并发与虚拟线程的结合，充分发挥了两者的优势，为高效并发编程提供了强大支持。</p>
<p>举个例子，假设开发一个高并发的网络爬虫应用，需要并发访问大量网页。使用虚拟线程和结构化并发，可这样实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此例中，我们使用虚拟线程并发访问多个URL。每个URL的访问任务通过<code>scope.fork()</code>方法创建，这些任务在虚拟线程中执行。由于虚拟线程的轻量级特性，我们可轻松创建大量任务，而不会对系统资源造成过大压力。同时，借助结构化并发的<code>StructuredTaskScope</code>，我们能方便地管理这些任务的生命周期和结果，确保所有任务正确执行并返回结果。这种结合方式使我们能高效处理高并发网络请求，提升应用程序的性能和响应速度。</p>
<p><strong>小贴士</strong>：虚拟线程和结构化并发的结合，就像给并发编程装上了“超级加速器”，让高并发任务处理变得轻松自如。</p>
<h2> 代码示例：实战Java 21结构化并发</h2>
<h3> 简单任务并发执行</h3>
<p>下面通过一个简单示例展示如何使用Java 21的结构化并发实现多个任务的并发执行。假设我们有三个独立任务，每个任务模拟一个耗时操作并返回结果。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此示例中，我们创建了<code>StructuredTaskScope.ShutdownOnFailure</code>对象<code>scope</code>，定义了任务执行范围。在该范围内，使用<code>scope.fork()</code>方法创建了<code>task1</code>、<code>task2</code>和<code>task3</code>三个并发任务。每个任务在独立线程中执行，并模拟了不同的耗时操作。</p>
<p><code>scope.join()</code>方法会阻塞当前线程，直至所有子任务完成。<code>throwIfFailed()</code>方法会检查是否有任务执行失败，若有则抛出异常。最后，通过<code>task1.resultNow()</code>、<code>task2.resultNow()</code>和<code>task3.resultNow()</code>方法获取并打印每个任务的执行结果。</p>
<p><strong>小贴士</strong>：结构化并发让并发任务管理如同“搭积木”，任务间关系一目了然。</p>
<h3> 复杂任务场景应用</h3>
<p>在实际开发中，常遇到复杂任务场景，如多任务依赖、任务优先级控制等。下面通过一个示例展示如何在这些场景下使用Java 21的结构化并发。</p>
<p>假设开发一个电商数据分析系统，需要从多个数据源获取数据，然后进行汇总和分析。其中，获取用户数据和订单数据的任务相互独立，可并发执行，但生成报表的任务依赖于用户数据和订单数据的获取结果。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此示例中，我们先创建了<code>userDataTask</code>和<code>orderDataTask</code>两个并发任务，分别用于获取用户数据和订单数据。通过<code>scope.join().throwIfFailed()</code>等待这两个任务完成，并获取结果。</p>
<p>接着，创建<code>reportTask</code>任务，它依赖于<code>userDataTask</code>和<code>orderDataTask</code>的结果，用于生成报表。最后，再次通过<code>scope.join().throwIfFailed()</code>等待报表生成任务完成，并获取报表结果进行打印。</p>
<p>通过这种方式，我们能清晰管理任务间的依赖关系，使复杂的并发任务逻辑更易于理解和维护。</p>
<p><strong>小贴士</strong>：结构化并发就像并发任务的“指挥官”，让任务协作有条不紊。</p>
<h2> 结构化并发应用场景与优势</h2>
<h3> 常见应用场景</h3>
<ul>
<li><strong>Web开发</strong>：在处理用户请求时，经常需要并发地获取多个数据源的数据，然后进行整合和处理。结构化并发可以轻松地并发执行这些任务，提高页面的加载速度和用户体验。</li>
<li><strong>大数据处理</strong>：在大数据处理中，常常需要对大量的数据进行并行计算和分析。结构化并发可以将数据处理任务拆分成多个子任务，每个子任务在独立的线程中执行，然后将结果合并，从而实现高效的数据处理。</li>
<li><strong>分布式系统</strong>：在分布式系统中，各个节点之间的通信和协作往往是并发进行的。结构化并发可以更好地管理这些并发操作，确保数据的一致性和系统的稳定性。</li>
</ul>
<h3> 相比传统并发的显著优势</h3>
<ul>
<li><strong>避免线程泄漏</strong>：结构化并发中，子任务的生命周期与父任务紧密绑定，当父任务结束时，所有未完成的子任务都会被自动取消，从而有效地避免了线程泄漏的发生。</li>
<li><strong>降低死锁风险</strong>：结构化并发通过明确的任务层次结构和执行顺序，减少了死锁发生的可能性。</li>
<li><strong>提高代码可读性和可维护性</strong>：结构化并发将并发任务组织成一个清晰的结构，使得代码的逻辑更加直观，易于理解和维护。</li>
<li><strong>提升性能</strong>：通过与虚拟线程的结合，结构化并发能够充分利用虚拟线程的轻量级特性，在处理大量并发任务时，减少线程创建和上下文切换的开销，从而显著提升系统的性能和响应速度。</li>
</ul>
<p><strong>小贴士</strong>：结构化并发就像是并发编程的“升级版”，让代码不仅更简洁，还更安全、更高效。</p>
<h2> 总结与展望</h2>
<p>Java 21的结构化并发为并发编程带来了重大的变革，它通过清晰的任务层次结构、更好的异常传播机制、简化的并发控制API以及与虚拟线程的完美融合，使得并发编程变得更加简单、可靠和高效。</p>
<p>在Web开发、大数据处理、分布式系统等众多领域，结构化并发都展现出了巨大的优势，能够帮助开发者更轻松地应对复杂的并发场景。</p>
<p>随着Java的不断发展，结构化并发有望成为并发编程的主流范式，为Java应用的性能和可靠性提供更强大的支持。我鼓励各位开发者积极尝试Java 21的结构化并发，将其应用到实际项目中，体验它带来的便利和优势。</p>
<p>如果你在使用Java 21结构化并发的过程中有任何问题、心得或体会，欢迎在留言区分享交流，让我们一起学习，共同进步！</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-14T18:21:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">jdk8+迭代记录</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/"/>
    <updated>2025-02-14T10:52:18.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>这里记录JDK8+之后的新的特性</p>
</blockquote>
<p>Java 8（2014年发布）到 Java 21（2023年发布）经历了多次迭代，新增了大量特性和改进。以下是主要版本（Java 9 到 Java 21）中值得关注的新特性分类整理：</p>
<hr>
<h3> <strong>一、语言特性改进</strong></h3>
<ol>
<li>
<p><strong>模块化系统（Java 9）</strong></p>
<ul>
<li><strong>Jigsaw 项目</strong>：引入模块化（<code>module-info.java</code>），解决 JAR 依赖和封装问题，提升安全性和可维护性。</li>
</ul>
</li>
<li>
<p><strong>局部变量类型推断（Java 10）</strong></p>
<ul>
<li><strong><code>var</code> 关键字</strong>：允许在局部变量声明时省略显式类型（如 <code>var list = new ArrayList&lt;String&gt;();</code>）。</li>
</ul>
</li>
<li>
<p><strong>文本块（Java 15 正式支持）</strong></p>
<ul>
<li><strong>多行字符串</strong>：使用 <code>""" ... """</code> 简化 HTML、JSON 等多行文本的编写。</li>
</ul>
</li>
<li>
<p><strong>模式匹配（逐步引入）</strong></p>
<ul>
<li><strong><code>instanceof</code> 模式匹配（Java 16）</strong>：直接提取对象属性，如 <code>if (obj instanceof String s) { ... }</code>。</li>
<li><strong><code>switch</code> 表达式（Java 14）</strong>：支持箭头语法和返回值，避免 <code>break</code> 的繁琐。</li>
<li><strong>模式匹配 <code>switch</code>（Java 21 正式）</strong>：支持类型匹配和复杂条件，例如：<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token class-name">Integer</span> i <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Integer: "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token class-name">String</span> s when s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Long string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p><strong>记录类（Record，Java 16 正式）</strong></p>
<ul>
<li>简化不可变数据类的定义，自动生成 <code>equals()</code>、<code>hashCode()</code> 等方法：<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">record</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p><strong>密封类（Sealed Classes，Java 17 正式）</strong></p>
<ul>
<li>限制类的继承关系，明确子类范围：<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token keyword">permits</span> <span class="token class-name">Circle</span><span class="token punctuation">,</span> <span class="token class-name">Square</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p><strong>字符串模板（Java 21 预览）</strong></p>
<ul>
<li>类似其他语言的模板插值功能，例如：<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"John"</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token string">"Hello \{name}!"</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
</ol>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p>这里记录JDK8+之后的新的特性</p>
</blockquote>
<p>Java 8（2014年发布）到 Java 21（2023年发布）经历了多次迭代，新增了大量特性和改进。以下是主要版本（Java 9 到 Java 21）中值得关注的新特性分类整理：</p>
<hr>
<h3> <strong>一、语言特性改进</strong></h3>
<ol>
<li>
<p><strong>模块化系统（Java 9）</strong></p>
<ul>
<li><strong>Jigsaw 项目</strong>：引入模块化（<code>module-info.java</code>），解决 JAR 依赖和封装问题，提升安全性和可维护性。</li>
</ul>
</li>
<li>
<p><strong>局部变量类型推断（Java 10）</strong></p>
<ul>
<li><strong><code>var</code> 关键字</strong>：允许在局部变量声明时省略显式类型（如 <code>var list = new ArrayList&lt;String&gt;();</code>）。</li>
</ul>
</li>
<li>
<p><strong>文本块（Java 15 正式支持）</strong></p>
<ul>
<li><strong>多行字符串</strong>：使用 <code>""" ... """</code> 简化 HTML、JSON 等多行文本的编写。</li>
</ul>
</li>
<li>
<p><strong>模式匹配（逐步引入）</strong></p>
<ul>
<li><strong><code>instanceof</code> 模式匹配（Java 16）</strong>：直接提取对象属性，如 <code>if (obj instanceof String s) { ... }</code>。</li>
<li><strong><code>switch</code> 表达式（Java 14）</strong>：支持箭头语法和返回值，避免 <code>break</code> 的繁琐。</li>
<li><strong>模式匹配 <code>switch</code>（Java 21 正式）</strong>：支持类型匹配和复杂条件，例如：<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p><strong>记录类（Record，Java 16 正式）</strong></p>
<ul>
<li>简化不可变数据类的定义，自动生成 <code>equals()</code>、<code>hashCode()</code> 等方法：<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p><strong>密封类（Sealed Classes，Java 17 正式）</strong></p>
<ul>
<li>限制类的继承关系，明确子类范围：<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p><strong>字符串模板（Java 21 预览）</strong></p>
<ul>
<li>类似其他语言的模板插值功能，例如：<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
</ol>
<hr>
<h3> <strong>二、API 增强</strong></h3>
<ol>
<li>
<p><strong>新的集合工厂方法（Java 9）</strong></p>
<ul>
<li>快速创建不可变集合：<code>List.of("a", "b")</code>、<code>Set.of(1, 2)</code>、<code>Map.of("k", "v")</code>。</li>
</ul>
</li>
<li>
<p><strong>Stream API 增强</strong></p>
<ul>
<li><strong><code>takeWhile</code>/<code>dropWhile</code>（Java 9）</strong>：根据条件截取流。</li>
<li><strong><code>Collectors.toUnmodifiableList()</code>（Java 10）</strong>：生成不可变集合。</li>
</ul>
</li>
<li>
<p><strong>HTTP/2 客户端（Java 11 正式）</strong></p>
<ul>
<li>支持异步请求的现代 HTTP 客户端（<code>java.net.http.HttpClient</code>）。</li>
</ul>
</li>
<li>
<p><strong>进程 API 改进（Java 9+）</strong></p>
<ul>
<li>管理操作系统进程（如获取 PID、直接执行命令）。</li>
</ul>
</li>
<li>
<p><strong>新的日期时间 API（Java 8 已有，后续优化）</strong></p>
<ul>
<li><code>java.time</code> 包优化，例如 <code>LocalDate</code>、<code>ZonedDateTime</code> 等。</li>
</ul>
</li>
</ol>
<hr>
<h3> <strong>三、并发与性能</strong></h3>
<ol>
<li>
<p><strong>虚拟线程（Virtual Threads，Java 21 正式）</strong></p>
<ul>
<li>轻量级线程（协程），显著提升高并发吞吐量，简化异步编程：<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p><strong>结构化并发（Java 21 预览）</strong></p>
<ul>
<li>通过 <code>StructuredTaskScope</code> 管理多个子任务的生命周期，避免资源泄漏。</li>
</ul>
</li>
<li>
<p><strong>分代 ZGC（Java 21）</strong></p>
<ul>
<li>低延迟垃圾收集器 ZGC 支持分代回收，减少内存占用。</li>
</ul>
</li>
<li>
<p><strong>Shenandoah GC（Java 12+）</strong></p>
<ul>
<li>另一种低停顿时间的垃圾收集器。</li>
</ul>
</li>
</ol>
<hr>
<h3> <strong>四、工具与 JVM 改进</strong></h3>
<ol>
<li>
<p><strong>JShell（Java 9）</strong></p>
<ul>
<li>交互式 REPL 工具，快速测试代码片段。</li>
</ul>
</li>
<li>
<p><strong>单文件源码运行（Java 11）</strong></p>
<ul>
<li>直接运行 <code>.java</code> 文件（无需手动编译）：<code>java HelloWorld.java</code>。</li>
</ul>
</li>
<li>
<p><strong>动态 CDS 存档（Java 13+）</strong></p>
<ul>
<li>提升启动速度，通过共享类数据减少内存占用。</li>
</ul>
</li>
<li>
<p><strong>Flight Recorder（JFR）开源（Java 11）</strong></p>
<ul>
<li>生产环境性能监控工具，低开销收集 JVM 数据。</li>
</ul>
</li>
</ol>
<hr>
<h3> <strong>五、其他重要特性</strong></h3>
<ol>
<li>
<p><strong><code>var</code> 支持 Lambda 参数（Java 11）</strong></p>
<ul>
<li>允许在 Lambda 表达式中使用 <code>var</code> 声明参数。</li>
</ul>
</li>
<li>
<p><strong><code>@Deprecated</code> 增强（Java 9）</strong></p>
<ul>
<li>标记 API 废弃状态和替代方案。</li>
</ul>
</li>
<li>
<p><strong>接口私有方法（Java 9）</strong></p>
<ul>
<li>在接口中定义私有方法，提升代码复用性。</li>
</ul>
</li>
<li>
<p><strong>移除过时功能</strong></p>
<ul>
<li>移除 Applet、Java Web Start、永久代（PermGen）等。</li>
</ul>
</li>
</ol>
<hr>
<h3> <strong>六、Java 21 核心特性总结</strong></h3>
<p>Java 21 作为 LTS（长期支持版本），整合了此前多个预览特性，并重点优化了并发和内存管理：</p>
<ul>
<li><strong>虚拟线程</strong>：彻底改变高并发编程模型。</li>
<li><strong>分代 ZGC</strong>：提升垃圾回收效率。</li>
<li><strong>模式匹配</strong>：简化条件分支代码。</li>
<li><strong>字符串模板</strong>：增强字符串处理能力。</li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-14T10:52:18.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">06.JDK21增强的模式匹配：更简洁、更强大的条件逻辑</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/06.%E5%A2%9E%E5%BC%BA%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk21/06.%E5%A2%9E%E5%BC%BA%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D.html"/>
    <updated>2025-02-13T11:02:29.000Z</updated>
    <summary type="html"><![CDATA[<h2> 1. 背景：为什么需要增强的模式匹配？</h2>
<p>在Java中，条件逻辑通常通过<code>if-else</code>或<code>switch</code>语句实现，但这些方式存在以下问题：</p>
<ol>
<li><strong>冗长</strong>：需要显式类型检查和类型转换</li>
<li><strong>易错</strong>：手动类型转换可能导致<code>ClassCastException</code></li>
<li><strong>局限性</strong>：<code>switch</code>语句仅支持有限的数据类型</li>
</ol>
<p><strong>增强的模式匹配</strong>（Enhanced Pattern Matching）是Java模式匹配的进一步扩展，旨在简化条件逻辑的编写。它结合了<strong>类型检查</strong>、<strong>类型转换</strong>和<strong>模式匹配</strong>的特性，使开发者能够以声明式的方式处理复杂条件逻辑。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 1. 背景：为什么需要增强的模式匹配？</h2>
<p>在Java中，条件逻辑通常通过<code>if-else</code>或<code>switch</code>语句实现，但这些方式存在以下问题：</p>
<ol>
<li><strong>冗长</strong>：需要显式类型检查和类型转换</li>
<li><strong>易错</strong>：手动类型转换可能导致<code>ClassCastException</code></li>
<li><strong>局限性</strong>：<code>switch</code>语句仅支持有限的数据类型</li>
</ol>
<p><strong>增强的模式匹配</strong>（Enhanced Pattern Matching）是Java模式匹配的进一步扩展，旨在简化条件逻辑的编写。它结合了<strong>类型检查</strong>、<strong>类型转换</strong>和<strong>模式匹配</strong>的特性，使开发者能够以声明式的方式处理复杂条件逻辑。</p>
<p>JDK16首次引入模式匹配<code>instanceof</code>，JDK17扩展了<code>switch</code>的模式匹配能力，JDK21进一步优化并正式发布。</p>
<h2> 2. 原理：增强的模式匹配如何工作？</h2>
<h3> 2.1 传统条件逻辑 vs 增强的模式匹配</h3>
<h4> 传统方式</h4>
<ul>
<li><strong>显式类型检查</strong>：使用<code>instanceof</code>检查类型</li>
<li><strong>显式类型转换</strong>：手动进行类型转换</li>
<li><strong>冗长代码</strong>：需要多行代码完成简单操作</li>
</ul>
<h4> 增强的模式匹配</h4>
<ul>
<li><strong>声明式匹配</strong>：直接匹配类型并绑定变量</li>
<li><strong>自动类型转换</strong>：编译器自动推断类型，无需显式类型转换</li>
<li><strong>简洁代码</strong>：减少样板代码，提升开发效率</li>
</ul>
<h3> 2.2 核心机制</h3>
<ol>
<li>
<p><strong>模式匹配<code>instanceof</code></strong><br>
在<code>instanceof</code>中直接绑定变量，例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>模式匹配<code>switch</code></strong><br>
在<code>switch</code>中支持类型匹配和模式解构，例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>嵌套模式匹配</strong><br>
支持嵌套模式匹配，简化复杂数据结构的处理。</p>
</li>
<li>
<p><strong>类型推断</strong><br>
编译器自动推断匹配类型，减少显式类型转换。</p>
</li>
</ol>
<h3> 2.3 优势：为什么选择增强的模式匹配？</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>传统方式</th>
<th>增强的模式匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td>代码简洁性</td>
<td>冗长</td>
<td><strong>简洁</strong></td>
</tr>
<tr>
<td>类型安全性</td>
<td>需显式类型转换</td>
<td><strong>自动推断</strong></td>
</tr>
<tr>
<td>嵌套支持</td>
<td>手动逐层匹配</td>
<td><strong>自动解构</strong></td>
</tr>
<tr>
<td>可读性</td>
<td>低</td>
<td><strong>高</strong></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>代码简洁</strong>：减少样板代码，提升开发效率</li>
<li><strong>类型安全</strong>：编译器自动检查类型，减少运行时错误</li>
<li><strong>嵌套支持</strong>：轻松处理复杂数据结构</li>
<li><strong>可读性高</strong>：声明式语法更符合直觉</li>
</ol>
<h2> 3. 使用示例</h2>
<h3> 示例1：模式匹配<code>instanceof</code></h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例2：模式匹配<code>switch</code></h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例3：嵌套模式匹配</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例4：结合<code>switch</code>表达式</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3.小结</h2>
<h3> 3.1 注意事项</h3>
<ol>
<li>
<p><strong>类型检查顺序</strong><br>
在<code>switch</code>中，更具体的模式应放在前面：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>空值处理</strong><br>
模式匹配不支持<code>null</code>值匹配，需额外检查：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p><strong>性能影响</strong><br>
模式匹配在运行时可能引入额外开销，需在性能敏感场景中测试。</p>
</li>
<li>
<p><strong>兼容性</strong><br>
增强的模式匹配需要JDK16及以上版本。</p>
</li>
</ol>
<h3> 3.2 总结</h3>
<p>JDK21增强的模式匹配通过以下革新提升Java条件逻辑的效率：</p>
<ul>
<li>✅ 简化条件逻辑代码</li>
<li>✅ 提升类型安全性和可读性</li>
<li>✅ 支持嵌套模式匹配</li>
<li>✅ 与<code>switch</code>表达式无缝集成</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>处理复杂条件逻辑</li>
<li>实现类型安全的模式匹配</li>
<li>简化数据验证和提取</li>
</ul>
<p>增强的模式匹配是Java模式匹配的重要扩展，有兴趣的小伙伴可以参考<a href="https://openjdk.org/jeps/406" target="_blank" rel="noopener noreferrer">官方文档</a>以掌握最佳实践。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK21"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-13T17:58:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">01.JDK21新特性及示例说明</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/01.JDK21%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk21/01.JDK21%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E.html"/>
    <updated>2025-02-13T08:59:24.000Z</updated>
    <summary type="html"><![CDATA[<p>JDK 21 在 JDK 8 的基础上引入了许多新特性，下面详细介绍一些主要特性并给出相应的示例代码：</p>
<h3> 1. 虚拟线程（Virtual Threads）</h3>
<p>虚拟线程是 JDK 21 引入的轻量级线程，能够以较低的开销处理大量并发任务。与传统的平台线程相比，虚拟线程由 Java 运行时管理，不需要操作系统内核线程的支持，从而可以创建数百万个虚拟线程而不会耗尽系统资源。</p>
<p><strong>示例代码</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ExecutorService</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Executors</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VirtualThreadsExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个虚拟线程执行器</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newVirtualThreadPerTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">final</span> <span class="token keyword">int</span> taskId <span class="token operator">=</span> i<span class="token punctuation">;</span>
                <span class="token comment">// 提交任务到执行器</span>
                executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Task "</span> <span class="token operator">+</span> taskId <span class="token operator">+</span> <span class="token string">" is running on thread: "</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        <span class="token comment">// 模拟任务执行</span>
                        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Task "</span> <span class="token operator">+</span> taskId <span class="token operator">+</span> <span class="token string">" is completed."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<p>JDK 21 在 JDK 8 的基础上引入了许多新特性，下面详细介绍一些主要特性并给出相应的示例代码：</p>
<h3> 1. 虚拟线程（Virtual Threads）</h3>
<p>虚拟线程是 JDK 21 引入的轻量级线程，能够以较低的开销处理大量并发任务。与传统的平台线程相比，虚拟线程由 Java 运行时管理，不需要操作系统内核线程的支持，从而可以创建数百万个虚拟线程而不会耗尽系统资源。</p>
<p><strong>示例代码</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 结构化并发（Structured Concurrency）</h3>
<p>结构化并发是一种新的并发编程模型，它将一组相关的任务视为一个单一的工作单元，使得任务的管理和错误处理更加简单和直观。通过使用 <code>StructuredTaskScope</code>，可以方便地启动和等待多个并发任务的完成。</p>
<p><strong>示例代码</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 记录模式（Record Patterns）</h3>
<p>记录模式允许在模式匹配中解构记录类型，使得代码更加简洁和易读。结合 <code>instanceof</code> 和 <code>switch</code> 表达式，可以更方便地处理记录类型的数据。</p>
<p><strong>示例代码</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 字符串模板（String Templates）</h3>
<p>字符串模板是一种新的字符串构建机制，它允许在字符串中嵌入表达式，使得字符串的拼接更加直观和方便。</p>
<p><strong>示例代码</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 增强的模式匹配（Enhanced Pattern Matching）</h3>
<p>JDK 21 进一步增强了模式匹配的功能，支持更复杂的模式匹配，如嵌套模式匹配和类型测试模式。</p>
<p><strong>示例代码</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK21"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-13T09:48:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">02.JDK21虚拟线程：重新定义Java高并发编程</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/02.%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk21/02.%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html"/>
    <updated>2025-02-13T08:59:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 1. 背景：为什么需要虚拟线程？</h2>
<p>在传统Java并发模型中，每个<code>java.lang.Thread</code>都直接对应一个操作系统线程（称为<strong>平台线程</strong>）。虽然这种1:1的模型保证了可靠的并发执行，但存在两个关键瓶颈：</p>
<ol>
<li><strong>资源限制</strong>：操作系统线程创建成本高（默认1MB栈空间），难以支持百万级并发</li>
<li><strong>上下文切换开销</strong>：线程数量激增时，CPU时间大量消耗在切换线程上下文上</li>
</ol>
<p>开发者通常通过线程池和异步编程（如CompletableFuture）缓解这些问题，但这导致了代码复杂度上升。<strong>Project Loom</strong>应运而生，其核心成果<strong>虚拟线程</strong>在JDK19中首次预览，最终在JDK21正式发布。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 1. 背景：为什么需要虚拟线程？</h2>
<p>在传统Java并发模型中，每个<code>java.lang.Thread</code>都直接对应一个操作系统线程（称为<strong>平台线程</strong>）。虽然这种1:1的模型保证了可靠的并发执行，但存在两个关键瓶颈：</p>
<ol>
<li><strong>资源限制</strong>：操作系统线程创建成本高（默认1MB栈空间），难以支持百万级并发</li>
<li><strong>上下文切换开销</strong>：线程数量激增时，CPU时间大量消耗在切换线程上下文上</li>
</ol>
<p>开发者通常通过线程池和异步编程（如CompletableFuture）缓解这些问题，但这导致了代码复杂度上升。<strong>Project Loom</strong>应运而生，其核心成果<strong>虚拟线程</strong>在JDK19中首次预览，最终在JDK21正式发布。</p>
<h2> 2. 原理：虚拟线程如何工作？</h2>
<h3> 2.1 传统线程模型 vs 虚拟线程模型</h3>
<h4> 传统线程模型（平台线程）</h4>
<ul>
<li><strong>1:1 模型</strong>：每个Java线程直接映射到一个操作系统线程。</li>
<li><strong>资源开销大</strong>：每个线程默认占用1MB栈空间，创建和销毁成本高。</li>
<li><strong>上下文切换依赖内核</strong>：线程切换需要内核介入，开销较大。</li>
<li><strong>并发限制</strong>：受限于操作系统线程数（通常数千个）。</li>
</ul>
<h4> 虚拟线程模型</h4>
<ul>
<li><strong>M:N 模型</strong>：大量虚拟线程（M）复用在少量平台线程（N）上运行。</li>
<li><strong>轻量级</strong>：虚拟线程的栈空间按需分配，初始内存占用仅几百字节。</li>
<li><strong>协作式调度</strong>：虚拟线程在阻塞操作（如I/O）时自动让出执行权，由JVM调度器管理。</li>
<li><strong>高并发支持</strong>：可轻松创建数百万个虚拟线程。</li>
</ul>
<h3> 虚拟线程的核心机制</h3>
<ol>
<li>
<p><strong>Continuation（延续体）</strong></p>
<ul>
<li>虚拟线程的核心是一个可暂停和恢复的任务单元（Continuation）。</li>
<li>当虚拟线程执行阻塞操作时，JVM会保存当前状态并挂起任务，切换到其他虚拟线程。</li>
<li>阻塞操作完成后，JVM恢复任务状态并继续执行。</li>
</ul>
</li>
<li>
<p><strong>调度器</strong></p>
<ul>
<li>默认使用<code>ForkJoinPool</code>作为调度器，将虚拟线程分配到平台线程上执行。</li>
<li>调度器负责在虚拟线程阻塞时将其从平台线程上卸载，并在就绪时重新调度。</li>
</ul>
</li>
<li>
<p><strong>栈管理</strong></p>
<ul>
<li>虚拟线程的栈空间是动态分配的，按需增长和收缩。</li>
<li>通过<strong>Stack Chunk</strong>技术，JVM可以高效地管理虚拟线程的栈内存。</li>
</ul>
</li>
<li>
<p><strong>阻塞操作优化</strong></p>
<ul>
<li>虚拟线程在执行I/O、锁等待等阻塞操作时，会自动让出平台线程。</li>
<li>这种机制避免了平台线程的浪费，提高了资源利用率。</li>
</ul>
</li>
</ol>
<h4> 对比总结</h4>
<table>
<thead>
<tr>
<th>特性</th>
<th>平台线程</th>
<th>虚拟线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>线程模型</td>
<td>1:1（Java线程:OS线程）</td>
<td>M:N（虚拟线程:平台线程）</td>
</tr>
<tr>
<td>内存开销</td>
<td>默认1MB/线程</td>
<td><strong>~200字节/线程</strong></td>
</tr>
<tr>
<td>上下文切换</td>
<td>内核参与，开销大</td>
<td><strong>JVM管理，开销小</strong></td>
</tr>
<tr>
<td>阻塞操作</td>
<td>占用平台线程</td>
<td><strong>自动让出平台线程</strong></td>
</tr>
<tr>
<td>并发能力</td>
<td>数千级</td>
<td><strong>百万级</strong></td>
</tr>
</tbody>
</table>
<h3> 2.2 虚拟线程调度</h3>
<p>虚拟现成的调度主要包含三个核心部分：虚拟线程（Virtual Threads）、平台线程（Platform Threads）和调度器（Scheduler）。</p>
<ol>
<li><strong>虚拟线程池：</strong></li>
</ol>
<ul>
<li>这是一个包含大量虚拟线程的集合。每个虚拟线程代表一个轻量级的执行单元，它们可以由用户代码创建并提交到执行器中等待执行。虚拟线程之间是平等的，它们的栈空间较小，创建和销毁的开销也很低。</li>
</ul>
<ol start="2">
<li><strong>平台线程池：</strong></li>
</ol>
<ul>
<li>平台线程是与操作系统内核线程一一对应的线程，数量相对较少。平台线程负责执行虚拟线程中的实际任务，它们是系统资源的实际使用者。</li>
</ul>
<ol start="3">
<li><strong>调度器：</strong></li>
</ol>
<ul>
<li>调度器是整个系统的核心，负责将虚拟线程分配到可用的平台线程上执行。</li>
<li>调度器会根据虚拟线程的状态（如就绪、阻塞等）和平台线程的负载情况进行智能调度。</li>
<li>当一个虚拟线程遇到阻塞操作（如 I/O 操作）时，调度器会将该虚拟线程暂停，并将平台线程分配给其他就绪的虚拟线程；当阻塞操作完成后，调度器会将该虚拟线程重新加入到就绪队列中，等待再次分配到平台线程执行。</li>
</ul>
<ol start="4">
<li><strong>阻塞与唤醒机制：</strong></li>
</ol>
<ul>
<li>当虚拟线程进行 I/O 等阻塞操作时，会触发阻塞信号，调度器将其标记为阻塞状态并让出平台线程；</li>
<li>当阻塞操作完成，会有唤醒信号，调度器将其重新标记为就绪状态等待调度。</li>
</ul>
<p>虚拟线程调度的基本流程：</p>
<p>虚拟线程进入调度器，调度器将其分配到平台线程执行，当平台线程上的虚拟线程遇到阻塞操作时通知调度器，调度器再去唤醒其他就绪的虚拟线程执行。</p>
<figure><img src="/imgs/column/java/jdk21_virtual_thread_00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2.3 优势：为什么选择虚拟线程？</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>平台线程</th>
<th>虚拟线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建数量</td>
<td>数千级</td>
<td><strong>百万级</strong></td>
</tr>
<tr>
<td>内存消耗</td>
<td>默认1MB/线程</td>
<td><strong>~200字节/线程</strong></td>
</tr>
<tr>
<td>上下文切换</td>
<td>内核参与</td>
<td><strong>JVM优化</strong></td>
</tr>
<tr>
<td>编程模型</td>
<td>回调地狱风险</td>
<td><strong>同步代码风格</strong></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>高吞吐</strong>：轻松支撑10万+并发连接</li>
<li><strong>低资源消耗</strong>：创建百万虚拟线程仅需几百MB内存</li>
<li><strong>代码简化</strong>：用同步代码实现异步性能，避免回调地狱</li>
<li><strong>兼容性</strong>：与现有Thread API、调试工具（如jstack）完全兼容</li>
</ol>
<h2> 3. 使用示例</h2>
<h3> 示例1：创建虚拟线程</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例2：HTTP服务器对比</h3>
<p><strong>传统线程池（20线程）：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>虚拟线程版：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例3：使用虚拟线程实现归并排序</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明：</strong></p>
<ul>
<li>使用虚拟线程并行化归并排序的递归任务。</li>
<li>每个子任务（<code>mergeSort</code>）都在独立的虚拟线程中执行。</li>
<li>通过<code>Future</code>获取子任务结果，并合并（<code>merge</code>）排序后的数组。</li>
</ul>
<h2> 4.小结</h2>
<h3> 4.1 注意事项</h3>
<ol>
<li><strong>阻塞操作仍影响平台线程</strong></li>
</ol>
<p>在<code>synchronized</code>块或native方法中阻塞会占用平台线程</p>
<ol start="2">
<li><strong>避免在虚拟线程中：</strong></li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li><strong>正确关闭ExecutorService</strong></li>
</ol>
<p>使用try-with-resources确保自动关闭</p>
<ol start="4">
<li><strong>不要池化虚拟线程</strong></li>
</ol>
<p>每个任务应新建虚拟线程（JVM已优化创建成本）</p>
<ol start="5">
<li><strong>性能考虑</strong></li>
</ol>
<p>虚拟线程适合处理 I/O 密集型任务，而传统线程更适合处理 CPU 密集型任务。在设计系统时，需要根据任务的特点合理分配线程类型，以充分发挥各自的优势。</p>
<ol start="6">
<li><strong>资源管理：</strong></li>
</ol>
<p>无论是虚拟线程还是传统线程，都需要注意资源的合理使用和释放，避免出现资源泄漏的问题。</p>
<h3> 4.2 小结</h3>
<p>JDK21虚拟线程通过以下革新重塑Java并发：</p>
<ul>
<li>✅ 使高并发应用的代码复杂度降低50%+</li>
<li>✅ 吞吐量提升10倍（Tomcat基准测试数据）</li>
<li>✅ 完全兼容现有代码和监控工具</li>
</ul>
<p><strong>适用场景</strong>：高并发服务、微服务架构、异步IO处理等</p>
<p>尽管虚拟线程并非万能（CPU密集型任务仍需平台线程），但它无疑是Java在云原生时代的重要进化。 有兴趣的小伙伴快尝试下吧，<a href="https://docs.oracle.com/en/java/javase/21/core/virtual-threads.html" target="_blank" rel="noopener noreferrer">更多使用相关推荐参考官方指导</a></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK21"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-13T11:48:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">03.JDK21结构化并发：重新定义并发任务的生命周期管理</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/03.%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk21/03.%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html"/>
    <updated>2025-02-13T08:59:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 1. 背景：为什么需要结构化并发？</h2>
<p>在传统Java并发编程中，开发者通过<code>ExecutorService</code>、<code>Future</code>或<code>CompletableFuture</code>管理多线程任务。然而，这些方式存在显著问题：</p>
<ol>
<li><strong>生命周期管理困难</strong>：子任务可能脱离父任务独立运行，导致“线程泄漏”</li>
<li><strong>错误处理复杂</strong>：异常可能被静默吞噬，难以追踪问题根源</li>
<li><strong>资源浪费</strong>：未及时关闭的线程池可能持续占用系统资源</li>
</ol>]]></summary>
    <content type="html"><![CDATA[<h2> 1. 背景：为什么需要结构化并发？</h2>
<p>在传统Java并发编程中，开发者通过<code>ExecutorService</code>、<code>Future</code>或<code>CompletableFuture</code>管理多线程任务。然而，这些方式存在显著问题：</p>
<ol>
<li><strong>生命周期管理困难</strong>：子任务可能脱离父任务独立运行，导致“线程泄漏”</li>
<li><strong>错误处理复杂</strong>：异常可能被静默吞噬，难以追踪问题根源</li>
<li><strong>资源浪费</strong>：未及时关闭的线程池可能持续占用系统资源</li>
</ol>
<p><strong>结构化并发</strong>（Structured Concurrency）的概念源自结构化编程，核心思想是<strong>任务的生命周期应与其创建者的作用域严格绑定</strong>。JDK21通过JEP 453引入结构化并发API（第二次预览），旨在以同步代码风格实现可靠的异步任务管理。</p>
<hr>
<h2> 2. 原理：结构化并发如何工作？</h2>
<h3> 2.1 传统并发 vs 结构化并发</h3>
<h4> 传统并发模型</h4>
<ul>
<li><strong>松散的任务关系</strong>：父任务与子任务之间无强制绑定</li>
<li><strong>手动管理关闭</strong>：需显式调用<code>shutdown()</code>或<code>cancel()</code></li>
<li><strong>错误传播困难</strong>：子任务异常无法自动传递到父任务</li>
</ul>
<h4> 结构化并发模型</h4>
<ul>
<li><strong>任务作用域</strong>：所有子任务必须在父任务的作用域内执行</li>
<li><strong>自动关闭保证</strong>：作用域退出时自动取消未完成子任务</li>
<li><strong>异常冒泡机制</strong>：子任务异常会直接中断父任务执行</li>
</ul>
<h3> 核心机制</h3>
<ol>
<li>
<p><strong>作用域（Scope）</strong><br>
通过<code>StructuredTaskScope</code>定义一个任务作用域，所有子任务必须在此作用域内创建和执行。作用域关闭时，自动清理所有子任务。</p>
</li>
<li>
<p><strong>关闭顺序控制</strong></p>
<ul>
<li>父任务作用域关闭时，首先取消所有未完成的子任务</li>
<li>等待所有子任务终止后才继续执行后续代码</li>
</ul>
</li>
<li>
<p><strong>错误传播</strong><br>
任一子任务抛出异常时，自动终止作用域内所有任务，并将异常传递给父任务。</p>
</li>
<li>
<p><strong>结果聚合</strong><br>
支持通过<code>ShutdownOnSuccess</code>（任一成功即返回）或<code>ShutdownOnFailure</code>（任一失败即终止）策略聚合结果。</p>
</li>
</ol>
<h3> 2.2 架构示意图</h3>
<div class="language-plaintext line-numbers-mode" data-ext="plaintext"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em>所有子任务的生命周期严格限定在父作用域内</em></p>
<hr>
<h2> 3. 优势：为什么选择结构化并发？</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>传统并发</th>
<th>结构化并发</th>
</tr>
</thead>
<tbody>
<tr>
<td>任务关系</td>
<td>松散</td>
<td><strong>严格层级化</strong></td>
</tr>
<tr>
<td>生命周期管理</td>
<td>手动</td>
<td><strong>自动管理</strong></td>
</tr>
<tr>
<td>异常传播</td>
<td>需显式处理</td>
<td><strong>自动冒泡</strong></td>
</tr>
<tr>
<td>代码可读性</td>
<td>回调嵌套复杂</td>
<td><strong>线性流程</strong></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>可靠性提升</strong>：避免线程泄漏，确保资源及时释放</li>
<li><strong>调试简化</strong>：通过线程转储（jstack）可清晰查看任务关系树</li>
<li><strong>错误处理统一</strong>：集中处理所有子任务的异常</li>
<li><strong>资源利用率优化</strong>：自动回收未完成任务占用的资源</li>
</ol>
<hr>
<h2> 4. 使用示例</h2>
<p>结构化并发的核心思想是将一组相关的并发任务视为一个单一的工作单元，这个工作单元有明确的开始和结束。在这个工作单元中，所有的子任务都在一个统一的作用域内执行，当工作单元完成或其中一个子任务失败时，整个工作单元会被正确地关闭，所有未完成的子任务也会被取消。这种方式使得并发代码的结构更加清晰，错误处理更加统一，从而提高了代码的可维护性和可靠性。</p>
<p>结构化并发通过 <code>StructuredTaskScope</code> 类来实现。<code>StructuredTaskScope</code> 提供了两种主要的模式：<code>ShutdownOnFailure</code> 和 <code>ShutdownOnSuccess</code></p>
<ul>
<li><code>ShutdownOnFailure：</code>当任何一个子任务失败时，会立即取消所有其他未完成的子任务，并抛出失败任务的异常。</li>
<li><code>ShutdownOnSuccess：</code>当任何一个子任务成功完成时，会立即取消所有其他未完成的子任务，并返回成功任务的结果。</li>
</ul>
<h3> 示例1：基本使用</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例2：订单处理（超时控制+异常处理）</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例3：并行聚合数据</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> 5. 小结</h2>
<h3> 5.1 注意事项</h3>
<ol>
<li>
<p><strong>作用域必须关闭</strong><br>
始终使用try-with-resources确保作用域关闭：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>避免跨作用域传递结果</strong><br>
子任务的结果应在同一作用域内消费：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>合理选择关闭策略</strong></p>
<ul>
<li><code>ShutdownOnSuccess</code>：适合快速获取首个成功结果（如多CDN择优）</li>
<li><code>ShutdownOnFailure</code>：适合所有子任务必须成功的场景（如支付验证）</li>
</ul>
</li>
<li>
<p><strong>与虚拟线程协同</strong><br>
结构化并发通常与虚拟线程配合使用：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h3> 5.2 小结</h3>
<p>JDK21结构化并发通过以下革新提升Java并发可靠性：</p>
<ul>
<li>✅ 将并发任务组织为可维护的树形结构</li>
<li>✅ 自动生命周期管理减少资源泄漏风险</li>
<li>✅ 异常传播机制提升调试效率</li>
<li>✅ 与虚拟线程协同实现高并发+高可靠</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>微服务中的并行API调用</li>
<li>批量数据处理任务</li>
<li>需要严格资源管理的长期运行任务</li>
</ul>
<p>目前结构化并发API仍处于预览阶段，可通过<code>--enable-preview</code>启用。 建议结合<a href="https://openjdk.org/jeps/453" target="_blank" rel="noopener noreferrer">官方指南</a>进行实践，这将为Java并发编程带来前所未有的代码清晰度与可靠性。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK21"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-13T15:48:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">04.JDK21记录模式：简化数据解构与模式匹配</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/04.%E8%AE%B0%E5%BD%95%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk21/04.%E8%AE%B0%E5%BD%95%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html"/>
    <updated>2025-02-13T08:59:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 1. 背景：为什么需要记录模式？</h2>
<p>在Java中，处理复杂数据结构（如嵌套对象或记录类）时，通常需要编写大量样板代码来提取和验证数据。例如：</p>
<ul>
<li>手动解构嵌套对象</li>
<li>使用<code>instanceof</code>和类型转换</li>
<li>编写冗长的条件分支</li>
</ul>
<p><strong>记录模式</strong>（Record Patterns）是Java模式匹配的进一步扩展，旨在简化数据解构和模式匹配的代码。它结合了<strong>记录类</strong>（Record）和<strong>模式匹配</strong>的特性，使开发者能够以声明式的方式提取和处理数据。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 1. 背景：为什么需要记录模式？</h2>
<p>在Java中，处理复杂数据结构（如嵌套对象或记录类）时，通常需要编写大量样板代码来提取和验证数据。例如：</p>
<ul>
<li>手动解构嵌套对象</li>
<li>使用<code>instanceof</code>和类型转换</li>
<li>编写冗长的条件分支</li>
</ul>
<p><strong>记录模式</strong>（Record Patterns）是Java模式匹配的进一步扩展，旨在简化数据解构和模式匹配的代码。它结合了<strong>记录类</strong>（Record）和<strong>模式匹配</strong>的特性，使开发者能够以声明式的方式提取和处理数据。</p>
<p>JDK19首次引入记录模式作为预览特性，JDK21进一步优化并正式发布。</p>
<h2> 2. 原理：记录模式如何工作？</h2>
<p>记录类是一种特殊的类，它主要用于封装不可变的数据，自动生成构造函数、equals()、hashCode() 和 toString() 等方法。</p>
<p>记录模式利用记录类的这种特性，使得在进行类型检查和数据提取时可以一步完成，避免了传统方式下繁琐的属性访问操作</p>
<h3> 2.1 传统数据解构 vs 记录模式</h3>
<h4> 传统方式</h4>
<ul>
<li><strong>手动解构</strong>：通过getter方法或字段访问提取数据</li>
<li><strong>类型检查</strong>：使用<code>instanceof</code>和类型转换</li>
<li><strong>冗长代码</strong>：需要多行代码完成简单操作</li>
</ul>
<h4> 记录模式</h4>
<ul>
<li><strong>声明式解构</strong>：直接匹配记录类的结构并提取字段</li>
<li><strong>类型推断</strong>：自动推断字段类型，无需显式类型转换</li>
<li><strong>模式嵌套</strong>：支持嵌套记录类的解构</li>
</ul>
<h3> 核心机制</h3>
<ol>
<li>
<p><strong>模式匹配</strong><br>
记录模式扩展了<code>instanceof</code>和<code>switch</code>的模式匹配能力，允许直接匹配记录类的结构。</p>
</li>
<li>
<p><strong>解构绑定</strong><br>
在匹配成功后，自动将记录类的字段绑定到变量中。</p>
</li>
<li>
<p><strong>嵌套支持</strong><br>
支持嵌套记录类的解构，简化复杂数据结构的处理。</p>
</li>
<li>
<p><strong>类型推断</strong><br>
编译器自动推断字段类型，减少显式类型转换。</p>
</li>
</ol>
<h3> 2.2 架构示意图</h3>
<div class="language-plaintext line-numbers-mode" data-ext="plaintext"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 优势：为什么选择记录模式？</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>传统方式</th>
<th>记录模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>代码简洁性</td>
<td>冗长</td>
<td><strong>简洁</strong></td>
</tr>
<tr>
<td>类型安全性</td>
<td>需显式类型转换</td>
<td><strong>自动推断</strong></td>
</tr>
<tr>
<td>嵌套支持</td>
<td>手动逐层解构</td>
<td><strong>自动解构</strong></td>
</tr>
<tr>
<td>可读性</td>
<td>低</td>
<td><strong>高</strong></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>代码简洁</strong>：减少样板代码，提升开发效率</li>
<li><strong>类型安全</strong>：编译器自动检查类型，减少运行时错误</li>
<li><strong>嵌套解构</strong>：轻松处理复杂数据结构</li>
<li><strong>可读性高</strong>：声明式语法更符合直觉</li>
</ol>
<h2> 4. 使用示例</h2>
<p>记录模式的基本语法是在 instanceof 或 switch 表达式中使用记录类的名称，并在括号内指定要解构的组件变量。例如：</p>
<h3> 示例1：基本使用</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例2：嵌套记录类</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例3：在<code>switch</code>中使用记录模式</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例4：结合泛型使用</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5. 小结</h2>
<h3> 5.1 注意事项</h3>
<ol>
<li>
<p><strong>记录类要求</strong><br>
记录模式仅适用于记录类（Record），普通类需转换为记录类才能使用。</p>
</li>
<li>
<p><strong>模式顺序</strong><br>
在<code>switch</code>中，更具体的模式应放在前面：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>空值处理</strong><br>
记录模式不支持<code>null</code>值匹配，需额外检查：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p><strong>性能影响</strong><br>
记录模式在运行时可能引入额外开销，需在性能敏感场景中测试。</p>
</li>
</ol>
<h2> 5.2 总结</h2>
<p>JDK21记录模式通过以下革新提升Java数据处理的效率：</p>
<ul>
<li>✅ 简化数据解构代码</li>
<li>✅ 提升类型安全性和可读性</li>
<li>✅ 支持嵌套记录类的解构</li>
<li>✅ 与模式匹配无缝集成</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>处理复杂数据结构</li>
<li>实现模式匹配逻辑</li>
<li>简化数据验证和提取</li>
</ul>
<p>记录模式是Java模式匹配的重要扩展，建议有兴趣的小伙伴可以参考<a href="https://openjdk.org/jeps/440" target="_blank" rel="noopener noreferrer">官方文档</a>来实际体验一下它的魅力</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK21"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-13T16:48:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">05.JDK21字符串模板：更安全、更强大的字符串拼接</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/05.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk21/05.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF.html"/>
    <updated>2025-02-13T08:59:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 1. 背景：为什么需要字符串模板？</h2>
<p>在Java中，字符串拼接是常见的操作，但传统方式存在诸多问题：</p>
<ol>
<li><strong>可读性差</strong>：使用<code>+</code>或<code>StringBuilder</code>拼接字符串时，代码冗长且难以维护</li>
<li><strong>安全性低</strong>：直接拼接用户输入可能导致SQL注入或XSS攻击</li>
<li><strong>性能开销</strong>：频繁拼接字符串可能产生大量临时对象，影响性能</li>
</ol>
<p><strong>字符串模板</strong>（String Templates）是JDK21引入的一项新特性（预览），旨在提供一种更安全、更直观的字符串构建方式。它结合了<strong>模板引擎</strong>的灵活性和<strong>Java类型系统</strong>的安全性。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 1. 背景：为什么需要字符串模板？</h2>
<p>在Java中，字符串拼接是常见的操作，但传统方式存在诸多问题：</p>
<ol>
<li><strong>可读性差</strong>：使用<code>+</code>或<code>StringBuilder</code>拼接字符串时，代码冗长且难以维护</li>
<li><strong>安全性低</strong>：直接拼接用户输入可能导致SQL注入或XSS攻击</li>
<li><strong>性能开销</strong>：频繁拼接字符串可能产生大量临时对象，影响性能</li>
</ol>
<p><strong>字符串模板</strong>（String Templates）是JDK21引入的一项新特性（预览），旨在提供一种更安全、更直观的字符串构建方式。它结合了<strong>模板引擎</strong>的灵活性和<strong>Java类型系统</strong>的安全性。</p>
<p><strong>基本概念</strong></p>
<p>字符串模板是一种允许在字符串字面量中嵌入表达式的机制。传统的 Java 字符串拼接通常使用 + 运算符或 String.format 方法，这在处理复杂的字符串拼接时会使代码变得冗长且不易阅读。而字符串模板通过将表达式直接嵌入到字符串中，使代码更加简洁和直观。</p>
<h2> 2. 原理：字符串模板如何工作？</h2>
<h3> 2.1 传统字符串拼接 vs 字符串模板</h3>
<h4> 传统方式</h4>
<ul>
<li><strong><code>+</code>操作符</strong>：简单但性能较差，可读性低</li>
<li><strong><code>StringBuilder</code></strong>：性能较好，但代码冗长</li>
<li><strong><code>String.format</code></strong>：可读性较高，但类型安全性差</li>
</ul>
<h4> 字符串模板</h4>
<ul>
<li><strong>嵌入式表达式</strong>：在字符串中直接嵌入变量或表达式</li>
<li><strong>类型安全</strong>：编译器检查表达式类型，避免运行时错误</li>
<li><strong>自定义处理器</strong>：支持通过处理器（Processor）自定义字符串生成逻辑</li>
</ul>
<h3> 核心机制</h3>
<ol>
<li>
<p><strong>模板语法</strong><br>
使用<code>\{...}</code>嵌入表达式，例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>模板处理器</strong><br>
字符串模板支持自定义处理器，例如：</p>
<ul>
<li><code>STR</code>：标准处理器，直接拼接字符串</li>
<li><code>FMT</code>：格式化处理器，支持格式化字符串</li>
<li>自定义处理器：实现<code>StringTemplate.Processor</code>接口</li>
</ul>
</li>
<li>
<p><strong>类型安全</strong><br>
编译器会检查嵌入表达式的类型，确保其与模板兼容。</p>
</li>
<li>
<p><strong>性能优化</strong><br>
字符串模板在编译时生成高效的字节码，减少运行时开销。</p>
</li>
</ol>
<h3> 2.2 优势：为什么选择字符串模板？</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>传统方式</th>
<th>字符串模板</th>
</tr>
</thead>
<tbody>
<tr>
<td>可读性</td>
<td>低</td>
<td><strong>高</strong></td>
</tr>
<tr>
<td>类型安全性</td>
<td>无</td>
<td><strong>有</strong></td>
</tr>
<tr>
<td>性能</td>
<td>较差</td>
<td><strong>优化</strong></td>
</tr>
<tr>
<td>灵活性</td>
<td>有限</td>
<td><strong>高</strong></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>代码简洁</strong>：减少样板代码，提升开发效率</li>
<li><strong>类型安全</strong>：编译器检查表达式类型，减少运行时错误</li>
<li><strong>性能优化</strong>：编译时生成高效字节码，减少运行时开销</li>
<li><strong>灵活扩展</strong>：支持自定义处理器，满足多样化需求</li>
</ol>
<h2> 3. 使用示例</h2>
<h3> 语法</h3>
<p>字符串模板主要有两种形式：简单字符串模板和带标签的字符串模板。</p>
<p><strong>简单字符串模板</strong></p>
<p>使用 STR 标签来标识字符串模板，在字符串中使用 <code>\{}</code> 语法嵌入表达式。</p>
<p><strong>带标签的字符串模板</strong></p>
<p>除了 STR 标签，我们还可以自定义标签来处理字符串模板。</p>
<ul>
<li>自定义标签是一个方法，它接收一个 TemplateContext 对象和一个 Object[] 数组作为参数。</li>
</ul>
<p>如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例1：基本使用</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例2：多行字符串</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例3：格式化字符串</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例4：自定义处理器</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4. 应用场景探索</h2>
<p>字符串模板的特性可以有效的应用在我们实际的业务场景中，如</p>
<h3> 4.1 构建动态消息</h3>
<p>在生成包含动态数据的消息时，字符串模板非常有用。比如生成用户欢迎消息、日志记录信息等。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.2 SQL拼接</h3>
<p>在构建 SQL 查询语句时，经常需要将变量值插入到 SQL 字符串中。使用字符串模板可以使代码更加清晰。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5. 小结</h2>
<h3> 4.1 注意事项</h3>
<ol>
<li>
<p><strong>语法兼容性</strong><br>
字符串模板使用<code>\{...}</code>语法，需确保与现有代码无冲突。</p>
</li>
<li>
<p><strong>处理器选择</strong><br>
根据需求选择合适的处理器，例如：</p>
<ul>
<li><code>STR</code>：普通字符串拼接</li>
<li><code>FMT</code>：格式化字符串</li>
<li>自定义处理器：复杂逻辑处理</li>
</ul>
</li>
<li>
<p><strong>性能测试</strong><br>
在性能敏感场景中，需测试字符串模板的性能表现。对于性能要求较高的场景，建议使用<code>StringBuilder</code>进行手动拼接</p>
</li>
<li>
<p><strong>安全性</strong><br>
使用自定义处理器时，确保对用户输入进行验证和转义，避免安全漏洞。</p>
</li>
<li>
<p><strong>表达式复杂度</strong>
嵌入的表达式应尽量保持简单，避免使用过于复杂的表达式，以免影响代码的可读性。</p>
</li>
<li>
<p><strong>转义字符</strong>
在字符串模板中，需要注意转义字符的使用。如果需要在字符串中包含 <code>\{</code> 或 <code>}</code>，需要进行适当的转义。</p>
</li>
</ol>
<h3> 4.2 总结</h3>
<p>JDK21字符串模板通过以下革新提升Java字符串处理的效率：</p>
<ul>
<li>✅ 简化字符串拼接代码</li>
<li>✅ 提升类型安全性和可读性</li>
<li>✅ 支持多行字符串和格式化</li>
<li>✅ 灵活扩展自定义处理器</li>
</ul>
<p>字符串模板是Java字符串处理的重要扩展，有兴趣的小伙伴可参考<a href="https://openjdk.org/jeps/430" target="_blank" rel="noopener noreferrer">官方文档</a>以掌握最佳实践。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK21"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-13T17:48:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">jdk21</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/jdk21/"/>
    <updated>2025-02-13T08:59:24.000Z</updated>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-13T08:59:24.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1.图片合成原理</title>
    <id>https://liuyueyi.github.io/tutorial/git/quick-media/image/01.%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90.html</id>
    <link href="https://liuyueyi.github.io/tutorial/git/quick-media/image/01.%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90.html"/>
    <updated>2025-02-11T08:53:41.000Z</updated>
    <summary type="html"><![CDATA[<h1> 图片合成</h1>
<blockquote>
<p>利用Java的绘图方法，实现图片合成</p>
</blockquote>
<p>在开始之前，先定一个小目标，我们希望通过图片合成的方式，创建一个类似下面样式的图片</p>
<figure><img src="/imgs/column/quick-media/image/13203703_6IVg.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> I. 设计思路</h3>
<blockquote>
<p>首先解析一下我们的目标实现图片合成，那么这些合成的基本组成单元有些什么？</p>
</blockquote>]]></summary>
    <content type="html"><![CDATA[<h1> 图片合成</h1>
<blockquote>
<p>利用Java的绘图方法，实现图片合成</p>
</blockquote>
<p>在开始之前，先定一个小目标，我们希望通过图片合成的方式，创建一个类似下面样式的图片</p>
<figure><img src="/imgs/column/quick-media/image/13203703_6IVg.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> I. 设计思路</h3>
<blockquote>
<p>首先解析一下我们的目标实现图片合成，那么这些合成的基本组成单元有些什么？</p>
</blockquote>
<p><strong>组成基本单元</strong></p>
<ul>
<li>图片</li>
<li>文字</li>
<li>几何图形</li>
</ul>
<p>也就是说，我们可以将任意个图片，文字，几何图形，按照自己的意愿进行拼接，那么问题就转变成两个</p>
<ul>
<li>基本单元如何在画布上渲染</li>
<li>基本单元之间如何配合使用</li>
</ul>
<h3> II. 基本单元绘制</h3>
<p>首先定义一个基本单元的接口，之后所有组合的元素都继承自这个接口</p>
<p>接口<code>IMergeCell</code>只定义一个绘制的方法，用于实现该基本单元的绘制方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1. 图片绘制</h4>
<p>绘制图片，一般来讲需要知道：</p>
<ul>
<li>绘制的坐标(x,y)</li>
<li>绘制图片的宽高(w,h)，当目标是绘制原图时，宽高一般为图片本身的宽高</li>
</ul>
<p>结合上面两点，图片组成单元的定义如下: <code>ImgCell</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2. 文本绘制</h4>
<blockquote>
<p>图片绘制比较简单，相比而言，文字绘制就麻烦一点，主要是文本绘制的对齐方式，竖排还是横排布局</p>
</blockquote>
<p><strong>首先分析我们需要的基本信息</strong></p>
<ul>
<li>
<p>考虑对齐方式（居中对齐，靠左，靠上，靠右，靠下）</p>
<ul>
<li>因此需要确定文本绘制的区域，所以需要两个坐标 (startX, startY), (endX, endY)</li>
</ul>
</li>
<li>
<p>文本绘制参数</p>
<ul>
<li>可以指定字体<code>Font</code>，文本颜色 <code>Color</code>，行间距 <code>lineSpace</code></li>
</ul>
</li>
<li>
<p>绘制的文本信息</p>
<ul>
<li>文本内容 <code>List&lt;String&gt;</code></li>
</ul>
</li>
</ul>
<p><strong>绘制实现</strong></p>
<ul>
<li>
<p>若单行的文本超过长度上限，则需要自动换行，所以有 <code>batchSplitText</code> 方法，对原文本内容进行分割，确保不会超过边界</p>
</li>
<li>
<p>不同的对齐方式，绘制的起始坐标需要计算, 所以在水平布局文字时，需要通过 <code>calculateX</code>方法获取新的x坐标；竖直布局文字时，需要通过 <code>calculateY</code>获取新的y坐标</p>
</li>
</ul>
<p>实际代码如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em>说明:</em></p>
<ul>
<li>单行文本的分割，使用了博文系列中的工具方法 <code>GraphicUtil.splitStr</code>，有兴趣的关注源码进行查看</li>
<li>水平布局时，期望 <code>startX &lt; endX</code>, 从习惯来讲，基本上我们都是从左到右进行阅读</li>
<li>水平or垂直布局，都希望是 <code>startY &lt; endY</code></li>
<li>垂直布局时，以字符为单位进行绘制；标点符号的绘制时，x坐标有一个偏移量</li>
</ul>
<h4> 3. Line直线绘制</h4>
<p>几何图形之直线绘制，给出起点和结束点坐标，绘制一条直线，比较简单；这里给出了虚线的支持</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4. 矩形框绘制</h4>
<p>矩形框绘制，同直线绘制，支持圆角矩形，支持虚线框</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5. 矩形区域填充</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> III. 封装</h3>
<p>上面实现了几个常见的基本单元绘制，接下来则是封装绘制, 这块的逻辑就比较简单了如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> IV. 测试</h3>
<p>写了一个模板<code>QrCodeCardTemplateBuilder</code>，用于拼装上图的样式，代码较长，不贴了，有兴趣的查看原图</p>
<p>测试代码如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>演示图如下:</p>
<figure><img src="/imgs/column/quick-media/image/13203703_6IVg.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> V. 其他</h3>
<p><strong>项目地址：</strong></p>
<ul>
<li><a href="https://github.com/liuyueyi/quick-media" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/quick-media</a></li>
<li><code>QuickMedia</code> 目标是创建一个专注图文，音视频，二维码处理的开源项目</li>
</ul>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="https://my.oschina.net/u/566591/blog/1359432" target="_blank" rel="noopener noreferrer">spring-boot &amp; ffmpeg 搭建一个音频转码服务</a></li>
<li><a href="https://my.oschina.net/u/566591/blog/1457164" target="_blank" rel="noopener noreferrer">spring-boot &amp; zxingy 搭建二维码服务</a></li>
<li><a href="https://my.oschina.net/u/566591/blog/1491697" target="_blank" rel="noopener noreferrer">二维码服务拓展(支持logo，圆角logo，背景图，颜色配置)</a></li>
<li><a href="https://my.oschina.net/u/566591/blog/1507162" target="_blank" rel="noopener noreferrer">zxing二维码生成服务之深度定制</a></li>
<li><a href="https://my.oschina.net/u/566591/blog/1514644" target="_blank" rel="noopener noreferrer">Java实现长图文生成</a></li>
<li><a href="https://my.oschina.net/u/566591/blog/1529564" target="_blank" rel="noopener noreferrer">Java竖排长图文生成</a></li>
<li><a href="https://my.oschina.net/u/566591/blog/1535380" target="_blank" rel="noopener noreferrer">Java实现markdown 转 html</a></li>
<li><a href="https://my.oschina.net/u/566591/blog/1536078" target="_blank" rel="noopener noreferrer">Java实现html 转 image</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2018-07-13T20:37:49.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">2.Java实现长图文生成</title>
    <id>https://liuyueyi.github.io/tutorial/git/quick-media/image/02.Java%E5%AE%9E%E7%8E%B0%E9%95%BF%E5%9B%BE%E6%96%87%E5%90%88%E6%88%90.html</id>
    <link href="https://liuyueyi.github.io/tutorial/git/quick-media/image/02.Java%E5%AE%9E%E7%8E%B0%E9%95%BF%E5%9B%BE%E6%96%87%E5%90%88%E6%88%90.html"/>
    <updated>2025-02-11T08:53:41.000Z</updated>
    <summary type="html"><![CDATA[<h1> Java实现长图文生成</h1>
<blockquote>
<p>很久很久以前，就觉得微博的长图文实现得非常有意思，将排版直接以最终的图片输出，收藏查看分享都很方便，现在则自己动手实现一个简单版本的</p>
</blockquote>
<h2> 目标</h2>
<p>首先定义下我们预期达到的目标：根据文字 + 图片生成长图文</p>
<h3> 目标拆解</h3>
<ul>
<li>支持大段文字生成图片</li>
<li>支持插入图片</li>
<li>支持上下左右边距设置</li>
<li>支持字体选择</li>
<li>支持字体颜色</li>
<li>支持左对齐，居中，右对齐</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h1> Java实现长图文生成</h1>
<blockquote>
<p>很久很久以前，就觉得微博的长图文实现得非常有意思，将排版直接以最终的图片输出，收藏查看分享都很方便，现在则自己动手实现一个简单版本的</p>
</blockquote>
<h2> 目标</h2>
<p>首先定义下我们预期达到的目标：根据文字 + 图片生成长图文</p>
<h3> 目标拆解</h3>
<ul>
<li>支持大段文字生成图片</li>
<li>支持插入图片</li>
<li>支持上下左右边距设置</li>
<li>支持字体选择</li>
<li>支持字体颜色</li>
<li>支持左对齐，居中，右对齐</li>
</ul>
<h3> 预期结果</h3>
<p>我们将通过spring-boot搭建一个生成长图文的http接口，通过传入参数来指定各种配置信息，下面是一个最终调用的示意图</p>
<figure><img src="/imgs/column/quick-media/image/18180654_y9iv.gif" alt="演示图" tabindex="0" loading="lazy"><figcaption>演示图</figcaption></figure>
<h2> 设计&amp;实现</h2>
<blockquote>
<p>长图文的生成，采用awt进行文字绘制和图片绘制</p>
</blockquote>
<h3> 1. 参数选项 <code>ImgCreateOptions</code></h3>
<p>根据我们的预期目标，设定配置参数，基本上会包含以下参数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 封装类 <code>ImageCreateWrapper</code></h3>
<p>封装配置参数的设置，绘制文本，绘制图片的操作方式，输出样式等接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面具体的文本和图片绘制实现没有，后面详细讲解，这里主要关注的是一个参数 <code>contentH</code>， 表示实际绘制的内容高度（包括上边距），因此最终生成图片的高度应该是</p>
<p><code>int realH = contentH + options.getBottomPadding();</code></p>
<p>其次简单说一下上面的图片输出方法：<code>com.hust.hui.quickmedia.common.image.ImgCreateWrapper.Builder#asImage</code></p>
<ul>
<li>计算最终生成图片的高度（宽度由输入参数指定）</li>
<li>绘制背景（如果没有背景图片，则用纯色填充）</li>
<li>绘制实体内容（即绘制的文本，图片）</li>
</ul>
<h3> 3. 内容填充 <code>GraphicUtil</code></h3>
<blockquote>
<p>具体的内容填充，区分为文本绘制和图片绘制</p>
</blockquote>
<h4> 设计</h4>
<ol>
<li>
<p>考虑到在填充的过程中，可以自由设置字体，颜色等，所以在我们的绘制方法中，直接实现掉内容的绘制填充，即 <code>drawXXX</code> 方法真正的实现了内容填充，执行完之后，内容已经填充到画布上了</p>
</li>
<li>
<p>图片绘制，考虑到图片本身大小和最终结果的大小可能有冲突，采用下面的规则</p>
</li>
</ol>
<ul>
<li>绘制图片宽度 &lt;=（指定生成图片宽 - 边距），全部填充</li>
<li>绘制图片宽度 &gt;（指定生成图片宽 - 边距），等比例缩放绘制图片</li>
</ul>
<ol start="3">
<li>文本绘制，换行的问题</li>
</ol>
<ul>
<li>每一行允许的文本长度有限，超过时，需要自动换行处理</li>
</ul>
<h4> 文本绘制</h4>
<p>考虑基本的文本绘制，流程如下</p>
<ul>
<li>创建<code>BufferImage</code>对象</li>
<li>获取<code>Graphic2d</code>对象，操作绘制</li>
<li>设置基本配置信息</li>
<li>文本按换行进行拆分为字符串数组, 循环绘制单行内容
<ul>
<li>计算当行字符串，实际绘制的行数，然后进行拆分</li>
<li>依次绘制文本（需要注意y坐标的变化）</li>
</ul>
</li>
</ul>
<p>下面是具体的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现比较清晰了，图片的绘制则更加简单</p>
<h4> 图片绘制</h4>
<p>只需要重新计算下待绘制图片的宽高即可，具体实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 内容渲染</h3>
<p>前面只是给出了单块内容（如一段文字，一张图片）的渲染，存在一些问题</p>
<ul>
<li>绘制的内容超过画布的高度如何处理</li>
<li>文本绘制要求传入的文本没有换行符，否则换行不生效</li>
<li>交叉绘制的场景，如何重新计算y坐标</li>
</ul>
<hr>
<p>解决这些问题则是在 <code>ImgCreateWrapper</code> 的具体绘制中进行了实现，先看文本的绘制</p>
<ul>
<li>根据换行符对字符串进行拆分</li>
<li>计算绘制内容最终转换为图片时，所占用的高度</li>
<li>重新生成画布 <code>BufferedImage result</code>
<ul>
<li>如果result为空，则直接生成</li>
<li>如果最终生成的高度，超过已有画布的高度，则生成一个更高的画布，并将原来的内容绘制上去</li>
</ul>
</li>
<li>迭代绘制单行内容</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面需要注意的是画布的生成规则，特别是高度超过上限之后，重新计算图片高度时，需要额外注意新增的高度，应该为基本的增量与（绘制内容高度+下边距）的较大值</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>重新生成画布实现 <code>com.hust.hui.quickmedia.common.util.GraphicUtil#createImg</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面理解之后，绘制图片就比较简单了，基本上行没什么差别</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. http接口</h3>
<p>上面实现的生成图片的公共方法，在 <code>quick-media</code> 工程中，利用spring-boot搭建了一个web服务，提供了一个http接口，用于生成长图文，最终的成果就是我们开头的那个gif图的效果，相关代码就没啥好说的，有兴趣的可以直接查看工程源码，链接看最后</p>
<h2> 测试验证</h2>
<p>上面基本上完成了我们预期的目标，接下来则是进行验证，测试代码比较简单，先准备一段文本，这里拉了一首诗</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出图片</p>
<figure><img src="/imgs/column/quick-media/image/18180717_MrRM.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 其他</h2>
<p>项目地址: <a href="https://github.com/liuyueyi/quick-media" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/quick-media</a></p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2017-08-18T18:06:49.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">3.Java实现竖排长图文生成</title>
    <id>https://liuyueyi.github.io/tutorial/git/quick-media/image/03.Java%E5%AE%9E%E7%8E%B0%E7%AB%96%E6%8E%92%E9%95%BF%E5%9B%BE%E6%96%87%E7%94%9F%E6%88%90.html</id>
    <link href="https://liuyueyi.github.io/tutorial/git/quick-media/image/03.Java%E5%AE%9E%E7%8E%B0%E7%AB%96%E6%8E%92%E9%95%BF%E5%9B%BE%E6%96%87%E7%94%9F%E6%88%90.html"/>
    <updated>2025-02-11T08:53:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 背景</h2>
<p>前面<a href="/tutorial/git/quick-media/image/02.Java%E5%AE%9E%E7%8E%B0%E9%95%BF%E5%9B%BE%E6%96%87%E5%90%88%E6%88%90.html" target="blank">2.Java实现长图文生成</a> 中实现了一个基本的长图文生成工具，但遗留了一些问题</p>
<ul>
<li>文字中包含英文字符时，分行计算问题</li>
<li>暂不支持竖排文字展示</li>
</ul>
<p>其中英文字符的计算已经修复，主要是通过<code>FontMetric</code>来计算字符串实际占用绘制的长度，这一块不做多讲，本篇主要集中在竖排文字的支持</p>]]></summary>
    <content type="html"><![CDATA[<h2> 背景</h2>
<p>前面<a href="/tutorial/git/quick-media/image/02.Java%E5%AE%9E%E7%8E%B0%E9%95%BF%E5%9B%BE%E6%96%87%E5%90%88%E6%88%90.html" target="blank">2.Java实现长图文生成</a> 中实现了一个基本的长图文生成工具，但遗留了一些问题</p>
<ul>
<li>文字中包含英文字符时，分行计算问题</li>
<li>暂不支持竖排文字展示</li>
</ul>
<p>其中英文字符的计算已经修复，主要是通过<code>FontMetric</code>来计算字符串实际占用绘制的长度，这一块不做多讲，本篇主要集中在竖排文字的支持</p>
<h2> 设计</h2>
<blockquote>
<p>有前面的基础，在做竖排文字支持上，本以为是比较简单就能接入的，而实际的实现过程中，颇为坎坷</p>
</blockquote>
<h3> 1. 竖排文字绘制</h3>
<p>首先需要支持竖排文字的绘制，使用<code>Graphics2d</code>进行绘制时，暂不支持竖排绘制方式，因此我们需要自己来实现</p>
<p>而设计思路也比较简单，一个字一个字的绘制，x坐标不变，y坐标依次增加</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 自动换行</h3>
<p>竖排的自动换行相比较与水平有点麻烦的是间隔问题，首先看下<code>FontMertric</code>的几个参数 <code>ascent</code>, <code>descent</code>, <code>height</code></p>
<figure><img src="/imgs/column/quick-media/image/05181941_gJBV.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>举一个例子来看如何进行自动换行</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先我们是需要获取内容的总长度，中文还比较好说，都是方块的，可以直接用 <code>fontMetrics.stringWidth(content)</code> 获取内容长度（实际为宽度），然后需要加空格(即<code>descent</code>)</p>
<p>所以计算最终的行数可以如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据上面的计算， <code>l=72, lineNum=5;</code></p>
<p>然后就是一个字符一个字符的进行绘制，每次需要重新计算y坐标</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其次就是需要判断是否要换行</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 从右到左支持</h3>
<p>从左到右还比较好说，y坐标一直增加，当绘制的内容超过当前的图片时，直接在扩展后的图片上(0,0)位置进行绘制即可；</p>
<p>而从右到左则需要计算偏移量，如下图</p>
<figure><img src="/imgs/column/quick-media/image/05182209_f6NC.jpg" alt="offset" tabindex="0" loading="lazy"><figcaption>offset</figcaption></figure>
<h2> 实现</h2>
<h3> 1. 文本自动换行</h3>
<p>实现一个公共方法，根据上面的思路用于文本的自动换行</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，唯一需要注意的是，换行时，y坐标自增的场景下，需要计算 <code>fontMetric.descent</code> 的值，否则换行偏移会有问题</p>
<h3> 2. 垂直文本的绘制</h3>
<h4> 1. 起始y坐标计算</h4>
<p>因为我们支持集中不同的对齐方式，所以在计算起始的y坐标时，会有出入, 实现如下</p>
<ul>
<li>上对齐，则 y = 上边距</li>
<li>下对其， 则 y = 总高度 - 内容高度 - 下边距</li>
<li>居中， 则 y = (总高度 - 内容高度) / 2</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2. 实际绘制y坐标计算</h4>
<p>实际绘制中，y坐标还不能直接使用上面返回值，因为这个返回是字体的最上边对应的坐标，因此需要将实际绘制y坐标，向下偏移一个字</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3. 换行时，x坐标计算</h4>
<p>绘制方式的不同，从左到右与从右到左两种场景下，自动换行后，新行的x坐标的增量计算方式也是不同的</p>
<ul>
<li>从左到右：<code>int fontWidth = 字体宽度 + 行间距</code></li>
<li>从右到左：<code>int fontWidth = - (字体宽度 + 行间距）</code></li>
</ul>
<h4> 完整的实现逻辑如下</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 垂直图片绘制</h3>
<p>文本绘制实现之后，再来看图片，就简单很多了，因为没有换行的问题，所以只需要计算y坐标的值即可</p>
<p>此外当图片大于参数指定的高度时，对图片进行按照高度进行缩放处理；当小于高度时，就原图绘制即可</p>
<p>实现逻辑如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 封装类的实现</h3>
<p>正如前面一篇博文中实现的水平图文生成的逻辑一样，垂直图文生成也采用之前的思路：</p>
<ul>
<li>每次在文本绘制时，直接进行渲染；</li>
<li>记录实际内容绘制的宽度（这个宽度包括左or右边距）</li>
<li>每次绘制时，判断当前的画布是否容纳得下所有的内容
<ul>
<li>容的下，直接绘制即可</li>
<li>容不下，则需要扩充画布，生成一个更宽的画布，将原来的内容重新渲染在新画布上，然后在新画布上进行内容的填充</li>
</ul>
</li>
</ul>
<p>因为从左到右和从右到左的绘制在计算x坐标的增量时，扩充画布的重新绘制时，有些明显的区别，所以为了逻辑清晰，将两种场景分开，提供了两个方法</p>
<p>实现步骤:</p>
<ol>
<li>计算实际绘制内容占用的宽度</li>
<li>判断是否需要扩充画布（需要则扩充）</li>
<li>绘制文本</li>
<li>更新内容的宽度</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对比从左到右与从右到左，区别主要是两点</p>
<ul>
<li>扩充时，在新画布上绘制原画布内容的x坐标计算，一个为0，一个为 <code>新宽度-旧宽度</code></li>
<li>offsetX 的计算</li>
</ul>
<p>上面是文本绘制，图片绘制比较简单，基本上和水平绘制时，没什么区别，只不过是扩充时的w，h计算不同罢了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 输出</h3>
<p>上面是绘制的过程，绘制完毕之后，需要输出为图片的，因此对于这个输出需要再适配一把</p>
<p>再前一篇的基础上，输出新增了签名+背景的支持，这里一并说了</p>
<ul>
<li>计算生成图片的宽高</li>
<li>有签名时，绘制签名背景，在最下方绘制签名文本</li>
<li>背景图片</li>
<li>绘制填充内容</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 测试</h2>
<p>测试case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出图片</p>
<figure><img src="/imgs/column/quick-media/image/05182105_2smp.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://static.oschina.net/uploads/img/201709/05182105_2smp.jpg" alt="https://static.oschina.net/uploads/img/201709/05182105_2smp.jpg" tabindex="0" loading="lazy"><figcaption><a href="https://static.oschina.net/uploads/img/201709/05182105_2smp.jpg" target="_blank" rel="noopener noreferrer">https://static.oschina.net/uploads/img/201709/05182105_2smp.jpg</a></figcaption></figure>
<p>再输出一个从右到左的，居中显示样式</p>
<figure><img src="/imgs/column/quick-media/image/05182138_My1E.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 其他</h2>
<p>相关博文：<a href="https://my.oschina.net/u/566591/blog/1514644" target="_blank" rel="noopener noreferrer">《Java 实现长图文生成》</a></p>
<p>项目地址：<a href="https://github.com/liuyueyi/quick-media" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/quick-media</a></p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2017-09-05T18:19:49.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">4.图片合成使用示例</title>
    <id>https://liuyueyi.github.io/tutorial/git/quick-media/image/04.%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</id>
    <link href="https://liuyueyi.github.io/tutorial/git/quick-media/image/04.%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html"/>
    <updated>2025-02-11T08:53:41.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>本文为 <a href="https://github.com/liuyueyi/quick-media/tree/master/plugins/image-plugin" target="_blank" rel="noopener noreferrer">image-plugin</a> 图片合成的使用参考示例</p>
</blockquote>
<h2> 1. 项目依赖</h2>
<p>直接从中央仓库，导入最新依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token comment">&lt;!-- https://mvnrepository.com/artifact/com.github.liuyueyi.media/image-plugin --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.github.liuyueyi.media<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>image-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 请使用最新版本号替换下面的版本 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p>本文为 <a href="https://github.com/liuyueyi/quick-media/tree/master/plugins/image-plugin" target="_blank" rel="noopener noreferrer">image-plugin</a> 图片合成的使用参考示例</p>
</blockquote>
<h2> 1. 项目依赖</h2>
<p>直接从中央仓库，导入最新依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 参数说明</h2>
<p>相关参数配置由<code>com.github.hui.quick.plugin.image.wrapper.create.ImgCreateOptions</code>实体类进行装载，对应的参数说明如下</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>bgImg</td>
<td>BufferedImage</td>
<td>绘制的背景图</td>
</tr>
<tr>
<td>imgW</td>
<td>Integer</td>
<td>生成图片的宽</td>
</tr>
<tr>
<td>imgH</td>
<td>Integer</td>
<td>生成图片的高</td>
</tr>
<tr>
<td>font</td>
<td>Font</td>
<td>字体，默认值为 DEFAULT_FONT</td>
</tr>
<tr>
<td>fontColor</td>
<td>Color</td>
<td>字体色，默认值为黑色</td>
</tr>
<tr>
<td>leftPadding</td>
<td>int</td>
<td>左边距</td>
</tr>
<tr>
<td>rightPadding</td>
<td>int</td>
<td>右边距</td>
</tr>
<tr>
<td>topPadding</td>
<td>int</td>
<td>上边距</td>
</tr>
<tr>
<td>bottomPadding</td>
<td>int</td>
<td>底边距</td>
</tr>
<tr>
<td>linePadding</td>
<td>int</td>
<td>行距</td>
</tr>
<tr>
<td>alignStyle</td>
<td>AlignStyle</td>
<td>对齐方式，水平绘制时为左对齐、居中、右对齐；垂直绘制时为上对齐、居中、下对齐</td>
</tr>
<tr>
<td>drawStyle</td>
<td>DrawStyle</td>
<td>文本绘制方式，水平或垂直</td>
</tr>
</tbody>
</table>
<h2> 3. 使用示例</h2>
<blockquote>
<p>所有的使用姿势，可以在源码对应的test工程中获取</p>
<p>下文对应的示例，详情查看: <a href="https://github.com/liuyueyi/quick-media/blob/master/plugins/image-plugin/src/test/java/com/github/hui/quick/plugin/test/ImgCreateWrapperTest.java" target="_blank" rel="noopener noreferrer">ImgCreateWrapperTest.java</a></p>
</blockquote>
<h3> 3.1 基本使用示例</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/quick-media/image/2out.png" alt="输出图" tabindex="0" loading="lazy"><figcaption>输出图</figcaption></figure>
<p>如我们希望生成竖排输出的图文，可以在上面的基础上做一个微调即可快速实现，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/quick-media/image/v2out.png" alt="输出图" tabindex="0" loading="lazy"><figcaption>输出图</figcaption></figure>
<p>若我们希望在文字中间穿插图片，并设置对文字设置不同的颜色、字体、样式时，可以参照下面的实现方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/quick-media/image/more2out.png" alt="输出图" tabindex="0" loading="lazy"><figcaption>输出图</figcaption></figure>
<h3> 3.2 逐行打印文本，生成gif动画</h3>
<p>主要参数同上，使用姿势可以参考: <a href="https://github.com/liuyueyi/quick-media/blob/master/plugins/image-plugin/src/test/java/com/github/hui/quick/plugin/test/LineCreateWrapperTest.java" target="_blank" rel="noopener noreferrer">LineCreateWrapperTest</a></p>
<p>具体的使用示例与上面基本没有什么区别，无非是输出的图是gif动图</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/quick-media/image/line.gif" alt="输出图" tabindex="0" loading="lazy"><figcaption>输出图</figcaption></figure>
<h3> 3.3 逐字输出，生成gif动画</h3>
<p>主要参数同上，使用姿势可以参考: <a href="https://github.com/liuyueyi/quick-media/blob/master/plugins/image-plugin/src/test/java/com/github/hui/quick/plugin/test/LineCreateWrapperTest.java" target="_blank" rel="noopener noreferrer">LineCreateWrapperTest</a></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/quick-media/image/word.gif" alt="输出图" tabindex="0" loading="lazy"><figcaption>输出图</figcaption></figure>
<h2> 4. 进阶使用</h2>
<p>上面介绍的使用姿势适用于简单的图文合成，当我们有一些相对复杂的图片需要合成时，可以考虑一下基于模板的图文合成方式</p>
<p>这里主要使用的是 <code>ImgMergeWrapper</code> 提供的能力，其内部提供了五个基本单元（也支持扩展自己的基本绘制单元）</p>
<h3> 4.1 基础绘制单元</h3>
<p>如需要实现自定义的绘制单元，则可以通过实现下面的接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>image-plugin原生提供的几个实现如下</p>
<ul>
<li>TextCell: 文字绘制，支持超出最终输出图片的宽高时，自动换行</li>
<li>LineCell: 线条绘制，原生提供实线和虚线两种样式，也可以自定义线条样式</li>
<li>RectCell: 矩形框绘制</li>
<li>RectFillCell: 矩形区域绘制</li>
<li>ImgCell: 图片绘制</li>
</ul>
<h3> 4.2 基本使用</h3>
<blockquote>
<p>源码： <a href="https://github.com/liuyueyi/quick-media/blob/master/plugins/image-plugin/src/test/java/com/github/hui/quick/plugin/test/ImgMergeWrapperTest.java" target="_blank" rel="noopener noreferrer">ImgMergeWrapperTest</a></p>
</blockquote>
<p>下面是一个简单的示例，生成书籍封面图，一张底图，一个矩形框，一个矩形区域，然后再矩形区域内填充书名</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>输出1</th>
<th>输出2</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/imgs/column/quick-media/image/cover.png" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/cover2.png" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h3> 4.3 模板复用</h3>
<p>我们可以定义自己的合成模板，然后通过传入不同的参数来生成不同的图片；比如原生提供了一个二维码签名的模板</p>
<p>关键点在于 <code>QrCodeCardTemplateBuilder</code> 的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后对应的使用姿势就非常简单了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的输出图，实际上就是我的个人推介名片</p>
<figure><img src="/imgs/column/quick-media/image/qrcode.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-05T18:19:49.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">5.图片转SVG使用示例</title>
    <id>https://liuyueyi.github.io/tutorial/git/quick-media/image/05.%E5%9B%BE%E7%89%87%E8%BD%ACSVG%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</id>
    <link href="https://liuyueyi.github.io/tutorial/git/quick-media/image/05.%E5%9B%BE%E7%89%87%E8%BD%ACSVG%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html"/>
    <updated>2025-02-11T08:53:41.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>本文为 <a href="https://github.com/liuyueyi/quick-media/tree/master/plugins/image-plugin" target="_blank" rel="noopener noreferrer">image-plugin</a> 中图转SVG的使用参考示例</p>
</blockquote>
<h2> 1. 基本原理</h2>
<p>我们知道图片是由一个一个的像素点组成的，将图片转换为svg的一个思路就是将图片中的每个像素点直接转换为svg中的矩形颜色块，这样就可以直接生成一个对应的svg文本了</p>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p>本文为 <a href="https://github.com/liuyueyi/quick-media/tree/master/plugins/image-plugin" target="_blank" rel="noopener noreferrer">image-plugin</a> 中图转SVG的使用参考示例</p>
</blockquote>
<h2> 1. 基本原理</h2>
<p>我们知道图片是由一个一个的像素点组成的，将图片转换为svg的一个思路就是将图片中的每个像素点直接转换为svg中的矩形颜色块，这样就可以直接生成一个对应的svg文本了</p>
<p>一个基本的转换实现可以参见 <a href="https://github.com/liuyueyi/quick-media/blob/master/plugins/image-plugin/src/test/java/com/github/hui/quick/plugin/test/feat/svg/SvgParseTest.java" target="_blank" rel="noopener noreferrer">SvgParseTest.java</a></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/quick-media/image/parseSvg-out1.svg" alt="输出图" tabindex="0" loading="lazy"><figcaption>输出图</figcaption></figure>
<p>上面实现就是基本的像素块的替换了，可以看到输出的svg文本较大；接下来我们可以再优化一下，首先利用<code>ImgPixelWrapper</code>将图片转换为像素块（降低精度），然后再将像素块的图片转换为svg</p>
<p>因此可以对上面的实现进行一个微调</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如上面设置<code>size = 8</code>，相当于将原图精度损失8倍，对应生成的svg如下</p>
<figure><img src="/imgs/column/quick-media/image/parseSvg-out2.svg" alt="输出图" tabindex="0" loading="lazy"><figcaption>输出图</figcaption></figure>
<h2> 2. 使用示例</h2>
<h3> 2.1 参数说明</h3>
<p>核心参数四个，其中source传图为必填</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>说明</th>
<th>是否必填</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>source</code></td>
<td><code>BufferedImage</code></td>
<td>原始图</td>
<td>是</td>
</tr>
<tr>
<td><code>blockSize</code></td>
<td><code>int</code></td>
<td>对于转字符图时，它控制字符大小；对于灰度/像素处理时，这个表示像素化的处理操作</td>
<td>非必填，默认 <code>4</code></td>
</tr>
<tr>
<td><code>scaleRate</code></td>
<td><code>Double</code></td>
<td>缩放比例，1 表示输出的图不缩放； &gt; 1，表示生成的图，按倍数扩大</td>
<td>非必填，默认 <code>1</code></td>
</tr>
<tr>
<td><code>bgPredicate</code></td>
<td><code>Predicate&lt;Color&gt;</code></td>
<td>背景色判断方式，传参为 <code>intColor</code>，如果返回<code>true</code>，表示认定为背景色；否则不是</td>
<td>非必填，默认纯白色为背景</td>
</tr>
</tbody>
</table>
<h3> 2.2 使用示例</h3>
<p>使用姿势形如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一个简单的使用示例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>原图</th>
<th>svg图</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/imgs/column/quick-media/image/d5137769-1836-cc20-c1eb-20af1109dc7a.jpg" height="500px"></td>
<td><img src="/imgs/column/quick-media/image/dlam.svg" height="500px"></td>
</tr>
</tbody>
</table>
<p>接下来再看一个真实人像的转换过程，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>说明：原图来自网上 <a href="https://fc.sinaimg.cn/large/ea98bce0gy1h6u8ge7y66j22q55wi4qs.jpg" target="_blank" rel="noopener noreferrer">https://www.5youqu.com/bizhi/124906.html</a>，做了背景剔除</p>
</blockquote>
<p>对比结果如下</p>
<table>
<thead>
<tr>
<th>原图</th>
<th>svg图</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/imgs/column/quick-media/image/lyf.png" height="500px"></td>
<td><img src="/imgs/column/quick-media/image/lyf.svg" height="500px"></td>
</tr>
<tr>
<td><img src="/imgs/column/quick-media/image/lyf.png" height="500px"></td>
<td><img src="/imgs/column/quick-media/image/lyf2.svg" height="500px"></td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-06T10:19:49.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">6.像素图片-图片灰度化</title>
    <id>https://liuyueyi.github.io/tutorial/git/quick-media/image/06.%E5%9B%BE%E7%89%87%E7%81%B0%E5%BA%A6%E5%8C%96.html</id>
    <link href="https://liuyueyi.github.io/tutorial/git/quick-media/image/06.%E5%9B%BE%E7%89%87%E7%81%B0%E5%BA%A6%E5%8C%96.html"/>
    <updated>2025-02-11T08:53:41.000Z</updated>
    <summary type="html"><![CDATA[<p>本文通过一个简单的实例，演示如何使用java来实现图片灰度化处理，主要借助下面两种策略来处理颜色</p>
<p><strong>灰度化公式</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>avgColor <span class="token operator">=</span> red <span class="token operator">*</span> <span class="token number">0.299f</span> <span class="token operator">+</span> green <span class="token operator">*</span> <span class="token number">0.587f</span> <span class="token operator">+</span> blue <span class="token operator">*</span> <span class="token number">0.114f</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<p>本文通过一个简单的实例，演示如何使用java来实现图片灰度化处理，主要借助下面两种策略来处理颜色</p>
<p><strong>灰度化公式</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>均值方式</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>基于上面两种方式，我们要实现一个图片灰度化的处理，无非就是获取图片的每个像素点的颜色，然后计算avgColor，再用新的颜色填充即可</p>
<p>一个基础的实现演示如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>生成原图与灰度图的对比如下</p>
<figure><img src="/imgs/211112/00.jpg" alt="输出图" tabindex="0" loading="lazy"><figcaption>输出图</figcaption></figure>
<p>注意上面的实现，其中加载网络图片的具体实现，之前的博文有介绍，有兴趣的小伙伴可以参考: 封装一个根据路径获取文件资源的工具类</p>
<p>此外介绍一个更好用的姿势，直接使用开源项目 <a href="https://github.com/liuyueyi/quick-media" target="_blank" rel="noopener noreferrer">quick-media/image-plugins</a> 来实现灰度处理</p>
<p>使用这个项目的 image-plugins 之后，生成一个灰度图就很简单了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>原图</th>
<th>svg图</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/imgs/column/quick-media/image/20180916175034_Gr2hk.jpeg" target="_blank" rel="noopener noreferrer">20180916175034_Gr2hk.jpeg</a></td>
<td><a href="/imgs/column/quick-media/image/gray.png" target="_blank" rel="noopener noreferrer"></a></td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-11-12T10:19:49.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">7.像素图片-图片转字符图</title>
    <id>https://liuyueyi.github.io/tutorial/git/quick-media/image/07.%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E5%9B%BE.html</id>
    <link href="https://liuyueyi.github.io/tutorial/git/quick-media/image/07.%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E5%9B%BE.html"/>
    <updated>2025-02-11T08:53:41.000Z</updated>
    <summary type="html"><![CDATA[<p>前面介绍了一篇java实现图片灰度化处理的小demo，接下来再介绍一个有意思的东西，将一个图片转换成字符图片</p>
<p>借助前面图片灰度化处理的知识点，若我们希望将一张图片转成字符图片，同样可以遍历每个像素点，然后将像素点由具体的字符来替换，从而实现字符化处理</p>
<p>基于上面这个思路，具体的实现就很清晰了</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testRender</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> file <span class="token operator">=</span> <span class="token string">"http://i0.download.fd.52shubiao.com/t_960x600/g1/M00/10/17/oYYBAFWvR5-IeXHuAAd5kPb8eSgAACm0QF50xIAB3mo414.jpg"</span><span class="token punctuation">;</span>
    <span class="token comment">// 从网络上下载图片</span>
    <span class="token class-name">BufferedImage</span> img <span class="token operator">=</span> <span class="token class-name">ImageIO</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">FileReadUtil</span><span class="token punctuation">.</span><span class="token function">getStreamByFileName</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token keyword">int</span> w <span class="token operator">=</span> img<span class="token punctuation">.</span><span class="token function">getWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> h <span class="token operator">=</span> img<span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建新的字符图片画板</span>
    <span class="token class-name">BufferedImage</span> gray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedImage</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> h<span class="token punctuation">,</span> img<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Graphics2D</span> g2d <span class="token operator">=</span> gray<span class="token punctuation">.</span><span class="token function">createGraphics</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    g2d<span class="token punctuation">.</span><span class="token function">setColor</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    g2d<span class="token punctuation">.</span><span class="token function">fillRect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Font</span> font <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Font</span><span class="token punctuation">(</span><span class="token string">"宋体"</span><span class="token punctuation">,</span> <span class="token class-name">Font</span><span class="token punctuation">.</span><span class="token constant">BOLD</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    g2d<span class="token punctuation">.</span><span class="token function">setFont</span><span class="token punctuation">(</span>font<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> w<span class="token punctuation">;</span> x <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> h<span class="token punctuation">;</span> y <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      g2d<span class="token punctuation">.</span><span class="token function">setColor</span><span class="token punctuation">(</span><span class="token class-name">ColorUtil</span><span class="token punctuation">.</span><span class="token function">int2color</span><span class="token punctuation">(</span>img<span class="token punctuation">.</span><span class="token function">getRGB</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            g2d<span class="token punctuation">.</span><span class="token function">drawString</span><span class="token punctuation">(</span><span class="token string">"灰"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    g2d<span class="token punctuation">.</span><span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"渲染完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<p>前面介绍了一篇java实现图片灰度化处理的小demo，接下来再介绍一个有意思的东西，将一个图片转换成字符图片</p>
<p>借助前面图片灰度化处理的知识点，若我们希望将一张图片转成字符图片，同样可以遍历每个像素点，然后将像素点由具体的字符来替换，从而实现字符化处理</p>
<p>基于上面这个思路，具体的实现就很清晰了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，在会字符的时候，先取出源像素点的色彩，然后重新设置给g2d，这个int转color也比较简单，实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就实现了一个基础版的转字符图了，实际跑一下看看效果</p>
<figure><img src="/imgs/211116/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这下尴尬了，输出的并不是我们预期的字符图，那么问题出在哪呢？</p>
<p>仔细看上面的文字大小为1，文字太小，导致即使是有字符组件的图，最终肉眼看起来和原图也没啥区别</p>
<p>那么我们就试一下将这个文字搞大点，将<code>n*n</code>个像素点作为一个文字渲染区域，这样我们需要调整一下遍历的步长；其次就是这个区域的颜色怎么定
直接取均值</p>
<ul>
<li>直接取均值</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外的就是改一下遍历的步长</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次执行之后结果如下，实现了我们的预期效果</p>
<figure><img src="/imgs/211116/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>最后再介绍一个更好用的姿势，直接使用开源项目 <a href="https://github.com/liuyueyi/quick-media" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/quick-media/image-plugins</a> 来实现图片字符画</p>
<p>使用这个项目的 image-plugins 之后，生成一个字符图就很简单了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-11-16T11:19:49.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">8.像素图片-GIF图片转字符动图</title>
    <id>https://liuyueyi.github.io/tutorial/git/quick-media/image/08.GIF%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E5%8A%A8%E5%9B%BE.html</id>
    <link href="https://liuyueyi.github.io/tutorial/git/quick-media/image/08.GIF%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E5%8A%A8%E5%9B%BE.html"/>
    <updated>2025-02-11T08:53:41.000Z</updated>
    <summary type="html"><![CDATA[<p>前面介绍了两篇基于jdk实现图片灰度处理、转字符图片的操作，接下来我们在将之前的能力扩展一下，支持将一个gif图灰度化或者转gif字符图</p>
<p>本文的实现主要在前面两篇文章的基础上来实现，推荐没有看过的小伙伴也可以瞅一眼</p>
<ul>
<li><a href="/tutorial/git/quick-media/image/06.%E5%9B%BE%E7%89%87%E7%81%B0%E5%BA%A6%E5%8C%96.html" target="blank">像素图片-图片灰度化</a></li>
<li><a href="/tutorial/git/quick-media/image/07.%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E5%9B%BE.html" target="blank">像素图片-图片转字符图</a></li>
</ul>]]></summary>
    <content type="html"><![CDATA[<p>前面介绍了两篇基于jdk实现图片灰度处理、转字符图片的操作，接下来我们在将之前的能力扩展一下，支持将一个gif图灰度化或者转gif字符图</p>
<p>本文的实现主要在前面两篇文章的基础上来实现，推荐没有看过的小伙伴也可以瞅一眼</p>
<ul>
<li><a href="/tutorial/git/quick-media/image/06.%E5%9B%BE%E7%89%87%E7%81%B0%E5%BA%A6%E5%8C%96.html" target="blank">像素图片-图片灰度化</a></li>
<li><a href="/tutorial/git/quick-media/image/07.%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E5%9B%BE.html" target="blank">像素图片-图片转字符图</a></li>
</ul>
<p>单张图的灰度化与转字符实现之后，gif图的实现就简单多了；gif图无非是多张图组合而成，将每一张图转换之后，再重新组装成gif图就完事了</p>
<p>这里我们使用的gif工具类来自于 <a href="https://github.com/liuyueyi/quick-media/tree/master/plugins/base-plugin/src/main/java/com/github/hui/quick/plugin/base/gif" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/quick-media/tree/master/plugins/base-plugin/src/main/java/com/github/hui/quick/plugin/base/gif</a></p>
<p>核心关键类为GifEncode与GifDecode；借助它来实现gif图的加载与保存</p>
<p>首先我们将上篇博文中的转字符图的方法抽取一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着就是Gif的操作了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上图转换成功之后，输出如下</p>
<figure><img src="/imgs/211120/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如果希望输出图片更像原图，可以修改上面的fontSize，比如上面用的是12，可以调整成8，6等值，根据实际情况进行选择</p>
<p>有的小伙伴可能会说了，动漫的gif图转换之后相似度还可以，那么真实人物图转换之后呢？</p>
<p>接下来我们借助开源项目 <a href="https://github.com/liuyueyi/quick-media" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/quick-media</a> 来迅速的实现一个gif图转换</p>
<blockquote>
<p>下图来自网络，有兴趣的自己打开查看，就不贴上了😏）
<a href="http://n.sinaimg.cn/sinacn/w390h219/20171231/0ac1-fyqefvw5238474.gif" target="_blank" rel="noopener noreferrer">http://n.sinaimg.cn/sinacn/w390h219/20171231/0ac1-fyqefvw5238474.gif</a></p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/211120/01.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>最后提个小问题，gif图都能生成字符图了，那么视频也可以生成字符视频么？</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-11-20T11:19:49.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">9.像素图片-位图转矢量图</title>
    <id>https://liuyueyi.github.io/tutorial/git/quick-media/image/09.%E4%BD%8D%E5%9B%BE%E8%BD%AC%E7%9F%A2%E9%87%8F%E5%9B%BE.html</id>
    <link href="https://liuyueyi.github.io/tutorial/git/quick-media/image/09.%E4%BD%8D%E5%9B%BE%E8%BD%AC%E7%9F%A2%E9%87%8F%E5%9B%BE.html"/>
    <updated>2025-02-11T08:53:41.000Z</updated>
    <summary type="html"><![CDATA[<p>通过前面几篇图片转字符、灰度图的文章介绍之后，接下来我们再来看一个有意思的东西，基于前文的基础，实现位图转矢量图的功能</p>
<p>关于位图与矢量图的简单理解如下：</p>
<ul>
<li>位图：如Jpg/png，放大之后会失真，看到像素块</li>
<li>矢量图：如svg，放大图片也不会失真</li>
</ul>
<h3> 1. 实现策略</h3>
<p>要实现位图转矢量图，可不是一个简单的活；当然我们这里也不追求完美实现，在前文的基础上，可以想到一个实现策略</p>
<ul>
<li>首先根据位图输出字符画</li>
<li>然后通过字符画，来生成矢量图</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<p>通过前面几篇图片转字符、灰度图的文章介绍之后，接下来我们再来看一个有意思的东西，基于前文的基础，实现位图转矢量图的功能</p>
<p>关于位图与矢量图的简单理解如下：</p>
<ul>
<li>位图：如Jpg/png，放大之后会失真，看到像素块</li>
<li>矢量图：如svg，放大图片也不会失真</li>
</ul>
<h3> 1. 实现策略</h3>
<p>要实现位图转矢量图，可不是一个简单的活；当然我们这里也不追求完美实现，在前文的基础上，可以想到一个实现策略</p>
<ul>
<li>首先根据位图输出字符画</li>
<li>然后通过字符画，来生成矢量图</li>
</ul>
<p>基于上面这个策略，第一步生成字符前一篇博文已经介绍过了；接下来重点就是如何根据输出的字符数组，来生成svg呢？</p>
<h3> 2. 实现方法</h3>
<p>第一步位图输出字符画的代码就不贴了，有兴趣的小伙伴可以参考前文</p>
<ul>
<li><a href="/tutorial/git/quick-media/image/07.%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E5%9B%BE.html" target="blank">像素图片-图片转字符图</a></li>
</ul>
<p>接下来我们重点看一下如何根据生成的<code>List&lt;String&gt;</code>来生成svg图</p>
<p>首先我们定义一个svg模板，用于来表示基于字符输出的矢量图，如下</p>
<div class="language-svg line-numbers-mode" data-ext="svg"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于上面的模板中，有几个关键值需要替换</p>
<ul>
<li>svg 标签中
<ul>
<li><code>{width}</code>: 生成矢量图的宽度</li>
<li><code>{height}</code>: 生成矢量图的高度</li>
<li><code>{BG_COLOR}</code>: 背景颜色</li>
</ul>
</li>
<li>style 样式设置
<ul>
<li><code>{FONT_COLOR}</code>: 字符渲染颜色</li>
</ul>
</li>
</ul>
<p>其次<code>tspan</code>标签内容就是我们需要输出的字符，一行字符对应一个<code>tspan</code>标签</p>
<p>因此我们的实现逻辑就是上面这个模板的关键字替换输出了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现逻辑中的几个变量就是上面模板的关键值，就不重复输出了；详情看文末的源码查看</p>
<ul>
<li>SVG_START</li>
<li>SVG_END</li>
</ul>
<h3> 3. 实测演示</h3>
<p>上面已经贴出了核心的实现代码，接下来我们根据成品来看一下输出效果如何；下面是直接使用封装好的方法来调用测试</p>
<p>项目源码：<a href="https://github.com/liuyueyi/quick-media/tree/master/plugins/image-plugin" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/quick-media/tree/master/plugins/image-plugin</a></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出的svg文件如下</p>
<ul>
<li><a href="/imgs/211126/pkq.svg" target="_blank" rel="noopener noreferrer">皮卡丘.svg</a></li>
<li><a href="/imgs/211126/queen.svg" target="_blank" rel="noopener noreferrer">冰雪女王.svg</a></li>
</ul>
<p>实例图:</p>
<figure><img src="/imgs/211126/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-11-26T21:44:26.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">10.图片像素化使用示例</title>
    <id>https://liuyueyi.github.io/tutorial/git/quick-media/image/10.%E5%9B%BE%E7%89%87%E5%83%8F%E7%B4%A0%E5%8C%96%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</id>
    <link href="https://liuyueyi.github.io/tutorial/git/quick-media/image/10.%E5%9B%BE%E7%89%87%E5%83%8F%E7%B4%A0%E5%8C%96%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html"/>
    <updated>2025-02-11T08:53:41.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>本文为 <a href="https://github.com/liuyueyi/quick-media/tree/master/plugins/image-plugin" target="_blank" rel="noopener noreferrer">image-plugin</a> 中土拍你像素化相关操作的使用参考示例</p>
</blockquote>
<h2> 1. 项目依赖</h2>
<p>直接从中央仓库，导入最新依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token comment">&lt;!-- https://mvnrepository.com/artifact/com.github.liuyueyi.media/image-plugin --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.github.liuyueyi.media<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>image-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 请使用最新版本号替换下面的版本 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p>本文为 <a href="https://github.com/liuyueyi/quick-media/tree/master/plugins/image-plugin" target="_blank" rel="noopener noreferrer">image-plugin</a> 中土拍你像素化相关操作的使用参考示例</p>
</blockquote>
<h2> 1. 项目依赖</h2>
<p>直接从中央仓库，导入最新依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 参数说明</h2>
<p>相关参数配置由<code>com.github.hui.quick.plugin.image.wrapper.pixel.ImgPixelOptions</code>实体类进行装载，对应的参数说明如下</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>说明</th>
<th>是否必要</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>source</code></td>
<td><code>BufferedImage</code></td>
<td>原图</td>
<td>与下面的gifSource必须有一个存在</td>
</tr>
<tr>
<td><code>gifSource</code></td>
<td><code>GifDecoder</code></td>
<td>gif 图</td>
<td>于上的source必须有一个存在</td>
</tr>
<tr>
<td><code>pixelType</code></td>
<td><code>IPixelStyle</code></td>
<td>转换类型</td>
<td>否，默认为<code>CHAR_COLOR</code></td>
</tr>
<tr>
<td><code>blockSize</code></td>
<td><code>int</code></td>
<td>对于转字符图时，它控制字符大小；对于灰度/像素处理时，这个表示像素化的处理操作</td>
<td>否 1</td>
</tr>
<tr>
<td><code>fontSize</code></td>
<td><code>int</code></td>
<td>字体大小</td>
<td>否</td>
</tr>
<tr>
<td><code>chars</code></td>
<td><code>String</code></td>
<td>字符图时，用于渲染的字符集</td>
<td><code>$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/|()1{}[]?-_+~&lt;&gt;i!lI;:,\"^'. </code></td>
</tr>
<tr>
<td><code>font</code></td>
<td><code>Font</code></td>
<td>字符字体</td>
<td>否，默认黑色字体</td>
</tr>
<tr>
<td><code>rate</code></td>
<td><code>Double</code></td>
<td>缩放比例，1 表示输出的图不缩放； &gt; 1，表示生成的图，按倍数扩大</td>
<td>否，默认1</td>
</tr>
<tr>
<td><code>picType</code></td>
<td><code>String</code></td>
<td>输出图片类型</td>
<td>否，默认<code>png</code></td>
</tr>
<tr>
<td><code>bgChar</code></td>
<td><code>Character</code></td>
<td>背景字符，默认值为空格</td>
<td>否，默认为空格</td>
</tr>
<tr>
<td><code>bgColor</code></td>
<td><code>Color</code></td>
<td>字符图/svg 图的背景色</td>
<td>否，默认白色</td>
</tr>
<tr>
<td><code>fontColor</code></td>
<td><code>Color</code></td>
<td>字符图/svg 图的字体色</td>
<td>否，默认黑色</td>
</tr>
<tr>
<td><code>bgPredicate</code></td>
<td><code>Predicate&lt;Integer&gt;</code></td>
<td>背景色判断方式，传参为 intColor，如果返回 true，表示认定为背景色；否则不是</td>
<td>否，默认颜色rbga == 0时为背景</td>
</tr>
</tbody>
</table>
<p>上面的配置参数中，重点关注一下 <code>PixelType</code>，它表明了具体的转换策略</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>示例图</th>
</tr>
</thead>
<tbody>
<tr>
<td>GRAY_ALG</td>
<td>基于灰度公式将图片灰度化</td>
<td><img src="/imgs/column/quick-media/image/gray_alg.png" alt="" loading="lazy"></td>
</tr>
<tr>
<td>GRAY_AVG</td>
<td>基于灰度均值将图片灰度化</td>
<td><img src="/imgs/column/quick-media/image/gray_avg.png" alt="" loading="lazy"></td>
</tr>
<tr>
<td>PIXEL_COLOR_AVG</td>
<td>图片像素化时，采用颜色均值</td>
<td><img src="/imgs/column/quick-media/image/pixelColorAvg.png" alt="" loading="lazy"></td>
</tr>
<tr>
<td>CHAR_COLOR</td>
<td>图片转字符图</td>
<td><img src="/imgs/column/quick-media/image/charColor.png" alt="" loading="lazy"></td>
</tr>
<tr>
<td>CHAR_GRAY</td>
<td>图片转灰度字符图</td>
<td><img src="/imgs/column/quick-media/image/charGray.png" alt="" loading="lazy"></td>
</tr>
<tr>
<td>CHAR_BLACK</td>
<td>图片转纯黑白字符，常用于svg输出</td>
<td><img src="/imgs/column/quick-media/image/charGray.svg" alt="" loading="lazy"></td>
</tr>
<tr>
<td>CHAR_SEQ_SCALE_UP</td>
<td>图片转文字图，根据字符顺序绘画，且支持按比例放大</td>
<td><img src="/imgs/column/quick-media/image/charSeq.png" alt="" loading="lazy"></td>
</tr>
<tr>
<td>BLACK_CHAR_BORDER</td>
<td>只针对有颜色的边框进行渲染，常用于文本输出</td>
<td><img src="/imgs/column/quick-media/image/charBorder.jpg" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h2> 3. 使用示例</h2>
<blockquote>
<p>所有的使用姿势，可以在源码对应的test工程中获取 <a href="https://github.com/liuyueyi/quick-media/blob/master/plugins/image-plugin/src/test/java/com/github/hui/quick/plugin/test/pixel/BasicPixelTest.java" target="_blank" rel="noopener noreferrer">BasicPixelTest.java</a></p>
</blockquote>
<p>根据实际需要，选择不同的处理枚举，如</p>
<h3> case1: 希望对图片进行灰度处理时：</h3>
<ul>
<li><code>PixelStyleEnum.GRAY_ALG</code></li>
<li><code>PixelStyleEnum.GRAY_AVG</code></li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下:</p>
<table>
<thead>
<tr>
<th>样式</th>
<th>原图</th>
<th>转换图</th>
</tr>
</thead>
<tbody>
<tr>
<td>GRAY_ALG</td>
<td><img src="/imgs/column/quick-media/image/nezha.jpeg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/gray_alg.png" alt="" loading="lazy"></td>
</tr>
<tr>
<td>GRAY_AVG</td>
<td><img src="/imgs/column/quick-media/image/nezha.jpeg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/gray_avg.png" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h3> case2: 希望将图片转换像素块图时</h3>
<p>主要需要设置 <code>blockSize</code> 参数，将其设置&gt;1，此时可使用的转换类型方式为</p>
<ul>
<li><code>PixelStyleEnum.GRAY_ALG</code></li>
<li><code>PixelStyleEnum.GRAY_AVG</code></li>
<li><code>PixelStyleEnum.PIXEL_COLOR_AVG</code></li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下:</p>
<table>
<thead>
<tr>
<th>样式</th>
<th>原图</th>
<th>转换图</th>
</tr>
</thead>
<tbody>
<tr>
<td>PIXEL_COLOR_AVG</td>
<td><img src="/imgs/column/quick-media/image/nezha.jpeg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/pixelColorAvg.png" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h3> case3: 将图转换为字符图时</h3>
<p>可以输出图片也可以输出svg，常用的转换类型方式为</p>
<ul>
<li><code>PixelStyleEnum.CHAR_COLOR</code></li>
<li><code>PixelStyleEnum.CHAR_GRAY</code></li>
<li><code>PixelStyleEnum.CHAR_BLACK</code>：常用于输出svg字符图、二维字符数组</li>
<li><code>PixelStyleEnum.CHAR_SEQ_SCALE_UP</code>: 它于上面三个的区别在于根据传入的文字进行顺序渲染，且对输出图片会按照文字的大小进行等比例放大、以确保文字可见</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>样式</th>
<th>原图</th>
<th>转换图</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR_COLOR</td>
<td><img src="/imgs/column/quick-media/image/nezha.jpeg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/charColor.png" alt="" loading="lazy"></td>
</tr>
<tr>
<td>CHAR_GRAY</td>
<td><img src="/imgs/column/quick-media/image/nezha.jpeg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/charGray.png" alt="" loading="lazy"></td>
</tr>
<tr>
<td>CHAR_BLACK</td>
<td><img src="/imgs/column/quick-media/image/nezha.jpeg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/charGray.svg" alt="" loading="lazy"></td>
</tr>
<tr>
<td>CHAR_SEQ_SCALE_UP</td>
<td><img src="/imgs/column/quick-media/image/nezha.png" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/charSeq.png" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h3> case4: 输出字符画</h3>
<p>将图片转换为ascii或者特定的字符画，可用</p>
<ul>
<li><code>PixelStyleEnum.CHAR_BLACK</code></li>
<li><code>PixelStyleEnum.BLACK_CHAR_BORDER</code>: 与上面的区别在于它希望输入的是线图</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>样式</th>
<th>原图</th>
<th>转换图</th>
</tr>
</thead>
<tbody>
<tr>
<td>BLACK_CHAR_BORDER</td>
<td><img src="/imgs/column/quick-media/image/slake.jpeg" width="600px"></td>
<td><img src="/imgs/column/quick-media/image/charBorder.jpg" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h3> case5: GIF图转换</h3>
<p>上面除了给出对静态图的处理之外，我们还额外支持gif图的转换，需要注意的是gif图时，只支持输出为gif，不支持输出svg格式</p>
<p>基本使用姿势与前面一致，区别在于传入的图片为gif格式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>原图</th>
<th>v1</th>
<th>v2</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/imgs/column/quick-media/image/xhr.gif" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/outV1.gif" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/outV2.gif" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2025-02-11T11:44:26.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">9.耗时输出重定向</title>
    <id>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/09.%E8%80%97%E6%97%B6%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91.html</id>
    <link href="https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/09.%E8%80%97%E6%97%B6%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91.html"/>
    <updated>2024-09-02T07:47:09.000Z</updated>
    <summary type="html"><![CDATA[<p>前面实现的耗时分布输出直接以日志的方式进行打印，在实际的业务场景中，可能希望以其他的方式（比如Prometheus）来收集耗时，基于这种场景，我们的组件又可以怎么进行演进呢？</p>
<h3> 1. 控制日志是否输出</h3>
<p>首先我们来看一下，若我不希望输出日志，最简单的实现方式就是直接在<code>TraceRecoder</code>中添加变量，用于控制是否进行输出日志</p>
<p>首先改造一下<code>DefaultTraceRecoder</code>，新增<code>logEnable</code>变量</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 控制是否打印日志的条件
 */</span>
<span class="token keyword">private</span> <span class="token keyword">boolean</span> logEnable<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">DefaultTraceRecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token class-name">AsyncUtil</span><span class="token punctuation">.</span>executorService<span class="token punctuation">,</span> <span class="token string">"TraceDog"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token class-name">DefaultTraceRecoder</span><span class="token punctuation">(</span><span class="token class-name">ExecutorService</span> executorService<span class="token punctuation">,</span> <span class="token class-name">String</span> task<span class="token punctuation">,</span> <span class="token keyword">boolean</span> logEnable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>traceName <span class="token operator">=</span> task<span class="token punctuation">;</span>
    list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 支持排序的耗时记录</span>
    cost <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentSkipListMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>executorService <span class="token operator">=</span> <span class="token class-name">TtlExecutors</span><span class="token punctuation">.</span><span class="token function">getTtlExecutorService</span><span class="token punctuation">(</span>executorService<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>markExecuteOver <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>logEnable <span class="token operator">=</span> logEnable<span class="token punctuation">;</span>
    <span class="token function">start</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">MdcUtil</span><span class="token punctuation">.</span><span class="token function">setGlobalTraceId</span><span class="token punctuation">(</span><span class="token class-name">MdcUtil</span><span class="token punctuation">.</span><span class="token function">fetchGlobalMsgIdForTraceRecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<p>前面实现的耗时分布输出直接以日志的方式进行打印，在实际的业务场景中，可能希望以其他的方式（比如Prometheus）来收集耗时，基于这种场景，我们的组件又可以怎么进行演进呢？</p>
<h3> 1. 控制日志是否输出</h3>
<p>首先我们来看一下，若我不希望输出日志，最简单的实现方式就是直接在<code>TraceRecoder</code>中添加变量，用于控制是否进行输出日志</p>
<p>首先改造一下<code>DefaultTraceRecoder</code>，新增<code>logEnable</code>变量</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着是输出日志的时候，加一个判断</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除此之外，我们还需要改造一下 <code>trace-watch-dog-spring</code> 工程中的 <code>@TraceDog</code> 注解，需要新增一个是否输入日志的逻辑</p>
<p>考虑到适用的场景，我们新增两个属性来判定是否输出日志</p>
<ul>
<li><code>boolean logEnable() default true</code>: 简单版，控制是否输出日志</li>
<li><code>String logSpEL() default "";</code> SpEL版，根据动态参数来判断是否输出日志</li>
</ul>
<p>上面两个属性搭配使用；当不存在 <code>logSpEL</code> 时，我们直接以 <code>logEnable</code> 来判断是否要打印日志；若存在 <code>logSpEL</code>，那么我们就要要求上面两个同时为<code>true</code>才能输出日志;</p>
<p>核心的实现就是<code>logSpEL</code>的执行</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的实际实现来看，控制是否打印日志比较简单，那么这个真的有用么？</p>
<p>下面给出几个应用场景：</p>
<ul>
<li>某个执行链路，我们希望测试环境打印日志，生产环境不打印日志（根据运行环境判断是否需要打印日志）</li>
<li>某个执行链路，我们通过一个动态的配置来控制是否需要打印日志，当需要进行排查耗时情况分析时，打开配置输出日志；其他情况则进行关闭</li>
</ul>
<h3> 2. 日志输出重定向</h3>
<p>到目前为止，我们所有的耗时输出都是基于控制台/日志文件，当我们的项目集成了类似Prometheus监控系统时，我们可能更希望将耗时上报到Prometheus，因此就有了输出重定向的诉求</p>
<p>为了支持输出重定向，我们新增一个扩展，在<code>prettyPrint</code>方法中，根据用户自定义的实现来处理</p>
<p>先定义一个函数方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接入两个参数，其中 <code>cost</code> 记录总耗时 + 各子任务的耗时，traceName 表示入口任务名，主要用于获取总耗时</p>
<p>然后调整一下 <code>DefaultTraceRecoder</code></p>
<ol>
<li>新增<code>private List&lt;CostOutput&gt; output;</code> 保存输出重定向的规则</li>
<li>添加默认的<code>log.info</code>输出规则</li>
<li>支持传入自定义的输出重定向规则</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调整下 <code>prettyPrint</code> 方法的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后就是默认的日志输出</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 <code>TraceWatch</code> 中维持全局的重定向规则</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在输出重定向的实现中，主要是借助函数方法来提供能力增强，由于<code>TraceRecoder</code>都是以实例的方式来运行的，如果一个自定义的重定向，需要在每个使用地方都手动注册，显然对使用者极不友好，因此我们提供了全局的注册逻辑，这样就可以实现一次注册，全局生效；同时单个实例也可以有自己的个性化逻辑</p>
<h3> 3. 测试</h3>
<p>接下来我们写个测试用例，使用自定义的输出代替默认的日志输出规则</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点关注上面的<code>testWithAsyncTrace</code>的逻辑，首先是注册全局的自定义耗时输出规则； 然后就是在创建<code>TraceRecoder</code>时，通过传入false，表示不使用原来的日志输出</p>
<p>执行成功之后，我们将得到如下输出:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="技术组件"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2024-09-01T18:19:48.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">8.借助AOP提供非侵入的使用姿势</title>
    <id>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/08.%E5%80%9F%E5%8A%A9AOP%E6%8F%90%E4%BE%9B%E9%9D%9E%E4%BE%B5%E5%85%A5%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/08.%E5%80%9F%E5%8A%A9AOP%E6%8F%90%E4%BE%9B%E9%9D%9E%E4%BE%B5%E5%85%A5%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html"/>
    <updated>2024-08-28T11:39:50.000Z</updated>
    <summary type="html"><![CDATA[<p>再前面完成封装的<code>TraceWatch</code>，进一步简化了使用体验，但是依然存在一个明显的缺陷，对业务代码的侵入性较强，需要再业务代码中，进行主动的埋点</p>
<p>对应常年和Spring打交道的java开发者来说，一个很容易想到的优化方案就是借助AOP来简化业务代码的侵入，接下来我们就看一下，如何借助Spring的AOP能力，对我们之前提供的<code>TraceWatch</code>做一个能力增强</p>
<h2> 1. 方案设计</h2>
<p>对于某个链路的耗时统计，首先确定有一个方法作为耗时记录的入口，表示开始记录耗时，然后就是再执行的过程中，发现有需要统计耗时的方法，则通过<code>Around</code>环绕切面来计算耗时，最后再入口方法执行完毕之后，输出耗时情况即可</p>]]></summary>
    <content type="html"><![CDATA[<p>再前面完成封装的<code>TraceWatch</code>，进一步简化了使用体验，但是依然存在一个明显的缺陷，对业务代码的侵入性较强，需要再业务代码中，进行主动的埋点</p>
<p>对应常年和Spring打交道的java开发者来说，一个很容易想到的优化方案就是借助AOP来简化业务代码的侵入，接下来我们就看一下，如何借助Spring的AOP能力，对我们之前提供的<code>TraceWatch</code>做一个能力增强</p>
<h2> 1. 方案设计</h2>
<p>对于某个链路的耗时统计，首先确定有一个方法作为耗时记录的入口，表示开始记录耗时，然后就是再执行的过程中，发现有需要统计耗时的方法，则通过<code>Around</code>环绕切面来计算耗时，最后再入口方法执行完毕之后，输出耗时情况即可</p>
<h3> 1.1 整体实现流程</h3>
<figure><img src="/imgs/column/trace/12-aop.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面是一个简单的AOP集成说明：</p>
<ol>
<li>首先自定义一个注解，用来表示哪些方法需要进行耗时记录</li>
<li>执行链路中的，首个被自定义注解标注的方法，作为耗时记录的入口
<ul>
<li>即调用 <code>TraceWatch.start</code> 来创建 <code>TraceRecoder</code></li>
</ul>
</li>
<li>在入口方法内部执行的调用链路中，执行到需要记录耗时的方法时，通过<code>traceRecoder.sync/async</code>来加入耗时统计</li>
<li>在入口方法执行完毕时，输出耗时分布</li>
</ol>
<h3> 1.2 方案细节确认</h3>
<p><strong>如何确定入口</strong></p>
<p>上面的流程中，说的是第一个被切面拦截的方法，作为入口，那么这种方式是否合适呢？</p>
<p>如有一个通用的请求校验方法，在支付的链路中，需要记录耗时分布；但是这个方法又会被其他的如提交订单、查看订单等场景使用，又不希望记录耗时，显然这种场景下，使用上面的姿势就不太合适</p>
<p>因此我们自定义注解中，新增一个<code>传播属性 Progation</code>，设置下面三种类型</p>
<ul>
<li>REQUIRED: 支持当前trace记录，如果当前上下文中不存在DefaultTraceRecoder存在，则新创建一个TraceRecoder作为入口开始记录</li>
<li>SUPPORTS: 支持当前trace记录，如果当前上下文中不存在DefaultTraceRecoder存在，则以同步的SyncTraceRecoder方式执行，不参与耗时统计</li>
<li>NEVER: 不支持记录，不管当前存不存在，都以同步的方式执行，且不参与记录</li>
</ul>
<p><strong>耗时记录任务名规则</strong></p>
<p>当不指定具体的任务名时，使用<code>类名#方法名</code>来作为这个耗时的任务名</p>
<p><strong>同步异步选择</strong></p>
<p>默认方法都是同步调用，那么需要异步并行调用时，我们可以通过一个参数来控制</p>
<p><strong>异步方法返回值如何获取</strong></p>
<p>如果某一个方法是异步去执行，那这个方法的返回值怎么获取呢？</p>
<p>如果是直接返回结果，那对于调用者而言，这个异步执行就是个伪并行了（因为需要等待它执行完毕获取结果），因此对于异步调用的方法，返回结果应该由<code>CompletableFuture</code>来包裹</p>
<h2> 2. AOP实现</h2>
<h3> 2.0 前置依赖</h3>
<p>我们接下来借助Spring的AOP来实现，首先需要集成相关依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了避免对使用者项目带来影响，因此我们的实现对引入的依赖是scope是<code>provided</code></p>
<h3> 2.1 注解定义</h3>
<p>首先我们来定义一下关键注解</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.2 传播属性定义</h3>
<p>内置传播属性的枚举<code>Propagation</code>，入口处使用<code>REQUIRED</code>来标识，过程中则使用<code>SUPPORTS</code>来标识</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.3 切面实现</h3>
<p>切面的实现逻辑中，直接根据注解来切连接点，然后基于传播属性，判断是否为入口；对于过程执行中，则需要重点确认下同步还是异步调用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的实现中，我们通过 <code>genTraceName</code> 获取任务名，其规则就是优先从注解中取，拿不到时用<code>类名#方法名</code>作为任务名</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们在来包装一下，目标方法的同步/异步执行，对于异步调用的方法，因为方法本身返回的是<code>CompletableFuture</code>类型，<code>TraceRecoder.async()</code> 返回的也是<code>CompletableFuture</code>，因此我们需要执行下 <code>join()</code> 来获取真实的返回</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同步异步执行的实现逻辑补全，其中复杂一些的在于异步的实现，需要区分有没有返回结果</p>
<ul>
<li>如果有返回结果，且是 <code>CompletableFuture</code> 封装，则需要调用上面的<code>executeWithFuture</code>走异步执行</li>
<li>如果有返回结果，但是直接返回了对象，这种场景对于调用者而言等同于同步调用直接拿到返回结果，因此我们依然走同步执行</li>
<li>如果没有返回结果，则使用<code>async</code>异步执行</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.4 自动注册</h3>
<p>上面就完成了AOP的核心功能实现，接下来就是针对SpringBoot/Spring场景下，做些自动装配的工作</p>
<p>bean声明配置类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SpringBoot的自动装配，在<code>resource/META-INF</code>目录下，新增<code>spring.factories</code>文件</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于不是SpringBoot的场景，则可以通过<code>@EnableTraceWatchDog</code>来开启</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 使用示例与小结</h2>
<h3> 3.1 使用示例</h3>
<p>接下来我们演示一下基于AOP的使用姿势</p>
<p>下两个demoBean</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>已<code>Index#buildIndexVo()</code>作为统计入口，<code>DemoService</code>中提供了五个方法，但是只有四个上有<code>@TraceDog</code>注解，因此方法耗时统计也只会有这四个; 由于<code>ignoreCost</code>内部添加了一个代码块的执行耗时，因此最终的耗时分布输出会额外加上这个代码块的耗时，共5个</p>
<p>接下来实际访问测试一下，添加测试依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试入口如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行之后的输出如</p>
<figure><img src="/imgs/column/trace/13-aopUse.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3.2 小结</h3>
<p>本文我们主要借助AOP对耗时分布统计的工具类做了使用侧的能力增强，从上面的使用示例也可以看出，不需要再业务代码中进行埋点，再需要的方法上，添加上注解就行了，当然若我们对某一段代码块的耗时需要进行统计时，也可以再具体的方法内，通过<code>raceWatch.getRecoderOrElseSync().sync(() -&gt; {}, "任务名");</code> 方式来实现</p>
<p>对于AOP的使用方式，我们需要重点注意：</p>
<ol>
<li>对于希望使用异步的方法，首先注解的<code>async</code>设置为true，其次如果存在返回结果，则必须是<code>CompletableFuture</code>类型</li>
<li>注意AOP切面不生效的场景，同样会导致无法记录耗时（如服务内部调用，注解装饰private方法等）</li>
</ol>
<blockquote>
<p>本文中的测试用例，可以到这里查看 <a href="https://github.com/liuyueyi/hhui-components/blob/master/trace-watch-dog-spring/src/test/java/com/github/liuyueyi/hhui/trace/test/step/BasicDemo.java" target="_blank" rel="noopener noreferrer">trace-watch-dog-spring</a></p>
<p>本文中的实现对应的是 <a href="https://github.com/liuyueyi/hhui-components/blob/master/trace-watch-dog-spring" target="_blank" rel="noopener noreferrer">trace-watch-dog-spring</a> 核心实现</p>
</blockquote>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="技术组件"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2024-08-28T18:19:48.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">7. 便捷的使用封装</title>
    <id>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/07.%E4%BE%BF%E6%8D%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B0%81%E8%A3%85.html</id>
    <link href="https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/07.%E4%BE%BF%E6%8D%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B0%81%E8%A3%85.html"/>
    <updated>2024-08-28T11:39:50.000Z</updated>
    <summary type="html"><![CDATA[<p>接上文，我们现在实现的耗时分布记录工具路<code>TraceRecoder</code>已基本成型，接下来我们将重点放在使用层面的优化上，看一下如何给调用者提供简洁、舒适的使用体验</p>
<h2> 1. 使用侧的问题分析</h2>
<p>现来看一下前面测试用例中的使用case</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCost2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">TraceRecorder</span> recorder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TraceRecorder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">randSleep</span><span class="token punctuation">(</span><span class="token string">"前置"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        recorder<span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">randSleep</span><span class="token punctuation">(</span><span class="token string">"task1"</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"task1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        recorder<span class="token punctuation">.</span><span class="token function">async</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">randSleep</span><span class="token punctuation">(</span><span class="token string">"task2"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"task2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<p>接上文，我们现在实现的耗时分布记录工具路<code>TraceRecoder</code>已基本成型，接下来我们将重点放在使用层面的优化上，看一下如何给调用者提供简洁、舒适的使用体验</p>
<h2> 1. 使用侧的问题分析</h2>
<p>现来看一下前面测试用例中的使用case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么上面这种使用姿势，有什么问题呢？</p>
<p>对于单一方法的代码块而言，并没有什么问题，假设再<code>randSleep</code>方法中，我也希望统计某些代码块的执行耗时，那应该怎么做呢？</p>
<h3> 1.1 嵌套的耗时记录方式</h3>
<p>再需要的地方再创建一个 <code>TraceRecoder</code>，实现链路内的代码块耗时记录</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/trace/09-trace-use1.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的输出也可以看出，外层<code>testCost3</code>的 <code>TraceRecoder</code> 与内部方法<code>subRun</code>的 <code>TraceRecoder</code> 各打印了自己的输出</p>
<p>而我更希望的是将所有的耗时都集成在一个输出中</p>
<h3> 1.2 传参方式</h3>
<p>既然我们希望所有的耗时都放在一个<code>TraceRecoder</code>中，那么可以考虑将这个对象透传给需要的地方，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/trace/10-trace-use2.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>使用同一个<code>TraceRecoder</code>作为参数传递给需要记录耗时的方法之后，我们可以看到所有的耗时都集成再一起了</p>
<p>虽然这种方式可以满足诉求，但是对业务代码的改动就有点大了，需要修改调用方法的传参，那么有其他的解决方法么？</p>
<h3> 1.3 上下文维护TraceRecoder</h3>
<p>借助上下文来保存<code>TraceRecoder</code>，然后再需要的地方直接从上下文中获取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是一个基于上下文的简单使用示例，再整个执行链路中，需要记录耗时的地方，直接从上下文中获取<code>TraceRecoder</code>即可</p>
<p>但是这里依然存在一个问题，如果上面的这个 <code>subRun</code> 方法，被另外一个入口调用，但是这个入口的调用链路中，没有开启耗时记录，即上下文中没有<code>TraceRecoder</code>，那岂不是就会导致<code>NPE</code>?</p>
<p>因此我们需要再上下文获取<code>TraceRecoder</code>时，做一个保护</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 使用优化</h2>
<p>基于上面的几个分析步骤，我们对使用侧的优化就有了一个基本的方向：</p>
<ol>
<li>借助ThreadLocal来持有<code>TraceRecoder</code></li>
<li>再开始记录的入口，初始化<code>TraceRecoder</code>，并保存到上下文</li>
<li>再链路的过程中，需要记录耗时的，可以直接从上下文中获取</li>
</ol>
<h3> 2.1 抽象TraceRecoder</h3>
<p>基于上面提到的几点实现思路，面临一个现实的问题就是从上下文获取<code>TraceRecoder</code>记录耗时时，若返回null，需要再使用侧做一个兼容，为了不让业务代码变得恶心，我们就需要考虑再使用侧做一个保护</p>
<p>我们抽象一个<code>ITraceRecoder</code>的接口类，将前面的工具类作为一个具体实现<code>DefaultTraceRecoder</code>，然后再提供一个同步的实现类<code>SyncTraceRecoder</code>，用于从上下文中获取不到<code>DefaultTraceRecoder</code>时，就返回<code>SyncTraceRecoder</code>，这样对于使用侧而言就不需要做<code>if/else</code>的<code>null</code>保护了</p>
<p>接口定义:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>兜底的同步实现<code>SyncTraceRecoder</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前面封装的耗时统计实现<code>DefaultTraceRecoder</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.2 使用门面</h3>
<p>接下来我们就需要对上面的实现做一个使用的门面封装<code>TraceWatch</code>，对外提供统一的访问姿势</p>
<p>我们可以考虑在<code>TraceWatch</code>中，持有上下文信息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.3 使用示例</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/trace/11-trace-use3.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p>本文中的过程代码，可以到这里查看 <a href="https://github.com/liuyueyi/hhui-components/blob/master/trace-watch-dog/src/test/java/com/github/liuyueyi/hhui/trace/test/step/Step7.java" target="_blank" rel="noopener noreferrer">trace-watch-dog</a></p>
<p>本文中的实现对应的是 <a href="https://github.com/liuyueyi/hhui-components/blob/master/trace-watch-dog" target="_blank" rel="noopener noreferrer">trace-watch-dog</a> 核心实现</p>
</blockquote>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="技术组件"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2024-08-27T18:19:48.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">6. 日志输出与全链路traceId透传</title>
    <id>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/06.%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E4%B8%8E%E5%85%A8%E9%93%BE%E8%B7%AFtraceId%E9%80%8F%E4%BC%A0.html</id>
    <link href="https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/06.%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E4%B8%8E%E5%85%A8%E9%93%BE%E8%B7%AFtraceId%E9%80%8F%E4%BC%A0.html"/>
    <updated>2024-08-27T09:29:58.000Z</updated>
    <summary type="html"><![CDATA[<p>前面封装耗时任务分布工具类的输出，主要是通过<code>System.out.println</code>进行控制台输出，这显然不符合实际的生产使用，接下来我们使用<code>Slf4j</code>进行输出的替换，额外需要注意的就是异步场景下，避免出现全链路的traceId的丢失</p>
<h2> 1. 日志集成</h2>
<h3> 1.1 slf4j日志输出</h3>
<p>在项目中使用日志比较简单，先添加依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token comment">&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.slf4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>slf4j-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.0.16<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<p>前面封装耗时任务分布工具类的输出，主要是通过<code>System.out.println</code>进行控制台输出，这显然不符合实际的生产使用，接下来我们使用<code>Slf4j</code>进行输出的替换，额外需要注意的就是异步场景下，避免出现全链路的traceId的丢失</p>
<h2> 1. 日志集成</h2>
<h3> 1.1 slf4j日志输出</h3>
<p>在项目中使用日志比较简单，先添加依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后就是更新下<code>prettyPrint</code>的日志输出</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点关注下上面的实现，<code>LoggerFactory.getILoggerFactory() instanceof NOPLoggerFactory</code> 通过这一行来判断当前使用的项目中，是否已经集成了日志打印，如果是就利用 <code>log.info()</code> 打印日志，若没有集成类似<code>logback/log4j</code>之类的日志框架，那就依然使用<code>System.out.println</code>来输出耗时情况</p>
<h3> 1.2 全链路的日志集成</h3>
<p>对全链路有过了解的小伙伴应该知晓，在整个执行链路中，即便是出现了异步（线程池调度）、跨进程（RPC)、跨服务等场景，仍然需要一个traceId从头到尾一直携带到最后</p>
<p>那么我们的工具类中的异步代码块执行，如何将这个<code>traceId</code>携带进去呢？</p>
<ul>
<li>借助<code>MDC</code>来实现</li>
</ul>
<p>作为一个工具提供方，我们需要知晓如何从MDC中获取全链路的<code>traceId</code>，如果没有自定义的全链路traceId生成携带策略，我们也可以提供一个默认的实现进行支持</p>
<p>因此我们先封装一个<code>MdcUtil</code>工具类，来读写上下文中的traceId</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，这里主要提供了一个全局的配置<code>traceIdAutoGen</code>来控制，当上下文中拿不到<code>traceId</code>时，我们应该是重新生成一个还是压根就不管它</p>
<p>然后我们就需要在之前的实现层<code>TraceRecoder</code>，做一些改造，以实现异步执行时的traceId透传</p>
<ul>
<li>在执行代码块的封装层，在业务代码执行前初始化<code>traceId</code> （需要注意，不要将获取traceId的逻辑放在代码块中了）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3 全链路traceId测试</h3>
<p>接下来就需要我们来验证一下集成情况了，首先再看一下完整修改后的<code>TraceRecoder</code>工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面将本次新增的逻辑标记了出来，对原有的改造较小，接下来，再写个测试用例，基本使用姿势与之前无异，唯一的区别在于我们再异步代码块中，使用日志输出看看<code>traceId</code>是否能打印出来</p>
<p>要使用slf4j，先添加一个具体的日志实现，比如logback</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再资源目录下，添加配置文件 <code>resources/logback.xml</code></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后就是测试用例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>先看下，直接借助已有的<code>traceId</code>场景</p>
<figure><img src="/imgs/column/trace/07-traceId1.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>再看下，上下文中没有<code>traceId</code>，使用默认的的<code>traceId</code>生成策略</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/trace/08-traceId2.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 1.4 小结</h3>
<p>到这里我们就已经实现了<code>trace-watch-dog</code>的日志集成了，并且为全链路的<code>traceId</code>透传也提供了相应的解决方案</p>
<p>从上面的实现来看，我们还有有个更推荐的写法，再任务的执行前后各添加一个钩子，然后再钩子中进行任务执行前后的执行单元注册，将全链路的<code>traceId</code>透传放在钩子中执行，这样也可以提供更强的扩展能力</p>
<p>至于这个如何设计后续再来介绍</p>
<blockquote>
<p>本文中的相关代码，可以到这里查看 <a href="https://github.com/liuyueyi/hhui-components/blob/master/trace-watch-dog/src/test/java/com/github/liuyueyi/hhui/trace/test/step/Step6.java" target="_blank" rel="noopener noreferrer">trace-watch-dog</a></p>
</blockquote>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="技术组件"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2024-08-26T18:19:48.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">5. 上下文信息传递</title>
    <id>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/05.%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92.html</id>
    <link href="https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/05.%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92.html"/>
    <updated>2024-08-27T09:29:58.000Z</updated>
    <summary type="html"><![CDATA[<p>前面完成的<code>TraceRecoder</code>支持了异步代码块的调度，接下来我们就需要重点解决一下多线程下的数据传递问题，确保异步代码块的执行过程中，不会出现各种难以理解的并发问题</p>
<h2> 1. 并发问题复现</h2>
<p>首先我们先来看一下，<code>TraceRecoder</code> 会在什么场景出现问题</p>
<h3> 1.1 上下文再线程池场景下的共享异常</h3>
<p>既然我们的工具类是支持异步代码块封装，考虑到上下文的共享，我们第一想到就是使用<code>InheritableThreadLocal</code> 来替代 <code>ThreadLocal</code> 来存储上下文信息</p>]]></summary>
    <content type="html"><![CDATA[<p>前面完成的<code>TraceRecoder</code>支持了异步代码块的调度，接下来我们就需要重点解决一下多线程下的数据传递问题，确保异步代码块的执行过程中，不会出现各种难以理解的并发问题</p>
<h2> 1. 并发问题复现</h2>
<p>首先我们先来看一下，<code>TraceRecoder</code> 会在什么场景出现问题</p>
<h3> 1.1 上下文再线程池场景下的共享异常</h3>
<p>既然我们的工具类是支持异步代码块封装，考虑到上下文的共享，我们第一想到就是使用<code>InheritableThreadLocal</code> 来替代 <code>ThreadLocal</code> 来存储上下文信息</p>
<p>但是有过了解的小伙伴会知道这个东西，在线程池的场景是可能出现共享异常的</p>
<p>我们可以构造一个简单的demo来验证一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，主要是模拟<code>TraceRecoder</code>的线程池中的线程复用场景，从而诱导线程池复用、导致引用其他任务的上下文出现的概率</p>
<p>当我们执行上面的测试用例，将会可能得到下面的输出</p>
<figure><img src="/imgs/column/trace/06-并发问题.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的输出，也可以直观的看到 <code>t2</code> 执行链路中 获取到了<code>t1</code>执行链路的上下文；</p>
<p>那么怎么解决这种问题呢?</p>
<h3> 1.2 解决方案</h3>
<p>借助阿里开源的<code>transmittable-thread-local</code>来替换默认的上下文，从而解决并发的上下文共享问题</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 并发问题改造</h2>
<h3> 2.1 异步工具类适配</h3>
<p>首先我们对线程池进行改造，使用<code>TtlExecutors</code>进行包裹，先调整默认的线程池</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着对用户传递线程池进行保护</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.2 要求使用TransmittableThreadLocal上下文</h3>
<p>接下来就是对使用侧进行约束，对于有异步使用的场景，请使用<code>TransmittableThreadLocal</code>替换jdk的<code>ThreadLocal</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再调整之后，可以继续执行前面的测试用例，我们稍微调整一下，用于多次执行判断是否有异常情况</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.3 小结</h3>
<p>本文主要介绍了 <code>TraceRecoder</code> 在异步执行场景执行下可能出现的上下文共享问题，为了解决并发问题，在使用层，我们需要注意使用<code>TransmittableThreadLocal</code> 来存储上下文信息</p>
<blockquote>
<p>本文中的相关代码，可以到这里查看 <a href="https://github.com/liuyueyi/hhui-components/blob/master/trace-watch-dog/src/test/java/com/github/liuyueyi/hhui/trace/test/step/Step5.java" target="_blank" rel="noopener noreferrer">trace-watch-dog</a></p>
</blockquote>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="技术组件"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2024-08-23T09:19:48.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">3. 从0到1封装一个通用的耗时统计工具类</title>
    <id>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/03.%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E8%80%97%E6%97%B6%E5%88%86%E5%B8%83%E5%B7%A5%E5%85%B7%E7%B1%BB.html</id>
    <link href="https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/03.%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E8%80%97%E6%97%B6%E5%88%86%E5%B8%83%E5%B7%A5%E5%85%B7%E7%B1%BB.html"/>
    <updated>2024-08-22T10:54:29.000Z</updated>
    <summary type="html"><![CDATA[<p>接下来本文将再前面的基础耗时工具类的基础之上，从0到1写一个支持多线程场景下的耗时统计工具类</p>
<h2> 1. 设计思路</h2>
<h3> 1.1 明确思路</h3>
<p>首先明确目标：</p>
<ul>
<li>实现一个并发安全的<code>StopWatch</code>工具类</li>
</ul>
<p>主要挑战：</p>
<ul>
<li>并发安全</li>
</ul>
<p>实现思路：</p>
<ul>
<li>参照<code>StopWatch</code>的实现，解决并发问题</li>
</ul>
<h3> 1.2 设计思路</h3>
<p>到这里，假定大家已经看过了<code>StopWatch</code>的实现源码（实际上没看过也没啥影响）</p>]]></summary>
    <content type="html"><![CDATA[<p>接下来本文将再前面的基础耗时工具类的基础之上，从0到1写一个支持多线程场景下的耗时统计工具类</p>
<h2> 1. 设计思路</h2>
<h3> 1.1 明确思路</h3>
<p>首先明确目标：</p>
<ul>
<li>实现一个并发安全的<code>StopWatch</code>工具类</li>
</ul>
<p>主要挑战：</p>
<ul>
<li>并发安全</li>
</ul>
<p>实现思路：</p>
<ul>
<li>参照<code>StopWatch</code>的实现，解决并发问题</li>
</ul>
<h3> 1.2 设计思路</h3>
<p>到这里，假定大家已经看过了<code>StopWatch</code>的实现源码（实际上没看过也没啥影响）</p>
<ul>
<li>在<code>StopWatch</code>中，通过<code>List&lt;TaskInfo&gt; taskList</code>来记录每个任务的耗时情况</li>
<li>因为它主要应用于单线程场景，所以不存在任务的并行耗时记录的场景，通常是要给任务执行完毕，然后开始记录下一个任务，所以在全局使用<code>startTimeNanos</code>表示当前任务的开始时间，当结束记录时，将任务耗时情况写入<code>taskList</code>列表</li>
</ul>
<p>基本工作原理如下</p>
<figure><img src="/imgs/column/trace/02-stopwatch原理.jpg" alt="StopWatch工作原理" tabindex="0" loading="lazy"><figcaption>StopWatch工作原理</figcaption></figure>
<p>从StopWatch的工作原理上，想实现一个并发安全的貌似也不难，我们将List换成Map，支持同时记录多个任务的耗时情况</p>
<figure><img src="/imgs/column/trace/03-traceDog原理.jpg" alt="trace-watch-dog工作原理" tabindex="0" loading="lazy"><figcaption>trace-watch-dog工作原理</figcaption></figure>
<p>我们的设计上也相对清晰</p>
<ol>
<li>使用一个并发安全的Map容器（如ConcurrentHashMap)来记录任务的耗时情况</li>
<li>开始记录一个任务时，向Map中写入<code>任务名</code> + <code>当前时间戳</code> 的键值对</li>
<li>结束一个任务时，从Map中获取对应任务的时间戳，与当前时间戳取差值，得到任务的执行耗时，并写回到Map中，这样Map中记录的就是这个任务的耗时时间了</li>
<li>耗时分布输出：遍历map，打印结果</li>
</ol>
<h2> 2. 实现</h2>
<h3> 2.1 基础实现</h3>
<blockquote>
<p>下面的源码，可在<code>com.github.liuyueyi.hhui.trace.test.step.Step3</code>进行查看</p>
</blockquote>
<p>接下来我们按照上面的设计思路，现来实现一个Map版本的<code>StopWatch</code></p>
<p>定义一个工具类 <code>TraceWatch</code>，申明两个核心变量 <code>taskName:总任务名</code> + <code>taskCost:子任务耗时map</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后就是实现记录某个任务执行耗时的开始、结束方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后再实现一个各任务的耗时输出分布 （日志打印基本上验用StopWatch的格式化打印，区别在于这里使用的是毫秒输出）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到这里，一个支持多任务耗时并行记录的工具类就实现了，接下来写一个测试用例来验证下效果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一个示例的输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的使用demo以及输出，会发现存在一些问题</p>
<ol>
<li>代码的冗余度高</li>
<li>总耗时与实际不符（总耗时是每个任务的耗时加和，但是有些任务是并行执行的）</li>
<li>最终的结果输出时，得等到所有任务执行完毕，但是上面的实现无法保证这一点</li>
<li>耗时统计的代码块抛出异常时，会导致无法正确记录耗时情况（即stop方法要求业务方确保和start一起出现，一定会被调用到）</li>
</ol>
<h3> 2.2 使用姿势优化</h3>
<p>接下来我们尝试解决提出的问题，首先是使用姿势的优化，提供一个耗时的封装</p>
<p>在前面的基础上，新增一个无返回/有返回的方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，我们再借助<code>try</code>语句来实现自动的耗时输出, 再结果打印时，我们遍历一下所有的任务，看一下是否已经执行完毕(通过判断taskCost中存的是时间戳还是耗时来判断任务是否执行完毕，当然也是可以新增一个状态来判断任务是否已执行完)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来再看一下新的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>整体来说，相比较于前面的版本，使用侧还是要简单明了不少的。 但是请注意，再实际使用的过程中，可能会出现最后一个 task4 耗时统计异常的情况，如下</p>
<figure><img src="/imgs/column/trace/04-traceWatch输出.jpg" alt="异常输出" tabindex="0" loading="lazy"><figcaption>异常输出</figcaption></figure>
<p>为什么会出现这种情况呢？ 我们在耗时输出时，不是已经做了一个自旋等待所有任务执行完毕么，为啥还会出现任务没有执行完毕的情况呢？</p>
<p>这里主要的原因在于并行的场景下，<code>TraceWatch</code> 的 <code>close</code> 方法执行过程中，<code>allExecuted</code> 这个方法执行完了之后，而在 <code>prettyPrint</code> 打印前，上面的task4这个任务执行了<code>start()</code>方法开始了耗时记录，从而导致出现上面的问题</p>
<h3> 2.3 并发优化</h3>
<p>接下来我们再优化一下上面的工具类，除了解决上面的问题之外，我们再调整一下整体耗时的规则，记录从<code>TraceWatch</code>初始化，到最终耗时输出这个时间段的耗时，作为整体的耗时记录（取代之前的所有的单个任务耗时加和作为总耗时）</p>
<ul>
<li>新增 <code>markExecuteOver</code> 标记是否所有的任务执行完毕</li>
<li>若所有任务执行完毕，则不再支持新的任务耗时记录</li>
<li>对象创建时，作为整体任务的开始时间； 日志打印/close方法触发时，作为整体任务执行结束时间</li>
</ul>
<p>添加上面三个逻辑之后，新的工具类如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的使用姿势基本上与前面没什么差别，我们新增一个没有被<code>traceWatch.cost</code>包裹的代码块，验证下新的工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>多执行几次，将会看到下面这类的输出</p>
<figure><img src="/imgs/column/trace/05-traceWatch输出2.jpg" alt="输出结果" tabindex="0" loading="lazy"><figcaption>输出结果</figcaption></figure>
<p>重点注意几个关键输出：</p>
<ol>
<li>task4 耗时记录被忽略了，即出现了先执行<code>allExecuted()</code>，后统计 <code>task4</code> 耗时的场景</li>
<li><code>整体耗时(147ms)</code> 约等于 <code>前置(12ms)</code> + <code>task1(106ms)</code> + <code>task3(27ms)</code></li>
</ol>
<p>因为task2是异步执行的，它可以与task1/3并行执行，所以对整体的耗时基本没有影响，这里的整体耗时输出和我们外层直接统计的耗时输出基本一致，表明这个整体的耗时输出结果是符合真实预期的</p>
<h3> 2.4 小结</h3>
<p>本文通过一步一步的实现 + 复盘，得出了一个简单的、适用于并发场景下的耗时分布统计工具类。再实现的过程中，给出了为什么最终的成品长这样，因为什么原因，引入了xx成员变量，解决了什么问题，通过将这个工具类的实现步骤拆分，给大家演示了一下一个相对成熟的工具类的迭代过程</p>
<p><strong>知识点</strong></p>
<p>接下来我们对整体的实现，从技术侧做一个小结，相关的知识点有：</p>
<ul>
<li>并发任务耗时支持： 借助<code>ConcurrentHashMap</code>来记录每个任务的耗时情况</li>
<li>通过函数方法，封装代码块的耗时统计使用姿势，确保 <code>start</code> 与 <code>stop</code> 一定会配套出现</li>
<li>自旋等待的方式，等待所有的任务执行完毕之后，再输出耗时分布</li>
<li>全局结束标记，当标记结束之后，不再支持新的任务耗时统计（注意<code>markExecuteOver</code>前面的修饰<code>volatile</code>）</li>
</ul>
<p><strong>缺陷点</strong></p>
<p>然后我们再看一下这个工具类的缺陷：</p>
<ul>
<li>代码侵入性问题（依然时需要再业务代码侧进行埋点）</li>
<li>任务名相同时，会出现耗时覆盖</li>
<li>任务耗时百分比加和不是100%(因为异步任务以及任务之外的代码块执行耗时的影响，导致占比一般不是100%了)</li>
</ul>
<p><strong>待优化点</strong></p>
<p>在上面这个工具类的基础上，我们还有什么可以优化的地方么?</p>
<ul>
<li>简化异步代码块的耗时统计，看是否可以直接将异步的能力集成在工具类中，减小业务侧异步支持的成本</li>
</ul>
<blockquote>
<p>本文所有代码均可以在 <a href="https://github.com/liuyueyi/hhui-components/blob/master/trace-watch-dog/src/test/java/com/github/liuyueyi/hhui/trace/test/step/Step4.java" target="_blank" rel="noopener noreferrer">trace-watch-dog</a> 获取</p>
</blockquote>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="技术组件"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2024-08-22T09:19:48.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">4. 异步使用能力增强</title>
    <id>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/04.%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81%E7%AD%96%E7%95%A5.html</id>
    <link href="https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/04.%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81%E7%AD%96%E7%95%A5.html"/>
    <updated>2024-08-23T10:27:59.000Z</updated>
    <summary type="html"><![CDATA[<p>接上文的耗时统计工具类，对于<code>TraceWatch</code>工具类的基本使用，都是基于同步的策略来的，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
<span class="token comment">// 无返回结果</span>
traceWatch<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> xxx<span class="token punctuation">,</span> <span class="token string">"task1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 有返回结果</span>
ans <span class="token operator">=</span> traceWatch<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> xxx<span class="token punctuation">;</span>  <span class="token keyword">return</span> xxx<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"task1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<p>接上文的耗时统计工具类，对于<code>TraceWatch</code>工具类的基本使用，都是基于同步的策略来的，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们考虑对它的能力进行增强，我们希望可以简单的指定需要统计的代码块是同步执行还是异步执行</p>
<p>比如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 1. 异步增强</h2>
<h3> 1.1 通用的线程池工具类</h3>
<p>既然是异步能力增强，支持代码块的异步调度，那么我们可以封装一个简单的线程池工具类，主要用于异步执行的线程池的创建</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2 异步能力增强</h3>
<p>当我们希望包装的代码块可以同步/异步执行时，首先是在创建对象的时候，指定一下线程池</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们封装一下上面的<code>start</code>, <code>end</code>方法的使用姿势，与前面的工具类的实现，重要的区别在于返回</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么返回的是 <code>Runnable/Supplier</code>？</p>
<blockquote>
<p>这个就需要从同步/异步的调用方法来看为什么这么设计了</p>
</blockquote>
<p>对于同步执行的场景，我们可以分别为有返回/无返回提供两个方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于异步执行的场景，我们需要将<code>xxWithTime</code>的返回丢到线程池中执行</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看到上面的实现之后，我们很容易想到，在输出耗时分布时，判断是否所有任务执行完毕，实际上不需要用之前的自旋等待的方式判断是否都执行完毕了，我们可以持有异步的返回的<code>CompletableFuture</code>，通过join的方式来等待所有任务执行完毕</p>
<p>因此我们可以声明一个全局的异步结果缓存容器，在实例化对象的时候进行初始化</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来就是在异步调度时，保存一下结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>等待所有任务执行完毕就可以直接借助<code>CompletableFuture.allOf().join</code>来实现了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此，我们的异步能力增强已基本实现完毕, 接下来进入实测体验</p>
<h2> 2. 使用体验</h2>
<h3> 2.1 完整工具类</h3>
<p>下面是完整的工具实现类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.2 使用体验</h3>
<p>接下来看一下具体的使用实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出示例</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.3 小结</h3>
<p>从上面的使用来看，现在的工具类相对来说就完整很多了，使用上也比较简单(至少代码阅读起来，还算优雅)，但是依然没能解决<code>业务代码侵入</code>问题</p>
<p>此外，在异步的场景下，我们需要注意多线程/线程池场景下的上下文传递问题，若上面的<code>async</code>代码块中，希望获取主线程中的上下文参数，可以正常拿到么？</p>
<blockquote>
<p>本文中的相关代码，可以到这里查看 <a href="https://github.com/liuyueyi/hhui-components/blob/master/trace-watch-dog/src/test/java/com/github/liuyueyi/hhui/trace/test/step/Step5.java" target="_blank" rel="noopener noreferrer">trace-watch-dog</a></p>
</blockquote>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="技术组件"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2024-08-22T18:19:48.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">2. 封装一个基础的耗时统计工具类</title>
    <id>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/02.%E5%9F%BA%E7%A1%80%E8%80%97%E6%97%B6%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85.html</id>
    <link href="https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/02.%E5%9F%BA%E7%A1%80%E8%80%97%E6%97%B6%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85.html"/>
    <updated>2024-08-22T10:54:29.000Z</updated>
    <summary type="html"><![CDATA[<p>在日常的工作中，对某一段代码的执行耗时进行记录，属于相对常见的诉求，实现起来也很简单，不就是开始前记录一下当前时间戳，执行结束之后再记录一下当前时间戳，两者相减就可以得到我们想要的结果了</p>
<h2> 1. 时间戳差值法</h2>
<p>这里主要借助的就是 <code>System.currentTimeMillis()</code> 来获取当前的时间戳（毫秒）</p>
<h3> 1.1 基本实现</h3>
<p>先来看一下基本的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// com.github.liuyueyi.hhui.trace.test.step.Step1#testCost</span>
<span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ... 这里省略掉需要计算耗时的业务逻辑</span>
<span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"cost: "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<p>在日常的工作中，对某一段代码的执行耗时进行记录，属于相对常见的诉求，实现起来也很简单，不就是开始前记录一下当前时间戳，执行结束之后再记录一下当前时间戳，两者相减就可以得到我们想要的结果了</p>
<h2> 1. 时间戳差值法</h2>
<p>这里主要借助的就是 <code>System.currentTimeMillis()</code> 来获取当前的时间戳（毫秒）</p>
<h3> 1.1 基本实现</h3>
<p>先来看一下基本的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法比较简单直接，唯一的问题就是会有较多的重复冗余代码，特别是再一个执行链路中，存在较多的地方需要输出耗时时，就会发现代码块中，会出现大量的上面的代码块</p>
<p>有没有什么办法可以提炼一下呢？</p>
<ul>
<li>通过函数方法来实现</li>
</ul>
<h3> 1.2 公用方法</h3>
<p>针对上面的写法，我们抽出一个耗时统计的公用方法，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当执行一个代码块不需要关注返回结果时，就可以通过下面这种方式进行耗时输出</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行以下上面的 testCost2 ，会得到如下的执行耗时输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的公用方法适用于没有返回结果的耗时打印，但是现实中，当然还存在需要获取返回的场景，这个时候我们可以再封装一个公共方法，适用于有返回结果的场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>给出一个具体的使用demo</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是执行的返回结果示例</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3 实现小结</h3>
<p>上面基于时间戳封装了一个简单的耗时打印公共方法，我们整合一下关键的实现，提炼一个通用工具类如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的使用姿势也比较简单，根据是否有返回结果，可以区分为下面两种</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从结果来看，这个工具类已经能满足基本诉求了，那么到此为止么？再看一下这个工具类，会有什么问题么？</p>
<p>从使用侧的角度来看，这个工具类还有两个不便</p>
<ol>
<li>代码侵入性强，需要主动再业务代码中进行集成</li>
<li>输出结果分散，对于链路较长的业务，具体是哪一块业务逻辑耗时较久不太直观</li>
</ol>
<h2> 2. StopWatch工具类</h2>
<p>Spring本身提供了一个耗时统计的工具类<code>StopWatch</code>，当然也有很多的组件库(如Hutool)提供了类似的工具类，那么它主要是为了解决什么问题呢？</p>
<h3> 2.1 使用体验</h3>
<p>接下来我们通过实际的使用，来体验一下<code>StopWatch</code>的效果表现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的输出结果，可以直观看到每个任务的耗时，对整体耗时的占用百分比，基于此可以更容易找到性能瓶颈点，这里也可以回答上一节的疑问，主要解决的就是上面提到的第二个缺陷：输出比较分散的问题</p>
<h3> 2.2 使用封装</h3>
<p>同样的，我们也希望将上面的使用姿势做一个封装，尽量减少冗余代码对业务代码的侵入</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的工具类中，我们借助<code>Closeable</code> + <code>try</code> 来实现自动的耗时输出</p>
<p>接下来再看一下使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出示例</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用工具类，整体上对业务代码的可阅读性上，相比较于之前会更优雅一点； 那么这个StopWatchWrapper的工具类是否就已经可以满足我们的诉求了呢？</p>
<h3> 2.3 StopWatch特性小结</h3>
<p>仔细看一下上面的耗时打印，StopWatch 输出的耗时，实际上是从首次调用 <code>stopWatch.start</code> 开始计算耗时，到最后一个 <code>stopWatch.stop</code> 调用作为结束</p>
<p>即上面的测试代码中，try语句中的第一个<code>randSleep(300);</code> 和最后一个 <code>randSleep(300);</code> 的耗时，实际上是不包含在最终的耗时输出结果中的，这里就有一点反直觉了</p>
<p>此外，有看过<code>StopWatch</code>源码的小伙伴可以知道，它是线程不安全的，即在多线程场景下，即容易出错</p>
<figure><img src="/imgs/column/trace/01-stopwatch.jpg" alt="异常提示" tabindex="0" loading="lazy"><figcaption>异常提示</figcaption></figure>
<h2> 3. 小结</h2>
<p>我们这里主要封装了两个工具类，主要解决的是使用层面的问题</p>
<ol>
<li>CostUtil</li>
</ol>
<p>适用于单一代码块的耗时输出，借助 <code>System.currentTimeMillis</code> 获取当前时间戳，通过代码块执行前后的时间差来输出耗时情况</p>
<p>封装的工具类主要借助函数方法来简化使用方式，它本身的缺点有下面几点</p>
<ul>
<li>侵入性强，需要主动埋点记录耗时</li>
<li>对于复杂的业务链路下，存在多个任务耗时统计时，输出结果离散不直观</li>
</ul>
<ol start="2">
<li>StopWatchWrapper</li>
</ol>
<p>适用于某一业务链路，多个任务耗时打印输出场景，借助<code>StopWatch</code>来实现耗时分布统计</p>
<p>这里主要借助函数方法 + try/closeable来简化使用方式, 它解决了CostUtil的输出离散问题，单依然存在下面几个缺点</p>
<ul>
<li>侵入性强，需要主动埋点记录耗时</li>
<li>并发场景下容易出现异常</li>
</ul>
<p>既然现有的工具方法不够完美，那就自己撸一个，目标是</p>
<ul>
<li>侵入性小</li>
<li>支持并发场景的耗时记录</li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="技术组件"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2024-08-21T19:19:48.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1. 诞生的契机</title>
    <id>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/01.%E8%AF%9E%E7%94%9F%E7%9A%84%E5%A5%91%E6%9C%BA.html</id>
    <link href="https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/01.%E8%AF%9E%E7%94%9F%E7%9A%84%E5%A5%91%E6%9C%BA.html"/>
    <updated>2024-08-14T14:17:36.000Z</updated>
    <summary type="html"><![CDATA[<p>为什么会萌发写一个记录链路耗时的组件的念头呢？ 来源于一个不太美妙的线上问题。 自从开始做toB的业务之后，对系统的性能要求阈值不断下降，当一个接口响应超过3s时，发现适应适应还可接受，然后逐渐的，你会发现接口的响应会滑向5s、10s... (底线一段突破，那就将没有底线可言)</p>
<p>在经历某一次重大的迭代之后，整体的数据量翻了两翻，部分接口的响应直接突破10s，然后业主方终于是不能忍了，明确提出要求做性能优化</p>
<p>那么怎么做呢？</p>
<p>按照一般的做事惯例，先定目标，然后基于现状拆解任务，接着就是任务的研发推进，最终的交付测试上线</p>
<p>当明确提出要优化某个接口时，至少我们现在的目标是明确，要缩减接口的耗时</p>]]></summary>
    <content type="html"><![CDATA[<p>为什么会萌发写一个记录链路耗时的组件的念头呢？ 来源于一个不太美妙的线上问题。 自从开始做toB的业务之后，对系统的性能要求阈值不断下降，当一个接口响应超过3s时，发现适应适应还可接受，然后逐渐的，你会发现接口的响应会滑向5s、10s... (底线一段突破，那就将没有底线可言)</p>
<p>在经历某一次重大的迭代之后，整体的数据量翻了两翻，部分接口的响应直接突破10s，然后业主方终于是不能忍了，明确提出要求做性能优化</p>
<p>那么怎么做呢？</p>
<p>按照一般的做事惯例，先定目标，然后基于现状拆解任务，接着就是任务的研发推进，最终的交付测试上线</p>
<p>当明确提出要优化某个接口时，至少我们现在的目标是明确，要缩减接口的耗时</p>
<p>现在也是明确的，接口响应很慢。 那么我们的任务也相对明确，即是解决接口响应慢的问题。 接下来就自然有一个疑问，到底是哪里慢了？ 对应的策略有两种</p>
<ol>
<li>老老实实啃代码，根据个人经验来判断慢的点</li>
<li>借助一些工具，输出各关键节点的耗时分布情况，直观上找到性能瓶颈点</li>
</ol>
<p>对于第一点，没有什么好说的；重点看一下第二个，我现在迫切需要一个工具，能帮我分析整个接口的执行链路中，是哪些环节会比较慢</p>
<p>现在我有什么？</p>
<ul>
<li>skywalking</li>
<li>loki + grafana</li>
</ul>
<p>既然有全链路监控神器Skywalking，当然想着就是充分利用起来，先直接观察一下链路的执行情况</p>
<figure><img src="/imgs/column/trace/00-skywalking.jpg" alt="来自网图" tabindex="0" loading="lazy"><figcaption>来自网图</figcaption></figure>
<p>默认的Skywalking的链路追踪中，主要显示的是一些io相关的耗时操作，对于我们实际的业务场景有帮助，但不大（链路长、网络io非常多，很难精确定位到具体是哪里耗时久）</p>
<p>此时就需要我们主动在代码的方法上埋点，通过<code>@Trace</code>注解来手动插入<code>LocalSpan</code>，从而增加关键方法的执行情况输出；接下来我遇到另外一个稍显现实的问题，特么的代码写得有点拉跨，大部分逻辑放在一个方法里，咋搞....</p>
<blockquote>
<p>关于skywalking的基础知识点：（<a href="https://www.jianshu.com/p/541eb76c6edc" target="_blank" rel="noopener noreferrer">Skywalking的埋点-Trace的基本概念 - 简书</a>）</p>
</blockquote>
<p>接下来只能老老实实的在代码中通过 <code>StopWatch</code> 来统计代码块的执行耗时情况了，耗时打印输出日志，借助<code>loki+grafana</code>来统一收集查看，也能满足诉求，但是，这种方式写出来的代码，会导致本就岌岌可危的业务代码，又添加了一堆无甚鸟用的逻辑，实在是有点难以忍受； 还有另外一个严重的问题，则是<code>StopWatch</code>对并发的支持不行，对于链路中存在异步调用的场景下，会出现统计偏差或异常</p>
<p>既然现存的工具栈不合心意，那就自己搞一个，先指定几个基本要求：</p>
<ul>
<li>不会引入新的问题</li>
<li>使用简单方便，输出直观的耗时统计</li>
<li>对现有的业务代码块侵入较小</li>
<li>支持链路中存在并行任务执行场景的耗时统计</li>
<li>可以方便的将某些方法/代码块，由同步的调度改成异步的调度，从而提高接口性能</li>
</ul>
<p>接下来我们将正式进入实现篇，如何从0到1手撸一个耗时分布统计的工具组件</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="技术组件"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2024-08-14T19:19:48.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">trace-watch-dog</title>
    <id>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/</id>
    <link href="https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/"/>
    <updated>2024-08-21T09:27:37.000Z</updated>
    <summary type="html"><![CDATA[<h2> trace-watch-dog</h2>
<blockquote>
<p>源码地址： <a href="https://github.com/liuyueyi/hhui-components/blob/master/trace-watch-dog" target="_blank" rel="noopener noreferrer">trace-watch-dog</a></p>
</blockquote>
<p>用于记录项目中，某一个链路的执行耗时情况，同时也支持将链路中的某些同步调用，改成异步执行，从而提高整体的性能表现</p>
<h3> 迭代记录</h3>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> v1.0.1 支持在上下文中，随时获取 <code>TraceBridge</code> 进行手动埋点, 支持传入自定义的logSpEL，控制是否输出日志</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> v1.0.0 实现一个基础的 <code>TraceWatch</code> 工具类，通过手动埋点的方式记录整体的耗时分布情况</label></li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> trace-watch-dog</h2>
<blockquote>
<p>源码地址： <a href="https://github.com/liuyueyi/hhui-components/blob/master/trace-watch-dog" target="_blank" rel="noopener noreferrer">trace-watch-dog</a></p>
</blockquote>
<p>用于记录项目中，某一个链路的执行耗时情况，同时也支持将链路中的某些同步调用，改成异步执行，从而提高整体的性能表现</p>
<h3> 迭代记录</h3>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> v1.0.1 支持在上下文中，随时获取 <code>TraceBridge</code> 进行手动埋点, 支持传入自定义的logSpEL，控制是否输出日志</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> v1.0.0 实现一个基础的 <code>TraceWatch</code> 工具类，通过手动埋点的方式记录整体的耗时分布情况</label></li>
</ul>
<h3> 系列教程</h3>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> trace-watch-dog 诞生的契机</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> 如何实现一个基础版本的耗时监控工具类</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-4" disabled="disabled"><label class="task-list-item-label" for="task-item-4"> 便捷的同步转异步的实现策略</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-5" disabled="disabled"><label class="task-list-item-label" for="task-item-5"> 解决异步的上下文信息丢失问题（如traceId）</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-6" disabled="disabled"><label class="task-list-item-label" for="task-item-6"> 借助上下文，支持随时使用</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-7" disabled="disabled"><label class="task-list-item-label" for="task-item-7"> 借助AOP，实现非侵入式的埋点</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-8" disabled="disabled"><label class="task-list-item-label" for="task-item-8"> AOP的使用缺陷</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-9" disabled="disabled"><label class="task-list-item-label" for="task-item-9"> 基于Agent的实现方式</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-10" disabled="disabled"><label class="task-list-item-label" for="task-item-10"> 耗时输出重定向(标准输出，slf4j输出，日志上报三方平台)</label></li>
</ul>
<h3> 使用姿势</h3>
<p>引入依赖，基于jitpack的如下</p>
<blockquote>
<p>版本根据实际需要进行选择，当前最新版本 0.0.1</p>
</blockquote>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基础核心使用，可应用非Spring应用场景</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于SpringBoot的应用场景下，可以引入下面的依赖，支持基于AOP的埋点方式</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2024-08-14T14:17:36.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1. Centos 安装ElasticSearch</title>
    <id>https://liuyueyi.github.io/tutorial/db/es/200605-Centos-%E5%AE%89%E8%A3%85ElasticSearch.html</id>
    <link href="https://liuyueyi.github.io/tutorial/db/es/200605-Centos-%E5%AE%89%E8%A3%85ElasticSearch.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>本文记录<code>Centos 7.5</code> 安装 <code>ElasticSearch 6.8.5</code> 版本的全过程</p>
]]></summary>
    <content type="html"><![CDATA[<p>本文记录<code>Centos 7.5</code> 安装 <code>ElasticSearch 6.8.5</code> 版本的全过程</p>
<!-- more -->
<h3> 1. ES安装流程</h3>
<blockquote>
<p>es的运行依赖jdk，所以需要先安装好java环境，我们这里用的jdk1.8，这里不额外说明jdk环境的安装流程</p>
</blockquote>
<h4> a. 下载</h4>
<p>首先到目标网站，查询需要下载的版本 : <a href="https://www.elastic.co/cn/downloads/past-releases#elasticsearch" target="_blank" rel="noopener noreferrer">https://www.elastic.co/cn/downloads/past-releases#elasticsearch</a></p>
<p>本文选择<code>6.8.5</code>（主要是为了和<code>SpringBoot 2.2.0-RELEASE</code>对上）</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> b. 解压启动</h4>
<p>下载完之后，直接解压，并进入目录，</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>修改配置，指定数据存储和日志路径，支持外部访问</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> c. 启动测试</h4>
<p>直接运行bin目录下的<code>elasticsearch</code>即可启动es，当然也可以以后台方式启动</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本机访问:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="ElasticSearch"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-06-05T17:24:44.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">2. Elastic &amp; Kibana安装与基本使用</title>
    <id>https://liuyueyi.github.io/tutorial/db/es/210329-Elastic-Kibana%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html</id>
    <link href="https://liuyueyi.github.io/tutorial/db/es/210329-Elastic-Kibana%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>本文主要介绍es &amp; kibana的安装和基本使用，更多es的相关用法后面逐一补上</p>
]]></summary>
    <content type="html"><![CDATA[<p>本文主要介绍es &amp; kibana的安装和基本使用，更多es的相关用法后面逐一补上</p>
<!-- more -->
<h3> 1. elasticsearch安装</h3>
<p>linux环境下，直接下载安装包</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>jvm参数配置</p>
<p>默认es启动，占用的内存太大了，本机测试有必要限制一下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>启动完毕之后，会看到控制台有一些输出，日志不打印时，可以输入下面的查询，验证是否ok</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. kibana安装</h3>
<p>同样linux环境下，直接下载tar包解压使用</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>访问</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 3. Dev Tools 实现es基本操作</h3>
<p>借助kibana来做一些es的基本操作，如添加文档，查询等</p>
<p>打开url: <a href="http://localhost:5601/app/dev_tools#/console" target="_blank" rel="noopener noreferrer">http://localhost:5601/app/dev_tools#/console</a></p>
<p><strong>添加文档</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210329/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>查询所有</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210329/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>精确查询</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210329/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>删除索引</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210329/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="ElasticSearch"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-03-29T18:49:05.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">3. 基本使用姿势</title>
    <id>https://liuyueyi.github.io/tutorial/db/es/210331-ElasticSearch-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/db/es/210331-ElasticSearch-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>ElasticSearch 基本使用姿势，如常见的</p>
<ul>
<li>添加文档</li>
<li>常见的查询姿势</li>
<li>修改/删除文档</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<p>ElasticSearch 基本使用姿势，如常见的</p>
<ul>
<li>添加文档</li>
<li>常见的查询姿势</li>
<li>修改/删除文档</li>
</ul>
<!-- more -->
<h3> 1. 添加文档</h3>
<p>首次添加文档时，若索引不存在会自动创建； 借助kibana的<code>dev-tools</code>来实现es的交互</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然也可以直接使用http进行交互，下面的方式和上面等价（后面都使用kibanan进行交互，更直观一点）</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 查询文档</h3>
<h4> 2.0 kibana配置并查询</h4>
<p>除了基础的查询语法之外，直接使用kibana进行查询，对于使用方而言，门槛最低；首先配置上面的es索引</p>
<ul>
<li>Management -&gt; Stack Management -&gt; Kiabana Index Patterns</li>
<li>index pattern name</li>
<li>时间字段，选择 <code>@timestamp</code> 这个与实际的文档中的field有关</li>
</ul>
<figure><img src="/hexblog/imgs/210331/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/hexblog/imgs/210331/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/hexblog/imgs/210331/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/hexblog/imgs/210331/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来进入<code>Discover</code> 进行查询</p>
<figure><img src="/hexblog/imgs/210331/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>比如字段查询</p>
<figure><img src="/hexblog/imgs/210331/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 2.1 查询所有</h4>
<p>不加任何匹配，捞出文档(当数据量很多时，当然也不会真的全部返回，也是会做分页的)</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 2.2 term精确匹配</h4>
<p>根据field进行value匹配，忽略大小写;</p>
<p>查询语法，形如:   <code>{"query": {"term": {"成员名": {"value": "查询值"}}}}</code></p>
<ul>
<li><code>query</code>, <code>term</code>, <code>value</code> 三个key为固定值</li>
<li><code>成员名</code>: 为待查询的成员</li>
<li><code>查询值</code>: 需要匹配的值</li>
</ul>
<p>(说明：后面语法中，中文的都是需要替换的，英文的为固定值)</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>当value不匹配，或者查询的field不存在，则查不到的对应的信息，如</p>
<figure><img src="/hexblog/imgs/210331/09.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 2.3 terms 多值匹配</h4>
<p>term表示value的精确匹配，如果我希望类似<code>value in (xxx)</code>的查询，则可以使用terms</p>
<p>语法:</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实例如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/10.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 2.4 range 范围匹配</h4>
<p>适用于数值、日期的比较查询，如常见的 &gt;, &gt;=, &lt;, &lt;=</p>
<p>查询语法</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>范围操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>gt</code></td>
<td>大于 &gt;</td>
</tr>
<tr>
<td><code>gte</code></td>
<td>大于等于 &gt;=</td>
</tr>
<tr>
<td><code>lt</code></td>
<td>小于 &lt;</td>
</tr>
<tr>
<td><code>lte</code></td>
<td>小于等于 &lt;=</td>
</tr>
</tbody>
</table>
<p>实例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/11.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 2.5 字段过滤</h4>
<p>根据是否包含某个字段来查询， 主要有两个 <code>exists</code> 表示要求存在， <code>missing</code>表示要求不存在</p>
<p>查询语法</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/12.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 2.6 组合查询</h4>
<p>上面都是单个查询条件，单我们需要多个查询条件组合使用时，可以使用<code>bool + must/must_not/should</code>来实现</p>
<p>查询语法</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面截图以 must_not 输出示意</p>
<figure><img src="/hexblog/imgs/210331/13.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>说明</strong></p>
<ul>
<li>前面根据字段查询 <code>existing</code> 只能单个匹配，可以借助这里的组合来实现多个的判断</li>
</ul>
<h4> 2.7 match查询</h4>
<p>最大的特点是它更适用于模糊查询，比如查询某个field中的字段匹配</p>
<p>语法</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举例说明</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/14.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>说明，如果有精确查询的需求，使用前面的term，可以缓存结果</strong></p>
<h4> 2.8 multi_match查询</h4>
<blockquote>
<p>更多相关信息，可以查看: <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/multi-match-query.html" target="_blank" rel="noopener noreferrer">官网-multi_match查询</a></p>
</blockquote>
<p>多个字段中进行查询</p>
<p>语法</p>
<ul>
<li>type: <code>best_fields</code> 、 <code>most_fields</code> 和 <code>cross_fields</code> （最佳字段、多数字段、跨字段）</li>
<li><strong>最佳字段</strong> ：当搜索词语具体概念的时候，比如 “brown fox” ，词组比各自独立的单词更有意义</li>
<li><strong>多数字段</strong>：为了对相关度进行微调，常用的一个技术就是将相同的数据索引到不同的字段，它们各自具有独立的分析链。</li>
<li><strong>混合字段</strong>：对于某些实体，我们需要在多个字段中确定其信息，单个字段都只能作为整体的一部分</li>
</ul>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实例演示</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/15.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面除了写上精确的字段之外，还支持模糊匹配，比如所有字段中进行匹配</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.9 wildcard查询</h4>
<p>shell统配符</p>
<ul>
<li><code>?</code>: 0/1个字符</li>
<li><code>*</code>: 0/n个字符</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明，对中文可能有问题</strong></p>
<h4> 2.10 regexp查询</h4>
<p>正则匹配</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.11 prefix查询</h4>
<p>前缀匹配</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.12 排序</h4>
<p>查询结果排序，根据sort来指定</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.13 更多</h4>
<p>更多操作姿势，可以在官方文档上获取</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html" target="_blank" rel="noopener noreferrer">官方教程</a></p>
<h3> 3. 删除文档</h3>
<p>需要根据文档id进行指定删除</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/16.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>删除成功</p>
<figure><img src="/hexblog/imgs/210331/17.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4.更新文档</h3>
<h4> 4.1 覆盖更新</h4>
<p>使用PUT来实现更新，同样通过id进行</p>
<ul>
<li>覆盖更新</li>
<li>version版本会+1</li>
<li>如果id对应的文档不存在，则新增</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/18.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 4.2 增量更新</h4>
<p>采用POST来实现增量更新</p>
<ul>
<li>field 存在，则更新</li>
<li>field不存在，则新增</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/19.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>此外还可以采用script脚本更新</p>
<ul>
<li>在原来的age基础上 + 5</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="ElasticSearch"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-03-31T17:39:55.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">6. 全文搜索支持配置</title>
    <id>https://liuyueyi.github.io/tutorial/db/es/211018-ElasticSearch%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E6%94%AF%E6%8C%81%E9%85%8D%E7%BD%AE.html</id>
    <link href="https://liuyueyi.github.io/tutorial/db/es/211018-ElasticSearch%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E6%94%AF%E6%8C%81%E9%85%8D%E7%BD%AE.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>在es的使用过程中，全文搜索属于一个常见的场景，特别是当我们将es作为日志存储检索来使用时，根据关键字查询对应的日志信息，可以怎么处理呢?</p>
]]></summary>
    <content type="html"><![CDATA[<p>在es的使用过程中，全文搜索属于一个常见的场景，特别是当我们将es作为日志存储检索来使用时，根据关键字查询对应的日志信息，可以怎么处理呢?</p>
<!-- more -->
<h3> 1. 动态模板结合copy_to方式</h3>
<p>在创建索引的时候，我们新增一个allColumnValue的字段，将所有其他的column值都拷贝过去，然后针对这个字段进行检索，即可以实现全文的搜索方式了</p>
<p>这里借助<code>dynamic_templtes</code>来实现上面的自动拷贝逻辑，因此我们可以如下创建一个索引</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建上面的映射表时，两个点</p>
<ul>
<li>allColumnValue：字段</li>
<li>dynamic_templates: 实现字段拷贝</li>
</ul>
<p>接下来写入一个数据进行测试</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后检索一下是否可以查询到希望的结果</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个查询之后，正常会命中我们的数据，并返回</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<p>使用上面这种配置时，对于Field有要求，当我们制定一个Map类型时，会失败</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的<code>ddd</code>会提示异常</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 部分字段组合搜索</h3>
<p>上面介绍的是全量的数据凭借到allColumnValue，从而实现全文检索；可能在实际的场景中，我只是希望对部分的field进行联合检索，基于此可以如下设置</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>新增两个数据</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们检索<code>一灰</code>时，可以查到第二条数据</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 小结</h3>
<p>本文主要介绍借助copy_to，来实现es的联合/全文搜索的功能；通过简单的设置，来支撑更友好的查询场景</p>
<h2> II. 其他</h2>
<h3> 1. <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">一灰灰Blog</a>： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">https://liuyueyi.github.io/hexblog</a></h3>
<p>一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3> 2. 声明</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
</ul>
<h3> 3. 扫描关注</h3>
<p><strong>一灰灰blog</strong></p>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="ElasticSearch"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-10-18T18:47:39.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">8. 分组查询抛异常解决方案</title>
    <id>https://liuyueyi.github.io/tutorial/db/es/211123-ElasticSearch%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2%E6%8A%9B%E5%BC%82%E5%B8%B8%EF%BC%9F.html</id>
    <link href="https://liuyueyi.github.io/tutorial/db/es/211123-ElasticSearch%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2%E6%8A%9B%E5%BC%82%E5%B8%B8%EF%BC%9F.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>在使用es进行组合查询的时候，遇到一个非常有意思的场景，特此记录一下</p>
<p>某些场景下，直接针对某个Field进行分组查询，居然无法返回结果，会给出类似<code>Text fields are not optimised for operations that require per-document field data like aggregations and sorting, so these operations are disabled by default</code>的提示信息，接下来看一下这个问题是个什么情况，以及如何解决</p>
]]></summary>
    <content type="html"><![CDATA[<p>在使用es进行组合查询的时候，遇到一个非常有意思的场景，特此记录一下</p>
<p>某些场景下，直接针对某个Field进行分组查询，居然无法返回结果，会给出类似<code>Text fields are not optimised for operations that require per-document field data like aggregations and sorting, so these operations are disabled by default</code>的提示信息，接下来看一下这个问题是个什么情况，以及如何解决</p>
<!-- more -->
<h3> 1. 数据准备</h3>
<p>初始化一个索引，写入一些测试数据</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 分组查询基本知识点</h3>
<p>相当于sql中的<code>group by</code>，常用于聚合操作中的统计计数的场景</p>
<p>在es中，使用<code>aggs</code>来实现，语法如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如我们希望根据url统计访问计数，对应的查询可以是</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接执行上面的分组查询，结果问题来了</p>
<figure><img src="/hexblog/imgs/211123/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>右边返回的提示信息为<code>Text fields are not optimised for operations that require per-document field data like aggregations and sorting, so these operations are disabled by default. Please use a keyword field instead. Alternatively, set fielddata=true on [url] in order to load field data by uninverting the inverted index. Note that this can use significant memory</code>这个异常</p>
<h3> 3. 解决方案</h3>
<p>简单来说，上面这个问题，就是因为url这个字段为text类型，默认情况下这种类型的不走索引，不支持聚合排序，如果需要则需要设置<code>fielddata=true</code>，或者使用url的分词<code>url.keyword</code></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/211123/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>注意</strong></p>
<ul>
<li>
<p>虽然我们更注重的是分组后的结果，但是<code>hits</code>中依然会返回命中的文档，若是只想要分组后的统计结果，可以在查询条件中添加 <code>size:0</code></p>
</li>
<li>
<p>聚合操作和查询条件是可以组合的，如只查询某个url对应的计数</p>
</li>
</ul>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/211123/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面介绍了TEXT类型的field，根据分词进行聚合操作；还有一种方式就是设置<code>fielddata=true</code>，操作姿势如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改完毕之后，再根据url进行分组查询，就不会抛异常了</p>
<figure><img src="/hexblog/imgs/211123/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 小结</h3>
<p>最后小结一下，当我们使用es的某个field进行分组操作时，此时需要注意</p>
<p>当这个field类型为text，默认的场景下是不支持分组操作的，如果非要用它进行分组查询，有两个办法</p>
<ul>
<li>使用它的索引字段，如 <code>url.keyword</code></li>
<li>在索引的filed上添加<code>fileddata: true</code> 配置</li>
</ul>
<h2> 一灰灰的联系方式</h2>
<p>尽信书则不如无书，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>个人站点：<a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
<li>微信公众号：<strong>一灰灰blog</strong></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="ElasticSearch"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-11-23T18:11:36.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">5. Grafana使用语法之ES/Luence篇</title>
    <id>https://liuyueyi.github.io/tutorial/db/es/220302-Grafana%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95%E4%B9%8BES-Luence%E7%AF%87.html</id>
    <link href="https://liuyueyi.github.io/tutorial/db/es/220302-Grafana%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95%E4%B9%8BES-Luence%E7%AF%87.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>Grafnan结合ElasticSearch，实现数据统计，大盘配置</p>
]]></summary>
    <content type="html"><![CDATA[<p>Grafnan结合ElasticSearch，实现数据统计，大盘配置</p>
<!-- more -->
<h3> 1. 查询成员字段</h3>
<p>语法：<code>{"find": "fields", "type": "keyword"}</code></p>
<ul>
<li>find： 表示查什么东西</li>
<li>type：表示检索条件</li>
</ul>
<p>如查询<code>long</code>类型的字段，可以如下处理</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>什么时候用这个呢？</p>
<ul>
<li>比如我想知道这个es中定义了哪些字段</li>
<li>比如在配置Grafana的变量时，可以使用它来做一些限定</li>
</ul>
<h3> 2. 查询成员值</h3>
<p>语法： <code>{"find": "terms", "field": "成员名", "size": 100}</code></p>
<ul>
<li>find：后面跟上的是 terms， 表示查询具体的值</li>
<li>field: 用于限定需要查的成员</li>
<li>size：数量限制，可以不填</li>
</ul>
<p>举例如下，查询所有的服务器ip</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用范围：</p>
<ul>
<li>常见于配置Grafana变量，配置一个服务器ip选择的变量，用于查看不同服务器的表现情况</li>
</ul>
<h3> 3. 条件查询成员值</h3>
<p>在前面的基础上加一下限定，比如一个es为多个应用使用，此时我只关注其中app1的大盘，此时配置服务器时，想加一个条件限定</p>
<p>语法: <code>{"find": "terms", "field": "成员名", "query": "k:v"}</code></p>
<ul>
<li>query： lucence查询语法，要求成员k的值为v</li>
</ul>
<p>举例，查询server_name = app的服务器ip</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. Lucene 查询语法</h3>
<p>配置大盘的查询条件，主要就是借助lucene语法来处理，接下来看一下常见的使用姿势</p>
<h4> 4.1  条件等于查询</h4>
<p>语法： <code>field_name: filed_value</code></p>
<ul>
<li>filed_name: 字段名</li>
<li>field_value: 需要检索的值</li>
</ul>
<p><strong>注意：</strong> 中间使用英文冒号分隔，表示条件命中</p>
<h4> 4.2 不等于查询</h4>
<p>如果希望不等于查询，主要使用下面这种方式</p>
<ul>
<li><code>!(field_name:field_value)</code></li>
</ul>
<h4> 4.3 字段本身存在与否</h4>
<ul>
<li><code>_exists_:field_name</code>:  查询包含field成员的记录</li>
<li><code>_missing_:field_name</code>:  查询不包含field成员的记录</li>
</ul>
<h4> 4.4 通配符查询</h4>
<p>在查询条件中，包含下面两个的表示使用通配查询</p>
<ul>
<li><code>?</code>匹配打个字符</li>
<li><code>*</code> 匹配0或多个字符</li>
</ul>
<p>比如我有个应用，部署多个环境，分别名为 app-cn, app-usa，现在想统计整个应用的情况，就可以使用下面这种正则方式</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>除了上面的示例，在实际的工作中，更常见的是url的统计，比如统计 <code>/get/</code> 这个域名开头的请求</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.5 模糊搜索</h4>
<p>在单次后面添加剂上 <code>~</code>来实现模糊搜索，这种更适用于搜索业务场景，通常对于grafana的大盘配置，个人感觉不太实用</p>
<p>实用方式</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.6 范围搜索</h4>
<p>除了前面的精确搜索，我们还可以进行范围搜索</p>
<p>语法： <code>[ a TO b ]</code>,  <code>{a TO B}</code></p>
<ul>
<li><code>[]</code>： 闭包区间，包含左边的值</li>
<li><code>{}</code>： 开区间，不包含两边值</li>
<li><code>a/b</code> 如果为 <code>*</code> 表示某一侧不限制范围</li>
</ul>
<p>实例演示，查询http状态码为 4xx 的case</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>除了上面这种写法，也可以使用 <code>&gt; &lt; </code>的方式，比如上面的写法等价</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.7 逻辑操作</h4>
<p>多条件组合，使用AND/OR来处理，这里的组合即可以表明多个field，也可以是一个field的多个value组合</p>
<p>如多字段匹配：找出app-cn应用中状态码为500的记录</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如多value匹配：找出状态码为500, 503的记录</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 4.8 转移字符</h4>
<p>当查询条件中，包含下面字符中的一个时，需要使用注意</p>
<ul>
<li>特殊字符: <code>+ - = &amp;&amp; || &gt; &lt; ! ( ) { } [ ] ^ " ~ * ? : \ /</code></li>
<li>转义修饰: <code>\/</code></li>
</ul>
<p>如url的查询时，通常会用到转义</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 5. 小结</h3>
<p>本文主要介绍Grafana中使用es数据源时，常见的语法操作，当然其中Lucence的部分，在kibana中也同样适用；</p>
<p>通常来讲，在Grafana中，有下面几个地方会使用到上面的知识点</p>
<p>变量配置时，使用第1，2，3节中的方式，过滤出下拉选项</p>
<figure><img src="/hexblog/imgs/220302/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在大盘配置的Query输入框中，使用 Lucene 语法</p>
<figure><img src="/hexblog/imgs/220302/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在Explore中使用Lucene语法</p>
<figure><img src="/hexblog/imgs/220302/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>参考博文：</p>
<ul>
<li><a href="https://www.cnblogs.com/xing901022/p/4974977.html" target="_blank" rel="noopener noreferrer">Lucene查询语法详解</a></li>
</ul>
<h2> 一灰灰的联系方式</h2>
<p>尽信书则不如无书，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>个人站点：<a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
<li>微信公众号：<strong>一灰灰blog</strong></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="运维"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2022-03-02T14:48:19.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">7. 开启权限验证</title>
    <id>https://liuyueyi.github.io/tutorial/db/es/220321-ElasticSearch%E5%BC%80%E5%90%AF%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81.html</id>
    <link href="https://liuyueyi.github.io/tutorial/db/es/220321-ElasticSearch%E5%BC%80%E5%90%AF%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>为了保证es的安全性，一般来讲我们会对es集群开启权限验证，下面将简单记录一下如何开启Basic Auth验证</p>
]]></summary>
    <content type="html"><![CDATA[<p>为了保证es的安全性，一般来讲我们会对es集群开启权限验证，下面将简单记录一下如何开启Basic Auth验证</p>
<!-- more -->
<p>修改配置文件 <code>config/elasticsearch.yml</code>，添加下面的配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>启动es服务</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>生成密码</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>es的交互，主要使用 <code>Basic Auth</code> 方式进行身份校验，简单来讲，就是在请求头中，添加</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 一灰灰的联系方式</h2>
<p>尽信书则不如无书，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>个人站点：<a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
<li>微信公众号：<strong>一灰灰blog</strong></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="ElasticSearch"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2022-03-21T20:04:31.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">4. 基本使用姿势二</title>
    <id>https://liuyueyi.github.io/tutorial/db/es/220412-ElasticSearch%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%BA%8C.html</id>
    <link href="https://liuyueyi.github.io/tutorial/db/es/220412-ElasticSearch%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%BA%8C.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>本文作为elasticsearch 基本使用姿势第二篇，包含以下内容</p>
<ul>
<li>查询指定字段</li>
<li>限制返回条数</li>
<li>分页查询</li>
<li>分组查询</li>
<li>高亮</li>
<li>自动补全提示</li>
<li>排序</li>
<li>返回结果聚合，如统计文档数，某个field value的求和、平均值等</li>
</ul>
<blockquote>
<p>更多相关知识点请查看: * <a href="https://blog.hhui.top/hexblog/2021/03/31/210331-ElasticSearch-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">210331-ElasticSearch 基本使用姿势 - 一灰灰Blog</a></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<p>本文作为elasticsearch 基本使用姿势第二篇，包含以下内容</p>
<ul>
<li>查询指定字段</li>
<li>限制返回条数</li>
<li>分页查询</li>
<li>分组查询</li>
<li>高亮</li>
<li>自动补全提示</li>
<li>排序</li>
<li>返回结果聚合，如统计文档数，某个field value的求和、平均值等</li>
</ul>
<blockquote>
<p>更多相关知识点请查看: * <a href="https://blog.hhui.top/hexblog/2021/03/31/210331-ElasticSearch-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/" target="_blank" rel="noopener noreferrer">210331-ElasticSearch 基本使用姿势 - 一灰灰Blog</a></p>
</blockquote>
<!-- more -->
<h3> 0. 数据准备</h3>
<p>初始化一个索引，写入一些测试数据</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1. 查询指定字段</h3>
<p>比如我现在只关心url返回的状态码, 主要借助<code>_source</code>来指定需要查询的字段，查询的语法和之前介绍的一致</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/220412/00.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 返回条数限制</h3>
<p>针对返回结果条数进行限制，属于比较常见的case了，在es中，直接通过<code>size</code>来指定</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/220412/01.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 分页查询</h3>
<p>通过size限制返回的文档数，通过from来实现分页</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>(注意下面输出截图，与上面的对比，这里返回的是第二条数据)</p>
<figure><img src="/hexblog/imgs/220412/02.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 分组查询</h3>
<p>相当于sql中的<code>group by</code>，常用于聚合操作中的统计计数的场景</p>
<p>在es中，使用<code>aggs</code>来实现，语法如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如我们希望根据url统计访问计数，对应的查询可以是</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是在执行时，会发现并不能正常响应</p>
<figure><img src="/hexblog/imgs/220412/03.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>右边返回的提示信息为<code>Text fields are not optimised for operations that require per-document field data like aggregations and sorting, so these operations are disabled by default. Please use a keyword field instead. Alternatively, set fielddata=true on [url] in order to load field data by uninverting the inverted index. Note that this can use significant memory</code>这个异常</p>
<p>简单来说，就是url这个字段为text类型，默认情况下这种类型的不走索引，不支持聚合排序，如果需要则需要设置<code>fielddata=true</code>，或者使用url的分词<code>url.keyword</code></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/220412/04.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>注意</strong></p>
<ul>
<li>
<p>虽然我们更注重的是分组后的结果，但是<code>hits</code>中依然会返回命中的文档，若是只想要分组后的统计结果，可以在查询条件中添加 <code>size:0</code></p>
</li>
<li>
<p>聚合操作和查询条件是可以组合的，如只查询某个url对应的计数</p>
</li>
</ul>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/220412/05.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面介绍了TEXT类型的field，根据分词进行聚合操作；还有一种方式就是设置<code>fielddata=true</code>，操作姿势如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改完毕之后，再根据url进行分组查询，就不会抛异常了</p>
<figure><img src="/hexblog/imgs/220412/06.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 全文搜索</h3>
<ul>
<li><a href="https://blog.hhui.top/hexblog/2021/10/18/211018-ElasticSearch%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E6%94%AF%E6%8C%81%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener noreferrer">211018-ElasticSearch全文搜索支持配置 - 一灰灰Blog</a></li>
</ul>
<p>通过配置一个动态索引模板，将所有的field构建一个用于全文检索的field，从而实现全文搜索</p>
<h3> 6. 聚合操作</h3>
<p>上面的分组也算是聚合操作中的一种，接下来仔细看一下es的聚合，可以支持哪些东西</p>
<p><strong>聚合语法:</strong></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从聚合分类来看，可以划分为下面几种</p>
<ul>
<li>Metric Aggregation: 指标分析聚合</li>
<li>Bucket Aggregation: 分桶聚合</li>
<li>Pipeline: 管道分析类型</li>
<li>Matrix: 矩阵分析类型</li>
</ul>
<h4> 5.1 Metric Aggregation: 指标分析聚合</h4>
<p>常见的有 <code>min, max, avg, sum, cardinality,  value count</code></p>
<p>通常是值查询一些需要通过计算获取到的值</p>
<p>下面分别给出一些演示说明</p>
<h5> 5.1.1 min最小值</h5>
<p>获取请求耗时最小的case</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>size: 0  表示不需要返回原数据</li>
<li>min_cost: 自定义的聚合名</li>
<li>min: 表示聚合类型，为取最小值</li>
<li><code>"field": "execute.cost"</code>:  表示取的是<code>Field: execute.cost</code>的最小值</li>
</ul>
<figure><img src="/hexblog/imgs/220412/07.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h5> 5.1.2 max 最大值</h5>
<p>基本同上，下面中贴出请求代码，截图就省略掉了</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 5.1.3 sum 求和</h5>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 5.1.4 avg平均值</h5>
<p>在监控平均耗时的统计中，这个还是比较能体现服务的整体性能的</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 5.1.5 cardinality 去重统计计数</h5>
<p>这个等同于我们常见的 <code>distinct count</code> 注意与后面的 <code>value count</code> 统计所有有值的文档数量之间的区别</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>去重统计url的计数，如下图，可以看到返回统计结果为3，但是实际的文档数有5个</p>
<figure><img src="/hexblog/imgs/220412/08.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h5> 5.1.6 value count 计数统计</h5>
<p>文档数量统计，区别于上面的去重统计，这里返回的是全量</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果配合cardinality的返回，做一个对比可以加强理解</p>
<figure><img src="/hexblog/imgs/220412/09.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h5> 5.1.7 stats 多值计算</h5>
<p>一个stats 可以返回上面<code>min,max,sum...</code>等的计算值</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/220412/10.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h5> 5.1.8 extended_stats 多值扩展</h5>
<p>在上面stats的基础上进行扩展，支持方差，标准差等返回</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/220412/11.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h5> 5.1.9 percentile 百分位数统计</h5>
<blockquote>
<p>用于统计 xx% 的记录值，小于等于右边</p>
</blockquote>
<p>如下面截图，可知 99%的记录，耗时小于12</p>
<figure><img src="/hexblog/imgs/220412/12.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>默认的百分比区间是: <code>[1, 45, 25, 50, 75, 95, 99]</code>， 可以手动修改</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 5.1.10 percentile rank统计值所在的区间</h5>
<p>上面用于统计不同区间的占比，比如公司的人员年龄分布；而这一个则是我想知道18岁的我，在哪个占比里</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/220412/13.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 5.2 Bucket Aggregation 分桶聚合</h4>
<p>参考博文：</p>
<p><a href="https://blog.csdn.net/qq_41063182/article/details/108944340" target="_blank" rel="noopener noreferrer">ElasticSearch：aggregations 聚合详解</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/107820698" target="_blank" rel="noopener noreferrer">Elasticsearch 聚合分析深入学习</a></p>
<p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html" target="_blank" rel="noopener noreferrer">Elasticsearch: 权威指南-聚合</a></p>
<h2> 一灰灰的联系方式</h2>
<p>尽信书则不如无书，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>个人站点：<a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
<li>微信公众号：<strong>一灰灰blog</strong></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="ElasticSearch"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2022-04-12T21:43:49.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">8. 延时插件安装</title>
    <id>https://liuyueyi.github.io/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%BB%B6%E6%97%B6%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85.html</id>
    <link href="https://liuyueyi.github.io/tutorial/db/rabbitmq/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%BB%B6%E6%97%B6%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>源码: <a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange" target="_blank" rel="noopener noreferrer">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</a></p>
<p>下载二进制的插件，如3.8.0下载地址: <a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/tag/v3.8.0" target="_blank" rel="noopener noreferrer">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/tag/v3.8.0</a></p>
<p>将下载的<code>ez</code>包，放在插件目录下，一般centos的查检目录放在<code>/usr/lib/rabbitmq/lib/rabbitmq_server-xxx/plugins</code></p>
<p>如果不知道具体在什么地方，可以通过进程查看</p>
<figure><img src="/hexblog/imgs/201021/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>拷贝完毕之后，启用插件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>rabbitmq-plugins <span class="token builtin class-name">enable</span> rabbitmq_delayed_message_exchange
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接着重启一下rabbit</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">service</span> rabbit-server restart
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<p>源码: <a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange" target="_blank" rel="noopener noreferrer">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</a></p>
<p>下载二进制的插件，如3.8.0下载地址: <a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/tag/v3.8.0" target="_blank" rel="noopener noreferrer">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/tag/v3.8.0</a></p>
<p>将下载的<code>ez</code>包，放在插件目录下，一般centos的查检目录放在<code>/usr/lib/rabbitmq/lib/rabbitmq_server-xxx/plugins</code></p>
<p>如果不知道具体在什么地方，可以通过进程查看</p>
<figure><img src="/hexblog/imgs/201021/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>拷贝完毕之后，启用插件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接着重启一下rabbit</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><!-- more -->
<p>再控制台中，查看是否安装成功</p>
<figure><img src="/hexblog/imgs/201021/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="RabbitMQ"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-10-16T15:32:27.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1. redis安装</title>
    <id>https://liuyueyi.github.io/tutorial/db/redis/01.redis%E5%AE%89%E8%A3%85.html</id>
    <link href="https://liuyueyi.github.io/tutorial/db/redis/01.redis%E5%AE%89%E8%A3%85.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<h2> I. redis安装</h2>
<p>centos安装并后台启动redis记录过程</p>
]]></summary>
    <content type="html"><![CDATA[<h2> I. redis安装</h2>
<p>centos安装并后台启动redis记录过程</p>
<!-- more -->
<p>安装redis命令，比较简单</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>后台启动redis方式：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看redis启动是否正常</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>客户端连接测试</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Shell"/>
    <category term="环境搭建"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2018-04-24T10:19:51.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">2. Redis集群搭建手册</title>
    <id>https://liuyueyi.github.io/tutorial/db/redis/02.Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%89%8B%E5%86%8C.html</id>
    <link href="https://liuyueyi.github.io/tutorial/db/redis/02.Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%89%8B%E5%86%8C.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>之前在使用redis的case中，更多的只是单机的使用；随着业务的增长，为了更好的性能提供，集群是一个必然的发展趋势；下面记录一下搭建集群的步骤</p>
<blockquote>
<p>单机安装手册，可以查看： <a href="https://blog.hhui.top/hexblog/2018/04/24/redis%E5%AE%89%E8%A3%85/" target="_blank" rel="noopener noreferrer">单机redis安装手册</a></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<p>之前在使用redis的case中，更多的只是单机的使用；随着业务的增长，为了更好的性能提供，集群是一个必然的发展趋势；下面记录一下搭建集群的步骤</p>
<blockquote>
<p>单机安装手册，可以查看： <a href="https://blog.hhui.top/hexblog/2018/04/24/redis%E5%AE%89%E8%A3%85/" target="_blank" rel="noopener noreferrer">单机redis安装手册</a></p>
</blockquote>
<!-- more -->
<h2> I. redis集群搭建过程</h2>
<h3> 1. 获取项目并编译</h3>
<p>首先是从官网获取最新稳定版的redis包，官网友链 -&gt; <a href="https://redis.io/" target="_blank" rel="noopener noreferrer">https://redis.io/</a></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面执行完毕之后，在src目录下，会生成常见的操作命令，如<code>redis-cli</code> <code>redis-server</code></p>
<h3> 2. 开始配置</h3>
<p>在redis目录下，配置文件<code>redis.conf</code>是我们需要关注的目标</p>
<p>我们这里在本机搭建三个节点，对应的端口号分别为7000, 7001, 7002</p>
<p>接下来，进入配置文件，进行修改</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 启动并设置集群</h3>
<p>上面设置完毕之后，开始启动redis</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动完毕之后，可以查看到如下的进程</p>
<figure><img src="/hexblog/imgs/190925/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>到这里，集群还没有设置完成，还需要通过<code>redis-cli</code>设置一下集群关系</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行上面的命名，发现并不能成功，提示如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面表示redis集群必须有三个主节点，当我们设置主从时，最少需要六个节点；当然我们在本机测试的时候，搞六个必要性不大，这里直接不要从节点</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行上面命令并确认之后，redis集群基本上就搭建完毕</p>
<h3> 4. 测试</h3>
<p>借助<code>redis-cli</code>进行集群的连接和测试</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过<code>keys</code>命令查看，我们上面设置的几个值分布在三个实例上了</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Shell"/>
    <category term="环境搭建"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-09-25T20:09:59.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">3. Redis实现分布式锁相关注意事项</title>
    <id>https://liuyueyi.github.io/tutorial/db/redis/03.Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.html</id>
    <link href="https://liuyueyi.github.io/tutorial/db/redis/03.Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<h1> Redis实现分布式锁相关注意事项</h1>
<blockquote>
<p>查看了不少关于redis实现分布式锁的文章，无疑要设计一个靠谱的分布式并不太容易，总会出现各种鬼畜的问题；现在就来小述一下，在设计一个分布式锁的过程中，会遇到一些什么问题</p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<h1> Redis实现分布式锁相关注意事项</h1>
<blockquote>
<p>查看了不少关于redis实现分布式锁的文章，无疑要设计一个靠谱的分布式并不太容易，总会出现各种鬼畜的问题；现在就来小述一下，在设计一个分布式锁的过程中，会遇到一些什么问题</p>
</blockquote>
<!-- more -->
<h2> I. 背景知识</h2>
<p>借助redis来实现分布式锁（我们先考虑单机redis的模式），首先有必要了解下以下几点：</p>
<ul>
<li>单线程模式</li>
<li>setnx  : 当不存在时，设置value，并返回1； 否则返回0</li>
<li>getset : 设置并获取原来的值</li>
<li>expire : 设置失效时间</li>
<li>get    : 获取对应的值</li>
<li>del    : 删除</li>
<li>ttl    : 获取key对应的剩余时间，若key没有设置过超时时间，或者压根没有这个key则返回负数（可能是-1，-2）</li>
<li>watch/unwatch : 事务相关</li>
</ul>
<h2> II. 方案设计</h2>
<h3> 1. 设计思路</h3>
<p><strong>获取锁：</strong></p>
<ul>
<li>调用 setnx 尝试获取锁，如果设置成功，表示获取到了锁</li>
<li>设置失败，此时需要判断锁是否过期
<ul>
<li>未过期，则表示获取失败；循环等待，并再次尝试获取锁</li>
<li>已过期，getset再次设置锁，判断是否获取了锁（根据返回的值进行判断，后面给出具体的方案）</li>
<li>若失败，则重新进入获取锁的逻辑</li>
</ul>
</li>
</ul>
<p><strong>释放锁：</strong></p>
<ul>
<li>一个原则就是确保每个业务方释放的是自己的锁</li>
</ul>
<h3> 2. getset的实现方案</h3>
<p>网上一种常见的case，主要思路如下</p>
<ul>
<li>setnx 尝试获取锁</li>
<li>失败，则 get 获取锁的value （一般是 uuid_timstamp）</li>
<li>判断是否过期，若没有过期，则表示真的获取失败</li>
<li>若过期，则采用 getset设置，尝试获取锁</li>
</ul>
<p>实现代码如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>观察获取锁的逻辑，特别是获取超时锁的逻辑，很容易想到有一个问题 <code>getSet</code> 方法会不会导致写数据混乱的问题，简单来说就是多个线程同时判断锁超时时，执行 <code>getSet</code>设置锁时，最终获取锁的线程，能否保证和redis中的锁的value相同</p>
<p>上面的实现方式，一个混乱的case如下:</p>
<ol start="0">
<li>三个线程a,b,c 都进入到了锁超时的阶段</li>
<li>线程a, 获取原始值 oldVal, 并设置 t1</li>
<li>线程b, 获取线程a设置的 t1, 并重设为 t2</li>
<li>线程c, 获取线程b设置的 t2, 并重设为 t3</li>
<li>线程a，判断，并正式获取到锁</li>
<li>线程b，判断失败，恢复原来锁的内容为t1</li>
<li>线程c, 判断失败，恢复原来锁的内容为t2</li>
<li>问题出现了，获取锁的线程a，期望所得内容为t1, 但是实际为t2; 导致无法释放锁</li>
</ol>
<p>实际验证</p>
<p>在上面的代码中，配合测试case，加上一些日志输出</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>部分输出结果:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点关注 <code>t1 &gt;&gt;&gt;&gt; t2_be06f80a-9b70-4a0e-a86d-44337abe8642_1515643763341</code>，表示t1线程过去了锁，但是锁的内容不是其value，即便t2去恢复，也会被t3给覆盖</p>
<hr>
<p><strong>如何解决上面这个问题呢？</strong></p>
<p>上面是典型的并发导致的问题，当然可以考虑从解决并发问题的角度出发来考虑，一个常见的方式就是加锁了，思路如下：（不详细展开了）</p>
<ul>
<li>在判断超时之后，加锁</li>
<li>再次获取对应的值，判断是否超时，是则执行上面的操作</li>
<li>否则退出逻辑，继续循环</li>
</ul>
<p><strong>这种实现方式，会有以下的问题：</strong></p>
<ul>
<li>getset 这个方法执行，可能导致写入脏数据</li>
<li>基于服务器时钟进行超时判断，要求所有服务器始终一致，否则有坑</li>
</ul>
<h3> 3. expire实现方式</h3>
<p>相比于前面一种直接将value设置为时间戳，然后来比对的方法，这里则直接借助redis本身的expire方式来实现超时设置，主要实现逻辑相差无几</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取锁的逻辑相比之前的，就简单很多了，接下来则需要简单的分析下，上面这种实现方式，会不会有坑呢？我们主要看一下获取锁失败的场景</p>
<ul>
<li>如果获取锁失败</li>
<li>表示有其他的业务方已经获取到了锁</li>
<li>此时，只能等持有锁的业务方主动释放锁</li>
<li>判断锁是否设置了超时时间，若没有则加一个（防止设置超时时间失败导致问题）</li>
</ul>
<p><strong>从上面这个逻辑来看问题不大，但是有个问题，case ：</strong></p>
<ul>
<li>如某个业务方setnx获取到了锁，但是因为网络问题，过了很久才获取到返回，此时锁已经失效并被其他业务方获取到了，就会出现多个业务方同时持有锁的场景</li>
</ul>
<h2> III. 小结说明</h2>
<p>想基于redis实现一个相对靠谱的分布式锁，需要考虑的东西还是比较多的，而且这种锁并不太适用于业务要求特别严格的地方，如</p>
<ul>
<li>一个线程持有锁时，如果发生gc，导致锁超时失效，但是自己又不知道，此时就会出现多个业务方同时持有锁的场景</li>
<li>对于锁超时的场景，需要仔细考虑，是否会出现并发问题</li>
<li>确保只能释放自己的锁（以防止释放了别人的锁，出现问题）</li>
</ul>
<h3> 参考链接</h3>
<ul>
<li><a href="http://blog.csdn.net/paincupid/article/details/75094550" target="_blank" rel="noopener noreferrer">基于Redis的分布式锁到底安全吗?</a></li>
<li><a href="http://blog.csdn.net/yuxxz/article/details/52551357" target="_blank" rel="noopener noreferrer">利用redis实现的分布式锁</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="Redis"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2018-01-14T16:12:29.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">4. Redis性能监控之Redis-Stat</title>
    <id>https://liuyueyi.github.io/tutorial/db/redis/4.Redis%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B9%8BRedis-Stat.html</id>
    <link href="https://liuyueyi.github.io/tutorial/db/redis/4.Redis%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B9%8BRedis-Stat.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<h2> redis性能监控工具</h2>
<p>使用 redis-stat 进行redis的性能监控数据收集</p>
]]></summary>
    <content type="html"><![CDATA[<h2> redis性能监控工具</h2>
<p>使用 redis-stat 进行redis的性能监控数据收集</p>
<!-- more -->
<h3> 1. 安装</h3>
<p>这个工程主要是ruby进行开发的，所以需要准备对应的环境</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译安装</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 使用</h3>
<p><strong>控制台使用</strong></p>
<p>每1s采集一次，总共显示10条</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>web使用</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>实际截图如下</p>
<figure><img src="https://github.com/junegunn/redis-stat/raw/master/screenshots/redis-stat-0.3.0.png" alt="show" tabindex="0" loading="lazy"><figcaption>show</figcaption></figure>
<h3> 3. 源码</h3>
<ul>
<li><a href="https://github.com/junegunn/redis-stat" target="_blank" rel="noopener noreferrer">https://github.com/junegunn/redis-stat</a></li>
</ul>
<h2> II. 其他</h2>
<h3> 1. <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">一灰灰Blog</a>： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">https://liuyueyi.github.io/hexblog</a></h3>
<p>一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3> 2. 声明</h3>
<p>尽信书则不如，已上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
</ul>
<h3> 3. 扫描关注</h3>
<p><strong>一灰灰blog</strong></p>
<figure><img src="https://raw.githubusercontent.com/liuyueyi/Source/master/img/info/blogInfoV2.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
<p><strong>知识星球</strong></p>
<figure><img src="https://raw.githubusercontent.com/liuyueyi/Source/master/img/info/goals.png" alt="goals" tabindex="0" loading="lazy"><figcaption>goals</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="Redis"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2018-11-19T20:44:06.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">5. Redis配置参数在线修改（热修改）</title>
    <id>https://liuyueyi.github.io/tutorial/db/redis/5.Redis%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E5%9C%A8%E7%BA%BF%E4%BF%AE%E6%94%B9%EF%BC%88%E7%83%AD%E4%BF%AE%E6%94%B9%EF%BC%89.html</id>
    <link href="https://liuyueyi.github.io/tutorial/db/redis/5.Redis%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E5%9C%A8%E7%BA%BF%E4%BF%AE%E6%94%B9%EF%BC%88%E7%83%AD%E4%BF%AE%E6%94%B9%EF%BC%89.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>redis的配置除了直接修改配置文件之后，重启进程之外，还支持在线修改，下面记录一下使用姿势</p>
]]></summary>
    <content type="html"><![CDATA[<p>redis的配置除了直接修改配置文件之后，重启进程之外，还支持在线修改，下面记录一下使用姿势</p>
<!-- more -->
<p>我们主要通过config命令来查询和修改配置，如获取所有配置</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下面以一个具体的实例来进行说明，我们知道redis的默认保存策略是RDB方式，通过save参数配置保存规则</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>默认输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>第一行返回的是配置名</p>
<p>第二行返回的是配置信息，对应配置文件中的</p>
<div class="language-conf line-numbers-mode" data-ext="conf"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以修改一下，将60s的策略扔掉，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="Redis"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-01-15T15:28:06.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1. 简繁转换原理分析</title>
    <id>https://liuyueyi.github.io/tutorial/git/quick-chinese-transfer/01.%E7%AE%80%E7%B9%81%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html</id>
    <link href="https://liuyueyi.github.io/tutorial/git/quick-chinese-transfer/01.%E7%AE%80%E7%B9%81%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Quick系列"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2022-08-11T07:26:49.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1. Maven打包可项目执行的Jar</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/01.Maven%E6%89%93%E5%8C%85%E5%8F%AF%E9%A1%B9%E7%9B%AE%E6%89%A7%E8%A1%8C%E7%9A%84Jar.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/01.Maven%E6%89%93%E5%8C%85%E5%8F%AF%E9%A1%B9%E7%9B%AE%E6%89%A7%E8%A1%8C%E7%9A%84Jar.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>当我们希望项目打包为一个可执行的jar文件，丢到服务器上运行时，可以怎么做？借助maven。可以比较简单的实现这个</p>
<h2> I. 使用小结</h2>
<p>在pmo依赖文件中，添加下面的依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>maven-assembly-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appendAssemblyId</span><span class="token punctuation">&gt;</span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appendAssemblyId</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>descriptorRefs</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>descriptorRef</span><span class="token punctuation">&gt;</span></span>jar-with-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>descriptorRef</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>descriptorRefs</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>archive</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifest</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mainClass</span><span class="token punctuation">&gt;</span></span>com.git.hui.task.AppLaunch<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mainClass</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifest</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>archive</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>make-assembly<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">&gt;</span></span>package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">&gt;</span></span>assembly<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<p>当我们希望项目打包为一个可执行的jar文件，丢到服务器上运行时，可以怎么做？借助maven。可以比较简单的实现这个</p>
<h2> I. 使用小结</h2>
<p>在pmo依赖文件中，添加下面的依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的mainClass标签中，指定的是main方法执行入口，上面这种打包方式，会将所有依赖的第三方包，也一同打包到最终生成的jar文件中</p>
<p>即，这个jar文件，包含了所有的依赖和业务代码，可以直接运行，执行方式</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>源码验证case：</p>
<ul>
<li><a href="https://github.com/liuyueyi/quick-task" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/quick-task</a></li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Shell"/>
    <category term="Maven"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2018-07-17T21:15:07.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">2. jar包执行传参使用小结</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/02.jar%E5%8C%85%E6%89%A7%E8%A1%8C%E4%BC%A0%E5%8F%82%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/02.jar%E5%8C%85%E6%89%A7%E8%A1%8C%E4%BC%A0%E5%8F%82%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>虽说我们现在大多不太直接使用jar包运行方式，目前比较主流的是将自己的服务丢在某个容器中（如tomcat，jetty等）运行，比如我之前所属的电商公司，就是将项目打包为war包，丢到tomcat容器中运行的</p>
<p>在使用SpringBoot时，可能会出现直接打包一个可执行的jar，然后运行，这种时候，通过java命令执行时，时可以传参的，那么问题来了，main方法可以如何优雅的解析这些传参呢？</p>
]]></summary>
    <content type="html"><![CDATA[<p>虽说我们现在大多不太直接使用jar包运行方式，目前比较主流的是将自己的服务丢在某个容器中（如tomcat，jetty等）运行，比如我之前所属的电商公司，就是将项目打包为war包，丢到tomcat容器中运行的</p>
<p>在使用SpringBoot时，可能会出现直接打包一个可执行的jar，然后运行，这种时候，通过java命令执行时，时可以传参的，那么问题来了，main方法可以如何优雅的解析这些传参呢？</p>
<!-- more -->
<h2> I. 简陋版本</h2>
<p>最容易想到的，无非是自己直接解析main方法的传参，如我们知道的main方法的一般写法为</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>看到上面的写法，很容易就可以猜到，传入的参数最终都放到了args数组中，那么该怎么用就怎么用，一个<code>hello world</code>的实例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试如下：</p>
<figure><img src="https://upload-images.jianshu.io/upload_images/1405936-2d4f2e39d0bbaaf9.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure>
<p>看到这里，真心感觉没有什么干货，上面这些过于小白了吧，估计连入门都算不上，那么参数处理仅止于此么？</p>
<h2> II. 进阶版本</h2>
<p>玩过shell的同学应该都知道man命令，可以用来查看很多shell命令的帮助，里面介绍了很多的shell命令的参数说明，而且这些参数一般有缩写和全拼，而且有些参数可以带传值，有些并不需要，可以说shell命令的传参方式，已经拥有自己独立的一套规范了，而且用起来非常的爽</p>
<p>那么我们的jar包，能否支持这种传参方式呢？</p>
<p>举一个简单的例子，上面的HelloWord接收一个简单用户名参数</p>
<ul>
<li>不传入时，默认输出 hello world</li>
<li>短参方式: <code>-n xxx</code></li>
<li>长参方式: <code>--name=xxx</code></li>
</ul>
<p>仅仅支持这一个场景，需要自己来解析的话，就得写一长串的代码，好在这种需求已经有轮子了</p>
<h3> 1. commons-cli</h3>
<p>首先引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>开始使用，官网已经给出了例子，完整的doc可以参考</p>
<ul>
<li><a href="http://commons.apache.org/proper/commons-cli/usage.html" target="_blank" rel="noopener noreferrer">commons-cli Usage Scenarios</a></li>
</ul>
<h3> 2. 实例演示</h3>
<p>下面结合我的一个项目，给出实际的使用方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对上面的使用姿势进行简单的说明，从逻辑上划分，可以分为下面几块</p>
<ul>
<li>定义传参，包括参数说明，缩写和全拼，是否有参数值，描述等</li>
<li>解析传参数组，将具体的传参解析为<code>CommandLine</code>对象</li>
<li>获取参数，执行相应的业务逻辑</li>
</ul>
<p>从源码角度来看，没什么复杂或者难以理解的地方，稍稍提一点，参数的定义，即<code>buildOption</code>方法中，上面指定了两个参数 <code>help, task</code>, 其中一个要求有参数值，一个不需要参数值，下面实际演示如下</p>
<figure><img src="https://upload-images.jianshu.io/upload_images/1405936-f2e49d96af80d91b.png" alt="show" tabindex="0" loading="lazy"><figcaption>show</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="其他"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2018-07-18T21:23:49.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">3. Jar文件提取与查看</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/03.Jar%E6%96%87%E4%BB%B6%E6%8F%90%E5%8F%96%E4%B8%8E%E6%9F%A5%E7%9C%8B.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/03.Jar%E6%96%87%E4%BB%B6%E6%8F%90%E5%8F%96%E4%B8%8E%E6%9F%A5%E7%9C%8B.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>最近遇到一个奇怪的问题，一个jar包无法解压，直接使用<code>jar xvf xxx.jar</code>没有任何响应</p>
<p>因为实际想看的只是jar包中的某个class文件，基于此可以通过 <code>jar tf</code> 查看文件列表，在通过 <code>jar xf xxx.jar xxxfile</code>的方式来解压指定文件来实现目的</p>
<p>接下来记录一下jar包的几个操作case</p>
]]></summary>
    <content type="html"><![CDATA[<p>最近遇到一个奇怪的问题，一个jar包无法解压，直接使用<code>jar xvf xxx.jar</code>没有任何响应</p>
<p>因为实际想看的只是jar包中的某个class文件，基于此可以通过 <code>jar tf</code> 查看文件列表，在通过 <code>jar xf xxx.jar xxxfile</code>的方式来解压指定文件来实现目的</p>
<p>接下来记录一下jar包的几个操作case</p>
<!-- more -->
<h3> 1. jar包生成</h3>
<p>直接通过jar命令可以非常简单的将class文件打包到一个jar中</p>
<p>一个简单的java类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打包jar命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>直接使用上面这种打包，会有一个问题，当jar包中，有多个class文件存在main方法时，会提示没有主清单属性</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>主要原因就是在清单文件<code>MANIFEST.MF</code>中，没有指定主类</p>
<p>指定主类</p>
<div class="language-MF line-numbers-mode" data-ext="MF"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打包命令如下（下面新增了一个Wel.java，源码就不说了）</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. jar文件列表查看</h3>
<p>查看jar中有哪些文件，除了直接使用vim之外，还可考虑通过下面的命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用tf进行查看，就可以结合 grep 来过滤指定的文件</p>
<h3> 3. 指定文件提取</h3>
<p>对于jar文件整个解压，可以直接使用</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当我们只希望提取jar包中的某个文件时，可以在后面添加需要提取的文件路径</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 一灰灰的联系方式</h2>
<p>尽信书则不如无书，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>个人站点：<a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
<li>微信公众号：<strong>一灰灰blog</strong></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-12-28T19:00:56.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">4. 调用本地程序的几种姿势</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/04.Java%E8%B0%83%E7%94%A8%E6%9C%AC%E5%9C%B0%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/04.Java%E8%B0%83%E7%94%A8%E6%9C%AC%E5%9C%B0%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>作为一个后端同学，经常被安全的小伙伴盯上，找一找安全漏洞；除了常说的注入之外，还有比较吓人的执行远程命令，唤醒本地应用程序等；然后有意思的问题就来了，写了这么多年的代码，好像还真没有尝试过用java来唤醒本地应用程序的</p>
<p>比如说一个最简单的，打开本地的计算器，应该怎么搞？</p>
<p>接下来本文将介绍一下如何使用java打开本地应用，以及打开mac系统中特殊一点的处理方式（直白来说就是不同操作系统，使用姿势不一样）</p>
]]></summary>
    <content type="html"><![CDATA[<p>作为一个后端同学，经常被安全的小伙伴盯上，找一找安全漏洞；除了常说的注入之外，还有比较吓人的执行远程命令，唤醒本地应用程序等；然后有意思的问题就来了，写了这么多年的代码，好像还真没有尝试过用java来唤醒本地应用程序的</p>
<p>比如说一个最简单的，打开本地的计算器，应该怎么搞？</p>
<p>接下来本文将介绍一下如何使用java打开本地应用，以及打开mac系统中特殊一点的处理方式（直白来说就是不同操作系统，使用姿势不一样）</p>
<!-- more -->
<h3> 1. Runtime使用方式</h3>
<p>主要是基于<code>Runtime.getRuntime().exec()</code>来执行shell命令，来打开应用</p>
<ul>
<li>传参就是需要打开的应用名</li>
</ul>
<p>比如上面说到的打开计算器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的传参也可以看出两者的区别，为什么mac会整一个 <code>open -n</code>， 这个其实可以理解为在终端执行命令，打开计算器</p>
<p><strong>注意事项</strong></p>
<p>对于mac系统而言，除了上面这种打开方式之外，还有下面这种姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在exec中指定计算器的路径，有个很容易采的坑，直接写成下面这种</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这个直接执行之后会提示<code>权限错误</code>，其主要原因是mac系统的应用和win中的exe作为启动方式不太一样，对于mac而言，可以理解<code>xxx.app</code>为一个目录，真正执行文件是内部的<code>xxx/Contents/MacOS/xxx</code></p>
<h3> 2. ProcessBuilder使用方式</h3>
<p>除了Runtime唤起之外，使用ProcessBuilder也属于非常常见的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用上面这种姿势，特别需要注意的是内部传参不能是<code>open -n</code></p>
<h3> 3. 小结</h3>
<p>从上面介绍的方式来看，其实打开应用程序的思路主要就是利用java来执行脚本命令；内容比较简单，隐患却是比较大的；在自己的项目中，最好不要出现这种调用方式</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-12-31T10:55:56.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">5. 输出异常堆栈信息</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/05.Java%E4%B9%8B%E8%BE%93%E5%87%BA%E5%BC%82%E5%B8%B8%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/05.Java%E4%B9%8B%E8%BE%93%E5%87%BA%E5%BC%82%E5%B8%B8%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>在代码出现异常时，堆栈信息可以有效的辅助定位和排除问题，异常堆栈一般是怎么打印的呢</p>
]]></summary>
    <content type="html"><![CDATA[<p>在代码出现异常时，堆栈信息可以有效的辅助定位和排除问题，异常堆栈一般是怎么打印的呢</p>
<!-- more -->
<p>下面是一个简单的输出cas</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接使用 <code>System.out</code>输出时，看不到堆栈信息；使用<code>e.printStackTrace();</code>可以看到堆栈信息，输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然在我们实际的项目中，一般既不会使用<code>e.printStackTrace();</code>方式输出异常堆栈，也不会使用<code>System.out</code>方式输出；更常见的是通过专用的日志组件来处理，比如logback,slf4j2等</p>
<p>前不久做支持一个java动态编译运行的项目时，遇到的一个问题是我们通过控制台来控制某块java代码的执行，如果出现异常时，我希望将异常堆栈返回给控制台来查看，所以我希望可以从<code>Throwable</code>中获取堆栈信息，并转成String，那么可以怎么做呢？</p>
<p>主要的实现就是参考<code>e.printStackTrace</code>的实现，将输出到控制台的流，转换为我们自定义的额字符流</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再次测试，结果如下</p>
<figure><img src="/hexblog/imgs/190909/00.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> II. 其他</h2>
<h3> 1. <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">一灰灰Blog</a>： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">https://liuyueyi.github.io/hexblog</a></h3>
<p>一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3> 2. 声明</h3>
<p>尽信书则不如，已上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
</ul>
<h3> 3. 扫描关注</h3>
<p><strong>一灰灰blog</strong></p>
<figure><img src="https://raw.githubusercontent.com/liuyueyi/Source/master/img/info/blogInfoV2.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
<p><strong>知识星球</strong></p>
<figure><img src="https://raw.githubusercontent.com/liuyueyi/Source/master/img/info/goals.png" alt="goals" tabindex="0" loading="lazy"><figcaption>goals</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-09-09T19:11:32.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">6. 获取应用中所有线程</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/06.%E8%8E%B7%E5%8F%96%E5%BA%94%E7%94%A8%E4%B8%AD%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/06.%E8%8E%B7%E5%8F%96%E5%BA%94%E7%94%A8%E4%B8%AD%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>如何获取应用中，所有活动的线程？</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ThreadGroup</span> group <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 激活的线程数加倍</span>
<span class="token keyword">int</span> estimatedSize <span class="token operator">=</span> group<span class="token punctuation">.</span><span class="token function">activeCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token class-name">Thread</span><span class="token punctuation">[</span><span class="token punctuation">]</span> slackList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">[</span>estimatedSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<p>如何获取应用中，所有活动的线程？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是获取当前线程所在的ThreadGroup, 然后将这个分组内的所有线程丢到slackList数组中，实际测试时，数组大小可能是大于实际的线程数的（而且可能性特别大）</p>
<p>通过ThreadGroup，还可以获取上一层的Group, 然后遍历所有的线程</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK"/>
    <category term="并发"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2018-09-11T21:20:20.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">7. 数值型的字面值中使用下划线</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/07.Java%E4%B9%8B%E6%95%B0%E5%80%BC%E5%9E%8B%E7%9A%84%E5%AD%97%E9%9D%A2%E5%80%BC%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%8B%E5%88%92%E7%BA%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/07.Java%E4%B9%8B%E6%95%B0%E5%80%BC%E5%9E%8B%E7%9A%84%E5%AD%97%E9%9D%A2%E5%80%BC%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%8B%E5%88%92%E7%BA%BF.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>之前偶然在一个开源项目中看到下面这种写法，深感惊奇，当时没有记录，后来果不其然就忘掉了这种写法，现在又看到这种写法，特此记录</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">long</span> price <span class="token operator">=</span> <span class="token number">1_000_123L</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<p>之前偶然在一个开源项目中看到下面这种写法，深感惊奇，当时没有记录，后来果不其然就忘掉了这种写法，现在又看到这种写法，特此记录</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><!-- more -->
<h2> I. Java7新特性之数字中使用下划线</h2>
<p>为了直观性而言，在大数之间，加上下划线用于肉眼区分，下面实例小结下用法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是在数中间，插上下划线，用于划分段落</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2018-09-26T01:13:36.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">8. BigDecimal精度计算</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/08.%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97BigDecimal.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/08.%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97BigDecimal.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>目前接触的业务中，对数据的精度要求比较高，因此不再使用基本的float,double，改为用BigDecimal进行存储和相关的计算，端午前的这一篇博文，则简单的介绍下BigDecimal的使用姿势，早点回家早点放假</p>
]]></summary>
    <content type="html"><![CDATA[<p>目前接触的业务中，对数据的精度要求比较高，因此不再使用基本的float,double，改为用BigDecimal进行存储和相关的计算，端午前的这一篇博文，则简单的介绍下BigDecimal的使用姿势，早点回家早点放假</p>
<!-- more -->
<h2> I. 基本使用</h2>
<h3> 1. 构造方法</h3>
<p>几个常见的构造方式，将基本类型+String等，转换为BigDecimal对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 加减乘除</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的签名上，可以看出操作是属于链式结构（Builder模式），然后一个问题就是执行上面的操作之后，被调用的对象，是否会发生修改? (即下面的测试中的o值是否改变)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>结论：</strong> 计算后的结果需要保存，因为不会修改目标对象的值</p>
<h3> 3. 精度</h3>
<p>前面的例子中，输出后面一长串，而这往往并不是我们希望的，所以可以设置下精度</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>一个简单的case如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从上面的输出，特别是第二列，如果我们选择的精度方式是取下限，会不会有问题呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>所以需要注意的地方就来了，对浮点数进行精度设置时，需要根据自己的业务场景，选择合适的取整方式，不然很容易出问题</p>
<p>取精度的几个参数说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2018-06-15T18:15:22.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">9. BigDecimal除法的精度问题</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/09.BigDecimal%E9%99%A4%E6%B3%95%E7%9A%84%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/09.BigDecimal%E9%99%A4%E6%B3%95%E7%9A%84%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>在使用BigDecimal的除法时，遇到一个鬼畜的问题，本以为的精度计算，结果使用返回0，当然最终发现还是自己的使用姿势不对导致的，因此记录一下，避免后面重蹈覆辙</p>
]]></summary>
    <content type="html"><![CDATA[<p>在使用BigDecimal的除法时，遇到一个鬼畜的问题，本以为的精度计算，结果使用返回0，当然最终发现还是自己的使用姿势不对导致的，因此记录一下，避免后面重蹈覆辙</p>
<!-- more -->
<h2> I. 问题抛出</h2>
<p>在使用BigDecimal做高精度的除法时，一不注意遇到了一个小问题，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的输出是什么 ？</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么前面两个会是0呢，如果直接是 <code>541253 / 12389431</code> = 0 倒是可以理解, 但是BigDecimal不是高精度的计算么，讲道理不应该不会出现这种整除的问题吧</p>
<p>我们知道在BigDecimal做触发时，可以指定保留小数的参数，如果加上这个，是否会不一样呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>所以说在指定了保留小数之后，则没有问题，所以大胆的猜测一下，是不是上面的几种case中，由于scale值没有指定时，默认值不一样，从而导致最终结果的精度不同呢？</p>
<p>简单的深入源码分析一下，执行的方式为 <code>origin.divide(now, RoundingMode.HALF_UP);</code>, 所以这个scale参数就瞄准origin对象，而这个对象，就只能去分析它的构造了，因为没有其他的地方使用</p>
<h2> II. 源码定位</h2>
<h3> 1. 整形传参构造</h3>
<p>分析下面这一行， 直接进入源码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>很明显的int传参构造，进去简单看一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>so，很明确的知道默认的scale为0，也就是说当origin为正数时，以它进行的除法，不现实指定scale参数时，最终返回的都是没有小数的，同样看一眼，还有long的传参方式， BigInteger也一样</p>
<h3> 2. 浮点传参</h3>
<p>接下来就是浮点的scale默认值确认了，这个构造相比前面的复杂一点，源码就不贴了，太长，也看不太懂做了些啥，直接用猥琐一点的方式，进入debug模式，单步执行</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据debug的结果，第一个，scale为0； 第二个scale为29, 第三个scale为0</p>
<figure><img src="https://raw.githubusercontent.com/liuyueyi/Source/master/img/blog/daywork/180706/decimal01.jpg" alt="origin" tabindex="0" loading="lazy"><figcaption>origin</figcaption></figure>
<figure><img src="https://raw.githubusercontent.com/liuyueyi/Source/master/img/blog/daywork/180706/decimal02.jpg" alt="now" tabindex="0" loading="lazy"><figcaption>now</figcaption></figure>
<figure><img src="https://raw.githubusercontent.com/liuyueyi/Source/master/img/blog/daywork/180706/decimal03.jpg" alt="tmp" tabindex="0" loading="lazy"><figcaption>tmp</figcaption></figure>
<h3> 3. String传参</h3>
<p>依然是一大串的逻辑，同样采用单步debug的方式试下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面三个的scale都是1</p>
<figure><img src="https://raw.githubusercontent.com/liuyueyi/Source/master/img/blog/daywork/180706/decimal04.jpg" alt="smaple" tabindex="0" loading="lazy"><figcaption>smaple</figcaption></figure>
<h3> 4. 小结</h3>
<ul>
<li>对于BigDecimal进行除法运算时，最好指定其scale参数，不然可能会有坑</li>
<li>对于BigDecimla的scale初始化的原理，有待深入看下BigDecimal是怎么实现的</li>
</ul>
<p>最后贴一张乘法的图作为收尾</p>
<figure><img src="https://raw.githubusercontent.com/liuyueyi/Source/master/img/blog/daywork/180706/decimal05.jpg" alt="mul" tabindex="0" loading="lazy"><figcaption>mul</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2018-07-06T16:32:34.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">10. BigDecimal转int四舍五入的姿势</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/10.BigDecimal%E8%BD%ACint%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E7%9A%84%E5%A7%BF%E5%8A%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/10.BigDecimal%E8%BD%ACint%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E7%9A%84%E5%A7%BF%E5%8A%BF.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>从db中查了一个BigDecimal数据，希望按照四舍五入的方式进行取整，发现直接使用 <code>intValue</code> 不太对，特此记录一下正确姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token number">4.51</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setScale</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">RoundingMode</span><span class="token punctuation">.</span><span class="token constant">HALF_EVEN</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<p>从db中查了一个BigDecimal数据，希望按照四舍五入的方式进行取整，发现直接使用 <code>intValue</code> 不太对，特此记录一下正确姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><!-- more -->
<p>如果我们直接使用 <code>intValue</code>，会发现输出结果是直接将小数后面的扔掉了；所以这个时候需要先设置精度，然后再取整，测试如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的使用中，我们使用的<code>RoundingMode.HALF_EVEN</code>这种取整模式，当然常见的四舍五入还有 <code>HALF_UP</code> 和 <code>HALF_DOWN</code>，其中up表示为5时，向上取整；down表示为5时，向下取整；根据实际需要选择即可</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-06-05T19:53:16.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">11. Deflater压缩与Inflater解压</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/11.JDK%E4%B9%8BDeflater%E5%8E%8B%E7%BC%A9%E4%B8%8EInflater%E8%A7%A3%E5%8E%8B.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/11.JDK%E4%B9%8BDeflater%E5%8E%8B%E7%BC%A9%E4%B8%8EInflater%E8%A7%A3%E5%8E%8B.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>在实际的应用场景中，特别是对外传输数据时，将原始数据压缩之后丢出去，可以说是非常常见的一个case了，平常倒是没有直接使用JDK原生的压缩工具类，使用Protosutff和Kryo的机会较多,正好在实际的工作场景中遇到了，现在简单的看下使用姿势</p>
]]></summary>
    <content type="html"><![CDATA[<p>在实际的应用场景中，特别是对外传输数据时，将原始数据压缩之后丢出去，可以说是非常常见的一个case了，平常倒是没有直接使用JDK原生的压缩工具类，使用Protosutff和Kryo的机会较多,正好在实际的工作场景中遇到了，现在简单的看下使用姿势</p>
<!-- more -->
<h2> I. 压缩与解压工具类</h2>
<h3> 1. 基本实现</h3>
<p>主要借助的就是Deflater, Inflater两个工具类，其使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个简单的测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 注意事项</h3>
<p>上面这个运作的还挺好，但在接入使用时，总是提示<code>java.util.zip.DataFormatException: incorrect header check</code>, 因为接受的是第三方传递过来的压缩数据，比较坑爹的是对方就写了个Deflater压缩，然后什么都没有了，那么这个是啥原因呢？</p>
<p>其实看下Deflater的构造方法，发现还可以传一个boolean值(nowrap), 官方说明是</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是压缩时，如果nowrap为true，那么解压时也要为true；否则对不上时，就会抛异常</p>
<p>接下来简单对比下两种不同传参的情况，首先更新下工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，从大小来看，前者小那么一点点</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 小结</h3>
<p>一般来说，jdk自带的压缩与解压，除了方便之外，可能优势并不是那么的大，这里盗一张网上的对比表格</p>
<p>以下来自: <a href="https://www.cnblogs.com/lonelywolfmoutain/p/5563985.html" target="_blank" rel="noopener noreferrer">[java]序列化框架性能对比（kryo、hessian、java、protostuff）</a></p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>kryo</td>
<td>速度快，序列化后体积小</td>
<td>跨语言支持较复杂</td>
</tr>
<tr>
<td>hessian</td>
<td>默认支持跨语言</td>
<td>较慢</td>
</tr>
<tr>
<td>protostuff</td>
<td>速度快，基于protobuf</td>
<td>需静态编译</td>
</tr>
<tr>
<td>Protostuff-Runtime</td>
<td>无需静态编译，但序列化前需预先传入schema</td>
<td>不支持无默认构造函数的类，反序列化时需用户自己初始化序列化后的对象，其只负责将该对象进行赋值</td>
</tr>
<tr>
<td>jdk</td>
<td>使用方便，可序列化所有类</td>
<td>速度慢，占空间</td>
</tr>
</tbody>
</table>
<p>其次，在使用java的压缩与解压时，需要注意下，nowrap这个参数，需要保持一致，否则会报错</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2018-09-18T16:53:13.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">12. InputStream重复使用小技巧</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/12.InputStream%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/12.InputStream%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>在日常的编码中，有时会遇到，需要重复获取InputStream中的数据的需求；然后一般的流，只能读一次，读完就没了；那么如果我希望有一个可以重复读取数据的InputStream，可以怎么操作？</p>
]]></summary>
    <content type="html"><![CDATA[<p>在日常的编码中，有时会遇到，需要重复获取InputStream中的数据的需求；然后一般的流，只能读一次，读完就没了；那么如果我希望有一个可以重复读取数据的InputStream，可以怎么操作？</p>
<!-- more -->
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现方式基本就是将InputStream中的数据读取，写入到一个临时的输出流，然后再封装为<code>ByteArrayInputStream</code>即可</p>
<p>当我们使用时，如果需要重复消费流中数据，手动调用<code>java.io.ByteArrayInputStream#reset</code></p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="IO"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-11-07T19:50:18.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">13. Java获取类路径的几种姿势小结</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/13.Java%E8%8E%B7%E5%8F%96%E7%B1%BB%E8%B7%AF%E5%BE%84%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%E5%B0%8F%E7%BB%93.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/13.Java%E8%8E%B7%E5%8F%96%E7%B1%BB%E8%B7%AF%E5%BE%84%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%E5%B0%8F%E7%BB%93.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<h2> I. Java获取类路劲的几种姿势小结</h2>
<p>在Java环境中，如何获取当前类的路径，如何获取项目根路径，可以说是比较常见的需求场景了，下面简单的记录一下</p>
]]></summary>
    <content type="html"><![CDATA[<h2> I. Java获取类路劲的几种姿势小结</h2>
<p>在Java环境中，如何获取当前类的路径，如何获取项目根路径，可以说是比较常见的需求场景了，下面简单的记录一下</p>
<!-- more -->
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2018-08-27T18:03:59.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">14. Java根据路径获取文件内容</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/14.Java%E6%A0%B9%E6%8D%AE%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/14.Java%E6%A0%B9%E6%8D%AE%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>给出一个资源路径，然后获取资源文件的信息，可以说是非常常见的一种需求场景了，当然划分一下，本文针对最常见的三种状况进行分析</p>
<ul>
<li>网络地址</li>
<li>本地绝对路径</li>
<li>本地相对路径</li>
</ul>
<!--more-->
<h2> I. 实现</h2>
<h3> 1. 思路</h3>
<p><strong>http or no-http</strong></p>
<p>给出一个String表示资源文件的标识，如何判断是网络的文件还是本地的文件？</p>
<ul>
<li>http开头的看成是网络文件</li>
<li>否则看做是本地文件</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<p>给出一个资源路径，然后获取资源文件的信息，可以说是非常常见的一种需求场景了，当然划分一下，本文针对最常见的三种状况进行分析</p>
<ul>
<li>网络地址</li>
<li>本地绝对路径</li>
<li>本地相对路径</li>
</ul>
<!--more-->
<h2> I. 实现</h2>
<h3> 1. 思路</h3>
<p><strong>http or no-http</strong></p>
<p>给出一个String表示资源文件的标识，如何判断是网络的文件还是本地的文件？</p>
<ul>
<li>http开头的看成是网络文件</li>
<li>否则看做是本地文件</li>
</ul>
<p><strong>abs or relaitve</strong></p>
<p>对于mac和linux系统而言，就比较简单了</p>
<ul>
<li>以 "/" 和 "~" 开头的表示绝对路径</li>
<li>其他的看做是相对路径</li>
</ul>
<p>对于windows系统而言，绝对路径形如 "c:\test.txt"</p>
<ul>
<li>路径中包含 ":" 看成是绝对路径 （文件名中能否有:?)</li>
<li>以 "" 开头看做是绝对路径</li>
</ul>
<h3> 2. 实现</h3>
<p>操作系统判断</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>绝对路径与否判断</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文件获取封装类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 说明</h3>
<p>木有window操作系统，因此mac和linux已测试，window环境下是否ok，有待验证</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="工具"/>
    <category term="工具类"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2018-09-10T20:27:12.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">15. ArrayList#sublist的推荐使用姿势</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/15.ArrayList-sublist%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/15.ArrayList-sublist%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>我们有这么一个场景，给你一个列表，可以动态的新增，但是最终要求列表升序，要求长度小于20，可以怎么做？</p>
<p>这个还不简单，几行代码就可以了</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">trimList</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token keyword">int</span> add<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        list <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<p>我们有这么一个场景，给你一个列表，可以动态的新增，但是最终要求列表升序，要求长度小于20，可以怎么做？</p>
<p>这个还不简单，几行代码就可以了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><!-- more -->
<h3> 1. 测试验证</h3>
<p>上面的代码先不考虑性能的优化方面，有没有问题？</p>
<p>写了个简单的测试case，我们来看下会出现什么情况</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动参数修改下，添加jvm最大内存条件 <code>-Xmx3m</code>， 然后跑上面代码，一段时间之后居然出现<code>stack over flow</code></p>
<figure><img src="/hexblog/imgs/190515/00.jpg" alt="sof" tabindex="0" loading="lazy"><figcaption>sof</figcaption></figure>
<p>有意思的问题来了，从逻辑上看，这个数组固定长度为20，顶多有21条数据，怎么就会内存溢出呢？</p>
<h3> 2. SubList 方法揭秘</h3>
<p>我们看下ArrayList#sublis方法的实现逻辑，就可以发现获取子列表，居然只是重置了一下内部数组的索引</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>返回的是一个SubList类型对象，这个对象和原来的List公用一个存储数据的数组，但是多了两个记录子列表起始的偏移;</p>
<p>然后再看下SubList的add方法，也是直接在原来的数组中新增数据，想到与原来的列表在指定位置插入数据</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以上面实现的代码中 <code>list = list.subList(0, 20);</code> 这一行，有内存泄露，貌似是只返回了一个20长度大小的列表，但是这个列表中的数组长度，可能远远不止20</p>
<p>为了验证上面的说法，debug下上面的测试用例</p>
<figure><img src="/hexblog/imgs/190515/01.jpg" alt="debug" tabindex="0" loading="lazy"><figcaption>debug</figcaption></figure>
<p>动图演示如下</p>
<figure><img src="/hexblog/imgs/190515/02.gif" alt="gif" tabindex="0" loading="lazy"><figcaption>gif</figcaption></figure>
<h3> 3. 正确使用姿势</h3>
<p>上面知道sublist并不会新创建一个列表，旧的数据依然还在，只是我们用不了而已，所以改动也很简单，根据sublist的结果创建一个新的数组就好了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次测试，代码一直在顺利的执行，看下后面的计数，都已经5w多，前面1w多久报错了</p>
<figure><img src="/hexblog/imgs/190515/03.jpg" alt="show" tabindex="0" loading="lazy"><figcaption>show</figcaption></figure>
<p>虽然上面解决了内存泄露，但是gc也很频繁了，本篇的重点主要是指出sublist的错误使用姿势，所以上面算法的优化就不详细展开了</p>
<figure><img src="/hexblog/imgs/190515/04.jpg" alt="sof" tabindex="0" loading="lazy"><figcaption>sof</figcaption></figure>
<h3> 4. 知识点扩展</h3>
<p>看下下面的测试代码输出应该是什么</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再看具体的答案之前，先分析一下</p>
<p>针对case1/2，我们知道sublist返回的列表和原列表公用一个底层数组，所以这两个列表的增删，都是相互影响的</p>
<ul>
<li>case1 执行之后相当于在list数组的下标15这里，插入数据100</li>
<li>case2 执行之后，list的下标11，相当于sub的下标1，也就是说sub[1] 变成了200</li>
</ul>
<p>对于case3/4 而言，根据sub创建了一个新的列表，这个时候修改新的列表中的值，会影响到原来的列表中的值么？</p>
<p>分析这个场景，就需要看一下源码了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的源码分析，会不会相互影响就看这个数组拷贝是怎么实现的了（深拷贝？浅拷贝？）</p>
<hr>
<p>接下来看下实际的输出结果</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/190515/05.jpg" alt="out" tabindex="0" loading="lazy"><figcaption>out</figcaption></figure>
<p>从上面可以知道，case1/2的分析没啥问题，case3、4的输出有点意思了</p>
<ul>
<li>数组内为Integer时，两者互不影响</li>
<li>数组内为普通对象时，修改其中一个，会影响另外一个</li>
</ul>
<p>关从输出结果来看 <code>System.arraycopy</code> 是浅拷贝，至于为什么int不影响呢，这个就和方法调用传参是基本数据类型时，在方法内部修改参数不会影响到外部一个道理了</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK"/>
    <category term="容器"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-05-15T20:22:39.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">16. List遍历删除使用姿势</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/16.JDK%E4%B9%8BList%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/16.JDK%E4%B9%8BList%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>在实际的业务开发中，容器的遍历可以说是非常非常常见的场景了，遍历删除呢，用的机会也不会少，但你真的会用么</p>
]]></summary>
    <content type="html"><![CDATA[<p>在实际的业务开发中，容器的遍历可以说是非常非常常见的场景了，遍历删除呢，用的机会也不会少，但你真的会用么</p>
<!-- more -->
<h2> I. List遍历删除</h2>
<p>对于列表，这里以ArrayList进行举例说明，下面给出几种经常会遇到的写法</p>
<p>首先初始化一个list数组</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1. foreach</h3>
<p>这个属于我们最常见的foreach循环，在循环内部判断满足条件的直接删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法导致的问题，很容易可以发现，因为上面代码跑完之后，堆栈就出来了</p>
<figure><img src="/hexblog/imgs/190521/00.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<p>很典型的并发修改错误，在foreach循环中不允许删除,新增</p>
<h3> 2. 普通for循环</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法呢？我们希望把列表中，第0，5，10，15位置的元素干掉，正常执行，倒是不会报错，然而输出的结果却和我们的预期不一致</p>
<figure><img src="/hexblog/imgs/190521/01.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<p>for循环中，另外一种写法可能更加常见，为了避免每次都访问 <code>list.size()</code> 方法，我可能提前用一个变量保存数组大小</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个问题就很明显了，数组越界</p>
<h3> 3. 迭代方式</h3>
<p>下面这种可以说是标准的迭代删除的写法了，基本上大多都是这么玩</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. jdk8+ 流方式</h3>
<p>jdk8+ 推荐下面这种写法，简洁明了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-05-21T20:21:35.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">17. HashMap便利删除使用姿势</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/17.Java%E4%B9%8BHashMap%E8%BF%AD%E4%BB%A3%E5%88%A0%E9%99%A4%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/17.Java%E4%B9%8BHashMap%E8%BF%AD%E4%BB%A3%E5%88%A0%E9%99%A4%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>map的迭代删除，和我们常见的list，set不太一样，不能直接获取Iteraotr对象，提供的删除方法也是单个的，根据key进行删除，如果我们有个需求，将map中满足某些条件的元素删除掉，要怎么做呢？</p>
]]></summary>
    <content type="html"><![CDATA[<p>map的迭代删除，和我们常见的list，set不太一样，不能直接获取Iteraotr对象，提供的删除方法也是单个的，根据key进行删除，如果我们有个需求，将map中满足某些条件的元素删除掉，要怎么做呢？</p>
<!-- more -->
<h2> I. Map 迭代删除</h2>
<p>迭代删除，在不考虑并发安全的前提下，我们看下可以怎么支持</p>
<h3> 1. 非常不优雅版本</h3>
<p>我们知道map并不是继承自Collection接口的，HashMap 也没有提供迭代支持，既然没法直接迭代，那我就老老实的low b版好了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现怎么样？并没有什么毛病</p>
<p>(为啥不直接在遍历中删除？）</p>
<h3> 2. 正确姿势版</h3>
<p>虽然Map没有迭代，但是它的entrySet有啊，所以我们可以通过它来实现遍历删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个可能是我们经常使用的操作姿势了，利用迭代器来操作元素</p>
<h3> 3. 简洁版</h3>
<p>到jdk8之后，针对容器提供了很多简洁的操作方式，迭代删除这方面可以说更加简单了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-05-29T21:38:18.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">18. HashMap的key典型错误使用姿势</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/18.HashMap%E7%9A%84key%E5%85%B8%E5%9E%8B%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/18.HashMap%E7%9A%84key%E5%85%B8%E5%9E%8B%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>记录一个非常低级的错误导致的java应用一直fullgc的问题；根本原因就是HashMap的key使用姿势不对</p>
]]></summary>
    <content type="html"><![CDATA[<p>记录一个非常低级的错误导致的java应用一直fullgc的问题；根本原因就是HashMap的key使用姿势不对</p>
<!-- more -->
<h3> 1. 问题记录</h3>
<p>先捞出有问题的现场代码，之前写了一个简单的工具类，用来保存两个元素，简单的模拟了一下Guava的实现姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最开始主要是由于某些地方返回结果时，需要返回多个对象，而java并不能像python那么友好的支持这个功能，所以写了上面这个简单的工具类，对返回结果进行一个简单的封装</p>
<p>距离这个工具类写完之后一两个月的时间，突然有个临时需求场景，对于每次的请求，需要做一个简单的内存过滤；如果这次请求距离上次超过5s, 则直接不处理；否则才接受；于是写了下面这段代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接看上面这段代码，貌似没有啥问题，然后愉快的跑起来；但是一段时间之后呢？内存疯狂的上涨，且一直在fullgc</p>
<p>简单的测试下上面方法，发现过滤逻辑一直都没有生效</p>
<figure><img src="/hexblog/imgs/190403/00.jpg" alt="demo" tabindex="0" loading="lazy"><figcaption>demo</figcaption></figure>
<p>HashMap根据Key获取Value的方式，主要是根据key的<code>hashcode</code>去定位对应的元素位置，然后通过<code>equals</code>方法判断找到的对象是不是我们预期的目标</p>
<p>因为我们最上面的<code>ImmutablePair</code>类，没有覆盖这两个方法，所以是默认的，这个时候<code>equals</code>方法和<code>==</code>是等效的，主要是判断是否为同一个引用，所以上面的key每次都是重新创建对象，当然和缓存的不一致，从而导致每次都不命中，一直往Map里面塞数据，但是又回收不了，所以导致了这个问题</p>
<h3> 2. 小结</h3>
<ul>
<li>对于HashMap的key对象，务必保证是重写了<code>equals</code>和<code>hashcode</code>方法的</li>
<li>用内存做缓存时，使用guava的cache并设置上限，相对而言是更加优雅的方式</li>
<li>使用HashMap时，尽量指定Map的初始化容量，否则可能出现频繁的扩容；其次就是最好能保证下HashMap的个数，毫无限制的情况下，说不准哪天就暴雷了</li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="问题记录"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-04-03T19:08:13.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">19. HashMap初始化大小如何设置</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/19.%E8%80%81%E5%93%A5%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%9F%A5%E9%81%93HashMap%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E4%B9%88.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/19.%E8%80%81%E5%93%A5%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%9F%A5%E9%81%93HashMap%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E4%B9%88.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>HashMap对于javer而言，可以说是非常非常熟悉的一个容器类了，可以说99.99%的java开发者都用过它，那么你知道怎样创建一个HashMap是最优雅的方式呢？</p>
]]></summary>
    <content type="html"><![CDATA[<p>HashMap对于javer而言，可以说是非常非常熟悉的一个容器类了，可以说99.99%的java开发者都用过它，那么你知道怎样创建一个HashMap是最优雅的方式呢？</p>
<!-- more -->
<h2> I. HashMap初始化大小的推荐姿势</h2>
<h3> 1. 基本知识点</h3>
<p>在指明正确的使用姿势之前，有必要先了解一下HashMap的基础知识；本文重点不会放在源码分析，所以直接给一些必要的知识点</p>
<p><strong>数据结构</strong></p>
<p>HashMap的数据存储结构，在jdk1.7中，属于标准的 <code>数组+链表</code>; 在jdk1.8中，为<code>数组 + 链表/红黑树</code></p>
<p>这里不关注1.8中链表-&gt;红黑树的转换，简单说一下存储逻辑</p>
<ul>
<li>根据key计算hash值，针对数组长度取余得到这对kv在数组中的下标</li>
<li>因为hash碰撞问题，不同的key，对应的数组下标可能一致，所以数组中存的内容按列表/红黑树方式串联在一起</li>
</ul>
<p><strong>数组大小</strong></p>
<p>在HashMap中的，数组的大小为2^n</p>
<p><strong>扩容机制</strong></p>
<p>HashMap默认采用了预扩容机制，简单来讲就是虽然实际存的数据量还没有达到数组的长度，就会提前扩容为原来的两倍(如果是单个加入时，扩容两倍；如果是批量加入时，可能为2^n倍)</p>
<h3> 2. 一般使用初始化姿势</h3>
<p>首先来看一下一般的HashMap使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种使用方式从语法上来看，并没有什么问题；但实际情况呢?</p>
<p>假如我们可以确定，我们需要往map中添加的数据量有1024个，使用上面的方式，会出现(<code>16 -&gt; 32 -&gt; 64 -&gt; 128 -&gt; 256 -&gt; 512 -&gt; 1024 -&gt; 2048</code>=8)次的扩容，而扩容就会导致创建新的数组，数据拷贝。而如果我们在初始化的时候，直接指定大小为2048，那么就不会出现扩容了</p>
<p>为了验证1024个元素，扩容的次数，写一个简单的demo测试一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行上面的case，输出结果如下 (请注意，实例化HashMap对象时，并不会创建数组，只有在首次添加数据时才会创建数组)</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果将我们的map长度设置为2048，那么就不会有一次的扩容，上面的日志将不存在</p>
<p>那么我们应该如何确定Map的初始化大小呢？</p>
<h3> 3. 推荐初始化姿势</h3>
<p>仔细看一下上面的输出，结合第一节的内容，HashMap的扩容，并不是在达到数组的长度时，实现的扩容，比如在添加第13个元素时(从1开始计数），实现了16 -&gt; 32的扩容</p>
<p>看过HashMap源码的同学会知道，决定上面扩容阈值的主要来自于<code>loadFactor</code>这个参数，可以在初始化的时候指定，当然不太建议修改</p>
<p>默认的case下，<code>loadFactor == 0.75</code>，也就是说当map的数据量超过数组长度的3/4（<code>size &gt; len ** 0.75</code>）时，就会扩容</p>
<p>所以，在初始化HashMap时，特别是当你能预估map中数据量的大小为<code>len</code>时，请初始化时，指定大小 <code>size=2^n * 0.75 &gt; len的最小值</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>举几个实例</p>
<ul>
<li>map数量为2时，初始化大小为4</li>
<li>map数量为12时，初始化大小为16 (因为初始化为16时，扩容的阈值为12，正好没有超过阈值)</li>
<li>map数量为13时，初始化大小为32</li>
</ul>
<p>扩展一下：</p>
<ul>
<li>若项目中引入了Guava，那么有一个更好的方法来实现Map大小指定</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JDK"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-01-11T16:15:55.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">20. JDK的一次排序采坑记录</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/20.JDK%E7%9A%84%E4%B8%80%E6%AC%A1%E6%8E%92%E5%BA%8F%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/20.JDK%E7%9A%84%E4%B8%80%E6%AC%A1%E6%8E%92%E5%BA%8F%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>列表排序，我们可以说是用的比较多了，写起来也很溜，继承<code>Comparable</code>接口，实现<code>compareTo</code>方法，然后直接使用<code>java.util.List#sort</code>即可</p>
<p>虽说如此简单，今天却是一脚踩进去，花了不少时间才爬出来，下面复盘一下这个现场</p>
]]></summary>
    <content type="html"><![CDATA[<p>列表排序，我们可以说是用的比较多了，写起来也很溜，继承<code>Comparable</code>接口，实现<code>compareTo</code>方法，然后直接使用<code>java.util.List#sort</code>即可</p>
<p>虽说如此简单，今天却是一脚踩进去，花了不少时间才爬出来，下面复盘一下这个现场</p>
<!-- more -->
<h2> I. 排序场景复现</h2>
<p>背景比较简单，做一个新闻的聚合专栏，专栏内部的文章可以来自各个不同的来源，我们希望在专栏里面的文章，可以根据热度和发布时间进行排序，即热度高的放在前面，相同热度的文章，根据发布时间倒排</p>
<h3> 1. 模拟实现</h3>
<p>针对上面这个场景，给出一个可以复现的代码实现，我们先定义一个<code>ItemDO</code>，表示专栏内部的文章，其中与排序相关的主要有两个字段，热度<code>hot</code> 和发布时间<code>publishTime</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们希望实现上面的排序，所以可直接让这个DO继承<code>Compareable</code>接口，内部实现排序的逻辑</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看下我们上面的实现，我们在业务上已经能保证每个DO中的成员不会为null（因为直接从DB中获取，而db中不存null的字段）</p>
<p>首先根据sort进行排序，可以看到，hot大的，排在前面，hot小的往后排；如果hot相等，才会进入后面的时间比较；还特意加上了针对时间为0的特殊处理，然后捞了一批最近的数据，进行测试，发现一如预期，并没有什么问题</p>
<h3> 2. 坑在哪儿？</h3>
<p>上面的实现，现在明确指出，有问题，会在什么地方呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>就在上面这一行，会有什么问题？看到类型转换，就会想到溢出的问题，如果两篇文章的发布时间，间隔长一点就会出现这个问题</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以说在时间跨度小的时候，没啥问题，但是时间跨度大一点，就会出现int溢出，导致<code>compareTo</code>的返回结果和我们预期的不一致</p>
<h3> 3. 修改</h3>
<p>知道问题之后，就可以吭哧吭哧的修改了，方法一把ms转换成s再进行比较；方法二，用下面的比较方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 测试验证</h3>
<p>然后写几个简单的测试用例看一下是否和我们预期的一致</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下：</p>
<figure><img src="/hexblog/imgs/190618/00.jpg" alt="out" tabindex="0" loading="lazy"><figcaption>out</figcaption></figure>
<p>当然除了上面的比较的写法之外，更推荐的写法是直接使用 <code>Long.compare(a, b)</code></p>
<h3> 5. 小结</h3>
<p>虽然说在java中要想实现列表的排序比较简单，但是使用姿势一旦不对，同样会导致各种问题</p>
<p>在实现<code>Compareable</code>接口中的<code>compareTo</code>方法时</p>
<ul>
<li>不推荐使用两个数值的差作为返回值（因为可能出现溢出）</li>
<li>推荐根据需要返回 <code>1, 0, -1</code>
<ul>
<li><code>a.compareTo(b) == 1</code> 表示a往后排</li>
<li><code>a.compareTo(b) == -1</code> 表示a往前排</li>
</ul>
</li>
<li>数字的比较，推荐使用<code>Long.compare</code> 或者 <code>Integer.compare</code> 来实现</li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="问题记录"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-06-18T19:48:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">基础知识点</title>
    <id>https://liuyueyi.github.io/tutorial/java/basic/</id>
    <link href="https://liuyueyi.github.io/tutorial/java/basic/"/>
    <updated>2025-02-13T08:59:24.000Z</updated>
    <summary type="html"><![CDATA[<p>本目录下主要记录的是一些java相关的基本知识点，按需取用</p>
]]></summary>
    <content type="html"><![CDATA[<p>本目录下主要记录的是一些java相关的基本知识点，按需取用</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2024-08-02T10:41:58.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">jdk</title>
    <id>https://liuyueyi.github.io/tutorial/java/jdk/</id>
    <link href="https://liuyueyi.github.io/tutorial/java/jdk/"/>
    <updated>2025-02-13T08:59:24.000Z</updated>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2024-08-02T10:41:58.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">36.时间戳的取整小技巧</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/36.%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E5%8F%96%E6%95%B4%E5%B0%8FTIP.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/36.%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E5%8F%96%E6%95%B4%E5%B0%8FTIP.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<h1> 时间戳的取整小TIP</h1>
<p>一个简单的背景，持有ms为单位的时间戳，需要判断两个时间戳是否为同一分钟</p>
]]></summary>
    <content type="html"><![CDATA[<h1> 时间戳的取整小TIP</h1>
<p>一个简单的背景，持有ms为单位的时间戳，需要判断两个时间戳是否为同一分钟</p>
<!-- more -->
<p>先将问题简化下，对s进行取整如何做？</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>也就是丢掉后面的三位数；那么对分钟取整呢？</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其实思路和对整百的取整一样，唯一让人感到违和的可能就是时间是60进制的形式，导致一眼看上去，有点诡异</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="其他"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2018-06-04T20:31:31.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">37.手写定长数组</title>
    <id>https://liuyueyi.github.io/tutorial/java/skill/37.%E6%89%8B%E5%86%99%E5%AE%9A%E9%95%BF%E6%95%B0%E7%BB%84.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/skill/37.%E6%89%8B%E5%86%99%E5%AE%9A%E9%95%BF%E6%95%B0%E7%BB%84.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<h1> 手写定长数组</h1>
<p>有个背景场景如下：</p>
<p>一天划分为1440分钟，每分钟记录一个数据块，然后用一个数据结构存储着1440个数据块，随着时间的推移，每过一分钟，向这个数据结构中添加一块，并移除最前的那个；其次就是我希望根据当前的时间，可以获取往前n分钟的数据块</p>
<p>简单来说，上面的需求解析如下：</p>
<ul>
<li>一个数组，容量为1440</li>
<li>频繁的新增和删除</li>
<li>随机的访问</li>
</ul>
<p>后面两个就限制了ArrayList和LinkedList的使用场景了，所以为了满足这个场景，然后写了一个简单的数据结构</p>]]></summary>
    <content type="html"><![CDATA[<h1> 手写定长数组</h1>
<p>有个背景场景如下：</p>
<p>一天划分为1440分钟，每分钟记录一个数据块，然后用一个数据结构存储着1440个数据块，随着时间的推移，每过一分钟，向这个数据结构中添加一块，并移除最前的那个；其次就是我希望根据当前的时间，可以获取往前n分钟的数据块</p>
<p>简单来说，上面的需求解析如下：</p>
<ul>
<li>一个数组，容量为1440</li>
<li>频繁的新增和删除</li>
<li>随机的访问</li>
</ul>
<p>后面两个就限制了ArrayList和LinkedList的使用场景了，所以为了满足这个场景，然后写了一个简单的数据结构</p>
<!--more-->
<h2> I. 滑动定长数组</h2>
<p>来两个偏移量，将数组看成一个循环的结构，一个Start，一个End，分别记录开始和结束，直接在End处添加数据，每次删start处的数据；定位则计算与End或者Start的偏移量来做，超简单的实现如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. 其他</h2>
<h3> <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">一灰灰Blog</a>： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">https://liuyueyi.github.io/hexblog</a></h3>
<p>一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3> 声明</h3>
<p>尽信书则不如，已上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
</ul>
<h3> 扫描关注</h3>
<figure><img src="https://raw.githubusercontent.com/liuyueyi/Source/master/img/info/blogInfoV2.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="其他"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2018-06-07T19:52:19.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1. JDNI注入：RMI基本知识点介绍</title>
    <id>https://liuyueyi.github.io/tutorial/java/%E5%AE%89%E5%85%A8/211213-JDNI%E6%B3%A8%E5%85%A5%EF%BC%9ARMI%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BB%8B%E7%BB%8D.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/%E5%AE%89%E5%85%A8/211213-JDNI%E6%B3%A8%E5%85%A5%EF%BC%9ARMI%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BB%8B%E7%BB%8D.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>远程方法调用，现在更多的使用RPC来处理，至于RMI好像没有那么多了，最近闹的火热的log4j2漏洞，又让几个关键词jndi,rmi,ldap频繁出现；对于我这种面向Spring编程的javer而言，这些是啥? 干嘛用的？为啥漏洞这么多？</p>
<p>接下来简单学习下RMI的基本知识点</p>
]]></summary>
    <content type="html"><![CDATA[<p>远程方法调用，现在更多的使用RPC来处理，至于RMI好像没有那么多了，最近闹的火热的log4j2漏洞，又让几个关键词jndi,rmi,ldap频繁出现；对于我这种面向Spring编程的javer而言，这些是啥? 干嘛用的？为啥漏洞这么多？</p>
<p>接下来简单学习下RMI的基本知识点</p>
<!-- more -->
<h3> 1. RMI科普</h3>
<blockquote>
<p>参考：<a href="https://www.jianshu.com/p/de85fad05dcb" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/de85fad05dcb</a></p>
</blockquote>
<p>Java RMI，即 远程方法调用(Remote Method Invocation)，一种用于实现远程过程调用(RPC)(Remote procedure call)的Java API，能直接传输序列化后的Java对象和分布式垃圾收集。它的实现依赖于Java虚拟机(JVM)，因此它仅支持从一个JVM到另一个JVM的调用。</p>
<figure><img src="/hexblog/imgs/211213/00.jpg" alt="RMI架构图" tabindex="0" loading="lazy"><figcaption>RMI架构图</figcaption></figure>
<p>可以简单的将RMI理解为jdk原生提供的rpc支持方式</p>
<h3> 2. 基础体验</h3>
<p>基于上面的RMI架构图，要体验一下RMI的基本功能，非常简单了</p>
<h4> 2.1 服务端</h4>
<p>要提供一个rmi服务端就比较简单了，不需要额外引入依赖，直接使用</p>
<p>类似于我们常见的rpc框架，先提供一个接口，终点注意它需要继承<code>Remote</code>接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的实现类，重点注意继承自<code>UnicastRemoteObject</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后就是启动服务，提供一个上面的接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.2 客户端</h4>
<p>客户端访问rmi服务就很简单了，两行代码即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.3 测试</h4>
<p>先启动服务端，再启动客户端，可以看到客户端会拿到一个HelloService的实例，可以直接像调用本地方法一下访问这个方法</p>
<figure><img src="/hexblog/imgs/211213/01.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<p>注意上面这个case，客户端拿到实例，访问实例方法，这个逻辑是在哪里执行的呢？（客户端还是服务端？）</p>
<ul>
<li>服务端执行（可以通过在实现类中添加一行日志，看下这个日志是在服务端输出的还是客户端输出的）</li>
</ul>
<h4> 3.naming方式</h4>
<p>除了上面的这种方式之外，使用<code>Naming</code>方式的也非常普遍，如下</p>
<p>服务端，新的写法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>客户端的写法如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式与前面的效果相同，区别在于当有多个服务端时，使用naming的方式，可以指定ip + 端口号来获取对应的服务提供者</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JNDI"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-12-13T20:35:06.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">2 JDNI注入：RMI Reference注入问题</title>
    <id>https://liuyueyi.github.io/tutorial/java/%E5%AE%89%E5%85%A8/211216-JDNI%E6%B3%A8%E5%85%A5%EF%BC%9ARMI-Reference%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/%E5%AE%89%E5%85%A8/211216-JDNI%E6%B3%A8%E5%85%A5%EF%BC%9ARMI-Reference%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>前面一篇介绍了基础的RMI的使用case <a href="https://blog.hhui.top/hexblog/2021/12/13/211213-JDNI%E6%B3%A8%E5%85%A5%EF%BC%9ARMI%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">JDNI注入：RMI基本知识点介绍 - 一灰灰Blog</a>，其中有说到客户端通过rmi访问server时，表现和我们常见的rpc也一致，客户端拿到代理执行的方法，也是在远程服务端执行的，怎么就存在注入问题呢?</p>
<p>接下来我们再来看一个知识点，RMI + Reference，利用反序列化来实现注入</p>
]]></summary>
    <content type="html"><![CDATA[<p>前面一篇介绍了基础的RMI的使用case <a href="https://blog.hhui.top/hexblog/2021/12/13/211213-JDNI%E6%B3%A8%E5%85%A5%EF%BC%9ARMI%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener noreferrer">JDNI注入：RMI基本知识点介绍 - 一灰灰Blog</a>，其中有说到客户端通过rmi访问server时，表现和我们常见的rpc也一致，客户端拿到代理执行的方法，也是在远程服务端执行的，怎么就存在注入问题呢?</p>
<p>接下来我们再来看一个知识点，RMI + Reference，利用反序列化来实现注入</p>
<!-- more -->
<h3> 1. Reference服务端使用姿势</h3>
<p>区别于前面一篇rmi提供的远程接口访问方式，这里借助Refernce来实现，当客户单连接请求时，返回一个Class，当客户端拿到这个class并实例化时，实现我们预期的注入</p>
<p>服务器的实现与前面的大体相同，通过Registry起一个rmi服务，区别在于将之前的注册一个服务类改成注册一个Reference，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的Reference的定义，三个参数</p>
<ul>
<li>className：远程加载时所使用的类名；</li>
<li>classFactory：加载的class中需要实例化类的名称；</li>
<li>classFactoryLocation：远程加载类的地址，提供classes数据的地址可以是file/ftp/http等协议；</li>
</ul>
<p>上面表示的是当客户端连接到这个rmi发起请求之后，会尝试从 <code>http://127.0.0.1:9999/Inject.class</code> 获取并加载class文件</p>
<p>接下来写一个简单的Inject类，在静态块中可以执行任何你想执行的代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动一个简单的python服务器，这样可以直接通过网络加载这个class文件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样一个支持代码注入的rmi服务器就搭建完成了；</p>
<h3> 2. 客户端实测</h3>
<p>接下来看下客户单的访问姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当jdk版本较高时，会发现有下面这种提示，表示默认不允许读取远程的class文件</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们先模拟一下注入的case，所以先将这个开关开上，直接在启动中添加下面这一行配置</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来看一下执行结果</p>
<figure><img src="/hexblog/imgs/211216/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>重点关注上面输出的<code>hello world</code>，这个输出实际上是在Inject类的静态方法中输出的，在客户端被执行了；</p>
<p>接下来我们模拟一下，直接唤起客户单本地应用的case，在Inject类中，实现一个打开计算器的功能（可以借助 Runtime）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们再来执行一下看看会发生什么，计算器是否会如期被唤起</p>
<figure><img src="/hexblog/imgs/211216/01.gif" alt="a.gif" tabindex="0" loading="lazy"><figcaption>a.gif</figcaption></figure>
<p>看到上面这个的小伙伴可能会有疑问，不过是打开我的计算器，也没啥了不起的影响，但是请注意，上面这个Inject的静态类可以任由我们自己发挥</p>
<ul>
<li>如果你的客户端是linux，那么直接在<code>~/.ssh/authorized_keys</code>中写入黑客的公钥，这样就可以直接登录服务器</li>
<li>直接下载木马、病毒在本机执行</li>
<li>....</li>
</ul>
<p>所以上面这个问题还是相当可怕的，幸好的是在Oracle JDK11.0.1, 8u191, 7u201, 6u211及之后的版本，<code>trustURLCodebase</code>这个配置默认是false，一般也不会有人特意去开启这个配置，所以问题不大</p>
<p>那么真的是问题不大么？且待后续博文</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JNDI"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-12-16T19:04:00.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">3. JDNI注入：RMI之绕过trustURLCodebase配置的注入实例演示</title>
    <id>https://liuyueyi.github.io/tutorial/java/%E5%AE%89%E5%85%A8/211220-JDNI%E6%B3%A8%E5%85%A5%EF%BC%9ARMI%E4%B9%8B%E7%BB%95%E8%BF%87trustURLCodebase%E9%85%8D%E7%BD%AE%E7%9A%84%E6%B3%A8%E5%85%A5%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/%E5%AE%89%E5%85%A8/211220-JDNI%E6%B3%A8%E5%85%A5%EF%BC%9ARMI%E4%B9%8B%E7%BB%95%E8%BF%87trustURLCodebase%E9%85%8D%E7%BD%AE%E7%9A%84%E6%B3%A8%E5%85%A5%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>上一篇博文介绍了RMI绑定一个Reference，导致加载远程class文件时导致的注入问题，当时有提到对于高级的版本，对于默认的配置为<code>java.rmi.server.useCodebaseOnly=false</code>，对于远程的class文件做了安全校验的，但是即便如此，也并没能完全限制住注入</p>
<p>接下来我们来实例演示一下</p>
]]></summary>
    <content type="html"><![CDATA[<p>上一篇博文介绍了RMI绑定一个Reference，导致加载远程class文件时导致的注入问题，当时有提到对于高级的版本，对于默认的配置为<code>java.rmi.server.useCodebaseOnly=false</code>，对于远程的class文件做了安全校验的，但是即便如此，也并没能完全限制住注入</p>
<p>接下来我们来实例演示一下</p>
<!-- more -->
<h3> 1. 注入思路</h3>
<p>按照之前的case，RMI服务端提供的是一个远程的class文件，在客户端访问之后，去加载远程Class并实例化，从而导致静态代码块的执行，就带来了注入问题；现在因为<code>useCodebaseOnly=false</code>,不支持加载远程class文件，那应该怎么处理呢？</p>
<p>接下来的思路就是既然远程的class不让加载，那么就加载客户端本身的class类，然后通过覆盖其某些方法来实现；</p>
<p>从客户端访问的姿势进行debug，我们可以找到关键的代码节点</p>
<ul>
<li>com.sun.jndi.rmi.registry.RegistryContext#lookup(<a href="http://javax.naming.Name" target="_blank" rel="noopener noreferrer">javax.naming.Name</a>)</li>
<li>com.sun.jndi.rmi.registry.RegistryContext#decodeObject</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个方法，就是加载class文件并实例化的核心代码，重点关注下面两段</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的逻辑可以看到，为了不抛出异常，Reference中的factoryClassLocation设置为空；这样就可以继续走下面的<code>NamingManager.getObjectInstance</code>流程；最终核心点在下面的实例创建中，获取Factory，创建实例</p>
<ul>
<li>javax.naming.spi.NamingManager#createObjectFromFactories</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的核心实现上，可以看到两个关键信息：</p>
<ul>
<li><code>javax.naming.spi.ObjectFactory</code>: 对象工厂类，在客户端找一个这样的工厂类出来，用来创建入侵对象</li>
<li><code>factory.getObjectInstance</code>: 实例化时，注入我们希望执行的代码</li>
</ul>
<h3> 2. 注入服务端</h3>
<p>首先需要找一个ObjectFactory，我们这里选中的目标是tomcat中的<code>org.apache.naming.factory.BeanFactory</code></p>
<p>接下来看一下它的<code>getObjectInstance</code>实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面减去了一些不重要的代码，重点可以看到下面这个逻辑</p>
<ul>
<li>找到一个jvm中存在的类beanClass</li>
<li>对于<code>key = forceString</code> 的RefAddr，会做一个特殊处理
<ul>
<li>value形如 <code>argVal = rename</code></li>
<li>基于上面的形式，会从beanClass中找到一个名为<code>methodName = rename</code>，参数有一个，且为<code>String</code>的方法</li>
</ul>
</li>
<li>在对象实例化时，会调用上面的方法，其中具体的参数值，从 <code>RefAddr</code>中查找key = <code>argVal</code> 的取值</li>
</ul>
<p>举一个实例如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面三行，最终直接的结果就是在创建实例对象时，有下面三步</p>
<ul>
<li>从ElProcessor中找到eval方法</li>
</ul>
<figure><img src="/hexblog/imgs/211220/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>实例化时，调用eval方法，传参为x对应的值</li>
</ul>
<figure><img src="/hexblog/imgs/211220/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>即在实例化时，相当于执行下面这个方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>因此我们最终的服务端代码可以如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，服务端也需要依赖tomcat，对于SpringBoot项目，可以引入下面这个依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.实例演示</h3>
<p>客户端访问姿势与之前没有什么区别，我们这里基于SpringBoot起一个，主要是方便tomcat服务器的指定</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>客户端代码如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/211220/02.gif" alt="a.gif" tabindex="0" loading="lazy"><figcaption>a.gif</figcaption></figure>
<h3> 4.小结</h3>
<p>本文通过实例演示介绍了如何绕过<code>trustURLCodebase=false</code>的场景，从客户端执行逻辑出发，主要思路就是既然远程的class不可性，那就从目标服务器中去找一个满足条件的class，来执行注入代码</p>
<p>要满足我们注入条件的class，需要有下面这个关键要素</p>
<ul>
<li><code>javax.naming.spi.ObjectFactory</code>的子类</li>
<li><code>getObjectInstance</code>实现类中存在执行目标代码的场景</li>
</ul>
<p>此外就是借助脚本引擎来动态执行代码，本文是借助js，当然也可以考虑Groovy，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看到这里其实就会有个疑问点，常见的注入代码执行有哪些case呢？除了上面的脚本执行，还有别的么？且看下文</p>
<p><strong>相关博文</strong></p>
<p>本文主要思路来自于，欢迎有兴趣的小伙伴查看原文 * <a href="https://www.veracode.com/blog/research/exploiting-jndi-injections-java" target="_blank" rel="noopener noreferrer">Exploiting JNDI Injections in Java | Veracode blog</a></p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="JNDI"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-12-20T20:31:55.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">安全</title>
    <id>https://liuyueyi.github.io/tutorial/java/%E5%AE%89%E5%85%A8/</id>
    <link href="https://liuyueyi.github.io/tutorial/java/%E5%AE%89%E5%85%A8/"/>
    <updated>2025-02-13T08:59:24.000Z</updated>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2024-08-02T10:41:58.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1. Jackson 实用姿势小结</title>
    <id>https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/01.Jackson-%E5%AE%9E%E7%94%A8%E5%A7%BF%E5%8A%BF%E5%B0%8F%E7%BB%93.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/01.Jackson-%E5%AE%9E%E7%94%A8%E5%A7%BF%E5%8A%BF%E5%B0%8F%E7%BB%93.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>使用json进行数据交互可以说是非常常见的常见，在java侧，常用的json解析框架也不少，比如gson, fastjson以及spring mvc中默认使用的jackson；本文将主要介绍一下jackson的基本使用姿势，比如常见的</p>
<ul>
<li>普通对象转json字符串</li>
<li>json字符串转POJO，转Map/List</li>
<li>泛型支持</li>
<li>驼峰/下划线互转，自定义映射关系</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<p>使用json进行数据交互可以说是非常常见的常见，在java侧，常用的json解析框架也不少，比如gson, fastjson以及spring mvc中默认使用的jackson；本文将主要介绍一下jackson的基本使用姿势，比如常见的</p>
<ul>
<li>普通对象转json字符串</li>
<li>json字符串转POJO，转Map/List</li>
<li>泛型支持</li>
<li>驼峰/下划线互转，自定义映射关系</li>
</ul>
<!-- more -->
<h3> 1. 项目依赖</h3>
<p>使用maven来构建项目，需要使用Jackson进行序列化操作，核心引入下面的包</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 基本使用姿势</h3>
<p>在Jackson中，若希望实现序列化/反序列化，都离不开<code>ObjectMapper</code></p>
<p>比如将对象转Json String</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>反序列化</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<ul>
<li>jackson与gson/fastjson的一个显著区别在于它的序列化/反序列化有声明异常，使用时需要声明或者主动catch（这一点感觉不太友好）</li>
<li>其次，不推荐每次都创建一个ObjectMapper对象，可以考虑复用</li>
</ul>
<h3> 3. 泛型反序列化</h3>
<p>对于泛型的反序列化，直接使用上面，传入一个class对象，并不能很好的工作，和Gson/FastJson一样，Jackson也支持根据Type来返序列化</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点关注上面的传参，通过<code>objectMapper.getTypeFactory().constructType(type)</code>来创建需要的JavaType对象</p>
<p>一个demo使用姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 转Map/List</h3>
<p>转普通的Map/List没有什么特殊的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. JsonNode</h3>
<p>JsonNode为Jackson定义的节点对象，有些类似Gson的<code>JsonObject/JsonArray</code> 和 FastJson的<code>JSONObject/JSONArray</code>，使用它可以更友好的操作json对象（当然更推荐的是直接转JAVA bean）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用demo如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 驼峰与下划线</h3>
<p>常见的一个case，json字符串key为下划线，Java bean为驼峰命名，针对这种场景，jackson可以很方便的支持</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的代码也可以看出，驼峰与下划线的互转支持，主要是通过设置<code>PropertyNamingStrategies</code>来实现的，在jackson中，支持下面几种配置</p>
<ul>
<li><code>LOWER_CAMEL_CASE</code></li>
<li><code>UPPER_CAMEL_CASE</code></li>
<li><code>SNAKE_CASE</code></li>
<li><code>LOWER_CASE</code></li>
<li><code>KEBAB_CASE</code></li>
<li><code>LOWER_DOT_CASE</code></li>
</ul>
<p>使用上面这种方式适用于全局的下划线与驼峰的转换方式，如果我只希望针对单独某个类进行这样的设置呢？</p>
<p>可以借助注解<code>@JsonNaming</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个case中，如果我们将SimpleBean对象序列化为json串，即便调用的是前面最基础的使用姿势 <code>new ObjectMapper().writeValueAsString(simpleBean)</code>，输出的也是下划线格式的json串；同理反序列化时，也是将下划线转为驼峰</p>
<h3> 7. 字段别名</h3>
<p>上面介绍的是驼峰与下划线命名方式，当然也会有一些其他特殊的场景，针对某个字段进行别名设置，可以通过注解<code>@JsonProperties</code>来标注</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个表示序列化为json字符串时，userName对应的key为<code>user</code></p>
<h3> 8. 字段忽略</h3>
<p>在序列化时，难免会遇到某些字段不进行序列化/反序列化的场景，这里有两种常用的方式</p>
<h4> 8.1 @JsonIgnore注解</h4>
<p>直接在希望忽略的字段上添加注解<code>@JsonIgnore</code>即可，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 8.2 transient关键字</h4>
<p>除了使用上面的注解之外，也可以使用jdk原生提供的关键字<code>transient</code>来声明需要忽略的字段</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>重点注意：</strong></p>
<ul>
<li>在jackson中，默认的场景下，即便字段上修饰有<code>transient</code>关键字，也不会忽略还需要如下处理</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两种方式，都可以实现忽略<code>transient</code>关键字修饰的对象序列化</p>
<h3> 9. Java Bean约定</h3>
<h4> 9.1 get/set方法必须有</h4>
<p>Java Bean的get/set方法必须存在，否则额序列化与反序列化只会处理public修饰的成员</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>序列化后输出为 <code>{"desc":"hello world"}</code>； 反序列化也不会更新 <code>name</code>, <code>userId</code>；</p>
<p>特别的，当Java Bean对象，所有的成员都是private，又没有get方法时，在序列化时，会抛异常，提示信息如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 9.2 无参构造函数必须有</h4>
<p>如果java bean没有默认无参构造方法，那么在反序列化时，会抛出异常，无法实例化</p>
<p>一个如下的异常提示信息</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 10. Json串存在Bean未定义字段忽略设置</h3>
<p>默认的使用姿势下，若json串中存在一个bean未定义的kv，会抛异常，一个示例如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果希望忽略这种场景，那么就需要禁用<code>FAIL_ON_UNKNOWN_PROPERTIES</code>配置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>扩展知识点</strong></p>
<ul>
<li>对于Spring MVC而言，默认使用的是Jackson序列化框架，如果我们定义接收参数为json串，那么当前端传参多了一个未定义的字段，会直接抛异常么？</li>
</ul>
<h3> 11. 序列化输出时忽略null</h3>
<p>默认场景下，将一个bean对象序列化为json串，即便成员变量为null，也会输出，如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种case某些场景下是合适的，比如生成接口文档示例时，更关心的是参数说明，即便为null，也是希望有这个；但是另外一些场景下则希望忽略，毕竟可以节省对象大小</p>
<p>需要忽略null字段时，可以如下设置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>关键点就是配置 <code>setSerializationInclusion(JsonInclude.Include.NON_NULL)</code></p>
<h3> 12. key为null场景兼容</h3>
<p>对于普通的Java bean而言，不存在key为null的场景，但是如果是将一个Map对象，输出为json串时，那么就可能出现这种场景了，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个执行，直接抛异常</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果希望兼容这个场景，则可以如下处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个做法，就是将key为null的，以<code>null</code>字符串来替代</p>
<p><strong>说明</strong></p>
<ul>
<li>既然key可能为null，当然也为其他类型，但是在序列化输出时，会转String</li>
</ul>
<p>如下面这个case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出的字符串为</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 13 其他</h3>
<p>以上的知识点，基本上可以覆盖我们日常在使用Jackson进行序列化和反序列化中95%的场景，至于其他的比如自定义Name策略，反序列化的默认值类型，类型转换，json注释的支持与否等相对少见的姿势，看后续是否有空补上</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="Jackson"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-08-07T09:48:00.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">2. Gson 简单使用姿势小结</title>
    <id>https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/02.Gson-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E5%B0%8F%E7%BB%93.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/02.Gson-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E5%B0%8F%E7%BB%93.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>关于Json序列化的框架可以说比较多了，比如Spring默认的Jackson，国内互联网用的比较多的FastJson，本文则主要介绍一下Gson的简单使用姿势，并不会涉及到不同的json框架的性能对比</p>
<blockquote>
<p>本文主要内容来源于官方教程: <a href="https://github.com/google/gson/blob/master/UserGuide.md" target="_blank" rel="noopener noreferrer">https://github.com/google/gson/blob/master/UserGuide.md</a></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<p>关于Json序列化的框架可以说比较多了，比如Spring默认的Jackson，国内互联网用的比较多的FastJson，本文则主要介绍一下Gson的简单使用姿势，并不会涉及到不同的json框架的性能对比</p>
<blockquote>
<p>本文主要内容来源于官方教程: <a href="https://github.com/google/gson/blob/master/UserGuide.md" target="_blank" rel="noopener noreferrer">https://github.com/google/gson/blob/master/UserGuide.md</a></p>
</blockquote>
<!-- more -->
<h3> 1. 依赖导入</h3>
<p>首先我们借助maven来引入依赖包，按照自己的实际情况选择一个版本（简单的使用姿势与具体的版本并没有太大的关联性）</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 基本的序列化与反序列化</h3>
<p>一般来讲，我们通过Gson对象来实现Json的序列化与反序列化，如下是几个简单的序列化与反序列化的case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的case中，主要就是借助<code>gson.toJson</code>来输出Json字符串，借助<code>gson.fromJson</code>返序列化得到对象</p>
<h3> 3. 对象序列化</h3>
<p>对象的序列化与反序列化可以说是最常见的，在Gson的使用过程中，推荐的对象写法</p>
<ul>
<li>filed：private 修饰</li>
<li>不希望序列化的成员，添加<code>transient</code>修饰符</li>
<li>默认无参构造方法(可选，这里跟人推荐保留，不同于FastJson的必须存在)</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的使用姿势和前面并没有什么本质的区别，接下来看一下输出结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>请注意：</strong></p>
<ul>
<li>输出json串时，null和<code>transient</code>修饰的成员不会输出到json串中</li>
<li>对象没有Get/Set方法，也依然可以反序列化(对象也没有继承自Serialize接口，当然我个人的观点是请继承Serialize接口)</li>
</ul>
<p>如果我希望将null的成员，也可以输出到json串，可以如下操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>说明：如果希望扩展序列化方式，通过GsonBuilder来构建Gson对象是一个不错的选择</strong></p>
<h3> 4. JsonObject与JsonArray</h3>
<p>某些场景下我们可能并没有定义反序列化的数据对象，比如FastJson中的直接反序列化为<code>JSONObject/JSONArray</code>，然后手动获取数据进行业务处理，这种场景下，gson可以如何支持呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，我们这里主要借助的是<code>JsonParser.parseString</code>方法，输入参数可以是String也可以是流，返回的是<code>JsonElement</code>对象，这个对象比较有意思，提供了一些基础的类型输出方法如</p>
<ul>
<li>getAsString: 返回String</li>
<li>getAsInt: 返回int</li>
<li>getAsJsonArray: 返回JsonArray（json数组）</li>
<li>getAsJsonObject: 返回JsonObject (Json对象)</li>
<li>...</li>
</ul>
<figure><img src="/hexblog/imgs/200826/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 泛型序列化</h3>
<p>以上属于常规的基本使用姿势，实际的工作中，关于泛型的序列化和反序列化可以说非常常见了，那么应该如何处理呢</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/200826/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面的核心在于Type的生成: <code>new TypeToken&lt;ResWrapper&lt;User&gt;&gt;() {}.getType();</code></p>
<h3> 6. 进阶</h3>
<p>以上内容基本上可以覆盖日常业务开发中90%的场景，当然gson也支持一些更高级的功能</p>
<p><strong>如filed name映射</strong></p>
<ul>
<li><code>@SerializedName("custom_naming") </code></li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>如版本支持</strong></p>
<ul>
<li><code>@Since(1.1)</code></li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>自定义的类型转换</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>可视化的json输出</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="Gson"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2020-08-26T08:46:13.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">3. Json序列化框架对比与最佳实践推荐</title>
    <id>https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/03.Json%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%8E%A8%E8%8D%90.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/03.Json%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%8E%A8%E8%8D%90.html"/>
    <updated>2024-08-06T00:41:18.000Z</updated>
    <summary type="html"><![CDATA[<p>Java 生态中，最最常见的json序列化工具有三个jackson, gson, fastsjon，当然我们常用的也就是这几个</p>
<blockquote>
<p><a href="https://mvnrepository.com/open-source/json-libraries" target="_blank" rel="noopener noreferrer">https://mvnrepository.com/open-source/json-libraries</a></p>
</blockquote>
<figure><img src="/hexblog/imgs/210715/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>json协议虽然是一致的，但是不同的框架对json的序列化支持却不尽相同，那么在项目中如何使用这些框架，怎样的使用才算优雅呢？</p>
]]></summary>
    <content type="html"><![CDATA[<p>Java 生态中，最最常见的json序列化工具有三个jackson, gson, fastsjon，当然我们常用的也就是这几个</p>
<blockquote>
<p><a href="https://mvnrepository.com/open-source/json-libraries" target="_blank" rel="noopener noreferrer">https://mvnrepository.com/open-source/json-libraries</a></p>
</blockquote>
<figure><img src="/hexblog/imgs/210715/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>json协议虽然是一致的，但是不同的框架对json的序列化支持却不尽相同，那么在项目中如何使用这些框架，怎样的使用才算优雅呢？</p>
<!-- more -->
<p>Spring本身提供了比较多这种case，比如RestTemplate, RedisTemplate，可以让底层的redis\http依赖包无缝切换；因此我们在使用序列化框架的时，也应该尽量向它靠齐</p>
<p>以下为我认为在使用json序列化时，比较好的习惯</p>
<h2> I. 推荐规范</h2>
<h3> 1. Java Bean实现Serializable接口</h3>
<p>遵循jdk的规范，如果一个Java Bean会被序列化（如对外提供VO/DTO对象）、持久化（如数据库实体Entity），建议实现<code>Serializable</code>接口，并持有一个<code>serialVersionUID</code>静态成员</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>why?</p>
<ul>
<li>声明为Serializable接口的对象，可以被序列化，jdk原生支持；一般来讲所有的序列化框架都认这个；如果一个对象没有实现这个接口，则不能保证所有的序列化框架都能正常序列化了</li>
<li>实现Serializable接口的，务必不要忘了初始化<code>serialVersionUID</code>(直接通过idea自动生成即可)
<ul>
<li>idea设置自动生成提示步骤：</li>
<li><code>settings -&gt; inspections -&gt; Serializable class without serialVersionUID</code> 勾选</li>
</ul>
</li>
</ul>
<h3> 2. 忽略字段</h3>
<p>若实体中，某些字段不希望被序列化时，各序列化框架都有自己的支持方式，如:</p>
<ul>
<li>FastJson，使用JSONField注解</li>
<li>Gson，使用Expose注解</li>
<li>Jackson，使用JsonIgnore注解</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里强烈推荐使用jdk原生的关键字<code>transient</code>来修饰不希望被反序列化的成员</p>
<ul>
<li>优点：通用性更强</li>
</ul>
<p><strong>重点注意</strong></p>
<p>在使用jackson序列化框架时，成员变量如果有get方法，即便它被<code>transient</code>关键字修饰，输出json串的时候，也不会忽略它</p>
<blockquote>
<p>说明链接: <a href="https://stackoverflow.com/questions/21745593/why-jackson-is-serializing-transient-member-also" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/21745593/why-jackson-is-serializing-transient-member-also</a></p>
</blockquote>
<p>两种解决办法:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然jackson默认对<code>transient</code>关键字适配不友好，但是依然推荐使用这个关键字，然后添加上面的配置，这样替换json框架的时候，不需要修改源码</p>
<h3> 3. 不要用Map/List接收json串</h3>
<p>Java作为强类型语言在项目维护上有很高的优势，接收json串，推荐映射为对应的Java Bean，尽量不要用Map/List容器来接收，不然参数类型可能导致各种问题，可以看下面的默认值那一块说明</p>
<h2> II. 不同框架的差异性</h2>
<p>接下来将重点关注下三个框架在我们日常使用场景下的区别，定义一个Java Bean</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1. json字段映射缺失场景</h3>
<p>如果json字符串中，存在一个key，在定义的bean对象不存在时，上面三种序列化框架的表现形式也不一样</p>
<p>json串如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这个json中，userSkills2这个字段，和SimpleBean映射不上，如果进行反序列化，会出现下面的场景</p>
<ul>
<li>fastjson, gson 会忽略json字符串中未匹配的key；jackson会抛异常</li>
</ul>
<p>若jackson希望忽略异常，需要如下配置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 字段没有get/set方法</h3>
<p>若某个private字段没有get/set方法时，这个字段在序列化与反序列化时，表现不一致（public修饰话都可以序列化）</p>
<ul>
<li>gson: 可以序列化</li>
<li>fastjson/jackson:  忽略这个字段</li>
</ul>
<p>对于jackson，如果希望序列化一个没有<code>get/set</code>方法的属性时，如下设置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>fastjson，貌似没有相关的方法</p>
<p><strong>注意</strong></p>
<ul>
<li>建议对Java bean的字段添加get/set方法</li>
<li>若有 <code>getXxx()</code> 但是又没有属性<code>xxx</code>，会发现在序列化之后会多一个 <code>xxx</code></li>
</ul>
<h3> 3. value为null时，序列化时是否需要输出</h3>
<p>如果java bean中某个成员为null，默认表现如下</p>
<ul>
<li>fastjson/gson: 忽略这个字段</li>
<li>jackson:  保存这个字段，只是value为null</li>
</ul>
<p>如jackson对应的json串</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通常来讲，推荐忽略null，对此jackson的设置如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果null也希望输出（比如Swagger接口文档，需要把所有的key都捞出来），如下设置</p>
<p>fastjson配置如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>gson配置如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明</strong></p>
<ul>
<li>一般来讲，在序列化的时候，推荐忽略value为null的字段</li>
<li>jackson默认不会忽略，需要设置关闭</li>
</ul>
<h3> 4. 默认值</h3>
<p>将一个json串，转换为Map/List时，可以看到不同的数据类型与java数据类型的映射关系，下面是一些特殊的场景：</p>
<table>
<thead>
<tr>
<th>json数据类型</th>
<th>fastjson</th>
<th>gson</th>
<th style="text-align:left">jackson</th>
</tr>
</thead>
<tbody>
<tr>
<td>浮点数</td>
<td>BigDecimal</td>
<td>double</td>
<td style="text-align:left">double</td>
</tr>
<tr>
<td>整数</td>
<td>int/long</td>
<td>double</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td>对象</td>
<td>JSONObject</td>
<td>LinkedTreeMap</td>
<td style="text-align:left">LinkedHashMap</td>
</tr>
<tr>
<td>数组</td>
<td>JSONArray</td>
<td>ArrayList</td>
<td style="text-align:left">ArrayList</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>null</td>
<td style="text-align:left">null</td>
</tr>
<tr>
<td>输出Map</td>
<td>HashMap</td>
<td>LinkedTreeMap</td>
<td style="text-align:left">LinkedHashMap</td>
</tr>
</tbody>
</table>
<p>如果希望三种框架保持一致，主要需要针对以下几个点：</p>
<ul>
<li>浮点数 -》 double</li>
<li>整数  -》 int/long</li>
<li>数组 -》 ArrayList</li>
<li>Map -》是否有序</li>
</ul>
<blockquote>
<p>输出map，虽然类型不一致，一般来说问题不大，最大的区别就是gson/jackson保证了顺序，而FastJson则没有</p>
</blockquote>
<p>fastjson额外配置如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>数组转List而不是JSONArray，这个配置暂时未找到，可考虑自定义<code>ObjectDeserializer</code>来支持</li>
<li>Object转有序Map的配置也未找到，</li>
</ul>
<p>gson：</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/15507997/how-to-prevent-gson-from-expressing-integers-as-floats" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/15507997/how-to-prevent-gson-from-expressing-integers-as-floats</a></p>
</blockquote>
<p>对于gson而言，也没有配置可以直接设置整数转int/long而不是double，只能自己来适配</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后注册到Gson</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>jackson 就没有什么好说的了</p>
<p>在json字符串映射到Java的Map/List容器时，获取到的数据对象和预期的可能不一样，不同的框架处理方式不同；所以最佳的实践是：</p>
<ul>
<li>json字符串映射到Java bean，而不是容器</li>
<li>如果映射到容器时，取数据时，做好类型兼容，完全遵循json的规范
<ul>
<li>String：对应java的字符串</li>
<li>boolean: 对应java的Boolean</li>
<li>数值：对应Java的double
<ul>
<li>原则上建议不要直接存数值类型，对于浮点数会有精度问题，用String类型进行替换最好</li>
<li>如确实为数值，为了保证不出问题，可以多绕一圈，如</li>
<li><code>Double.valueOf(String.valueOf(xxx)).xxxValue()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3> 5. key非String类型</h3>
<p>一般来说不存在key为null的情况，但是map允许key为null，所以将一个map序列化为json串的时候，就有可能出现这种场景</p>
<p>FastJson 输出</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Gson输出</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Jackson直接抛异常</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>说明</strong></p>
<ul>
<li>对于FastJson而言，若key不是String，那么输出为Json串时，key上不会有双引号，这种是不满足json规范的</li>
<li>gson则不管key是什么类型，都会转string</li>
<li>jackson 若key为非string类型，非null，则会转String</li>
</ul>
<p>推荐采用gson/jackson的使用姿势，key都转String，因此FastJson的姿势如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对于key为null，jackson的兼容策略</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 类型不匹配</h3>
<p>String转其他基本类型（int/long/float/double/boolean），若满足<code>Integer.valueOf(str)</code>这种，则没有问题，否则抛异常</p>
<h3> 7. 未知属性</h3>
<p>当json串中有一个key，在定义的bean中不存在，表现形式也不一样</p>
<ul>
<li>fastjson: 忽略这个key</li>
<li>gson：忽略</li>
<li>jackson: 抛异常</li>
</ul>
<p>一般来说，忽略是比较好的处理策略，jackson的配置如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8. 循环引用</h3>
<p>对于循环引用序列化时，不同的框架处理策略也不一致</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出json串如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了上面这种自引用的case，更常见的是另外一种循环引用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次序列化，表现如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从安全性来看，FastJson的处理方式是比较合适的，针对Gson/Jackson，到没有比较简单的设置方式</p>
<p>一般来说，如果有循环引用的场景，请忽略这个字段的序列化，推荐添加 <code>transient</code>关键字</p>
<h3> 9. 驼峰与下划线</h3>
<p>java采用驼峰命名格式，php下划线的风格，他们两个之间的交互通常会面临这个问题</p>
<table>
<thead>
<tr>
<th>FastJson</th>
<th>Gson</th>
<th>Jackson</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认支持智能转换，也可以通过<code>@JSONField</code></td>
<td><code>@SerializedName</code></td>
<td><code>@JsonProperty</code></td>
</tr>
</tbody>
</table>
<p>虽然三种框架都提供了通过注解，来自定义输出json串的key的别名，但是更推荐使用全局的设置，来实现统一风格的转驼峰，转下划线</p>
<p><strong>FastJson 驼峰转下换线</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Gson 实现驼峰与下换线互转</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Jackson实现驼峰与下划线的转换</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明</strong></p>
<ul>
<li>对于Gson/Jackson而言，如果使用上面的驼峰转下划线的json串，那么反序列化的时候也需要使用对应的下划线转驼峰的方式</li>
<li>FastJson则默认开启驼峰与下划线的互转</li>
</ul>
<h3> 10. JsonObject,JsonArray</h3>
<p>通常在java 生态中，更常见的是将Json串转为Java Bean，但某些场景也会希望直接获取JsonObject，JsonArray对象，当然是可以直接转为Map/List，使用前者的好处就是可以充分利用JsonElement的一些特性，如更安全的类型转换等</p>
<p>虽说三个框架的使用姿势不一样，但最终的表现差不多</p>
<p><strong>FastJson</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Gson</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Jackson</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这些没啥好说的，但是，请一定注意，不要多个json工具混用，比如Gson反序列化为JsonObject，然后又使用Jackson进行序列化，可能导致各种鬼畜的问题</p>
<p>简单来说，就是不要尝试对<code>JSONObject/JSONArray</code>, <code>JsonObject/JsonArray</code>, <code>JsonNode</code>调用 <code>jsonutil.encode</code></p>
<p>如果想输出json串，请直接调用 <code>toString/toJSONString</code>，千万不要搞事情</p>
<h3> 11. 泛型</h3>
<p>Json串，转泛型bean时，虽然各框架都有自己的TypeReference，但是底层的<code>Type</code>都是一致的</p>
<p><strong>FastJson</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Gson</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Jackson</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> III. 小结</h2>
<p>上面内容比较多，下面是提炼的干货</p>
<p><strong>序列化</strong></p>
<ul>
<li>java bean
<ul>
<li>继承<code>Serializable</code>接口，持有<code>serialVersionUID</code>属性</li>
<li>每个需要序列化的，都需要有get/set方法</li>
<li>无参构造方法</li>
</ul>
</li>
<li>忽略字段
<ul>
<li>不希望输出的属性，使用关键字<code>transient</code>修饰，注意jackson需要额外配置</li>
</ul>
</li>
<li>循环引用
<ul>
<li>源头上避免出现这种场景，推荐直接在属性上添加 <code>transient</code>关键字</li>
</ul>
</li>
<li>忽略value为null的属性</li>
<li>遵循原生的json规范
<ul>
<li>即不要用单引号替换双引号</li>
<li>key都要用双引号包裹</li>
</ul>
</li>
<li>不要出现key为null的场景</li>
</ul>
<p><strong>反序列化</strong></p>
<ul>
<li>默认值
<ul>
<li>浮点型：转double，fastjson默认转为BigDecimal，需要额外处理</li>
<li>整数：转int/long
<ul>
<li>gson 默认转为double，需要额外处理</li>
</ul>
</li>
<li>对象:  转Map
<ul>
<li>fastJson需要额外处理</li>
</ul>
</li>
<li>数组: 转List
<ul>
<li>fastJson转成了JSONArray，需要注意</li>
</ul>
</li>
</ul>
</li>
<li>未知属性，忽略
<ul>
<li>json串中有一个bean未定义的属性，建议直接忽略掉</li>
<li>jackson需要额外配置</li>
</ul>
</li>
<li>泛型：
<ul>
<li>使用Type来精准的反序列化</li>
</ul>
</li>
</ul>
<p><strong>驼峰与下划线的互转</strong></p>
<ul>
<li>建议规则统一，如果输出下划线，就所有的都是下划线风格；不要出现混搭</li>
<li>不建议使用注解的别名方式来处理，直接在工具层进行统一是更好的选择，不会出现因为json框架不一致，导致结果不同的场景</li>
</ul>
<table>
<thead>
<tr>
<th>说明</th>
<th>实践策略</th>
<th>fastjson</th>
<th>gson</th>
<th>jackson</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java Bean</td>
<td>实现Serializable接口</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Java Bean</td>
<td>get/set方法，无参构造函数</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>key为null</td>
<td>原则上不建议出现这种场景；如出现也不希望抛异常</td>
<td>-</td>
<td>-</td>
<td><code>objectMapper.getSerializerProvider().setNullKeySerializer</code></td>
</tr>
<tr>
<td>循环引用</td>
<td>源头上避免这种场景</td>
<td>本身兼容</td>
<td>抛异常</td>
<td>抛异常</td>
</tr>
<tr>
<td>key非String</td>
<td>输出Json串的key转String</td>
<td><code>JSONObject.toJSONString(map,SerializerFeature.WriteNonStringKeyAsString)</code></td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>忽略字段</td>
<td>transient 关键字</td>
<td>无需适配</td>
<td>无需适配</td>
<td>case1: <code>objectMapper.configure(MapperFeature.PROPAGATE_TRANSIENT_MARKER, true);</code> <br>case2: <code>objectMapper.setVisibility(objectMapper.getSerializationConfig().getDefaultVisibilityChecker().withFieldVisibility(JsonAutoDetect.Visibility.ANY).withGetterVisibility(JsonAutoDetect.Visibility.NONE).withIsGetterVisibility(JsonAutoDetect.Visibility.NONE))</code>;</td>
</tr>
<tr>
<td>值为null</td>
<td>忽略</td>
<td>无需适配</td>
<td>无需适配</td>
<td><code>objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</code></td>
</tr>
<tr>
<td>属性找不到</td>
<td>忽略</td>
<td>无需适配</td>
<td>无需适配</td>
<td><code>objectMapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</code></td>
</tr>
<tr>
<td>反序列化默认值</td>
<td>浮点数转double</td>
<td>JSONObject.parseObject(str, Map.class,JSON.DEFAULT_PARSER_FEATURE &amp; ~Feature.UseBigDecimal.getMask())</td>
<td>无需适配</td>
<td>无需适配</td>
</tr>
<tr>
<td>反序列化默认值</td>
<td>整数转int/long</td>
<td>无需适配</td>
<td>自定义JsonDeserializer，见上文</td>
<td>无需适配</td>
</tr>
<tr>
<td>反序列化默认值</td>
<td>对象转map</td>
<td><code>JSON.DEFAULT_PARSER_FEATURE 1 Feature.CustomMapDeserializer.getMask()</code></td>
<td>无需适配</td>
<td>无需适配</td>
</tr>
<tr>
<td>驼峰与下划线</td>
<td>统一处理</td>
<td>反序列化自动适配，序列化见上文</td>
<td>驼峰转下划线<br>下划线转驼峰必须配套使用</td>
<td>驼峰转下划线<br>下划线转驼峰必须配套使用</td>
</tr>
<tr>
<td>泛型</td>
<td>Type是最好的选择</td>
<td><code>new com.alibaba.fastjson.TypeReference&lt;br /&gt;&lt;GenericBean&lt;Map&gt;&gt;() {}.getType()</code></td>
<td><code>new com.google.gson.reflect.TypeToken&lt;br /&gt;&lt;GenericBean&lt;Map&gt;&gt;() {}.getType()</code></td>
<td><code>new com.fasterxml.jackson.core.type.TypeReference&lt;GenericBean&lt;Map&gt;&gt;() {}.getType()</code></td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="Json"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-07-15T17:33:34.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">4. FastJson序列化对象中非字符串类型key输出非标准格式json串问题记录</title>
    <id>https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/04.FastJson%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E4%B8%AD%E9%9D%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8Bkey%E8%BE%93%E5%87%BA%E9%9D%9E%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8Fjson%E4%B8%B2%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/04.FastJson%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E4%B8%AD%E9%9D%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8Bkey%E8%BE%93%E5%87%BA%E9%9D%9E%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8Fjson%E4%B8%B2%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>采用fastjson作为项目的json序列化和反序列化工具，遇到一个蛋疼至极的问题, 如Map，key为int，则输出的字符串中，key没有被双引号括起来，导致前端解析失败</p>
]]></summary>
    <content type="html"><![CDATA[<p>采用fastjson作为项目的json序列化和反序列化工具，遇到一个蛋疼至极的问题, 如Map，key为int，则输出的字符串中，key没有被双引号括起来，导致前端解析失败</p>
<!-- more -->
<h3> 1. 问题复现</h3>
<p><strong>环境相关</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>测试case</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了对比，把gson也加进来了，输出结果如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>针对fastjson的输出，js的序列化直接异常</p>
<figure><img src="/hexblog/imgs/190412/00.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
<h3> 2. 兼容方案</h3>
<p>既然fastjson有这个问题，那有必要看一下有没有使用方式来避免这个问题了，看一下fastjson的常用序列化方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们常用的是上面的第一个方法，看到上面的第二个方法，自然可以想到，是不是可以通过传参来设置序列化的一些属性， <code>SerializerFeature</code> 是一个枚举，进去查看，会找到一些有意思的参数，如<code>SerializerFeature.WriteNonStringKeyAsString</code>将非字符串的key装换为String</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<figure><img src="/hexblog/imgs/190412/01.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="问题记录"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-04-12T14:22:40.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">5. Gson之序列化指定忽略字段的写法</title>
    <id>https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/05.Gson%E4%B9%8B%E5%BA%8F%E5%88%97%E5%8C%96%E6%8C%87%E5%AE%9A%E5%BF%BD%E7%95%A5%E5%AD%97%E6%AE%B5%E7%9A%84%E5%86%99%E6%B3%95.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/05.Gson%E4%B9%8B%E5%BA%8F%E5%88%97%E5%8C%96%E6%8C%87%E5%AE%9A%E5%BF%BD%E7%95%A5%E5%AD%97%E6%AE%B5%E7%9A%84%E5%86%99%E6%B3%95.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>在我们日常使用json序列化框架过程中，经常会遇到在输出json字符串时，忽略某些字段，那么在Gson框架中，要想实现这种方式，可以怎么处理呢？</p>
<p>本文介绍几种常见的姿势</p>
]]></summary>
    <content type="html"><![CDATA[<p>在我们日常使用json序列化框架过程中，经常会遇到在输出json字符串时，忽略某些字段，那么在Gson框架中，要想实现这种方式，可以怎么处理呢？</p>
<p>本文介绍几种常见的姿势</p>
<!-- more -->
<h3> 1. transient关键字</h3>
<p>最容易想到的case，就是直接借助jdk的transient关键字来修饰不希望输出的对象，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的对象中，pwd前面使用<code>transient</code>进行修饰，那么在输出json串时，默认会忽略</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. expose注解</h3>
<p>借助gson提供的expose注解，也可以实现上面的case，如在需要保留的字段上添加<code>@Expose</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们使用的地方，注意通过 <code>GsonBuilder</code>来创建Gson对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种使用姿势感觉有点怪怪的，在需要保留的字段上添加注解，这种使用方式并没有jackson的<code>@JsonIgnore</code>方式来得方便</p>
<h3> 3. 自定义排查策略ExclusionStrategy</h3>
<p>除了上面两种方式之外，通过自定义的排除策略可以实现即使不修改bean，也能指定哪些字段不序列化</p>
<p>一个简单的demo如下，如果包含自定义的注解，则不序列化，或者field_name == pwd也不序列化</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种姿势，更适用于有自定义需求场景的case，那么问题来了，如果我希望序列化的对象，并不是JOPO对象，比如传入的是一个Map，也希望针对某些key进行忽略，可以怎么整呢？</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="Gson"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-10-25T14:26:04.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">6. Gson实现Map忽略指定key序列化输出策略</title>
    <id>https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/06.Gson%E5%AE%9E%E7%8E%B0Map%E5%BF%BD%E7%95%A5%E6%8C%87%E5%AE%9Akey%E5%BA%8F%E5%88%97%E5%8C%96%E8%BE%93%E5%87%BA%E7%AD%96%E7%95%A5.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/06.Gson%E5%AE%9E%E7%8E%B0Map%E5%BF%BD%E7%95%A5%E6%8C%87%E5%AE%9Akey%E5%BA%8F%E5%88%97%E5%8C%96%E8%BE%93%E5%87%BA%E7%AD%96%E7%95%A5.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>前面介绍了几种gson在序列化时，忽略某些字段数输出的方式，然而当时的实例中，需要序列化的对象都是Java bean对象，如果我们需要序列化的是Map对象，又可以怎么处理呢？</p>
]]></summary>
    <content type="html"><![CDATA[<p>前面介绍了几种gson在序列化时，忽略某些字段数输出的方式，然而当时的实例中，需要序列化的对象都是Java bean对象，如果我们需要序列化的是Map对象，又可以怎么处理呢？</p>
<!-- more -->
<p>接下来我们通过实际的case，来演示如何实现Map忽略指定key的功能</p>
<p>这里主要用到的知识点是Gson提供的扩展<code>TypeAdapter</code>，通过自定义的适配器，来实现自定义的序列化/反序列化，如我们需要实现的逻辑如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面实现逻辑中的<code>write</code>方法，遍历map，这里默认将所有的key都当成String格式，内部的实现主要是基于gson的流式序列化策略来完成的（<code>JsonWrite</code>流式序列化，下篇博文介绍）</p>
<p>其次对于value的输出，这里做了简单的适配，如果是非基础类型，这里并没有使用普通的Gson进行转换，而是借助了递归的思路，关键点在于 <code>etGson()</code>的实现逻辑</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来写个简单的case验证一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意查看上面的实现，第一行是忽略了<code>pwd</code>的json串，第二行则是普通的Gson输出的json串；虽然第一个满足了我们的需求，但是<code>sub</code>的value从object变成了String，这个和我们的预期的不太一致，接下来，下一篇博文流式序列化将带来解决方案</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="Gson"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-10-28T21:59:01.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">7. Gson流式序列化JsonWriter</title>
    <id>https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/07.Gson%E6%B5%81%E5%BC%8F%E5%BA%8F%E5%88%97%E5%8C%96JsonWriter.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/07.Gson%E6%B5%81%E5%BC%8F%E5%BA%8F%E5%88%97%E5%8C%96JsonWriter.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>通常我们序列化使用时，是直接使用Gson将整个对象转换为Json串，如果有看过gson源码的小伙伴会发现其内部实际上是基于JsonWriter来实现流式序列化的</p>
<p>接下来我们来看一下JsonWriter的使用姿势</p>
]]></summary>
    <content type="html"><![CDATA[<p>通常我们序列化使用时，是直接使用Gson将整个对象转换为Json串，如果有看过gson源码的小伙伴会发现其内部实际上是基于JsonWriter来实现流式序列化的</p>
<p>接下来我们来看一下JsonWriter的使用姿势</p>
<!-- more -->
<p>首先需要获取JsonWriter对象，在创建时需要指定输出流</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来看一下流式的序列化输出可以怎么整</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，对于普通对象而言，流式使用 <code>beginObject()</code> 开头，使用<code>endObject()</code>结尾</p>
<p>在中间，通过 name指定json串的key，value为json串的值</p>
<p>比如上面的执行输出为</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果对象内部嵌套了对象或者数组，同样是通过<code>beginObject/beginArray</code>来处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下:</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="Gson"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-10-30T19:32:36.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">8. Gson流式反序列化JsonReader</title>
    <id>https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/08.Gson%E6%B5%81%E5%BC%8F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/08.Gson%E6%B5%81%E5%BC%8F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>前面介绍了一片Gson的流式序列化，接下来我们看一下流式的反序列化，主要借助JsonReader来实现</p>
]]></summary>
    <content type="html"><![CDATA[<p>前面介绍了一片Gson的流式序列化，接下来我们看一下流式的反序列化，主要借助JsonReader来实现</p>
<!-- more -->
<h3> 1. 关键类与方法</h3>
<p>流式反序列化，关键实现类为 JsonReader，每次在使用前后需要通过 <code>beginObject</code>/<code>endObject</code>来声明一个序列化的过程</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 实例演示</h3>
<p>接下来通过一个实例来演示流式的反序列化过程</p>
<p>json串 <code>"{\"user\": \"一灰灰blog\", \"age\": 18}"</code></p>
<p>反序列化过程</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的反序列化case，可以看出对于一层json串而言，比较简单，那么如果json串中的value是一个对象，或者数组，那改怎么处理呢？</p>
<p>如我们在User类中，新增一个列表对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="Gson"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-11-05T18:26:30.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">9. ProtoStuff无法反序列化Deprecated注解成员问题记录</title>
    <id>https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/09.ProtoStuff%E6%97%A0%E6%B3%95%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Deprecated%E6%B3%A8%E8%A7%A3%E6%88%90%E5%91%98%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/09.ProtoStuff%E6%97%A0%E6%B3%95%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Deprecated%E6%B3%A8%E8%A7%A3%E6%88%90%E5%91%98%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>今天开发过程中，遇到一个鬼畜的问题，在DO的某个成员上添加<code>@Deprecated</code>注解之后，通过ProtoStuff反序列化得到的DO中，这个成员一直为null；花了不少时间才定位这个问题，特此记录一下</p>
]]></summary>
    <content type="html"><![CDATA[<p>今天开发过程中，遇到一个鬼畜的问题，在DO的某个成员上添加<code>@Deprecated</code>注解之后，通过ProtoStuff反序列化得到的DO中，这个成员一直为null；花了不少时间才定位这个问题，特此记录一下</p>
<!-- more -->
<h2> I. 全程实录</h2>
<h3> 1. 环境相关</h3>
<p>原项目中使用protostuff作为POJO序列化工具，对应的版本为</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 场景复现</h3>
<p>写了一个简单的demo，我们在POJO中添加一个拥有删除注解的成员，然后查看下反序列化结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是测试输出，可以看到反序列化的结果中，b为null</p>
<figure><img src="/hexblog/imgs/190821/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>自然就会有个疑问，是在序列化的时候直接丢掉了这个成员信息呢，还是反序列化的时候跳过了这个成员？</p>
<p>我们新增一个POJO，与BDO的成员类似，只是没有<code>@Deprecated</code>注解</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后验证下BDO序列化的结果，通过反序列化为NDO对象，如果b成员有值，说明在序列化的时候并没有丢掉；</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从下面的输出可以看到，反序列化不出来，在序列化的时候就已经丢掉了</p>
<figure><img src="/hexblog/imgs/190821/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接着我们再验证下NDO序列化的结果，因为没有Deprecated注解，反序列化为NDO对象时，应该是齐全的，那么反序列化为BDO呢</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从下面的输出可以看出，反序列化时，成员上有<code>@Deprecated</code>注解时，也无法获取正确的结果</p>
<figure><img src="/hexblog/imgs/190821/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 兼容方案</h3>
<p>查了下protostuf的相关文档，个人感觉它的设计理念就是认为加了这个删除注解，就没有必要继续存在了，就直接给忽略了。那么我希望加上了这个注解的可以被序列化/反序列化，有办法么？</p>
<p>查看api的时候，发现在创建Schema的时候，有个方法<code>io.protostuff.runtime.RuntimeSchema#createFrom(java.lang.Class&lt;T&gt;, java.util.Map&lt;java.lang.String,java.lang.String&gt;, io.protostuff.runtime.IdStrategy)</code>， 可以指定成员列表</p>
<p>于是我们就有了一个猥琐的兼容方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试结果如下，反序列化的实例中有相应的数据了</p>
<figure><img src="/hexblog/imgs/190821/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 小结</h3>
<p>遵循ProtoStuff的使用规范，如果一个成员上有注解<code>@Deprecated</code>，那么这个成员的数据将不会被序列化和反序列化</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="问题记录"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-08-21T19:11:24.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">10. ProtoStuff不支持BigDecimal序列化/反序列化记录</title>
    <id>https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/10.ProtoStuff%E4%B8%8D%E6%94%AF%E6%8C%81BigDecimal%E5%BA%8F%E5%88%97%E5%8C%96-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AE%B0%E5%BD%95.html</id>
    <link href="https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/10.ProtoStuff%E4%B8%8D%E6%94%AF%E6%8C%81BigDecimal%E5%BA%8F%E5%88%97%E5%8C%96-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AE%B0%E5%BD%95.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>平时使用ProtoStuff作为序列化工具，对于一些POJO对象序列化，但是在实际使用中，发现针对BigDecimal对象进行序列化时却出现了问题</p>
<ul>
<li>不管什么数，生成的byte数组都一样</li>
<li>无法正确反序列化</li>
</ul>
<p>下面记录一下这个问题</p>
]]></summary>
    <content type="html"><![CDATA[<p>平时使用ProtoStuff作为序列化工具，对于一些POJO对象序列化，但是在实际使用中，发现针对BigDecimal对象进行序列化时却出现了问题</p>
<ul>
<li>不管什么数，生成的byte数组都一样</li>
<li>无法正确反序列化</li>
</ul>
<p>下面记录一下这个问题</p>
<!-- more -->
<h3> 1. 场景复现</h3>
<p>我们使用的protostuff依赖如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>写一个简单测试demo，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行如下</p>
<figure><img src="/hexblog/imgs/190920/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 疑似原因与兼容方法</h3>
<p>并没有找到具体的原因，在github上有一个issure: <a href="https://github.com/protostuff/protostuff/issues/245" target="_blank" rel="noopener noreferrer">https://github.com/protostuff/protostuff/issues/245</a>，其中回复为</p>
<blockquote>
<p>Protostuff works on user-defined types (pojos), not on built-in jdk types.</p>
</blockquote>
<p>上面的说法是ProtoStuff更多的是用于简单对象的序列化，而不是基础的jdk类型，因此推荐的是序列一个成员变量为BigDecimal的对象</p>
<p>接下来我们试一下，定义一个简单的对象，成员为BigDecimal的场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试输出如下</p>
<figure><img src="/hexblog/imgs/190920/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面虽然可以正常工作，但与我们希望的差别有点大，序列化一个BigDecimal，还需要定义一个POJO包装他，有点麻烦；于是一个猥琐的方法就是在序列化和反序列化的时候，针对BigDeimal进行特殊处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次测试，正常执行</p>
<figure><img src="/hexblog/imgs/190920/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Java"/>
    <category term="问题记录"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-09-20T17:52:10.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">Json序列化</title>
    <id>https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <link href="https://liuyueyi.github.io/tutorial/java/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <updated>2025-02-13T08:59:24.000Z</updated>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2024-08-02T10:41:58.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1. linux grafana大盘接入mysql</title>
    <id>https://liuyueyi.github.io/tutorial/tool/Devops/210318-linux-grafana%E5%A4%A7%E7%9B%98%E6%8E%A5%E5%85%A5mysql.html</id>
    <link href="https://liuyueyi.github.io/tutorial/tool/Devops/210318-linux-grafana%E5%A4%A7%E7%9B%98%E6%8E%A5%E5%85%A5mysql.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>grafana 安装接入mysql数据源</p>
]]></summary>
    <content type="html"><![CDATA[<p>grafana 安装接入mysql数据源</p>
<!-- more -->
<h3> 1. 安装</h3>
<p>官网下载地址: <a href="https://grafana.com/grafana/download?pg=get&amp;plcmt=selfmanaged-box1-cta1" target="_blank" rel="noopener noreferrer">https://grafana.com/grafana/download?pg=get&amp;plcmt=selfmanaged-box1-cta1</a></p>
<p>linux安装</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>centos</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 启动</h3>
<p>启动命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>测试: <a href="http://localhost:3000" target="_blank" rel="noopener noreferrer">http://localhost:3000</a></p>
<p>登录密码: admin/admin</p>
<h3> 3. MySql数据源配置</h3>
<p>添加数据源: <a href="http://localhost:3000/datasources/new" target="_blank" rel="noopener noreferrer">http://localhost:3000/datasources/new</a></p>
<p>选择 mysql</p>
<p>输入数据库信息</p>
<ul>
<li>Host: 主机 + 端口号</li>
<li>Database: 数据库名</li>
<li>User/Password</li>
</ul>
<p>连接信息</p>
<ul>
<li>Max open: 4</li>
<li>Max idle: 2</li>
</ul>
<p>测试并保存，然后配置面板即可</p>
<p>至于grafana面板配置说明，下篇博文介绍</p>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="运维"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-03-18T19:53:17.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">2. Grafana prometheus变量支持include all设置方法</title>
    <id>https://liuyueyi.github.io/tutorial/tool/Devops/211026-Grafana-prometheus%E5%8F%98%E9%87%8F%E6%94%AF%E6%8C%81include-all%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95.html</id>
    <link href="https://liuyueyi.github.io/tutorial/tool/Devops/211026-Grafana-prometheus%E5%8F%98%E9%87%8F%E6%94%AF%E6%8C%81include-all%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>使用Prometheus进行采样收集，借助Grafana进行大盘展示，可以说是系统监控层面的基本操作了，在grafana的大盘配置时，借助变量的灵活性，来展示不同维度的数据表盘比较常见</p>
<p>现在有这样一个场景，一个应用有多台机器，我们设置一个变量 instance 来表示具体的实例ip，支持通过ip来选择不同机器的监控，怎么操作？</p>
]]></summary>
    <content type="html"><![CDATA[<p>使用Prometheus进行采样收集，借助Grafana进行大盘展示，可以说是系统监控层面的基本操作了，在grafana的大盘配置时，借助变量的灵活性，来展示不同维度的数据表盘比较常见</p>
<p>现在有这样一个场景，一个应用有多台机器，我们设置一个变量 instance 来表示具体的实例ip，支持通过ip来选择不同机器的监控，怎么操作？</p>
<!-- more -->
<h3> 1.变量配置</h3>
<p>要实现上面这个case，第一步就是设置一个变量</p>
<figure><img src="/hexblog/imgs/211026/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>注意上面的变量配置，<code>label_values(instance)</code> 获取的是所有的实例ip，然而一般的情况下，我们需要针对应用维度进行区分，比如每个上报的metric，都包含application，现在我只希望查看<code>prometheus-example</code>应用的相关信息</p>
<p>测试变量配置可以如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意<code>http_server_requests_seconds_count</code> 这个属于上报metric name，选一个实际有的即可，接下来配置大盘</p>
<figure><img src="/hexblog/imgs/211026/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. include all配置</h3>
<p>上面这个完成了一个基本的变量使用配置，但是有这么个问题，如果我想查这个应用所有机器的监控，该怎么办？</p>
<figure><img src="/hexblog/imgs/211026/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>为了支持使用全部，我们的metrics的表达式，就不能使用之前的精确匹配了，需要改成正则方式</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/211026/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 小结</h3>
<p>借助Grafana的变量配置来实现大盘的条件筛选，其中变量配置关键点在于</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其次在大盘的metric配置中，对于include all的支持，关键点在于promql的使用</p>
<ul>
<li><code>=</code> : 选择与提供的字符串完全相同的标签。</li>
<li><code>!=</code> : 选择与提供的字符串不相同的标签。</li>
<li><code>=~</code> : 选择正则表达式与提供的字符串（或子字符串）相匹配的标签。</li>
<li><code>!~</code> : 选择正则表达式与提供的字符串（或子字符串）不匹配的标签。</li>
</ul>
]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="开源"/>
    <category term="运维"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2021-10-26T10:08:06.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">Devops</title>
    <id>https://liuyueyi.github.io/tutorial/tool/Devops/</id>
    <link href="https://liuyueyi.github.io/tutorial/tool/Devops/"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2024-08-02T10:41:58.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">2. Centos使用docker构建ecs环境</title>
    <id>https://liuyueyi.github.io/tutorial/tool/Docker/181207-Centos%E4%BD%BF%E7%94%A8docker%E6%9E%84%E5%BB%BAecs%E7%8E%AF%E5%A2%83.html</id>
    <link href="https://liuyueyi.github.io/tutorial/tool/Docker/181207-Centos%E4%BD%BF%E7%94%A8docker%E6%9E%84%E5%BB%BAecs%E7%8E%AF%E5%A2%83.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>本文主要介绍利用docker来构建一个java后端可用的开发运维环境</p>
]]></summary>
    <content type="html"><![CDATA[<p>本文主要介绍利用docker来构建一个java后端可用的开发运维环境</p>
<!-- more -->
<h2> I. java环境搭建</h2>
<p>首先是jdk的安装，可以安装open-jdk，也可以从jdk官网下载jdk包进行配置，简单说明下两种使用方式</p>
<h3> 1. open-jdk安装</h3>
<p>基本安装过程如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. jdk包安装</h3>
<h4> a. 获取包</h4>
<p><strong>官网下载</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>宿主机拷贝</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> b. 安装</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> c. 配置</h4>
<p>进入配置文件 <code>vi /etc/profile</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>应用并查看是否配置ok</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 删除自带的openjdk</h3>
<p>如果希望删除自带的jdk，可以执行下面的命令查看安装的版本</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后执行</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> II. Maven配置</h2>
<p>maven的配置相对简单，下载好包之后，设置mvn的配置即可</p>
<h3> 1. 获取包</h3>
<p>下载maven包，推荐到官网下载，我这里是从宿主机拷贝</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 解压</h3>
<p>到docker中，解压并配置</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 配置</h3>
<p>设置配置文件 <code>vi /etc/profile</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>配置生效 <code>source /etc/profile</code> 并查看</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> III. tomcat安装</h2>
<p>tomcat的安装基本上就是解压个包的事情了</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> IV. nginx安装</h2>
<h3> 1. 直接使用 yum 安装</h3>
<p>后面一个参数表示指定安装的位置</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这种安装，在配置https时，会有问题，提示要安装ssl模块啥的，因此可以这么添加一下参数</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果你是先执行了上面的步骤，后面发现需要安装ssl模块，要怎么办 ？</p>
<p>操作如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 源码安装</h3>
<p>上面其实已经包含了源码安装的步骤，下面简单的列一下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 命令</h3>
<p>nginx 命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>验证是否启动成功</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> V. Redis安装</h2>
<p>redis的安装，可以直接根据<code>yum</code>简单的进行安装，也可以下载安装包</p>
<h3> 1. yum安装方式</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>后台启动redis方式：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看redis启动是否正常</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>客户端连接测试</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关闭redis</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. 源码安装方式</h3>
<p>下载源码并编译</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>设置下redis的相关配置文件，假设我们约定将数据文件存放在 <code>/home/data/redis</code> 目录下，则配置需要如下修改</p>
<p>进入配置文件 redis.conf</p>
<div class="language-conf line-numbers-mode" data-ext="conf"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在启动redis之前，首先需要创建对应的目录</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>开始启动redis并测试</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> VI. Mysql环境安装</h2>
<p>这里采用最简单的方式进行安装mysql，需要关注的是后面的默认配置的修改</p>
<h3> 1. 安装</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面安装完毕之后，可以开始启动服务</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的命令在docker中执行时，会报错</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以如下操作</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面搞定之后，就可以继续启动mysql了</p>
<p>如果登录需要密码时，如下确定</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置修改</h3>
<h4> a. 端口号修改</h4>
<p>默认的端口号为3306，如果需要修改端口号，则找到my.cnf文件，新加一个配置即可:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>服务重启</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 2. 密码修改</h4>
<p>使用set password</p>
<p><strong>格式：</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>例子：</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>update 方式</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>添加用户</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>授予权限</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Shell"/>
    <category term="Docker"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2018-12-07T17:22:09.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">3. docker非root用户可使用配置</title>
    <id>https://liuyueyi.github.io/tutorial/tool/Docker/190703-docker%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E5%8F%AF%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE.html</id>
    <link href="https://liuyueyi.github.io/tutorial/tool/Docker/190703-docker%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E5%8F%AF%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>docker要求使用root权限进行启动，但是启动之后，普通的账号会发现没有访问docker的权限，然而每次都使用root进行访问过于麻烦，那么有办法让普通账号也能正常访问么?</p>
]]></summary>
    <content type="html"><![CDATA[<p>docker要求使用root权限进行启动，但是启动之后，普通的账号会发现没有访问docker的权限，然而每次都使用root进行访问过于麻烦，那么有办法让普通账号也能正常访问么?</p>
<!-- more -->
<p>docker安装完毕之后，启动</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后使用普通账号进行访问，提示如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>因为权限被拒绝，下面是解决办法</p>
<p><strong>1. 创建docker组</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>2. 将用户加入docker组</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3. 重启docker</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>4. 测试</strong></p>
<p>可能在某些情况下，需要断开连接重新登录才有权限继续访问</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Shell"/>
    <category term="Docker"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-07-03T19:24:27.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
  <entry>
    <title type="text">1. Centos安装docker与使用说明</title>
    <id>https://liuyueyi.github.io/tutorial/tool/Docker/191206-Centos%E5%AE%89%E8%A3%85docker%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html</id>
    <link href="https://liuyueyi.github.io/tutorial/tool/Docker/191206-Centos%E5%AE%89%E8%A3%85docker%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html"/>
    <updated>2024-08-02T10:41:58.000Z</updated>
    <summary type="html"><![CDATA[<p>本文主要介绍Centos下如何安装docker，并给出一些基本的使用case</p>
]]></summary>
    <content type="html"><![CDATA[<p>本文主要介绍Centos下如何安装docker，并给出一些基本的使用case</p>
<!-- more -->
<h3> 1. 安装说明</h3>
<p>通过脚本进行docker安装，比较简单</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>执行完毕之后，启动docker</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后开始验证是否可以使用</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果安装正确，如下</p>
<figure><img src="/hexblog/imgs/191206/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 使用相关</h3>
<h4> 1. 安装centos镜像</h4>
<p>在docker中安装一个centos的镜像，然后在docker中的centos里面搞事情</p>
<p>安装命令: <code>docker pull 镜像名:版本</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在安装之前，如果我们不确定有哪些镜像，可以怎么办？可以简单的搜索一下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后从上面的搜索结果中，挑选合适的镜像进行下载，然后可以查看本地镜像列表</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2. 容器使用</h4>
<p>这一小节，主要目的就是如何加载一个镜像，启动，关闭，删除容器等操作</p>
<p><strong>加载镜像</strong></p>
<p>主要就是run方式运行容器, 下面启动一个可交互的centos容器</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面执行完毕之后，会进入容器内的centos，通过 <code>exit</code>退出</p>
<p><strong>查看容器</strong></p>
<p>查看docker当前加载的容器列表</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行之后，可以看到刚才的centos对应的容器，状态为突出</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>那么我们能再次进入这个容器么？</p>
<p><strong>启动容器</strong></p>
<p>想进入上面这个容器，首先得让它跑起来,通过start命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>进入容器</strong></p>
<p>通过 <code>docker exec</code> 方式进入容器，之前看到一个博文，说是有四种进入方式，这里选择exec方式进入</p>
<ul>
<li>原文：<a href="http://www.cnblogs.com/xhyan/p/6593075.html" target="_blank" rel="noopener noreferrer">Docker容器进入的4种方式</a></li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面执行完毕之后，会发现又一次进入了容器内的centos系统</p>
<figure><img src="/hexblog/imgs/191206/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>到这里就会有个疑问</p>
<ul>
<li>我在这个容器里面的修改是否会保留下来，我下次进来的时候，是不是这些东西还有没有</li>
<li>每次退出之后，容器都会停止运行么？</li>
</ul>
<p>针对上面的两个疑问，实际的操作一下，结果如下图</p>
<ul>
<li>容器内的修改会保留</li>
<li>exit退出之后，容器并不会停止，依然是运行的状态</li>
</ul>
<figure><img src="/hexblog/imgs/191206/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>停止容器</strong></p>
<p>如果想要关闭容器，也比较简单</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>删除容器</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 3. 定制镜像</h4>
<p>以交互式运行centos镜像</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后就进入了docker中的centos操作系统了，然后可以在里面部署基本的环境，先做一个简单的演示，在home文件夹下初始化几个目录</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行过程如下</p>
<figure><img src="/hexblog/imgs/191206/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>退出容器之后，将上面我们的修改保存</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/191206/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>我们改的docker实际上是在原始docker的基础上改进而来，可以通过下面的命令查看演进过程</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/191206/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来就是如何使用我们修改后的镜像了，首先是加载自定义的容器, 然后一番操作如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/191206/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>保存后的镜像，还可以修改tag，命令如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content>
    <author>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </author>
    <category term="Shell"/>
    <category term="Docker"/>
    <contributor>
      <name>一灰灰blog</name>
      <uri>https://hhui.top</uri>
    </contributor>
    <published>2019-12-06T15:53:50.000Z</published>
    <rights>Copyright by 一灰灰blog</rights>
  </entry>
</feed>