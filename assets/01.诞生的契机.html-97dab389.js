import{_ as i,V as t,W as c,Z as e,a1 as o,$ as n,Y as l,F as p}from"./framework-b1bd8911.js";const r="/tutorial/imgs/column/trace/00-skywalking.jpg",s={},_=l('<p>为什么会萌发写一个记录链路耗时的组件的念头呢？ 来源于一个不太美妙的线上问题。 自从开始做toB的业务之后，对系统的性能要求阈值不断下降，当一个接口响应超过3s时，发现适应适应还可接受，然后逐渐的，你会发现接口的响应会滑向5s、10s... (底线一段突破，那就将没有底线可言)</p><p>在经历某一次重大的迭代之后，整体的数据量翻了两翻，部分接口的响应直接突破10s，然后业主方终于是不能忍了，明确提出要求做性能优化</p><p>那么怎么做呢？</p><p>按照一般的做事惯例，先定目标，然后基于现状拆解任务，接着就是任务的研发推进，最终的交付测试上线</p><p>当明确提出要优化某个接口时，至少我们现在的目标是明确，要缩减接口的耗时</p><p>现在也是明确的，接口响应很慢。 那么我们的任务也相对明确，即是解决接口响应慢的问题。 接下来就自然有一个疑问，到底是哪里慢了？ 对应的策略有两种</p><ol><li>老老实实啃代码，根据个人经验来判断慢的点</li><li>借助一些工具，输出各关键节点的耗时分布情况，直观上找到性能瓶颈点</li></ol><p>对于第一点，没有什么好说的；重点看一下第二个，我现在迫切需要一个工具，能帮我分析整个接口的执行链路中，是哪些环节会比较慢</p><p>现在我有什么？</p><ul><li>skywalking</li><li>loki + grafana</li></ul><p>既然有全链路监控神器Skywalking，当然想着就是充分利用起来，先直接观察一下链路的执行情况</p><figure><img src="'+r+'" alt="来自网图" tabindex="0" loading="lazy"><figcaption>来自网图</figcaption></figure><p>默认的Skywalking的链路追踪中，主要显示的是一些io相关的耗时操作，对于我们实际的业务场景有帮助，但不大（链路长、网络io非常多，很难精确定位到具体是哪里耗时久）</p><p>此时就需要我们主动在代码的方法上埋点，通过<code>@Trace</code>注解来手动插入<code>LocalSpan</code>，从而增加关键方法的执行情况输出；接下来我遇到另外一个稍显现实的问题，特么的代码写得有点拉跨，大部分逻辑放在一个方法里，咋搞....</p>',14),d={href:"https://www.jianshu.com/p/541eb76c6edc",target:"_blank",rel:"noopener noreferrer"},k=l("<p>接下来只能老老实实的在代码中通过 <code>StopWatch</code> 来统计代码块的执行耗时情况了，耗时打印输出日志，借助<code>loki+grafana</code>来统一收集查看，也能满足诉求，但是，这种方式写出来的代码，会导致本就岌岌可危的业务代码，又添加了一堆无甚鸟用的逻辑，实在是有点难以忍受； 还有另外一个严重的问题，则是<code>StopWatch</code>对并发的支持不行，对于链路中存在异步调用的场景下，会出现统计偏差或异常</p><p>既然现存的工具栈不合心意，那就自己搞一个，先指定几个基本要求：</p><ul><li>不会引入新的问题</li><li>使用简单方便，输出直观的耗时统计</li><li>对现有的业务代码块侵入较小</li><li>支持链路中存在并行任务执行场景的耗时统计</li><li>可以方便的将某些方法/代码块，由同步的调度改成异步的调度，从而提高接口性能</li></ul><p>接下来我们将正式进入实现篇，如何从0到1手撸一个耗时分布统计的工具组件</p>",4);function g(u,f){const a=p("ExternalLinkIcon");return t(),c("div",null,[_,e("blockquote",null,[e("p",null,[o("关于skywalking的基础知识点：（"),e("a",d,[o("Skywalking的埋点-Trace的基本概念 - 简书"),n(a)]),o("）")])]),k])}const h=i(s,[["render",g],["__file","01.诞生的契机.html.vue"]]);export{h as default};
