import{_ as i,V as t,W as o,X as r,Y as s,Z as n,$ as e,a1 as l,F as p}from"./framework-094145d2.js";const d="/tutorial/imgs/180323/180323_LOCK2.jpg",c="/tutorial/imgs/180323/180323_LOCK3.jpg",u="/tutorial/imgs/180323/180323_LOCK4.jpg",k="/tutorial/imgs/180323/180323_LOCK5.jpg",m="/tutorial/imgs/180323/180323_LOCK6.jpg",h="/tutorial/imgs/180323/180323_LOCK7.jpg",b="/tutorial/imgs/180323/180323_LOCK8.gif",v="/tutorial/imgs/180323/180323_LOCK9.gif",g="/tutorial/imgs/180323/180323_LOCK10.gif",y="/tutorial/imgs/180323/180323_LOCK11.gif",w={},f=l('<h1 id="mysql之锁与事务" tabindex="-1"><a class="header-anchor" href="#mysql之锁与事务" aria-hidden="true">#</a> Mysql之锁与事务</h1><p>平时的业务中，顶多也就是写写简单的sql，连事务都用的少，对锁这一块的了解就更加欠缺了，之前一个大神分享了下mysql的事务隔离级别，感觉挺有意思的，正好发现一个很棒的博文，然后也收集了一些相关知识，正好来学习下，mysql中锁与事务的神秘面纱，主要内容包括</p><ol><li>共享锁和排它锁的区别以及适合范围</li><li>mysql的表锁和行锁的区别</li><li>怎么判断一个sql是否执行了锁，执行的是表锁还是行锁</li><li>事务是什么，怎么用</li><li>事务的特性ACID</li><li>事务的隔离级别 (RU, RC, RR, SER)</li><li>如何查看mysql使用的隔离级别</li></ol>',3),_=l(`<h2 id="i-锁" tabindex="-1"><a class="header-anchor" href="#i-锁" aria-hidden="true">#</a> I. 锁</h2><p>在学习多线程时，我们也经常会遇到锁这个东西，那个时候谈的比较多的是乐观锁和悲观锁，那这两种锁和DB中常说的共享锁和独占锁有什么区别呢？先给出我们已知的乐观锁和悲观锁定义</p><ul><li>乐观锁：多线程中的CAS就是一种乐观锁，实际上不加锁，先尝试去执行，如果失败则重试（或者根据失败策略进行处理）</li><li>悲观锁：上锁，一次只能有一个线程访问，其他的都只能等待</li></ul><h3 id="_1-共享锁和排它锁" tabindex="-1"><a class="header-anchor" href="#_1-共享锁和排它锁" aria-hidden="true">#</a> 1. 共享锁和排它锁</h3><h4 id="a-共享锁" tabindex="-1"><a class="header-anchor" href="#a-共享锁" aria-hidden="true">#</a> a. 共享锁</h4><p>突出在共享这个关键词上，顾名思义，表示这个锁可以多人共享，一般又可以称为读锁(S锁)</p><p>在DB中，读锁表示所有的读取数据的小伙伴都不会被锁阻塞，可以放心大胆的获取数据，专业一点的说法就是同一时刻，允许多个连接并发的读取同一资源</p><h4 id="b-排它锁" tabindex="-1"><a class="header-anchor" href="#b-排它锁" aria-hidden="true">#</a> b. 排它锁</h4><p>排它，表示当某个人持有这个锁之后，其他的人再来竞争锁就会失败，只能等待锁释放， 又称为写锁(X锁)</p><p>在DB中，写锁表示同一时刻，只能有一个小伙伴操作，其他的不管是读还是写，都得排队，专业说法是写锁会阻塞其他的读锁或写锁请求，确保同一时刻只能有一个连接可以写入资源，并防止其他连接读取或者写资源</p><h4 id="c-gaplock-和-next-key-lock" tabindex="-1"><a class="header-anchor" href="#c-gaplock-和-next-key-lock" aria-hidden="true">#</a> c. gapLock 和 next key lock</h4><ul><li>next key lock 主要是范围匹配的场景下，会锁某一个范围区间</li><li>gapLock 主要用来锁边界</li></ul><p>如下面的case（说明，columnA是非唯一索引，RR隔离级别）</p><ul><li><code>where columnA between 10 and 30</code>, next key lock 确保不会在10, 30 之内插入新的数据行</li><li><code>where columnA = 10</code>, gap lock 确保不会再次插入一个columnA=10的行</li></ul><h3 id="_2-表锁和行锁" tabindex="-1"><a class="header-anchor" href="#_2-表锁和行锁" aria-hidden="true">#</a> 2. 表锁和行锁</h3><p>对于DB的操作，通常会出现两种情况，一个是锁表，一个锁行</p><ul><li>表锁：表示整个表被某一个连接占用了写锁，导致其他连接的读锁或者写锁都会阻塞；影响整个表的读写</li><li>行锁：表示表中某些行被某个连接占用了写锁，但是其他行，依然可以被其他的连接请求读锁、写锁；仅影响被锁的那些行数据</li></ul><p>那么一个问题就来了，什么sql会导致行锁，什么会导致写锁？甚至我们如何判断一个sql是否会请求锁，请求的是读锁还是写锁呢？</p><h3 id="_3-如何使用锁" tabindex="-1"><a class="header-anchor" href="#_3-如何使用锁" aria-hidden="true">#</a> 3. 如何使用锁</h3><p>上面一节抛出了问题，那么现在就是来看下如何使用和分析锁了，首先我们是我们最常见的几个sql</p><ul><li>select</li><li>update</li><li>delete</li><li>insert</li></ul><p>其中很容易得出的结论是 <code>update, delete, insert</code> 三个涉及到写锁；而且这种操作绝大部分的场景是操作具体的某些行（想想为什么?），所以更常见的是行锁</p><p>select读操作则有点特殊</p><h4 id="a-select分析" tabindex="-1"><a class="header-anchor" href="#a-select分析" aria-hidden="true">#</a> a. select分析</h4><p>MVCC(multiple-version-concurrency-control）是个行级锁的变种，它在普通读情况下避免了加锁操作，因此开销更低。即下面这个没有读锁也没有写锁</p><p>快照读，不加锁</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">table</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当前读，select 语句可以指定读锁和写锁，如下</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 读锁</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">table</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>

<span class="token comment">-- 写锁</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">table</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明，insert, update, delete 也是当前读，理由如下：</p><p>1.update和delete操作流程分解：</p><ul><li>首先通过where条件查询到第一个满足的记录，并加锁</li><li>对这条记录进行更新，再读取下一条记录</li><li>对记录更新，继续读下一条直到完毕</li></ul><p>2.insert操作流程分解：</p><ul><li>unique key 冲突检测，会有一个当前读</li><li>无冲突时，插入</li></ul><h4 id="b-sql实例分析" tabindex="-1"><a class="header-anchor" href="#b-sql实例分析" aria-hidden="true">#</a> b. sql实例分析</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">--- SQL1：</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token comment">--- SQL2：</span>
<span class="token keyword">delete</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在分析上面的sql之前，需要明确几个前提：</p><ul><li>id是否为主键（id是否有索引）</li><li>系统的隔离级别（隔离级别是什么东西可以先看下下文介绍）</li></ul><p>分别说明:</p><p><strong>case1:</strong> 主键+RC级别</p><ul><li>sql1不加锁，MySQL是使用多版本并发控制的，读不加锁</li><li>sql2加写锁（即X锁），只锁 id=10这一行</li></ul><figure><img src="`+d+'" alt="180323_LOCK2.jpg" tabindex="0" loading="lazy"><figcaption>180323_LOCK2.jpg</figcaption></figure><p><strong>case2:</strong> 唯一索引+rc级别</p><ul><li>sql2加写锁，如下图的case，就两把锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name=’d’,id=10]的记录</li></ul><figure><img src="'+c+'" alt="180323_LOCK3.jpg" tabindex="0" loading="lazy"><figcaption>180323_LOCK3.jpg</figcaption></figure><p><strong>case3:</strong> id非唯一索引+RC</p><ul><li>sql2加写锁，如下图的case，会有四个写锁</li></ul><figure><img src="'+u+'" alt="180323_LOCK4.jpg" tabindex="0" loading="lazy"><figcaption>180323_LOCK4.jpg</figcaption></figure><p><strong>case4:</strong> 无索引+RC</p><ul><li>sql2分析：若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上写锁(X锁)。</li><li>但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省</li></ul><figure><img src="'+k+'" alt="180323_LOCK5.jpg" tabindex="0" loading="lazy"><figcaption>180323_LOCK5.jpg</figcaption></figure><p><strong>case5:</strong> 主键+RR</p><p>加锁同case1</p><p><strong>case6:</strong> 唯一索引+RR</p><p>加锁同case2</p><p><strong>case7:</strong> 非唯一索引+RR</p><p>RR级别不允许出现幻读，简单来说，在加锁的过程中，不允许在新增or修改满足条件的记录</p><p>即下图中，除了图三中类似的x锁之外，还会新增一个gap锁，这个gap锁主要确保那几个位置上不能插入新的记录</p><figure><img src="'+m+'" alt="180323_LOCK6.jpg" tabindex="0" loading="lazy"><figcaption>180323_LOCK6.jpg</figcaption></figure><p><strong>case8:</strong> 无索引+RR</p><ul><li>在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作</li></ul><figure><img src="'+h+'" alt="180323_LOCK7.jpg" tabindex="0" loading="lazy"><figcaption>180323_LOCK7.jpg</figcaption></figure><p><strong>case9:</strong> Serializable级别</p><ul><li>sql2: Serializable隔离级别。对于SQL2：delete from t1 where id = 10; 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致</li><li>SQL1: 在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC</li></ul><hr><h2 id="ii-事务" tabindex="-1"><a class="header-anchor" href="#ii-事务" aria-hidden="true">#</a> II. 事务</h2><p>事务可谓是db中非常重要的一个知识点了，接下来我们的目标就是弄懂什么是事务，怎么使用事务，以及事务与锁之间的关联是怎样的</p><p>说明：本文的分析主要是以mysql的innordb存储引擎为标准</p><h3 id="_1-定义" tabindex="-1"><a class="header-anchor" href="#_1-定义" aria-hidden="true">#</a> 1. 定义</h3><p>事务就是一组原子性的sql，或者说一个独立的工作单元。</p><p>事务就是说，要么mysql引擎会全部执行这一组sql语句，要么全部都不执行（比如其中一条语句失败的话）。</p><h3 id="_2-acid特性" tabindex="-1"><a class="header-anchor" href="#_2-acid特性" aria-hidden="true">#</a> 2. ACID特性</h3><h4 id="a-a-atomiciy-原子性" tabindex="-1"><a class="header-anchor" href="#a-a-atomiciy-原子性" aria-hidden="true">#</a> a. A:atomiciy 原子性</h4><p>一个事务必须保证其中的操作要么全部执行，要么全部回滚，不可能存在只执行了一部分这种情况出现。</p><h4 id="b-c-consistency一致性" tabindex="-1"><a class="header-anchor" href="#b-c-consistency一致性" aria-hidden="true">#</a> b. C:consistency一致性</h4><p>数据必须保证从一种一致性的状态转换为另一种一致性状态。</p><h4 id="c-i-isolation-隔离性" tabindex="-1"><a class="header-anchor" href="#c-i-isolation-隔离性" aria-hidden="true">#</a> c. I:isolation 隔离性</h4><p>在一个事务未执行完毕时，通常会保证其他Session 无法看到这个事务的执行结果</p><h4 id="d-d-durability-持久性" tabindex="-1"><a class="header-anchor" href="#d-d-durability-持久性" aria-hidden="true">#</a> d. D:durability 持久性</h4><p>事务一旦commit，则数据就会保存下来，即使提交完之后系统崩溃，数据也不会丢失</p><h3 id="_3-隔离级别" tabindex="-1"><a class="header-anchor" href="#_3-隔离级别" aria-hidden="true">#</a> 3. 隔离级别</h3><p>前面在分析锁的sql时，就提到了隔离级别，通常有四种： RU, RC, RR, Serializable</p><p>在说明这个之前，先了解几个概念</p><h4 id="a-基本概念" tabindex="-1"><a class="header-anchor" href="#a-基本概念" aria-hidden="true">#</a> a. 基本概念</h4><ul><li>脏读：读取到一个事务未提交的数据，因为这个事务最终无法保证一定执行成功，那么读取到的数据就无法保证一定准确</li><li>不可重复读：简单来说就是在一个事务中读取的数据可能产生变化，同样的sql，在一个事务中执行多次，可能得到不同的结果</li><li>幻读：会话T1事务中执行一次查询，然后会话T2新插入一行记录，这行记录恰好可以满足T1所使用的查询的条件。然后T1又使用相同 的查询再次对表进行检索，但是此时却看到了事务T2刚才插入的新行</li><li>加锁读：<code>select * from table ...</code> 的执行是否加了读锁 (这个可以参考上面的sql加锁分析）</li></ul><h4 id="b-ru-read-uncommited-未提交读" tabindex="-1"><a class="header-anchor" href="#b-ru-read-uncommited-未提交读" aria-hidden="true">#</a> b. RU: Read Uncommited 未提交读</h4><p>事务中的修改，即使没有提交，对其他会话也是可见的，即表示可能出现脏读，一般数据库都不采用这种方案</p><h4 id="c-rc-read-commited-提交读" tabindex="-1"><a class="header-anchor" href="#c-rc-read-commited-提交读" aria-hidden="true">#</a> c. RC: Read Commited 提交读</h4><p>这个隔离级别保证了一个事务如果没有完全成功（commit执行完），事务中的操作对其他会话是不可见的，避免了脏读的可能</p><p>但是可能出现不可重复度的情况，举例说明：</p><ul><li>会话T1, 执行查询 <code>select * from where id=1</code>，第一次返回一个结果</li><li>会话T2, 执行修改 <code>update table set updated=xxx where id=1</code> 并提交</li><li>会话T1，再次执行查询 <code>select * from where id=1</code>，这次返回的结果中update字段就和前面的不一样了</li></ul><p>实际的生产环境中，这个级别用的比较多，特意查了下公司的db隔离级别就是这个</p><p>一个RC级别的演示过程：</p><ul><li>会话1，开启事务，查询</li><li>会话2，开启事务，更新DB，提交事务</li><li>会话1，再次查询，提交事务</li><li>从下面的实际演示结果可以知道，会话1，同一个sql，两次执行的结果不同</li></ul><figure><img src="'+b+`" alt="180323_LOCK8.gif" tabindex="0" loading="lazy"><figcaption>180323_LOCK8.gif</figcaption></figure><p>相关的sql代码如下:</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 设置会话隔离级别</span>
<span class="token keyword">set</span> <span class="token keyword">session</span> <span class="token keyword">transaction</span> ioslation <span class="token keyword">read</span> commited<span class="token punctuation">;</span>

<span class="token comment">-- 查看当前会话隔离级别</span>
<span class="token keyword">select</span> @<span class="token variable">@tx_isolation</span><span class="token punctuation">;</span>

<span class="token comment">-- 会话1的操作</span>
<span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> newuser <span class="token keyword">where</span> userId<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>


<span class="token comment">-- 会话2开始操作</span>
<span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> newuser <span class="token keyword">where</span> userId<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">update</span> newuser <span class="token keyword">set</span> updated<span class="token operator">=</span><span class="token number">1521786092</span> <span class="token keyword">where</span> userId<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> newuser <span class="token keyword">where</span> userId<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">commit</span><span class="token punctuation">;</span>


<span class="token comment">-- 再次进入会话1，同样执行上次的sql，对比两次输出结果</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> newuser <span class="token keyword">where</span> userId<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">-- 注意观察，会话1，前后两次这个sql的输出结果，特别是updated字段</span>
<span class="token comment">-- 正常情况会如上面的demo图，会发生改变</span>


<span class="token comment">-- 关闭会话</span>
<span class="token keyword">commit</span><span class="token punctuation">;</span>

<span class="token comment">-- 再次查询</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> newuser <span class="token keyword">where</span> userId<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="d-rr-repeatable-read-可重复度" tabindex="-1"><a class="header-anchor" href="#d-rr-repeatable-read-可重复度" aria-hidden="true">#</a> d. RR: Repeatable Read 可重复度</h4><p>一个事务中多次执行统一读SQL,返回结果一样。 这个隔离级别解决了脏读的问题，幻读问题</p><p>实例演示解决脏读的过程(将上面的过程同样来一次）</p><ul><li>发现不管会话1同一个sql，返回的结果都是相同的</li></ul><figure><img src="`+v+`" alt="180323_LOCK9.gif" tabindex="0" loading="lazy"><figcaption>180323_LOCK9.gif</figcaption></figure><h4 id="e-serializable-可串行化" tabindex="-1"><a class="header-anchor" href="#e-serializable-可串行化" aria-hidden="true">#</a> e. Serializable 可串行化</h4><p>最强的隔离级别，通过给事务中每次读取的行加锁，写加写锁，保证不产生幻读问题，但是会导致大量超时以及锁争用问题。</p><h4 id="f-常用命令" tabindex="-1"><a class="header-anchor" href="#f-常用命令" aria-hidden="true">#</a> f. 常用命令</h4><ul><li>查看当前会话隔离级别: <code>select @@tx_isolation</code></li><li>查看系统当前隔离级别: <code>select @@global.tx_isolation</code></li><li>设置当前会话隔离级别: <code>set session transaction isolation level read committed;</code></li><li>设置系统当前隔离级别: <code>set global transaction isolation level read committed;</code></li><li>命令行， <ul><li>开始事务: <code>start transactioin;</code></li><li>提交: <code>commit;</code></li></ul></li></ul><h3 id="_4-使用姿势" tabindex="-1"><a class="header-anchor" href="#_4-使用姿势" aria-hidden="true">#</a> 4. 使用姿势</h3><p>前面演示事务隔离级别的时候，给出的实例就演示了事务的使用姿势，一般作为三步骤：</p><ul><li>开始事务 <code>start transaction;</code></li><li>执行你的业务sql</li><li>提交事务 <code>commit;</code></li></ul><p>我们现在演示以下一个事务中，读锁、写锁对另一个事务的影响</p><h4 id="a-读锁的影响" tabindex="-1"><a class="header-anchor" href="#a-读锁的影响" aria-hidden="true">#</a> a. 读锁的影响</h4><p>我们采用mysql默认的RR级别进行测试，userId为主键</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 会话1</span>
<span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> newuser <span class="token keyword">where</span> userId<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>

<span class="token comment">-- 转入会话2</span>
<span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> newuser <span class="token keyword">where</span> userId<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">-- 会输出</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> newuser <span class="token keyword">where</span> userId<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span> <span class="token comment">-- 会输出</span>
<span class="token keyword">update</span> newuser <span class="token keyword">set</span> updated<span class="token operator">=</span><span class="token number">1521787137</span> <span class="token keyword">where</span> userId<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">-- 会挂起</span>


<span class="token comment">-- 转入会话1</span>
<span class="token comment">-- 提交, 此时观察会话2的写是否完成</span>
<span class="token keyword">commit</span><span class="token punctuation">;</span>

<span class="token comment">-- 转入会话2</span>
<span class="token keyword">commit</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际执行演示:</p><figure><img src="`+g+`" alt="180323_LOCK10.gif" tabindex="0" loading="lazy"><figcaption>180323_LOCK10.gif</figcaption></figure><h4 id="b-写锁的影响" tabindex="-1"><a class="header-anchor" href="#b-写锁的影响" aria-hidden="true">#</a> b. 写锁的影响</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 会话1</span>
<span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> newuser <span class="token keyword">where</span> userId<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>

<span class="token comment">-- 转入会话2</span>
<span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> newuser <span class="token keyword">where</span> userId<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">-- 会输出</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> newuser <span class="token keyword">where</span> userId<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span> <span class="token comment">-- 会挂住</span>

<span class="token comment">-- update newuser set updated=1521787137 where userId=1; -- 会挂住</span>

<span class="token comment">-- 转入会话1</span>
<span class="token comment">-- 提交, 此时观察会话2的写是否完成</span>
<span class="token keyword">commit</span><span class="token punctuation">;</span>

<span class="token comment">-- 转入会话2</span>
<span class="token keyword">commit</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际执行演示:</p><figure><img src="`+y+`" alt="180323_LOCK11.gif" tabindex="0" loading="lazy"><figcaption>180323_LOCK11.gif</figcaption></figure><h4 id="c-小结" tabindex="-1"><a class="header-anchor" href="#c-小结" aria-hidden="true">#</a> c. 小结</h4><ul><li>读锁，会阻塞其他请求写锁的sql执行</li><li>写锁，会阻塞其他读锁和写锁的sql执行</li><li>事务只有在提交之后，才会释放锁</li><li>额外注意，上面事务在提交之后才会释放锁，因此如果两个事务循环依赖锁时，可能发生死锁</li></ul><hr><h2 id="iii-小结" tabindex="-1"><a class="header-anchor" href="#iii-小结" aria-hidden="true">#</a> III. 小结</h2><p>锁和事务可谓是db中非常重要的知识点了，在我们实际的编码过程中（一般针对mysql, innordb存储引擎，rr隔离级别），做出下面的一些总结</p><h3 id="_1-sql分析" tabindex="-1"><a class="header-anchor" href="#_1-sql分析" aria-hidden="true">#</a> 1. sql分析</h3><ul><li><code>select * from table where xxx;</code> （读快照，一般不加锁）</li><li><code>select * from table where xxx lock in share mode;</code> (读锁，会阻塞其他的写锁请求，但其他的读锁请求没有影响）</li><li><code>select * from table where xxx for update;</code> (写锁，会阻塞其他的读写请求）</li><li><code>update tableName set xxx</code> (写锁）</li><li><code>insert</code> （写锁）</li><li><code>delete</code> （写锁）</li></ul><h3 id="_2-事务" tabindex="-1"><a class="header-anchor" href="#_2-事务" aria-hidden="true">#</a> 2. 事务</h3><p>简单来讲，事务就是一组sql，要么全部执行成功，要么全部失败</p><p><strong>四个特性：</strong> A(原子性)C(一致性)I(隔离性)D (持久性)</p><p><strong>四种隔离级别：</strong>(mysql 默认采用的是RR级别)</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>加锁读</th></tr></thead><tbody><tr><td>read uncommited</td><td>可能</td><td>可能</td><td>可能</td><td>无</td></tr><tr><td>read commited</td><td>不可能</td><td>可能</td><td>可能</td><td>无</td></tr><tr><td>repeatable read</td><td>不可能</td><td>不可能</td><td>不可能</td><td>无</td></tr><tr><td>serializable</td><td>不可能</td><td>不可能</td><td>不可能</td><td>有</td></tr></tbody></table><p><strong>使用姿势：</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span>

<span class="token comment">-- xxx 具体的sql</span>

<span class="token keyword">commit</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h3>`,134),x={href:"http://blog.csdn.net/lemon89/article/details/51477497",target:"_blank",rel:"noopener noreferrer"},q={href:"http://hedengcheng.com/?p=771#_Toc374698322",target:"_blank",rel:"noopener noreferrer"};function C(L,R){const a=p("ExternalLinkIcon");return t(),o("div",null,[f,r(" more "),_,s("ul",null,[s("li",null,[s("a",x,[n("深入理解Mysql——锁、事务与并发控制"),e(a)])]),s("li",null,[s("a",q,[n("MySQL 加锁处理分析"),e(a)])])])])}const O=i(w,[["render",C],["__file","03.180323-mysql之锁与事务详解.html.vue"]]);export{O as default};
