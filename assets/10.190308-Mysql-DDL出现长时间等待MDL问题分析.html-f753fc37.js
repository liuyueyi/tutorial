import{_ as o,V as l,W as i,X as c,Y as a,Z as n,$ as e,a1 as t,F as d}from"./framework-094145d2.js";const p="/tutorial/imgs/190308/00.jpg",r="/tutorial/imgs/190308/01.jpg",u="/tutorial/imgs/190308/02.jpg",h="/tutorial/imgs/190308/03.jpg",m="/tutorial/imgs/190308/04.jpg",k="/tutorial/imgs/190308/05.jpg",_={},b=a("p",null,[n("给表新增字段时，发现锁表了，查看进程，提示"),a("code",null,"Waiting for table metadata lock"),n("，等待锁释放；然而蛋疼的是几分钟过去了，依然没有任何的进展")],-1),v=a("p",null,"现在就有几个问题了",-1),D=a("ul",null,[a("li",null,"Metadata Lock 是什么鬼"),a("li",null,"是什么原因导致一直等待")],-1),L=t(`<h2 id="i-问题定位" tabindex="-1"><a class="header-anchor" href="#i-问题定位" aria-hidden="true">#</a> I. 问题定位</h2><p>首先需要确认什么地方加锁，从mysql出发，应该怎么定位？</p><h3 id="_1-定位过程" tabindex="-1"><a class="header-anchor" href="#_1-定位过程" aria-hidden="true">#</a> 1. 定位过程</h3><p>对于mysql而言，一般来讲上锁和事物时伴生关系，所以我们的直观出发点就是查找db当前正在执行的事物</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 查询当前正在执行的事物的sql</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> information_schema<span class="token punctuation">.</span>INNODB_TRX<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下，首先拿到事物对应的进程id</p><figure><img src="`+p+`" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure><p>拿到id之后，则可以分析对应的进程信息</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 查询进程信息</span>
<span class="token keyword">show</span> processlist

<span class="token comment">-- 查询所有的进程信息</span>
<span class="token keyword">show</span> <span class="token keyword">full</span> processlist
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后定位到具体的进程</p><figure><img src="`+r+`" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure><p>然后登陆到目标机器，查看端口号对应的进程，通过<code>lsof</code>命令查看</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">lsof</span> <span class="token parameter variable">-i</span> tcp:52951
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从图中可以看出，是一个python进程的mysql连接开启的事物，进程id为5436</p><figure><img src="`+u+`" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure><p>接着查看进程对应的信息</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">5436</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+h+`" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure><p>这个脚本正是测试aiomysql的python脚本，内容比较简单</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> asyncio
<span class="token keyword">import</span> aiomysql

loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>


<span class="token decorator annotation punctuation">@asyncio<span class="token punctuation">.</span>coroutine</span>
<span class="token keyword">def</span> <span class="token function">test_example</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    conn <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token keyword">from</span> aiomysql<span class="token punctuation">.</span>connect<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">&#39;127.0.0.1&#39;</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">3306</span><span class="token punctuation">,</span>
                                       user<span class="token operator">=</span><span class="token string">&#39;root&#39;</span><span class="token punctuation">,</span> password<span class="token operator">=</span><span class="token string">&#39;&#39;</span><span class="token punctuation">,</span> db<span class="token operator">=</span><span class="token string">&#39;test&#39;</span><span class="token punctuation">,</span>
                                       loop<span class="token operator">=</span>loop<span class="token punctuation">,</span> autocommit<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>

    cur <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token keyword">from</span> conn<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span> <span class="token keyword">from</span> cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">&quot;SELECT * from test_table&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>description<span class="token punctuation">)</span>
    r <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token keyword">from</span> cur<span class="token punctuation">.</span>fetchall<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
    <span class="token keyword">yield</span> <span class="token keyword">from</span> cur<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
    conn<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>

loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>test_example<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-原因分析" tabindex="-1"><a class="header-anchor" href="#_2-原因分析" aria-hidden="true">#</a> 2. 原因分析</h3><p>对python不太熟，直接借助google查一下，发现有同样的问题</p>`,22),g={href:"https://stackoverflow.com/questions/41126470/why-aiomysql-locks-the-table-even-when-using-context-manager",target:"_blank",rel:"noopener noreferrer"},M=t(`<p>这个问题抛出，在通过with打开连接获取游标后，执行mysql，但是没有commit之前，会锁表，这个期间修改表都会出现等待</p><p>下面近给出了解答，并没有看到更多的深层次的说明，先记录下，解决办法就是在创建连接池的时候，选择自动提交方式，然后就不会有这个问题了</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>pool <span class="token operator">=</span> <span class="token keyword">await</span> aiomysql<span class="token punctuation">.</span>create_pool<span class="token punctuation">(</span>
    host<span class="token operator">=</span><span class="token string">&quot;localhost&quot;</span><span class="token punctuation">,</span>
    user<span class="token operator">=</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">,</span>
    password<span class="token operator">=</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">,</span>
    db<span class="token operator">=</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">,</span>
    autocommit<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>
    cursorclass<span class="token operator">=</span>DictCursor<span class="token punctuation">,</span>
    loop<span class="token operator">=</span>loop<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="ii-metadata-lock说明" tabindex="-1"><a class="header-anchor" href="#ii-metadata-lock说明" aria-hidden="true">#</a> II. Metadata Lock说明</h2>`,4),f={href:"https://www.jb51.net/article/145599.htm",target:"_blank",rel:"noopener noreferrer"},E=t('<h3 id="_1-mdl-说明" tabindex="-1"><a class="header-anchor" href="#_1-mdl-说明" aria-hidden="true">#</a> 1. MDL 说明</h3><p>抓一下核心的要点，简单说一下看完这篇文章之后的朴素理解</p><p>MetaData Lock 简称为MDL，简单来说就是表的元数据锁；当修改表结构的时候，就需要持有这个锁</p><h4 id="a-作用" tabindex="-1"><a class="header-anchor" href="#a-作用" aria-hidden="true">#</a> a. 作用</h4><p>MDL的主要作用只有一点，<strong>保护一个正在执行的事物表结构不被修改</strong></p><p>有一个原则，MDL是事物级别的，只有事物结束之后才会释放，而这里面说的事物分为两类</p><ul><li>显示事物： <ul><li>关闭autocommit</li><li>以begin或start transaction开始的操作</li></ul></li><li>AC-NL-RO(auto-commit non-locking read-only): <ul><li>auto commit 开启之下的select操作</li></ul></li></ul><h4 id="b-实例说明" tabindex="-1"><a class="header-anchor" href="#b-实例说明" aria-hidden="true">#</a> b. 实例说明</h4><p>直接看上面的说明，不太直观，一个经典的case如下</p><figure><img src="'+m+'" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure><p>session1 开启了一个事物，执行查询操作；但是现在session2 要删除表，如果执行成功，那么session1的第二次查询就跪了，这样就违背了事物的原则，所有在5.5版本引入了MDL，来保证在事物执行期间，表结构不被修改</p><h3 id="_2-出现mdl等待原因及解决方法" tabindex="-1"><a class="header-anchor" href="#_2-出现mdl等待原因及解决方法" aria-hidden="true">#</a> 2. 出现MDL等待原因及解决方法</h3><p>当我们出现修改表结构，就需要获取MDL的排他锁，因此只有这个表没有事物在执行时，才能获取成功；当持有独占锁之后，这个表的其他操作将被阻塞（即不能插入数据，修改数据，也不能开启事物操作）</p><p>因此在执行DDL时，一直出现等待MDL的时候，常见的原因有下面三个</p><h4 id="a-长事物-阻塞ddl-从而阻塞所有同表的后续操作" tabindex="-1"><a class="header-anchor" href="#a-长事物-阻塞ddl-从而阻塞所有同表的后续操作" aria-hidden="true">#</a> a. 长事物，阻塞DDL，从而阻塞所有同表的后续操作</h4><p>通过 show processlist看到表上有正在进行的操作（包括读），此时修改表时也会等待获取MDL，这种时候解决办法要么就是等待执行完毕，要么就是直接kill掉进程</p><h4 id="b-未提交事物-阻塞ddl" tabindex="-1"><a class="header-anchor" href="#b-未提交事物-阻塞ddl" aria-hidden="true">#</a> b. 未提交事物，阻塞DDL</h4><p>通过 show processlist没有找到表上的操作，但是通过<code>information_schema.innodb_trx</code>发现有未提交的事物，</p><h4 id="c-异常的状况" tabindex="-1"><a class="header-anchor" href="#c-异常的状况" aria-hidden="true">#</a> c. 异常的状况</h4><p>通过 show processlist 和事物查询都没有的情况下，可能的场景是一个显示的事物中，对表的操作出现了异常，虽然事物失败，但是持有的锁还没有释放，也会导致这个原因</p><p>可以在<code>performance_schema.events_statements_current</code>表中查询失败的语句</p><h3 id="_3-mdl分类与sql实例" tabindex="-1"><a class="header-anchor" href="#_3-mdl分类与sql实例" aria-hidden="true">#</a> 3. MDL分类与sql实例</h3><p>前面两小节，分别说明什么是MDL（朴素理解为表的元数据锁），以及当修改表时出现长时间的等待MDL的原因分析；正常看完之后，应该会有下面的疑惑</p><ul><li>MDL有哪些类型</li><li>哪些sql会持有MDL</li></ul><p>对于MDL的类型，从网上截一张图</p><figure><img src="'+k+'" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure><p>接下来需要分析下不同锁模式对应的sql</p><table><thead><tr><th>属性</th><th>含义</th><th>事例</th></tr></thead><tbody><tr><td><code>MDL_INTENTION_EXCLUSIVE(IX)</code></td><td>意向排他锁用于global和commit的加锁。</td><td><code>truncate table t1;</code> <code>insert into t1 values(3,’abcde’);</code> 会加如下锁 <code>(GLOBAL,MDL_STATEMENT,MDL_INTENTION_EXCLUSIVE）(SCHEMA,MDL_TRANSACTION,MDL_INTENTION_EXCLUSIVE)</code></td></tr><tr><td><code>MDL_SHARED(S)</code></td><td>只访问元数据 比如表结构，不访问数据。</td><td><code>set golbal_read_only =on</code> 加锁 <code>(GLOBAL，MDL_EXPLICIT，MDL_SHARED）</code></td></tr><tr><td><code>MDL_SHARED_HIGH_PRIO(SH)</code></td><td>用于访问<code>information_scheam</code>表，不涉及数据。</td><td><code>select * from information_schema.tables;show create table xx; desc xxx;</code> 会加如下锁： <code>(TABLE,MDL_TRANSACTION,MDL_SHARED_HIGH_PRIO)</code></td></tr><tr><td><code>MDL_SHARED_READ(SR)</code></td><td>访问表结构并且读表数据</td><td><code>select * from t1;</code> <code>lock table t1 read;</code> 会加如下锁: <code>(TABLE，MDL_TRANSACTION，MDL_SHARE_READ）</code></td></tr><tr><td><code>MDL_SHARED_WRITE(SW)</code></td><td>访问表结构并且写表数据</td><td><code>insert/update/delete/select .. for update</code> 会加如下锁：<code>(TABLE，MDL_TRANSACTION，MDL_SHARE_WRITE)</code></td></tr><tr><td><code>MDL_SHARED_UPGRADABLE(SU)</code></td><td>是mysql5.6引入的新的metadata lock,可以说是为了online ddl 才引入的。特点是允许DML，防止DDL；</td><td><code>alter table/create index/drop index</code> 会加该锁; 加入下锁 <code>（TABLE，MDL_TRANSACTION，MDL_SHARED_UPGRADABLE）</code></td></tr><tr><td><code>MDL_SHARED_NO_WRITE(SNW)</code></td><td>可升级锁，访问表结构并且读写表数据，并且禁止其它事务写。</td><td><code>alter table t1 modify c bigint;</code> (非onlineddl) <code>(TABLE，MDL_TRANSACTION，MDL_SHARED_NO_WRITE）</code></td></tr><tr><td><code>MDL_SHARED_NO_READ_WRITE(SNRW)</code></td><td>可升级锁，访问表结构并且读写表数据，并且禁止其它事务读写。</td><td><code>lock table t1 write;</code> 加锁 <code>(TABLE，MDL_TRANSACTION,MDL_SHARED_NO_READ_WRITE</code></td></tr><tr><td><code>MDL_EXCLUSIVE(X)</code></td><td>防止其他线程读写元数据</td><td><code>CREATE/DROP/RENAME TABLE</code>，其他online DDL在rename阶段也持有X锁<code>(TABLE，MDL_TRANSACTION，MDL_EXCLUSIVE）</code></td></tr></tbody></table><h3 id="_4-小结" tabindex="-1"><a class="header-anchor" href="#_4-小结" aria-hidden="true">#</a> 4， 小结</h3><p>上面的内容，可能信息量比较大，特别是MDL的锁分类情况，很难抓住重点，针对我们日常接触中，简单给出小结</p><ul><li>MDL是为了保证事物执行过程中，表结构不被修改引入的；因此修改表结构的前提是这个表上没有事物（没有正在执行，失败，或者未提交的事物）</li><li>DDL执行，一般来讲是需要获取排他的MDL</li><li>DML都会开启事物，因此会获取 <code>MDL_SW</code> 锁</li><li>DQL语句会获取 <code>MDL_SR</code> 锁</li></ul><p>几个简称的说明</p><ul><li>MDL: metadata lock，可以简单理解为表的元数据锁</li><li>DDL: 数据定义语言，可以简单理解为表的操作，如创建，修改，删除表、视图等，新增索引、字段等操作</li><li>DML: 数据操作语言，也就是我们常规理解的 <code>insert, update, delete</code> 语句</li><li>DQL: 数据查询语言，常见的<code>select</code>语句</li></ul><p>几个常见疑问解答</p><h4 id="a-为什么同一张表的多个ddl不能并行执行" tabindex="-1"><a class="header-anchor" href="#a-为什么同一张表的多个ddl不能并行执行" aria-hidden="true">#</a> a. 为什么同一张表的多个DDL不能并行执行</h4><ul><li>MDL读锁是互相兼容的,可以有多个增删查改</li><li>MDL写锁是互斥的,只能有一个表的DDL</li></ul><h4 id="b-为什么有时候ddl会卡住" tabindex="-1"><a class="header-anchor" href="#b-为什么有时候ddl会卡住" aria-hidden="true">#</a> b. 为什么有时候DDL会卡住</h4><ul><li>MDL读写锁之间是互斥的,所以如果DDL卡住,就证明有事务在执行,不能申请MDL写锁</li></ul><h4 id="c-常见卡住的场景" tabindex="-1"><a class="header-anchor" href="#c-常见卡住的场景" aria-hidden="true">#</a> c. 常见卡住的场景</h4><ul><li>非常频繁的业务高峰期</li><li>有慢查询把持着MDL读锁</li><li>有事物一直未提交</li></ul><h4 id="d-为什么需要mdl锁" tabindex="-1"><a class="header-anchor" href="#d-为什么需要mdl锁" aria-hidden="true">#</a> d. 为什么需要MDL锁</h4><ul><li>当事务本身执行的时候理论上是不能容忍表结构在中途发生改变的</li></ul><h3 id="_5-更多参考" tabindex="-1"><a class="header-anchor" href="#_5-更多参考" aria-hidden="true">#</a> 5. 更多参考</h3><p>相关博文或者问答</p>',44),y={href:"https://stackoverflow.com/questions/41126470/why-aiomysql-locks-the-table-even-when-using-context-manager",target:"_blank",rel:"noopener noreferrer"},A={href:"https://www.jb51.net/article/145599.htm",target:"_blank",rel:"noopener noreferrer"},x={href:"http://www.ywnds.com/?p=7209",target:"_blank",rel:"noopener noreferrer"};function w(I,T){const s=d("ExternalLinkIcon");return l(),i("div",null,[b,v,D,c(" more "),L,a("ul",null,[a("li",null,[a("a",g,[n("Why aiomysql locks the table even when using context manager? "),e(s)])])]),M,a("blockquote",null,[a("p",null,[n("找到一篇文章说MDL的，推荐详细阅读 "),a("a",f,[n("MySQL表结构变更你不可不知的Metadata Lock详解"),e(s)])])]),E,a("ul",null,[a("li",null,[a("a",y,[n("Why aiomysql locks the table even when using context manager? "),e(s)])]),a("li",null,[a("a",A,[n("MySQL表结构变更你不可不知的Metadata Lock详解"),e(s)])]),a("li",null,[a("a",x,[n("理解MySQL的MDL元数据锁"),e(s)])])])])}const S=o(_,[["render",w],["__file","10.190308-Mysql-DDL出现长时间等待MDL问题分析.html.vue"]]);export{S as default};
