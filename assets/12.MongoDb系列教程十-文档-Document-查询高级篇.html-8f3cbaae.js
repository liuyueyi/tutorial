import{_ as a,V as s,W as t,a1 as e,X as n,a0 as o}from"./framework-23f3cf9b.js";const p="/tutorial/imgs/200331/00.jpg",i="/tutorial/imgs/200331/01.jpg",c="/tutorial/imgs/200331/02.jpg",u="/tutorial/imgs/200331/03.jpg",d="/tutorial/imgs/200331/04.jpg",l="/tutorial/imgs/200331/05.jpg",r="/tutorial/imgs/200331/06.jpg",g="/tutorial/imgs/200331/07.jpg",m={},b=n("p",null,"上一篇的mongodb查询，主要介绍的是一些基本操作，当然有基本就高阶操作；",-1),k=n("p",null,"本文将带来更多的查询姿势",-1),q=n("ul",null,[n("li",null,"排序"),n("li",null,"分页"),n("li",null,"聚合")],-1),v=o(`<h3 id="_1-排序" tabindex="-1"><a class="header-anchor" href="#_1-排序" aria-hidden="true">#</a> 1. 排序</h3><p>在mongodb中，使用sort方法进行排序，语法如下</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>db.collection.find<span class="token punctuation">(</span><span class="token punctuation">)</span>.sort<span class="token punctuation">(</span><span class="token punctuation">{</span>key: <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，sort内部是一个对象，key为field，value为1或者-1，其中1表示升序，-1表示降序</p><p>实例说明，根据age进行排序</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>db.doc_demo.find<span class="token punctuation">(</span><span class="token punctuation">)</span>.sort<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&#39;age&#39;</span><span class="token builtin class-name">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出如下:</p><figure><img src="`+p+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上面的演示属于常规的操作，但是针对mongodb的特点，自然会有一些疑问</p><p><strong>q1: 如果某个文档没有包含这个field，排序是怎样的？</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>db.doc_demo.find<span class="token punctuation">(</span><span class="token punctuation">)</span>.sort<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&#39;tag&#39;</span><span class="token builtin class-name">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+i+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从输出来看，升序时，不包含这个field的文档，在最前面；降序时，不包含这个field的文档，在最后面</p><p><strong>q2: 支持多个field排序吗？</strong></p><p>原则上一般不建议多个field的排序（比较影响性能），但对于数据库而言，你得支持吧</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 在开始之前，先改一下tag，让文档不完全一致</span>
db.doc_demo.update<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&quot;_id&quot;</span><span class="token builtin class-name">:</span> ObjectId<span class="token punctuation">(</span><span class="token string">&quot;5e7b5ac10172dc950171c488&quot;</span><span class="token punctuation">)</span><span class="token punctuation">}</span>, <span class="token punctuation">{</span><span class="token variable">$set</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span><span class="token string">&#39;tag&#39;</span><span class="token builtin class-name">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
db.doc_demo.update<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&quot;_id&quot;</span><span class="token builtin class-name">:</span> ObjectId<span class="token punctuation">(</span><span class="token string">&quot;5e7b5bb085a742842d2e23fc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">}</span>, <span class="token punctuation">{</span><span class="token variable">$set</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span><span class="token string">&#39;tag&#39;</span><span class="token builtin class-name">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment"># 先根据age进行升序排，当age相同的，根据tag降序排</span>
db.doc_demo.find<span class="token punctuation">(</span><span class="token punctuation">)</span>.sort<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&#39;age&#39;</span><span class="token builtin class-name">:</span> <span class="token number">1</span>, <span class="token string">&#39;tag&#39;</span><span class="token builtin class-name">:</span> -1<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment"># 先根据tag进行升序排，tag相同的，根据age升序排</span>
db.doc_demo.find<span class="token punctuation">(</span><span class="token punctuation">)</span>.sort<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&#39;tag&#39;</span><span class="token builtin class-name">:</span> <span class="token number">1</span>, <span class="token string">&#39;age&#39;</span><span class="token builtin class-name">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+c+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>请注意上的输出，在涉及到多个field排序时，优先根据第一个进行排序，当文档的field相同时，再根据后面的进行排序</p><h3 id="_2-分页" tabindex="-1"><a class="header-anchor" href="#_2-分页" aria-hidden="true">#</a> 2. 分页</h3><p>当文档很多时，我们不可能把所有的文档一次返回，所以就有了常见的分页，在sql中我们一般使用<code>limit</code> <code>offset</code>来实现分页，在mongodb中也差不多</p><p><strong>limit()</strong></p><p>限制返回的文档数</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>db.doc_demo.find<span class="token punctuation">(</span><span class="token punctuation">)</span>.limit<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+u+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>skip()</strong></p><p>使用limit进行返回条数限制，使用skip进行分页，表示跳过前面的n条数据</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 跳过第一条数据，返回两条； 相当于返回第2、3条数据</span>
db.doc_demo.find<span class="token punctuation">(</span><span class="token punctuation">)</span>.limit<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>.skip<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+d+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-聚合" tabindex="-1"><a class="header-anchor" href="#_3-聚合" aria-hidden="true">#</a> 3. 聚合</h3><p>使用<code>aggregate()</code>来实现聚合，用于处理求和、平均值，最大值，分组等</p><p>数据准备:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>{ &quot;_id&quot; : ObjectId(&quot;5e7b5ac10172dc950171c488&quot;), &quot;name&quot; : &quot;一灰灰blog&quot;, &quot;age&quot; : &quot;19&quot;, &quot;skill&quot; : [ &quot;java&quot;, &quot;python&quot;, &quot;sql&quot; ], &quot;tag&quot; : 2 }
{ &quot;_id&quot; : ObjectId(&quot;5e7b5ac40172dc950171c489&quot;), &quot;name&quot; : &quot;一灰灰blog&quot;, &quot;age&quot; : 20, &quot;skill&quot; : [ &quot;web&quot;, &quot;shell&quot;, &quot;js&quot; ], &quot;tag&quot; : 1 }
{ &quot;_id&quot; : ObjectId(&quot;5e7b5bb085a742842d2e23fc&quot;), &quot;name&quot; : &quot;一灰灰&quot;, &quot;age&quot; : 18, &quot;sex&quot; : &quot;man&quot;, &quot;tag&quot; : 2 }
{ &quot;_id&quot; : ObjectId(&quot;5e7b5c2e0172dc950171c48a&quot;), &quot;name&quot; : &quot;一灰灰&quot;, &quot;age&quot; : 18, &quot;hobby&quot; : [ &quot;play game&quot; ] }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>分组查询</strong></p><p>根据name进行分组统计</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 根据name进行分组，统计文档数量</span>
<span class="token comment"># 相当于sql中的  select name, count(1) from doc_demo group by name</span>
db.doc_demo.aggregate<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token variable">$group</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>_id: <span class="token string">&quot;<span class="token variable">$name</span>&quot;</span>, size: <span class="token punctuation">{</span><span class="token variable">$sum</span><span class="token builtin class-name">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>请注意，分组的条件中</p><ul><li><code>_id</code>: 表示根据哪个字段进行分组</li><li><code>size: {}</code>: 表示聚合条件指定，将结果输出到名为size的field中</li><li><code>filed</code>名前加<code>$</code>进行指定</li></ul><p>当前mongodb支持的聚合表达式包括:</p><table><thead><tr><th>表达式</th><th>说明</th><th>举例说明</th></tr></thead><tbody><tr><td>sum</td><td>求和</td><td><code>db.doc_demo.aggregate([{$group: {_id: &quot;$name&quot;, size: {$sum: &#39;$age&#39;}}}])</code></td></tr><tr><td>avg</td><td>平均值</td><td><code>db.doc_demo.aggregate([{$group: {_id: &quot;$name&quot;, size: {$avg: &#39;$age&#39;}}}])</code></td></tr><tr><td>min</td><td>取最小</td><td><code>db.doc_demo.aggregate([{$group: {_id: &quot;$name&quot;, age: {$min: &#39;$age&#39;}}}])</code></td></tr><tr><td>max</td><td>取最大</td><td><code>db.doc_demo.aggregate([{$group: {_id: &quot;$name&quot;, age: {$max: &#39;$age&#39;}}}])</code></td></tr><tr><td>push</td><td>结果插入到一个数组中</td><td><code>db.doc_demo.aggregate([{$group: {_id: &quot;$name&quot;, age: {$push: &#39;$age&#39;}}}])</code></td></tr><tr><td>addToSet</td><td>结果插入集合，过滤重复</td><td><code>db.doc_demo.aggregate([{$group: {_id: &quot;$name&quot;, age: {$addToSet: &#39;$age&#39;}}}])</code></td></tr><tr><td>first</td><td>第一个</td><td><code>db.doc_demo.aggregate([{$group: {_id: &quot;$name&quot;, age: {$first: &#39;$age&#39;}}}])</code></td></tr><tr><td>last</td><td>最后一个</td><td><code>db.doc_demo.aggregate([{$group: {_id: &quot;$name&quot;, age: {$last: &#39;$age&#39;}}}])</code></td></tr></tbody></table><figure><img src="'+r+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上面虽然介绍了分组支持的一些表达式，但是没有查询条件，难道只能针对所有的文档进行分组统计么？</p><p><strong>分组过滤</strong></p><p>借助<code>$match</code>来实现过滤统计，如下</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>db.doc_demo.aggregate<span class="token punctuation">(</span><span class="token punctuation">[</span>
  <span class="token punctuation">{</span><span class="token variable">$match</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span><span class="token string">&#39;tag&#39;</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span><span class="token variable">$gt</span><span class="token builtin class-name">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span>, 
  <span class="token punctuation">{</span><span class="token variable">$group</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>_id: <span class="token string">&#39;$name&#39;</span>, age: <span class="token punctuation">{</span><span class="token variable">$sum</span><span class="token builtin class-name">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>请注意，$match的语法规则和find的查询条件一样，会将满足条件的数据传递给后面的分组计算</p><p>这种方式和liux中的管道特别相似，aggregate方法的参数数组中，前面的执行完毕之后，将结果传递给后面的继续执行，除了<code>$match</code>和<code>$group</code>之外，还有一些其他的操作</p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>$project</td><td>修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</td></tr><tr><td>$match</td><td>用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</td></tr><tr><td>$limit</td><td>用来限制MongoDB聚合管道返回的文档数。</td></tr><tr><td>$skip</td><td>在聚合管道中跳过指定数量的文档，并返回余下的文档。</td></tr><tr><td>$unwind</td><td>将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</td></tr><tr><td>$group</td><td>将集合中的文档分组，可用于统计结果。</td></tr><tr><td>$sort</td><td>将输入文档排序后输出。</td></tr><tr><td>$geoNear</td><td>输出接近某一地理位置的有序文档。</td></tr></tbody></table>',49);function _(h,f){return s(),t("div",null,[b,k,q,e(" more "),v])}const x=a(m,[["render",_],["__file","12.MongoDb系列教程十-文档-Document-查询高级篇.html.vue"]]);export{x as default};
