import{_ as s,V as n,W as e,X as p,Y as a,Z as t,a1 as i}from"./framework-094145d2.js";const c={},l=a("h1",{id:"实战8-容器的初始化大小指定",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#实战8-容器的初始化大小指定","aria-hidden":"true"},"#"),t(" 实战8：容器的初始化大小指定")],-1),o=a("p",null,"容器可以说是我们日常开发中，除了基本对象之外，使用最多的类了，那么平时在使用的时候，是否有主意到良好编程习惯的大佬，在创建容器的时候，一般会设置size；那么他们为什么要这么干呢？是出于什么进行考量的呢？",-1),r=a("p",null,"今天我们将针对最常见的List/Map/Set三种容器类型的初始化值选择，进行说明",-1),d=i(`<h2 id="_1-容器初始化" tabindex="-1"><a class="header-anchor" href="#_1-容器初始化" aria-hidden="true">#</a> 1. 容器初始化</h2><h3 id="_1-1-list" tabindex="-1"><a class="header-anchor" href="#_1-1-list" aria-hidden="true">#</a> 1.1. List</h3><p>列表，在我们日常使用过程中，会接触到下面几个</p><ul><li>ArrayList: 最常见的数组列表</li><li>LinkedList: 基于链表的列表</li><li>CopyOnWriteArrayList: 线程安全的数组列表</li></ul><p>接下来逐一进行说明</p><h4 id="_1-1-1-arraylist" tabindex="-1"><a class="header-anchor" href="#_1-1-1-arraylist" aria-hidden="true">#</a> 1.1.1 ArrayList</h4><p>现在以ArrayList为例，进行源码分析，当我们不指定列表大小，直接创建时</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是内部实现，其中<code>elementData</code>就是列表中存数据的数组，初始化为默认数组</p><p>当我们第一次添加一个元素时，发现数组为默认值，会触发一次数组扩容，新的数组大小为10 （详情看源码）</p><p>其次就是数组的库容机制，通过源码/网上分享知识点可以知道，这个扩容的实现如下</p><ul><li>当新添加的元素，数组放不下时，实现扩容</li><li><code>扩容后的大小</code> = <code>扩容前大小</code> + max(<code>添加元素个数</code>, 1/2 * <code>扩容前大小</code>)</li></ul><p>基于上面的知识点，大致可以得出指定列表长度的好处</p><ul><li>节省空间（用多少申请多少，避免浪费）</li><li>减少扩容带来的拷贝（扩容一次就会带来一次数组拷贝，如果已知列表很大，结果还使用默认的10，这会产生很多可避免的扩容开销）</li></ul><h4 id="_1-1-2-linkedlist" tabindex="-1"><a class="header-anchor" href="#_1-1-2-linkedlist" aria-hidden="true">#</a> 1.1.2 LinkedList</h4><p>基于链表的列表，不同于上面的数组列表，它没有提供指定大小的构造方法，why?</p><p>因为链表本身的数据结构的特点，它就像糖葫芦一样，一个串一个，有数据，才有接上的可能，因此不需要指定大小</p><h4 id="_1-1-3-copyonwritearraylist" tabindex="-1"><a class="header-anchor" href="#_1-1-3-copyonwritearraylist" aria-hidden="true">#</a> 1.1.3 CopyOnWriteArrayList</h4><p>这个又非常有意思，它同样不能指定大小，但是原因与前面不同，主要在于它保证线程安全的实现方式</p><ul><li>每次新增/修改(加锁，保证单线程访问)，都是在拷贝的数组操作；完成之后，用新的替换旧的</li></ul><p>所以说，每次变更，都会存在数组拷贝，因此就没有必要提前指定数组大小</p><p>那么它的初始化每次都使用默认的么?</p><p>并不是这样的，当我们已知这个列表中的值时，推荐使用下面这种方式</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> values<span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">&quot;12&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;220&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> cList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>将初始化值，放在一个普通的列表中，然后利用普通列表来初始化<code>CopyOnWriteArrayList</code></li></ul><h3 id="_1-2-map" tabindex="-1"><a class="header-anchor" href="#_1-2-map" aria-hidden="true">#</a> 1.2.Map</h3><p>常见的map容器使用，大多是下面几个</p><ul><li><code>HashMap</code></li><li><code>LinkedHashMap</code>: 有序的hashmap</li><li><code>TreeMap</code>: 有序的hashmap</li><li><code>ConcurrentHashMap</code>: 线程安全的map</li></ul><h4 id="_1-2-1-hashmap" tabindex="-1"><a class="header-anchor" href="#_1-2-1-hashmap" aria-hidden="true">#</a> 1.2.1 HashMap</h4><p>HashMap的底层数据结构是 <code>数组 + 链表/红黑树</code>，关于这个就不细说了</p><p>我们在初始化时，若不指定size，则数组的默认长度为8（请注意，Map的数组长度是2的倍数）</p><p>与ArrayList的扩容时机不一样的是，默认情况下，Map容量没满就会触发一次扩容</p><p>默认是数量达到 <code>size * 0.75</code>(0.75为扩容因子，可以在创建时修改)，就会触发一次扩容</p><p>why?</p><ul><li>主要是为了减少hash冲突</li></ul><p>同样的为了减少冲突，在初始化时，我们需要指定一个合适大小</p><p>比如我们</p><ul><li>已知map的数量为2，这个时候Map的大小选择因该是4</li><li>map数量为6，这个时候Map的大小选择是16</li></ul><p>有时候让我们自己来计算这个值，就有些麻烦了，这个时候，可以直接使用Guava的工具类来完成这个目的</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newHashMapWithExpectedSize</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_1-2-2-linkedhashmap" tabindex="-1"><a class="header-anchor" href="#_1-2-2-linkedhashmap" aria-hidden="true">#</a> 1.2.2 LinkedHashMap</h4><p>初始化方式同上，略</p><h4 id="_1-2-3-concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#_1-2-3-concurrenthashmap" aria-hidden="true">#</a> 1.2.3 ConcurrentHashMap</h4><p>初始化方式同上，略</p><h4 id="_1-2-4-treemap" tabindex="-1"><a class="header-anchor" href="#_1-2-4-treemap" aria-hidden="true">#</a> 1.2.4 TreeMap</h4><p>不同于上面几个的是treeMap，没有提供指定容器大小的构造方法</p><p>原因和前面说到的LinkedList有些类似，TreeMap的底层数据结构为Tree，所以新增数据是挂在树的一个节点下面，无需指定容量大小</p><h3 id="_1-3-set" tabindex="-1"><a class="header-anchor" href="#_1-3-set" aria-hidden="true">#</a> 1.3. Set</h3><p>集合用的最多应该就是<code>HashSet</code>了，底层结构模型复用，所以初始化大小指定与HashMap一致，也不需要多说</p><h2 id="_2-小结" tabindex="-1"><a class="header-anchor" href="#_2-小结" aria-hidden="true">#</a> 2. 小结</h2><p>今天这篇博文主要介绍的是三种常见的容器，在创建时，如何指定容量大小</p><p>首先明确一点，指定容量大小是为了</p><ul><li>减少扩容带来的额外开销</li><li>指定容量代销，可以减少无效的内存开销</li></ul><p>初始化值设置的关键点:</p><ul><li>ArrayList: 数据有多少个，初始化值就是多少</li><li>HashMap: 考虑到扩容因子，初始化大小 = <code>(size / 0.75 + 1)</code></li></ul>`,55);function u(h,k){return n(),e("div",null,[l,o,r,p(" more "),d])}const m=s(c,[["render",u],["__file","08.容器的初始化大小指定.html.vue"]]);export{m as default};
