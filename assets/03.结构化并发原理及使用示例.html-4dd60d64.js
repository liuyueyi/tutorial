const e=JSON.parse('{"key":"v-5931c522","path":"/java/jdk/jdk21/03.%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html","title":"03.JDK21结构化并发：重新定义并发任务的生命周期管理","lang":"zh-CN","frontmatter":{"order":3,"title":"03.JDK21结构化并发：重新定义并发任务的生命周期管理","tag":["jdk"],"category":["Java","JDK21"],"date":"2025-02-13T15:48:09.000Z","keywords":["Java","JDK21","结构化并发"],"description":"1. 背景：为什么需要结构化并发？ 在传统Java并发编程中，开发者通过ExecutorService、Future或CompletableFuture管理多线程任务。然而，这些方式存在显著问题： 生命周期管理困难：子任务可能脱离父任务独立运行，导致“线程泄漏” 错误处理复杂：异常可能被静默吞噬，难以追踪问题根源 资源浪费：未及时关闭的线程池可能持续占用系统资源","head":[["meta",{"property":"og:url","content":"https://liuyueyi.github.io/tutorial/java/jdk/jdk21/03.%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html"}],["meta",{"property":"og:site_name","content":"一灰灰的站点"}],["meta",{"property":"og:title","content":"03.JDK21结构化并发：重新定义并发任务的生命周期管理"}],["meta",{"property":"og:description","content":"1. 背景：为什么需要结构化并发？ 在传统Java并发编程中，开发者通过ExecutorService、Future或CompletableFuture管理多线程任务。然而，这些方式存在显著问题： 生命周期管理困难：子任务可能脱离父任务独立运行，导致“线程泄漏” 错误处理复杂：异常可能被静默吞噬，难以追踪问题根源 资源浪费：未及时关闭的线程池可能持续占用系统资源"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-13T08:59:24.000Z"}],["meta",{"property":"article:tag","content":"jdk"}],["meta",{"property":"article:published_time","content":"2025-02-13T15:48:09.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-13T08:59:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"03.JDK21结构化并发：重新定义并发任务的生命周期管理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-02-13T15:48:09.000Z\\",\\"dateModified\\":\\"2025-02-13T08:59:24.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"1. 背景：为什么需要结构化并发？","slug":"_1-背景-为什么需要结构化并发","link":"#_1-背景-为什么需要结构化并发","children":[]},{"level":2,"title":"2. 原理：结构化并发如何工作？","slug":"_2-原理-结构化并发如何工作","link":"#_2-原理-结构化并发如何工作","children":[{"level":3,"title":"2.1 传统并发 vs 结构化并发","slug":"_2-1-传统并发-vs-结构化并发","link":"#_2-1-传统并发-vs-结构化并发","children":[]},{"level":3,"title":"核心机制","slug":"核心机制","link":"#核心机制","children":[]},{"level":3,"title":"2.2 架构示意图","slug":"_2-2-架构示意图","link":"#_2-2-架构示意图","children":[]}]},{"level":2,"title":"3. 优势：为什么选择结构化并发？","slug":"_3-优势-为什么选择结构化并发","link":"#_3-优势-为什么选择结构化并发","children":[]},{"level":2,"title":"4. 使用示例","slug":"_4-使用示例","link":"#_4-使用示例","children":[{"level":3,"title":"示例1：基本使用","slug":"示例1-基本使用","link":"#示例1-基本使用","children":[]},{"level":3,"title":"示例2：订单处理（超时控制+异常处理）","slug":"示例2-订单处理-超时控制-异常处理","link":"#示例2-订单处理-超时控制-异常处理","children":[]},{"level":3,"title":"示例3：并行聚合数据","slug":"示例3-并行聚合数据","link":"#示例3-并行聚合数据","children":[]}]},{"level":2,"title":"5. 小结","slug":"_5-小结","link":"#_5-小结","children":[{"level":3,"title":"5.1 注意事项","slug":"_5-1-注意事项","link":"#_5-1-注意事项","children":[]},{"level":3,"title":"5.2 小结","slug":"_5-2-小结","link":"#_5-2-小结","children":[]}]}],"git":{"createdTime":1739437164000,"updatedTime":1739437164000,"contributors":[{"name":"yihui","email":"bangzewu@126.com","commits":1}]},"readingTime":{"minutes":5.43,"words":1629},"filePathRelative":"java/jdk/jdk21/03.结构化并发原理及使用示例.md","localizedDate":"2025年2月13日","excerpt":"<h2> 1. 背景：为什么需要结构化并发？</h2>\\n<p>在传统Java并发编程中，开发者通过<code>ExecutorService</code>、<code>Future</code>或<code>CompletableFuture</code>管理多线程任务。然而，这些方式存在显著问题：</p>\\n<ol>\\n<li><strong>生命周期管理困难</strong>：子任务可能脱离父任务独立运行，导致“线程泄漏”</li>\\n<li><strong>错误处理复杂</strong>：异常可能被静默吞噬，难以追踪问题根源</li>\\n<li><strong>资源浪费</strong>：未及时关闭的线程池可能持续占用系统资源</li>\\n</ol>","copyright":{},"autoDesc":true}');export{e as data};
