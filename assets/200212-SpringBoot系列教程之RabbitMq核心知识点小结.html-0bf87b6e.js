import{_ as t,V as o,W as l,X as d,Y as e,Z as i,$ as r,a1 as n,F as h}from"./framework-094145d2.js";const s="/tutorial/imgs/200212/00.jpg",c="/tutorial/imgs/200212/01.jpg",p="/tutorial/imgs/200212/02.jpg",u="/tutorial/imgs/200212/03.jpg",b="/tutorial/imgs/200212/04.jpg",g="/tutorial/imgs/200212/05.jpg",_="/tutorial/imgs/200212/06.jpg",f="/tutorial/imgs/200212/07.jpg",m="/tutorial/imgs/200212/08.jpg",x={},Q=e("p",null,"RabbitMQ是一个基于AMQP协议实现的企业级消息系统，想要顺畅的玩耍的前提是得先了解它，本文将主要介绍rabbitmq的一些基本知识点",-1),k=e("ul",null,[e("li",null,"特点"),e("li",null,"基本概念"),e("li",null,"消息投递消费的几种姿势"),e("li",null,"事务"),e("li",null,"集群")],-1),M=e("h2",{id:"i-基本知识点",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#i-基本知识点","aria-hidden":"true"},"#"),i(" I. 基本知识点")],-1),y=e("p",null,"它是采用Erlang语言实现的AMQP(Advanced Message Queued Protocol)的消息中间件，最初起源于金融系统，用在分布式系统存储转发消息，目前广泛应用于各类系统用于解耦、削峰",-1),R=e("h3",{id:"_1-特点",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_1-特点","aria-hidden":"true"},"#"),i(" 1.特点")],-1),q=e("p",null,"首先得了解一下rabbitmq的特点，看看是否满足我们的系统需求（毕竟学习一个框架也是要不少时间的）",-1),C={href:"https://blog.csdn.net/weixin_40792878/article/details/82555791",target:"_blank",rel:"noopener noreferrer"},B=n('<p>主要特点，大致可以归纳为以下几个</p><ul><li>可靠性：通过支持消息持久化，支持事务，支持消费和传输的ack等来确保可靠性</li><li>路由机制：支持主流的订阅消费模式，如广播，订阅，headers匹配等</li><li>扩展性：多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li><li>高可用性：队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队仍然可用。</li><li>多种协议：RabbitMQ除了原生支持AMQP协议，还支持STOMP，MQTT等多种消息中间件协议。</li><li>多语言客户端：RabbitMQ几乎支持所有常用语言，比如Jav a、Python、Ruby、PHP、C#、JavaScript等。</li><li>管理界面：RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。</li><li>插件机制：RabbitMQ提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。</li></ul><h3 id="_2-基本概念" tabindex="-1"><a class="header-anchor" href="#_2-基本概念" aria-hidden="true">#</a> 2. 基本概念</h3><p>下图为rabbitmq的内部结构图</p><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从上图也可以发现几个基本概念（Message, Publisher, Exchange, Binding, Queue, Channel, Consuer, Virtual host）</p><p>下面逐一进行说明</p><h4 id="a-message" tabindex="-1"><a class="header-anchor" href="#a-message" aria-hidden="true">#</a> a. Message</h4><p>具体的消息，包含消息头（即附属的配置信息）和消息体（即消息的实体内容）</p><p>由发布者，将消息推送到Exchange，由消费者从Queue中获取</p><h4 id="b-publisher" tabindex="-1"><a class="header-anchor" href="#b-publisher" aria-hidden="true">#</a> b. Publisher</h4><p>消息生产者，负责将消息发布到交换器(Exchange)</p><h4 id="c-exchange" tabindex="-1"><a class="header-anchor" href="#c-exchange" aria-hidden="true">#</a> c. Exchange</h4><p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列</p><h4 id="d-binding" tabindex="-1"><a class="header-anchor" href="#d-binding" aria-hidden="true">#</a> d. Binding</h4><p>绑定，用于给Exchange和Queue建立关系，从而决定将这个交换器中的哪些消息，发送到对应的Queue</p><h4 id="e-queue" tabindex="-1"><a class="header-anchor" href="#e-queue" aria-hidden="true">#</a> e. Queue</h4><p>消息队列，用来保存消息直到发送给消费者</p><p>它是消息的容器，也是消息的终点</p><p>一个消息可投入一个或多个队列</p><p>消息一直在队列里面，等待消费者连接到这个队列将其取走</p><h4 id="f-connection" tabindex="-1"><a class="header-anchor" href="#f-connection" aria-hidden="true">#</a> f. Connection</h4><p>连接，内部持有一些channel，用于和queue打交道</p><h4 id="g-channel" tabindex="-1"><a class="header-anchor" href="#g-channel" aria-hidden="true">#</a> g. Channel</h4><p>信道（通道），MQ与外部打交道都是通过Channel来的，发布消息、订阅队列还是接收消息，这些动作都是通过Channel完成；</p><p>简单来说就是消息通过Channel塞进队列或者流出队列</p><h4 id="h-consumer" tabindex="-1"><a class="header-anchor" href="#h-consumer" aria-hidden="true">#</a> h. Consumer</h4><p>消费者，从消息队列中获取消息的主体</p><h4 id="i-virtual-host" tabindex="-1"><a class="header-anchor" href="#i-virtual-host" aria-hidden="true">#</a> i. Virtual Host</h4><p>虚拟主机，表示一批交换器、消息队列和相关对象。</p><p>虚拟主机是共享相同的身份认证和加密环境的独立服务器域。</p><p>每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。</p><p>vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 /</p><p><strong>可以理解为db中的数据库的概念，用于逻辑拆分</strong></p><h4 id="j-broker" tabindex="-1"><a class="header-anchor" href="#j-broker" aria-hidden="true">#</a> j. Broker</h4><p>消息队列服务器实体</p><h3 id="_3-消息投递消费" tabindex="-1"><a class="header-anchor" href="#_3-消息投递消费" aria-hidden="true">#</a> 3. 消息投递消费</h3><p>从前面的内部结构图可以知晓，消息由生产者发布到Exchange，然后通过路由规则，分发到绑定queue上，供消费者获取消息</p><p>接下来我们看一下Exchange支持的四种策略</p><h4 id="a-direct策略" tabindex="-1"><a class="header-anchor" href="#a-direct策略" aria-hidden="true">#</a> a. Direct策略</h4><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中</p><p>简单来讲，就是<code>rounting key</code>与<code>binding key</code>完全匹配</p><ul><li>如果一个队列绑定到交换机要求路由键为<code>dog</code></li><li>只转发<code>routing key</code> 标记为<code>dog</code>的消息，</li><li>不会转发<code>dog.puppy</code>，也不会转发“dog.guard”等等</li><li>它是完全匹配、单播的模式</li></ul><p>举例说明</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Exchange和两个队列绑定在一起：</p><ul><li>Q1的bindingkey是orange</li><li>Q2的binding key是black和green.</li><li>当Producer 发布一个消息，其<code>routing key</code>是<code>orange</code>时, exchange会把它放到Q1上, 如果是<code>black</code>或<code>green</code>就会到Q2上, 其余的Message被丢弃</li></ul><p><strong>注意</strong></p><ul><li>当有多个队列绑定到同一个Exchange，且binding key相同时，这时消息会分发给所有满足条件的队列</li></ul><h4 id="b-topic策略" tabindex="-1"><a class="header-anchor" href="#b-topic策略" aria-hidden="true">#</a> b. Topic策略</h4><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个策略可以看成是Direct策略的升级版，通过<code>routing key</code>与 <code>bingding key</code>的模式匹配方式来分发消息</p><p>简单来讲，直接策略是完全精确匹配，而topic则支持正则匹配，满足某类指定规则的（如以xxx开头的路由键），可以将消息分发过去</p><ul><li><code>#</code> 匹配0个或多个单词</li><li><code>*</code> 匹配不多不少一个单词</li></ul><p><strong>一个更直观的实例如下</strong></p><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Producer发送消息时需要设置routing_key,</p><ul><li>Q1 的binding key 是<code>*.orange.*</code></li><li>Q2 是 <code>*.*.rabbit</code> 和 <code>lazy.#</code>：</li><li>发布一个<code>routing key</code>为<code>test.orange.mm</code> 消息，则会路由到Q1； <ul><li><strong>注意：</strong> 如果是<code>routng key</code>是 <code>test.orange</code>则无法路由到Q1，</li><li>因为Q1的规则是三个单词，中间一个为orange，不满足这个规则的都无效</li></ul></li><li>发布一个<code>routing key</code>为<code>test.qq.rabbit</code>或者<code>lazy.qq</code>的消息 都可以分发到Q2；即路由key为三个单词，最后一个为rabbit或者不限制单词个数，主要第一个是lazy的消息，都可以分发过来</li><li>如果发布的是一个<code>test.orange.rabbit</code>消息，则Q1和Q2都可以满足 <ul><li><strong>注意：</strong> 这时两个队列都会接受到这个消息</li></ul></li></ul><h4 id="c-fanout策略" tabindex="-1"><a class="header-anchor" href="#c-fanout策略" aria-hidden="true">#</a> c. Fanout策略</h4><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>广播策略，忽略<code>routing key</code> 和 <code>binding key</code>，将消息分发给所有绑定在这个exchange上的queue</p><h4 id="d-headers策略" tabindex="-1"><a class="header-anchor" href="#d-headers策略" aria-hidden="true">#</a> d. Headers策略</h4><p>这个实际上用得不多，它是根据Message的一些头部信息来分发过滤Message，忽略routing key的属性，如果Header信息和message消息的头信息相匹配</p><h2 id="ii-消息一致性问题" tabindex="-1"><a class="header-anchor" href="#ii-消息一致性问题" aria-hidden="true">#</a> II. 消息一致性问题</h2><p>在进入rabbitmq如何保证一致性之前，我们先得理解，什么是消息一致性？</p><h3 id="_1-一致性问题" tabindex="-1"><a class="header-anchor" href="#_1-一致性问题" aria-hidden="true">#</a> 1. 一致性问题</h3>',67),E={href:"https://www.php.cn/faq/415782.html",target:"_blank",rel:"noopener noreferrer"},v=n('<p><strong>按照我个人的粗浅理解，我认为的消息一致性，应该包含下面几个</strong></p><ul><li>生产者，确保消息发布成功 <ul><li>消息不会丢</li><li>顺序不会乱</li><li>消息不会重复（如重传，导致发布一次，却出现多个消息）</li></ul></li><li>消费者，确保消息消费成功 <ul><li>有序消费</li><li>不重复消费</li></ul></li></ul><p><strong>发送端</strong></p><p>为了确保发布者推送的消息不会丢失，我们需要消息持久化</p><ul><li>broker持久化消息</li></ul><p>为了确定消息正确接收</p><ul><li>publisher 需要知道消息投递并成功持久化</li></ul><h3 id="_2-持久化" tabindex="-1"><a class="header-anchor" href="#_2-持久化" aria-hidden="true">#</a> 2. 持久化</h3><p>这里的持久化，主要是指将内存中的消息保存到磁盘，避免mq宕机导致的内存中消息丢失；然而单纯的持久化，只是保证一致性的其中一个要素，比如publisher将消息发送到exchange，在broker持久化的工程中，宕机了导致持久化失败，而publisher并不知道持久化失败，这个时候就会出现数据丢失，为了解决这个问题，rabbitmq提供了事务机制</p><h3 id="_3-事务机制" tabindex="-1"><a class="header-anchor" href="#_3-事务机制" aria-hidden="true">#</a> 3. 事务机制</h3><p>事务机制能够解决生产者与broker之间消息确认的问题，只有消息成功被broker接受，事务才能提交成功，否则就进行事务回滚操作并进行消息重发。但是使用事务机制会降低RabbitMQ的消息吞吐量，不适用于需要发布大量消息的业务场景。</p><p><strong>注意，事务是同步的</strong></p><h3 id="_4-消息确认机制" tabindex="-1"><a class="header-anchor" href="#_4-消息确认机制" aria-hidden="true">#</a> 4. 消息确认机制</h3>',13),w={href:"https://blog.csdn.net/anumbrella/article/details/81321701",target:"_blank",rel:"noopener noreferrer"},A=n('<p>消息确认机制，可以区分为生产端和消费端</p><p><strong>生产端</strong></p><ul><li>生产者将信道设置成Confirm模式，一旦信道进入Confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID(以confirm.select为基础从1开始计数)，</li><li>一旦消息被投递到所有匹配的队列之后，Broker就会发送一个确认给生产者（包含消息的唯一ID）,这就使得生产者知道消息已经正确到达目的队列了，</li><li>如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出，</li><li>Broker回传给生产者的确认消息中deliver-tag域包含了确认消息的序列号（此外Broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理）</li></ul><p>Confirm模式属性异步，publisher发布一条消息之后，在等信道返回确认的同时，依然可以继续发送下一条消息，所以小概率会出现投递的消息顺序和broker中持久化消息顺序不一致的问题</p><p>一般从编程角度出发，Confirm模式有三种姿势</p><ul><li>普通Confirm模式：发送一条消息之后，等到服务器confirm，然后再发布下一条消息（串行发布）</li><li>批量Confirm模式：发送一批消息之后，等到服务器confirm，然后再发布下一批消息（如果失败，这一批消息全部重复，所以会有重复问题）</li><li>异步Confirm模式：提供一个回调方法，服务器confirm之后，触发回调方法，因此不会阻塞下一条消息的发送</li></ul><p><strong>消费端</strong></p><p>ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除。</p><ul><li>如果一个消费者在处理消息出现了网络不稳定、服务器异常等现象，那么就不会有ACK反馈，RabbitMQ会认为这个消息没有正常消费，会将消息重新放入队列中</li><li>如果在集群的情况下，RabbitMQ会立即将这个消息推送给这个在线的其他消费者。这种机制保证了在消费者服务端故障的时候，不丢失任何消息和任务</li><li>消息永远不会从RabbitMQ中删除，只有当消费者正确发送ACK反馈，RabbitMQ确认收到后，消息才会从RabbitMQ服务器的数据中删除</li></ul><h2 id="iii-集群" tabindex="-1"><a class="header-anchor" href="#iii-集群" aria-hidden="true">#</a> III. 集群</h2><p>按照目前的发展趋势，一个不支持集群的中间件基本上是不会有市场的；rabbitmq也是支持集群的，下面简单的介绍一下常见的4种集群架构模式</p>',11),P={href:"https://www.jianshu.com/p/b7cc32b94d2a",target:"_blank",rel:"noopener noreferrer"},j=n('<h3 id="_1-主备模式" tabindex="-1"><a class="header-anchor" href="#_1-主备模式" aria-hidden="true">#</a> 1. 主备模式</h3><p>这个属于常见的集群模式了，但又不太一样</p><p>主节点提供读写，备用节点不提供读写。如果主节点挂了，就切换到备用节点，原来的备用节点升级为主节点提供读写服务，当原来的主节点恢复运行后，原来的主节点就变成备用节点</p><h3 id="_2-远程模式" tabindex="-1"><a class="header-anchor" href="#_2-远程模式" aria-hidden="true">#</a> 2. 远程模式</h3><p>远程模式可以实现双活的一种模式，简称 shovel 模式，所谓的 shovel 就是把消息进行不同数据中心的复制工作，可以跨地域的让两个 MQ 集群互联，远距离通信和复制。</p><ul><li>Shovel 就是我们可以把消息进行数据中心的复制工作，我们可以跨地域的让两个 MQ 集群互联。</li></ul><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如上图，有两个异地的 MQ 集群（可以是更多的集群），当用户在地区 1 这里下单了，系统发消息到 1 区的 MQ 服务器，发现 MQ 服务已超过设定的阈值，负载过高，这条消息就会被转到 地区 2 的 MQ 服务器上，由 2 区的去执行后面的业务逻辑，相当于分摊我们的服务压力。</p><h3 id="_3-镜像模式" tabindex="-1"><a class="header-anchor" href="#_3-镜像模式" aria-hidden="true">#</a> 3. 镜像模式</h3><p>非常经典的 mirror 镜像模式，保证 100% 数据不丢失。在实际工作中也是用得最多的，并且实现非常的简单，一般互联网大厂都会构建这种镜像集群模式。</p><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如上图，用 KeepAlived 做了 HA-Proxy 的高可用，然后有 3 个节点的 MQ 服务，消息发送到主节点上，主节点通过 mirror 队列把数据同步到其他的 MQ 节点，这样来实现其高可靠</p><h3 id="_4-多活模式" tabindex="-1"><a class="header-anchor" href="#_4-多活模式" aria-hidden="true">#</a> 4. 多活模式</h3><p>也是实现异地数据复制的主流模式，因为 shovel 模式配置比较复杂，所以一般来说，实现异地集群的都是采用这种双活 或者 多活模型来实现的。这种模式需要依赖 rabbitMQ 的 federation 插件，可以实现持续的，可靠的 AMQP 数据通信，多活模式在实际配置与应用非常的简单</p><p>rabbitMQ 部署架构采用双中心模式(多中心)，那么在两套(或多套)数据中心各部署一套 rabbitMQ 集群，各中心的rabbitMQ 服务除了需要为业务提供正常的消息服务外，中心之间还需要实现部分队列消息共享。</p><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>federation 插件是一个不需要构建 cluster ，而在 brokers 之间传输消息的高性能插件，federation 插件可以在 brokers 或者 cluster 之间传输消息，连接的双方可以使用不同的 users 和 virtual hosts，双方也可以使用不同版本的 rabbitMQ 和 erlang。federation 插件使用 AMQP 协议通信，可以接受不连续的传输。federation 不是建立在集群上的，而是建立在单个节点上的，如图上黄色的 rabbit node 3 可以与绿色的 node1、node2、node3 中的任意一个利用 federation 插件进行数据同步。</p><h2 id="iv-其他" tabindex="-1"><a class="header-anchor" href="#iv-其他" aria-hidden="true">#</a> IV. 其他</h2><h3 id="_0-项目" tabindex="-1"><a class="header-anchor" href="#_0-项目" aria-hidden="true">#</a> 0. 项目</h3>',19),z={href:"https://github.com/liuyueyi/spring-boot-demo",target:"_blank",rel:"noopener noreferrer"},I=e("h3",{id:"_1-相关博文",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_1-相关博文","aria-hidden":"true"},"#"),i(" 1. 相关博文")],-1),V={href:"https://www.rabbitmq.com/getstarted.html",target:"_blank",rel:"noopener noreferrer"},S={href:"https://blog.csdn.net/weixin_40792878/article/details/82555791",target:"_blank",rel:"noopener noreferrer"},T={href:"https://blog.hhui.top/hexblog/2018/05/27/RabbitMQ%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/",target:"_blank",rel:"noopener noreferrer"},F={href:"https://blog.csdn.net/anumbrella/article/details/81321701",target:"_blank",rel:"noopener noreferrer"},H={href:"https://www.jianshu.com/p/b7cc32b94d2a",target:"_blank",rel:"noopener noreferrer"},N={href:"http://www.voidcn.com/article/p-fdbmgrcd-brm.html",target:"_blank",rel:"noopener noreferrer"},D={href:"http://www.liaoqiqi.com/post/215",target:"_blank",rel:"noopener noreferrer"},K=e("li",null,null,-1),J=e("h3",{id:"_2-一灰灰blog",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_2-一灰灰blog","aria-hidden":"true"},"#"),i(" 2. 一灰灰Blog")],-1),L=e("p",null,"尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激",-1),O=e("p",null,"下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛",-1),W={href:"https://blog.hhui.top",target:"_blank",rel:"noopener noreferrer"},X={href:"http://spring.hhui.top",target:"_blank",rel:"noopener noreferrer"},Y=e("figure",null,[e("img",{src:"https://spring.hhui.top/spring-blog/imgs/info/info.png",alt:"一灰灰blog",tabindex:"0",loading:"lazy"}),e("figcaption",null,"一灰灰blog")],-1);function Z($,G){const a=h("ExternalLinkIcon");return o(),l("div",null,[Q,k,d(" more "),M,y,R,q,e("blockquote",null,[e("p",null,[i("以下内容来自: "),e("a",C,[i("MQ和RabbitMQ作用特点"),r(a)])])]),B,e("blockquote",null,[e("p",null,[e("a",E,[i("数据的一致性是什么"),r(a)])])]),v,e("blockquote",null,[e("p",null,[e("a",w,[i("RabbitMQ学习(六)——消息确认机制(Confirm模式)"),r(a)])])]),A,e("blockquote",null,[e("p",null,[i("以下内容来自网上博文，详情请点击右边："),e("a",P,[i("RabbitMQ 的4种集群架构"),r(a)])])]),j,e("ul",null,[e("li",null,[i("工程："),e("a",z,[i("https://github.com/liuyueyi/spring-boot-demo"),r(a)])])]),I,e("ul",null,[e("li",null,[e("a",V,[i("RabbitMQ Tutorials"),r(a)])]),e("li",null,[e("a",S,[i("MQ和RabbitMQ作用特点"),r(a)])]),e("li",null,[e("a",T,[i("RabbitMq基础教程之基本概念"),r(a)])]),e("li",null,[e("a",F,[i("RabbitMQ学习(六)——消息确认机制(Confirm模式)"),r(a)])]),e("li",null,[e("a",H,[i("RabbitMQ 的4种集群架构"),r(a)])]),e("li",null,[e("a",N,[i("Rabbitmq是如何来保证事务的"),r(a)])]),e("li",null,[e("a",D,[i("rabbitmq消息一致性问题"),r(a)])]),K]),J,L,O,e("ul",null,[e("li",null,[i("一灰灰Blog个人博客 "),e("a",W,[i("https://blog.hhui.top"),r(a)])]),e("li",null,[i("一灰灰Blog-Spring专题博客 "),e("a",X,[i("http://spring.hhui.top"),r(a)])])]),Y])}const ee=t(x,[["render",Z],["__file","200212-SpringBoot系列教程之RabbitMq核心知识点小结.html.vue"]]);export{ee as default};
