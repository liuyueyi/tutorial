import{_ as e,V as l,W as d,X as a,Y as i,Z as n,a1 as t}from"./framework-094145d2.js";const r={},s=i("h1",{id:"一次分库分表全过程记录",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#一次分库分表全过程记录","aria-hidden":"true"},"#"),n(" 一次分库分表全过程记录")],-1),h=i("p",null,"实际操刀过一次线上的分库分表，距离现在时间有点久了，现在想一想，发现还是有不少有意思的东西，所以来一个迟到的记录",-1),c=t('<h2 id="i-背景分析" tabindex="-1"><a class="header-anchor" href="#i-背景分析" aria-hidden="true">#</a> I. 背景分析</h2><p>当时主要负责商品评价这一块业务，评价信息单表存储，主要包括一些基本的评价信息，商品id，订单id，买家id和卖家id，当时DB量级已经在3-4亿了，经常出现一些慢SQL，考虑到量级的问题，所以着手分库分表</p><h3 id="_1-分库分表" tabindex="-1"><a class="header-anchor" href="#_1-分库分表" aria-hidden="true">#</a> 1. 分库分表</h3><p>首先知道分库分表一般有两种方式，水平划分和垂直划分</p><p>在具体划分，可如下</p><ul><li>垂直分表：将大表拆分成小表，将表中一些不常用的信息拆分出去，避免跨页查询</li><li>垂直分库：根据不同的业务进行划分，每个业务有自己独立的数据库，如商品有商品库，用户有用户库，店铺有店铺库，db与db之间物理or逻辑分离</li><li>水平分表：根据表中某些数据行，定义某种映射规则，将不同的数据行分布到不同的表中（表的结构基本不变）</li><li>水平分库分表：将水平分表拆分出来的分表，放入不同的库中</li></ul><h3 id="_2-业务场景分析" tabindex="-1"><a class="header-anchor" href="#_2-业务场景分析" aria-hidden="true">#</a> 2. 业务场景分析</h3><p>根据上面分库分表的理解，很容易得出一个期待的结果</p><ul><li>独立的评价库，这个库里面只保存评价相关的信息</li><li>采用水平分表，将原表的数据，拆分到1024(这个分表数量可自定义)张分表中（如果拆分的较合理，则单表数据量在30-40w）</li></ul><p>那么一个问题就是如何进行水平拆分了，而考虑这一点，则需要根据实际的场景出发，分析sql的case</p><ul><li>商品详情的评价查询：根据商品ID进行查询</li><li>卖家管理端查询所有评价：根据卖家ID进行查询</li><li>买家评价管理：根据买家ID进行查询</li><li>订单列表的评价信息：根据订单ID进行查询</li></ul><p>粗略可以设定两种分表方案：</p><p>方案一：上面四种场景，显然是根据商品ID查询的量最大（因为详情的流量最大），如果根据商品ID进行分表，那么一个商品的评价都在落在一个分表中，此时查询不会出现夸表，但是另外三中查询则会导致跨表；同样换成卖家ID则会导致其他三个查询会跨表</p><p>第二种方式，建立一张附表，只保存如下信息</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>rateId: 评价ID\nitemId: 商品ID\nsellerId: 卖家ID\nbuyerId: 买家ID\norderId: 订单ID\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后根据rateId进行分库分表，这样每次查询时，先通过附表，查询到对应的评价ID，然后拿rateId到分表去获取评价信息</p><h3 id="_3-基本信息" tabindex="-1"><a class="header-anchor" href="#_3-基本信息" aria-hidden="true">#</a> 3. 基本信息</h3><p>在实际的操作之前，先给出当时的表信息（说明，数据库和表名和表结构为本文定义，与实际有差异）</p><table><thead><tr><th>define</th><th>desc</th></tr></thead><tbody><tr><td>数据库</td><td>mysql</td></tr><tr><td>存储引擎</td><td>innorDB</td></tr><tr><td>库名</td><td>rate</td></tr><tr><td>表名</td><td>ItemRate</td></tr><tr><td>量级</td><td>3-4亿</td></tr><tr><td>binlog</td><td>开启binlog消息，有下游业务方通过mq方式消费db的变更</td></tr></tbody></table><p>表结构类似下表，干掉了很多与主题无关的信息</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>CREATE TABLE `ItemRate` (\n  `id` bigint(20) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;评价id&#39;,\n  `orderId` bigint(20) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;订单id&#39;,\n  `buyerId` bigint(20) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;买家ID&#39;,\n  `sellerId` bigint(20) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;卖家ID&#39;,\n  `itemId` bigint(20) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;商品ID&#39;,\n  `comment` varchar(1000) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;评价内容&#39;,\n  `imgUrls` varchar(500) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;上传的图片&#39;,\n  `created` int(11) unsigned NOT NULL DEFAULT &#39;0&#39;,\n  `updated` int(11) unsigned NOT NULL DEFAULT &#39;0&#39;,\n  `info` tinyint(4) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;其他信息，省略...&#39;,\n  PRIMARY KEY `id` (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=&#39;评价表&#39;;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="ii-设计-实现" tabindex="-1"><a class="header-anchor" href="#ii-设计-实现" aria-hidden="true">#</a> II. 设计&amp;实现</h2><p>在实际操作之前，首先是选择如何分库分表的方案了，其次就是整个操作的步骤规划，当这两个搞定之后，在开始编码实现才是比较合适的</p><p>首先确定分4库1024张表 （组内大神的建议，合理分表规则后单表量级在10w级别，业务没有大变化时，短期内将无序再次分表）</p><h3 id="_1-方案设计" tabindex="-1"><a class="header-anchor" href="#_1-方案设计" aria-hidden="true">#</a> 1. 方案设计</h3><p>前面业务场景的分析中，就给出了两种方式，一个是根据商品ID进行分表，一个是建立一个附表然后根据rateId进行分表，首先是分表规则，我们选择最简单的方式，根据id % 1024进行取模</p><p>接下来分析下两种的优劣</p><h4 id="a-itemid分表方案" tabindex="-1"><a class="header-anchor" href="#a-itemid分表方案" aria-hidden="true">#</a> a. itemID分表方案</h4><p>优点：</p><ul><li>相比与下一种而言，实现简单，无需附表，也不用考虑数据不一致问题</li><li>可以支持详情评价列表复杂的排序逻辑（当时排序方案不是离线计算的，走的DB的排序方式）</li><li>性能更优，少了一张附表的过渡</li></ul><p>缺点：</p><ul><li>非itemId查询会跨表</li><li>hash不均，导致单表量较多（比如可能出现某些爆款商品就有几十万的评价）</li></ul><h4 id="b-rateid分表方案" tabindex="-1"><a class="header-anchor" href="#b-rateid分表方案" aria-hidden="true">#</a> b. rateId分表方案</h4><p>优点：</p><ul><li>支持前面的几种查询场景，不过需要先查询出rateId</li><li>单表数据量分布均匀</li></ul><p>缺点：</p><ul><li>复杂的查询条件支持不友好，特别是排序，过滤等依赖到一些评价信息的场景</li><li>插入和更新时，都需要同步更新附表，这个保证复杂性更高（即要满足多表的事务，需要自己实现失败回滚）</li><li>每次查询都需要先通过附表查询rateIds，效率更低（公司内的数据库中间件不允许join查询）</li></ul><h4 id="c-方案选择" tabindex="-1"><a class="header-anchor" href="#c-方案选择" aria-hidden="true">#</a> c. 方案选择</h4><p>通过实际分析，选择了根据itemId进行分表的方案，理由如下：</p><ul><li>业务逻辑简单，后续维护也方便</li><li>线上的sql中，95%以上都是根据itemId进行查询</li><li>上层有一层根据solr的搜索，因此根据buyerId,sellerId,orderId 可以走搜索，不需进行db的多表联合查询，且性能ok</li><li>附表虽然结构简单，但是单表最终的数据量依然可能很大，在亿级已上性能怎样也不好保证</li></ul><p>因此，最终选择的方式是：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>db    ： Rate000 ~ Rate003,  \ntable ： ItemRate0000 ~ ItemRaet1023\n\n其中映射规则：\n\ntableIndex = itemId % 1024         ---&gt; 分表名  如 ItemRate0122\ndbIndex    = itemId % 1024 / 256   ---&gt; 分库名  如 Rate001\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-步骤计划" tabindex="-1"><a class="header-anchor" href="#_2-步骤计划" aria-hidden="true">#</a> 2. 步骤计划</h3><p>整个迁移的步骤，有两种方式，一个是双写方案：</p><p>方案一：采用双写</p><ul><li>创建DB</li><li>服务的sql改造，主要是所有的sql，都要有一个新的分库分表的方式</li><li>线上开始双写（即新增一条评价时，即写入就得表，也写入新的表）</li><li>全量将旧表数据导入到新表数据</li><li>线上读流量切换到新表，验证是否有问题</li><li>所有关注旧表binlog的业务，全部迁移到关注新表的binlog（这里需要dba支持，因为新表有1024张，不可能关注1024个topic，这里需要dba提供binlog的整合，不在本文重点，此处略过）</li><li>关闭双写，所有写直接切到新表</li><li>删除旧代码</li></ul><p>方案二：基于db的binlog实现的异步同步方式</p><ul><li>创建DB</li><li>服务的sql改造，主要是所有的sql，都要有一个新的分库分表的方式</li><li>开启增量，将某个时刻开始之后所有更新的数据，通过异步方式增量同步到新表</li><li>开始全量，将之前的数据全部导入到新表</li><li>线上读切新表，验证服务是否有问题</li><li>所有关注旧表binlog业务，全部迁移到关注新表binlog</li><li>线上切写到新表</li><li>增量完毕后，关闭增量</li><li>删除旧代码</li></ul><p>两种方案本质上没有太大的区别，其中第一种双写，需要自己来保障双写成功；而后面增量的方式，一般DBA这边会有较好的方案来实现增量同步</p><p>额外说一点, 在实际的场景中，推动接听旧表binlog的业务方迁移是一件不可控的操作（因为啥原因大家都懂得），所以当时实际的情况是切到新表后，还会进行反向同步，即将新表的数据又重新的写入到旧表中，因此这种场景要求方案二中，切写到新表时，需要先停写一段时间，等待增量同步完毕之后，关闭增量，然后开启反向同步脚本，然后再切写</p><p>因为停写，对业务会有影响，所以当时采取第一种方案，因为反向同步不再本文重点，所以如果不考虑反向同步的情况，上面两种方式没有什么区别</p><h3 id="_3-注意事项" tabindex="-1"><a class="header-anchor" href="#_3-注意事项" aria-hidden="true">#</a> 3. 注意事项</h3><ul><li>全量迁移，如果dba没有提供相关工具的话，就只能自己写了，当时是找了一台机器，部署了个服务利用jdbcTemplate来扫表，实现全量数据插入</li><li>双写时，需要注意，如果双写失败应该怎么办</li><li>数据对账比较有必要</li></ul><h2 id="iii-小结" tabindex="-1"><a class="header-anchor" href="#iii-小结" aria-hidden="true">#</a> III. 小结</h2><h3 id="_1-分库分表-1" tabindex="-1"><a class="header-anchor" href="#_1-分库分表-1" aria-hidden="true">#</a> 1. 分库分表</h3><ul><li><p>一般而言，当量级达到qw时，就该考虑分库分表了，不同的业务有自己独立的库</p></li><li><p>根据表中某些列进行分表，将大表数据拆分到分表中</p></li><li><p>大表拆分为小表</p></li></ul><h3 id="_2-一般实现步骤" tabindex="-1"><a class="header-anchor" href="#_2-一般实现步骤" aria-hidden="true">#</a> 2. 一般实现步骤</h3><ul><li>创建DB</li><li>服务的sql改造，主要是所有的sql，都要有一个新的分库分表的方式</li><li>线上开始双写</li><li>全量将旧表数据导入到新表数据</li><li>线上读流量切换到新表，验证是否有问题</li><li>关闭双写，所有写直接切到新表</li><li>删除旧代码</li></ul>',59);function u(b,p){return l(),d("div",null,[s,h,a(" more "),c])}const v=e(r,[["render",u],["__file","04.180413-生产环境分库分表的实际操作全记录.html.vue"]]);export{v as default};
