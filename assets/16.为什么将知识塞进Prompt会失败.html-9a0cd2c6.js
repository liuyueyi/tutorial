import{_ as e,V as p,W as r,a1 as o}from"./framework-094145d2.js";const t={},a=o('<p>在真正引入 RAG 之前，我们必须先推翻一个极其常见、也极具诱惑力的想法。</p><hr><h3 id="_10-1-一个看似合理的技术直觉" tabindex="-1"><a class="header-anchor" href="#_10-1-一个看似合理的技术直觉" aria-hidden="true">#</a> 10.1 一个看似合理的技术直觉</h3><p>很多团队在构建企业知识库助手时，都会自然地想到：</p><blockquote><p><em>既然模型不知道公司内部知识，那我就把文档直接塞进 Prompt。</em></p></blockquote><p>在 Demo 阶段，这个方法往往“看起来可行”：</p><ul><li>文档不多（比如只有 10 页产品手册）</li><li>问题简单（比如 “产品 A 的核心功能是什么”）</li><li>回答看似准确（模型能从塞进去的文档里找到关键词）</li></ul><p>但在真实系统中，这条路几乎必然失败。</p><blockquote><p>关于这个，我们在上下文历史中，同样也提到了这一点，简单的堆砌，必然不会成功</p></blockquote><hr><h3 id="_10-2-工程约束-为什么这条路走不通" tabindex="-1"><a class="header-anchor" href="#_10-2-工程约束-为什么这条路走不通" aria-hidden="true">#</a> 10.2 工程约束：为什么这条路走不通？</h3><p>把知识直接塞进 Prompt，会很快撞上三个硬性约束：</p><h4 id="_1-上下文窗口限制-文档规模不可线性扩展" tabindex="-1"><a class="header-anchor" href="#_1-上下文窗口限制-文档规模不可线性扩展" aria-hidden="true">#</a> 1. 上下文窗口限制：文档规模不可线性扩展</h4><p>当前主流大模型的上下文窗口是有限的，一次可以塞入的文档必然存在上限</p><p>但真实企业的知识库规模往往是：</p><ul><li>中型企业：数万份文档（产品手册、流程规范、历史会议纪要等）</li><li>大型企业：数十万甚至数百万份文档（跨部门、跨地区、跨时间维度）</li></ul><p>这意味着：<strong>当文档数量超过窗口承载能力时，你必须人工筛选 “可能相关” 的内容塞进 Prompt—— 但这本质上是让人类代替系统做 “检索”，完全失去了自动化的意义。</strong></p><h4 id="_2-注意力竞争-约束信息与知识信息相互稀释" tabindex="-1"><a class="header-anchor" href="#_2-注意力竞争-约束信息与知识信息相互稀释" aria-hidden="true">#</a> 2. 注意力竞争：约束信息与知识信息相互稀释</h4><p>Prompt 里不仅有知识，还有对模型的行为约束（比如 “用中文回答”“语气正式”“只基于给定信息”）。当知识内容过多时，这些关键约束会被海量知识 “淹没”。</p><p>举个例子：</p><p><em>如果 Prompt 里塞了 10 份产品文档（共 3 万 tokens），而行为约束只有 100 tokens，模型对约束的 “注意力占比” 会从 10%（100/1000）降到 0.3%（100/30100）。此时模型很可能 “忘记” 约束，开始基于自身训练数据回答 —— 这正是我们要避免的 “幻觉”。</em></p><p>更危险的是：知识内部也会竞争注意力。</p><p>当一份文档里同时包含 “产品 A 的定价” 和 “产品 B 的售后政策”，而用户只问产品 A 时，模型可能被不相关的产品 B 信息干扰，导致回答出错</p><h4 id="_3-维护成本爆炸-每次文档更新都意味着-prompt-重写" tabindex="-1"><a class="header-anchor" href="#_3-维护成本爆炸-每次文档更新都意味着-prompt-重写" aria-hidden="true">#</a> 3. 维护成本爆炸：每次文档更新都意味着 Prompt 重写</h4><p>企业知识不是静态的：</p><ul><li>产品迭代会更新功能说明</li><li>政策调整会修改流程规范</li><li>员工变动会更新负责人信息</li></ul><p>如果知识直接写在 Prompt 里，每次文档更新都需要人工修改 Prompt—— 这在大型企业中几乎不可执行。</p><p>想象一下：当某个部门每周更新 20 份文档时，团队需要每天安排专人修改 Prompt，不仅效率极低，还会引入 “漏改”“错改” 的风险。</p><p>在企业知识库助手中，这些共同导致一个致命的结果：</p><blockquote><p><strong>知识越多，回答反而越不稳定。</strong></p></blockquote><hr><h3 id="_10-3-技术决策结论" tabindex="-1"><a class="header-anchor" href="#_10-3-技术决策结论" aria-hidden="true">#</a> 10.3 技术决策结论</h3><p>到这里，我们可以给出一个明确判断：</p><blockquote><p><strong>Prompt 不是知识载体，而是行为约束载体。</strong></p></blockquote><p>当你试图让 Prompt 同时承担这两种职责时，系统一定会在规模上崩溃。</p><p>这迫使我们进入下一个问题：</p><blockquote><p><strong>如果知识不能“常驻上下文”，那它应该待在哪里？ 又该如何在需要时精准地 “请” 到上下文里？</strong></p></blockquote>',37),i=[a];function l(h,n){return p(),r("div",null,i)}const c=e(t,[["render",l],["__file","16.为什么将知识塞进Prompt会失败.html.vue"]]);export{c as default};
