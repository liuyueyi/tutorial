import{_ as l,V as e,W as a,X as c,Y as i,Z as o,a1 as r}from"./framework-094145d2.js";const d={},t=i("h2",{id:"背景",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#背景","aria-hidden":"true"},"#"),o(" 背景")],-1),n=i("p",null,"日常的系统中，报警是不可缺少的一环，目前报警方式很多，最常见的有直接打日志，微信报警，短信报警，邮件报警等；而涉及到报警，一般不可避免的需要提前设置一些基本信息，如报警方式，报警频率，报警用户，开关等；",-1),p=i("p",null,"另外一个常见的问题是一般采用的是单一的报警方式，比如不管什么类型的报警全部都用短信方式触达，然后就会发现手机时常处于被淹没的状态了，久而久之对报警短信就不会敏感了",-1),u=r('<h2 id="目标" tabindex="-1"><a class="header-anchor" href="#目标" aria-hidden="true">#</a> 目标</h2><p>因此我们准备设计一个通用的报警框架</p><ul><li>可以自由选择报警方式，</li><li>支持用户自定义报警方式拓展</li><li>支持动态的报警配置，</li><li>支持用户自定义报警规则拓展</li><li>支持报警方式自动切换规则设定</li><li>支持报警方式自定义自动切换规则拓展</li></ul><h2 id="设计" tabindex="-1"><a class="header-anchor" href="#设计" aria-hidden="true">#</a> 设计</h2><p>整体来说，报警主要可以划分为三个步骤，如下：</p><figure><img src="https://s17.mogucdn.com/mlcdn/c45406/180209_3f276k99cb3k1kec5g184f6c4hb7f_2030x996.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure><ul><li>提交报警：对外部使用者提供的接口</li><li>选择报警：根据报警相关信息，选择具体的报警执行单元</li><li>执行报警：实现具体的报警逻辑</li></ul><p>从任务划分上来看，比较清晰简单，但是每一块的内容又必须可以拓展，</p><ul><li><p>选择报警：</p><ul><li>报警规则的制定</li><li>报警规则加载器 <code>ConfLoader</code></li><li>报警规则变更的触发器 <code>ConfChangeTrigger</code></li><li>报警规则解析器 <ul><li><code>ConfParse</code> ： 解析文本格式报警规则为业务对象</li><li><code>AlarmSelector</code> ：根据报警规则和报警类型，选择具体报警执行器 <code>AlarmExecute</code></li></ul></li></ul></li><li><p>执行报警：</p><ul><li>线程池执行（以防止影响主业务流程）</li><li>AlarmExecute的动态拓展（支持用户自定义的报警器实现）</li><li>实际的报警逻辑</li></ul></li></ul><p>根据上面的拆解，在应用启动的时候，就有一些事情必须去做了</p><ol><li>ConfLoader的选择</li><li>报警规则加载</li><li>AlarmExecute的加载（包括默认的+自定义实现的）</li></ol><p>下图显示在应用启动时，报警规则解析的相关步骤</p><figure><img src="https://s17.mogucdn.com/mlcdn/c45406/180209_41ccjhcg1ag35i36ikel3jekf8ld9_868x608.png" alt="应用启动.png" tabindex="0" loading="lazy"><figcaption>应用启动.png</figcaption></figure><p>至于报警执行器的加载就比较简单了，如下图</p><figure><img src="https://s17.mogucdn.com/mlcdn/c45406/180209_5jii7f1ed2j3f8e0di3aalhgji114_1666x402.jpg" alt="IMAGE" tabindex="0" loading="lazy"><figcaption>IMAGE</figcaption></figure><p>因此，整个的工作流程如下图</p><figure><img src="https://s17.mogucdn.com/mlcdn/c45406/180209_5eh16796bg6gk4622dj44diaa09bd_1078x620.jpg" alt="alarm-arch.jpg" tabindex="0" loading="lazy"><figcaption>alarm-arch.jpg</figcaption></figure><h2 id="任务拆解" tabindex="-1"><a class="header-anchor" href="#任务拆解" aria-hidden="true">#</a> 任务拆解</h2><p>通过前面的任务设计之后，对需要做的东西有了一个大概的脉络了，因此在正式操刀实现之前，下对整个架构进行任务拆解，看下可以具体的执行步骤可以怎么来</p><ul><li>最直接的就是设计报警执行器<code>AlarmExecute</code><ul><li>定义基本接口</li><li>制定自定义扩展规则</li></ul></li><li>接下来就是设计报警规则 <ul><li>如何加载报警规则？</li><li>报警规则具体的定义细则</li><li>报警规则的解析：即根据报警类型来获取报警执行器</li><li>报警规则动态更新支持</li></ul></li><li>报警线程池 <ul><li>维护报警队列</li><li>报警的计数与频率控制</li></ul></li><li>封装对外使用接口</li></ul><p>所以，通过上面的分析可以看出，这个系统的结构还是蛮简单的，整个只需要四个部分就可以搞定，其中最主要的就是前面两个了，后面将分别说明</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>做一个东西，当然是希望可以带来一些用处，或者能学习到什么东西，才不枉花费精力来折腾一下，那么我们这个报警系统，究竟有什么用，或者可以从中学习到什么东西呢？</p><p><strong>用途：</strong></p><ul><li>支持灵活可配的报警规则，以及具体报警业务的自定义拓展</li><li>目标就是统一报警的使用姿势，也就是不管什么报警，都一个姿势，但是内部可以玩出各种花样，对使用者而言就方便简洁了</li></ul><p><strong>学习：</strong></p><p>抛开特有的知识点，可以抽象一些公共可用的地方，大概就下面这两点了</p><ul><li>我们可以如何支持功能的动态可拓展</li><li>线程池的使用</li></ul>',28);function g(s,h){return e(),a("div",null,[t,n,p,c(" more "),u])}const _=l(d,[["render",g],["__file","01.报警系统QuickAlarm总纲.html.vue"]]);export{_ as default};
