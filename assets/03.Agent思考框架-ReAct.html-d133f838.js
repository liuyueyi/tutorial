import{_ as a}from"./ag3-03-9645e73b.js";import{_ as r,V as o,W as s,Z as t,$ as d,a1 as e,Y as i,F as c}from"./framework-b1bd8911.js";const l="/tutorial/imgs/column/springai/ag3-01.webp",p="/tutorial/imgs/column/springai/ag3-02.webp",h={},u=t("h2",{id:"_1-背景与起源",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#_1-背景与起源","aria-hidden":"true"},"#"),e(" 1. 背景与起源")],-1),g=t("p",null,[t("strong",null,"ReAct 框架"),e("全称为 "),t("code",null,"[Reason + Act: Synergizing Reasoning and Acting in Language Models](https://react-lm.github.io/)"),e("，由 "),t("strong",null,"Yao et al.（2022, Google Research）"),e(" 首次提出。论文标题为：")],-1),A={href:"https://arxiv.org/pdf/2210.03629",target:"_blank",rel:"noopener noreferrer"},b=t("em",null,"ReAct: Synergizing Reasoning and Acting in Language Models",-1),_=i('<p>这篇论文的出发点非常直接：</p><blockquote><p>仅靠 Chain-of-Thought（CoT）能让模型“思考”，但不能“行动”； 而仅靠 Tool-use 或 Action-based Agent 能“行动”，但不会“思考”。</p><p><strong>ReAct 试图让模型在推理（Reason）与行动（Act）之间交替进行，从而实现真正的智能体行为。</strong></p></blockquote><figure><img src="'+l+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_2-核心思想-让模型在「思考」与「行动」之间循环" tabindex="-1"><a class="header-anchor" href="#_2-核心思想-让模型在「思考」与「行动」之间循环" aria-hidden="true">#</a> 2. 核心思想：让模型在「思考」与「行动」之间循环</h2><p>传统的 CoT 是<strong>静态推理</strong>：</p><blockquote><p>输入 → 推理链（CoT） → 答案</p></blockquote><p>而 ReAct 是<strong>动态交互式推理</strong>：</p><blockquote><p>输入 → 推理步骤（Reason） → 执行动作（Act） → 观察反馈（Observe） → 再推理（Reason） → 再行动（Act） → … → 最终答案</p></blockquote><p>这种循环让模型不只是生成一条思维链，而是能够：</p><ul><li><strong>主动与外部环境交互（通过工具或接口）</strong></li><li><strong>根据反馈修正推理路径</strong></li><li><strong>在多轮循环中完成复杂任务</strong></li></ul><p>举个例子如你想查 “北京明天是否适合户外施工”，会先想 “我需要知道明天的天气（推理）→ 打开天气 APP 查数据（行动）→ 看到明天有暴雨（观察）→ 得出‘不适合施工’的结论（再推理）”。 放在大模型 / Agent 场景中，ReAct 就是让模型不再局限于 “纯内部推理”（比如 CoT 只在脑子里想），而是通过 “调用工具、获取外部反馈” 来验证和修正推理，形成闭环：</p><ul><li>推理（Reasoning）：分析目标、拆解步骤、决定下一步 “该做什么”（比如 “用户要订建筑材料，我需要先查库存→ 调用库存工具”）；</li><li>行动（Acting）：执行具体操作（调用工具 API、查询数据库、发送指令等），是模型与外部世界交互的核心；</li><li>观察（Observation）：获取行动的结果反馈（比如库存工具返回 “钢筋库存充足”“水泥缺货”）；</li><li>迭代：根据观察结果调整推理，直到完成目标（比如水泥缺货→ 推理 “需要找替代供应商”→ 行动 “调用供应商匹配工具”）。</li></ul><h2 id="_3-react-的机制结构" tabindex="-1"><a class="header-anchor" href="#_3-react-的机制结构" aria-hidden="true">#</a> 3. ReAct 的机制结构</h2><h3 id="_3-1-核心闭环流程" tabindex="-1"><a class="header-anchor" href="#_3-1-核心闭环流程" aria-hidden="true">#</a> 3.1 核心闭环流程</h3><p>ReAct 的核心是一个循环式 Prompt 结构，每一轮由 3 个关键组件构成：</p><table><thead><tr><th>阶段</th><th>名称</th><th>功能</th></tr></thead><tbody><tr><td><code>Reason</code></td><td>思考步骤</td><td>模型分析当前状态，推理下一步要做什么</td></tr><tr><td><code>Act</code></td><td>执行动作</td><td>模型根据推理结果调用外部工具、API、搜索等</td></tr><tr><td><code>Observe</code></td><td>观察反馈</td><td>模型读取行动结果，更新内部状态</td></tr></tbody></table><p>循环结构如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Question: 谁是2016年的诺贝尔文学奖获得者？

Thought 1: 我需要先查一下2016年诺贝尔文学奖的结果。
Action 1: 搜索(&quot;2016 Nobel Prize in Literature winner&quot;)

Observation 1: 搜索结果显示是Bob Dylan。

Thought 2: 现在我知道了答案。
Action 2: 回答(&quot;2016年诺贝尔文学奖获得者是鲍勃·迪伦。&quot;)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种结构兼具“推理链的透明性”与“可执行性”，是 CoT 向 Agent 推理自然演化的形式。</p><h3 id="_3-2-关键要素" tabindex="-1"><a class="header-anchor" href="#_3-2-关键要素" aria-hidden="true">#</a> 3.2 关键要素</h3><p>要想让上面的ReAct的流程跑通，必须满足三个核心条件</p><ol><li>明确的目标与终止条件：目标要可量化（如2016年、诺贝尔文学奖获得者），终止条件要清晰（找到用户，任务完成）</li><li>标准化的工具接口：Agent 能 “看懂并调用” 工具（网络搜索）</li><li>状态记忆模块：Agent 能记录每一轮的 “思考结果、行动内容、观察反馈”，避免重复劳动或者遗忘关键信息</li></ol><h2 id="_4-与-cot-的关系-react-cot-行动接口" tabindex="-1"><a class="header-anchor" href="#_4-与-cot-的关系-react-cot-行动接口" aria-hidden="true">#</a> 4. 与 CoT 的关系：ReAct = CoT + 行动接口</h2><table><thead><tr><th>对比维度</th><th>Chain-of-Thought (CoT)</th><th>ReAct (推理行动)</th></tr></thead><tbody><tr><td>核心功能</td><td>静态推理（只思考）</td><td>推理 + 行动 + 反馈循环</td></tr><tr><td>是否交互</td><td>否（纯语言生成）</td><td>是（能调用外部工具/环境）</td></tr><tr><td>信息来源</td><td>依赖模型训练时的内部知识</td><td>内部知识 + 外部输入 + 工具反馈数据（调用工具获取）</td></tr><tr><td>可解释性</td><td>高（显式推理链）</td><td>更高（推理+行动全可追溯）</td></tr><tr><td>典型应用</td><td>逻辑推理、数学题</td><td>工具使用、问答、信息检索、任务规划</td></tr></tbody></table><p>可以这样理解：</p><blockquote><p><strong>CoT 让模型“会思考”； ReAct 让模型“边思考边行动”。</strong></p></blockquote><p>ReAct 实际上是将 CoT 的“推理链”扩展为一个“推理-行动交替链（Reason–Act Loop）”，使模型能够通过外部信息验证和修正自身推理过程。</p><h2 id="_5-典型应用场景" tabindex="-1"><a class="header-anchor" href="#_5-典型应用场景" aria-hidden="true">#</a> 5. 典型应用场景</h2><p>ReAct 框架已成为众多 <strong>LLM Agent 框架的基础逻辑</strong>，例如：</p><table><thead><tr><th>场景</th><th>示例</th></tr></thead><tbody><tr><td><strong>知识检索 Agent</strong></td><td>模型根据推理决定是否调用搜索 API，检索结果再反馈给模型</td></tr><tr><td><strong>任务执行 Agent</strong></td><td>模型通过多轮思考与动作完成复杂流程（如预定行程、分析数据）</td></tr><tr><td><strong>工具调用（Tool Use）</strong></td><td>ReAct 框架下的模型能自主判断何时调用计算器、数据库或Python执行环境</td></tr><tr><td><strong>多Agent协作</strong></td><td>多个 Agent 间通过 ReAct 循环共享中间推理结果，实现协同任务（如 AutoGen、LangGraph）</td></tr></tbody></table><p>ReAct 机制也被广泛集成在框架中：</p><ul><li><strong>LangChain / LangGraph</strong>：ReAct 是默认的 reasoning template；</li><li><strong>OpenAI GPTs / o1 系列</strong>：其系统提示内嵌了类似 ReAct 的隐式结构；</li><li><strong>DeepSeek-R1 / Claude 3.5</strong>：均具备“内隐 ReAct”式动态推理循环。</li></ul><h2 id="_6-react-的优势" tabindex="-1"><a class="header-anchor" href="#_6-react-的优势" aria-hidden="true">#</a> 6. ReAct 的优势</h2><table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td><strong>融合思考与行动</strong></td><td>不再需要人工编排先“思考”还是“执行”，模型可自动判断何时行动。</td></tr><tr><td><strong>支持闭环反馈</strong></td><td>环境结果反哺推理过程，形成自我纠错机制。 避免出现纯推理(如CoT)容易出现的“想当然”的错误</td></tr><tr><td><strong>可解释性强</strong></td><td>每一步 Reason 与 Action 都是可追踪文本，利于调试与评估。</td></tr><tr><td><strong>易扩展</strong></td><td>可嵌入任意工具调用接口（API、DB、Web 搜索等）。</td></tr><tr><td><strong>增强记忆与规划能力</strong></td><td>多轮 Reasoning 让模型能规划长序列任务，而非一次性输出。</td></tr><tr><td><strong>通用性强</strong></td><td>ReAct 不依赖特定任务或工具，只要能拆解步骤、调用工具，就能适用：比如从 “查天气” 到 “采购建筑材料”，从 “旅游规划” 到 “科研数据分析”，只需替换工具和目标，框架本身无需修改，开发效率高</td></tr></tbody></table><h2 id="_7-react-的局限与改进方向" tabindex="-1"><a class="header-anchor" href="#_7-react-的局限与改进方向" aria-hidden="true">#</a> 7. ReAct 的局限与改进方向</h2><table><thead><tr><th>局限</th><th>说明</th></tr></thead><tbody><tr><td><strong>推理质量依赖模型本身的 CoT 能力</strong></td><td>若模型的逻辑推理弱，ReAct 仍可能走错路线。</td></tr><tr><td><strong>长上下文管理复杂</strong></td><td>多轮循环可能导致上下文爆炸，需要 Memory 模块支持。</td></tr><tr><td><strong>计算成本高</strong></td><td>每轮 Reason + Act + Observe 都是一条完整的 API 调用。</td></tr><tr><td><strong>缺乏全局规划能力</strong></td><td>ReAct 是“逐步决策”，缺乏全局最优策略搜索。</td></tr></tbody></table><p>因此，后续研究提出了更高阶的扩展框架，如：</p><ul><li><strong>Tree-of-Thought (ToT)</strong>：将推理链分支化、多路径搜索；</li><li><strong>Reflexion / Self-Refine</strong>：在 ReAct 基础上加入“自我反思”机制；</li><li><strong>Graph-of-Thought (GoT)</strong>：通过图结构管理复杂的推理关系。</li></ul><p>这些框架都继承自 ReAct 的核心思想：<strong>Reason + Act 的循环推理范式</strong>。</p><h2 id="_8-react在agent中的具体应用示例" tabindex="-1"><a class="header-anchor" href="#_8-react在agent中的具体应用示例" aria-hidden="true">#</a> 8. ReAct在Agent中的具体应用示例</h2><p><code>ReAct</code> 是 <code>Agent</code> “编排层” 的核心逻辑，要在 <code>Agent</code> 中落地 <code>ReAct</code>，可以按照 “组件搭建→流程设计→优化迭代” 的三板斧进行套路</p><h3 id="_8-1-第一步-搭建agent的react核心组件" tabindex="-1"><a class="header-anchor" href="#_8-1-第一步-搭建agent的react核心组件" aria-hidden="true">#</a> 8.1 第一步：搭建Agent的ReAct核心组件</h3><p>前面说了ReAct的三个关键组件： Reason(思考)、Act(行动)、Observe(观察)，在具体的Agent实现中，我们还需要额外考虑上下文的管理(Memory)</p><p>因此一个Agent要实现ReAct，则应包含下面四个核心模块</p><blockquote><p>比如我现在给Agent下达一个任务，<code>帮用户采购 100 吨 HRB400E 钢筋，要求 3 天内送达北京朝阳区工地，预算 50 万元</code></p></blockquote><table><thead><tr><th>组件</th><th>功能描述</th><th>技术实现参照</th></tr></thead><tbody><tr><td>思考模块（Reasoner）</td><td>接收目标+状态→ 拆解步骤→ 决定下一步行动（比如“调用哪个工具”“参数是什么”）</td><td>基于大模型实现（如GPT-4、Gemini、DeepSeek），通过提示工程引导模型生成“行动指令”（比如“调用库存工具，参数：材料型号=HRB400E，数量=100吨”）</td></tr><tr><td>行动执行器（Actor）</td><td>解析思考模块的“行动指令”→ 调用对应的工具（API、数据库、RPA等）</td><td>搭建工具注册中心（统一管理工具名称、输入输出格式），用函数调用（Function Call）实现模型与工具的对接（比如模型输出JSON格式的行动指令，执行器解析后调用API）</td></tr><tr><td>观察模块（Observer）</td><td>获取工具返回结果→ 整理成模型能理解的格式（比如把API返回的JSON转成自然语言）</td><td>设计结果标准化模板（比如工具返回“{&quot;supplier&quot;:&quot;A&quot;,&quot;price&quot;:3700}&quot;→ 整理为“供应商A的HRB400E钢筋报价3700元/吨”）</td></tr><tr><td>状态记忆模块（Memory）</td><td>存储“目标+每一轮的思考/行动/观察结果”→ 为下一轮思考提供上下文</td><td>用向量数据库（如Milvus、FAISS）存储长上下文，支持“关键词检索”（比如快速查找“供应商A的履约率”）</td></tr></tbody></table><h3 id="_8-2-第二步-设计-react-闭环执行流程" tabindex="-1"><a class="header-anchor" href="#_8-2-第二步-设计-react-闭环执行流程" aria-hidden="true">#</a> 8.2 第二步：设计 ReAct 闭环执行流程</h3><p>依然以上面的建筑材料采购Agent为例</p><h4 id="_1-初始化-明确目标与工具" tabindex="-1"><a class="header-anchor" href="#_1-初始化-明确目标与工具" aria-hidden="true">#</a> （1）初始化：明确目标与工具</h4><ul><li>目标：用户输入“采购100吨HRB400E钢筋，3天内送达北京朝阳工地，预算50万”；</li><li>注册工具：库存查询工具、供应商履约率工具、报价对比工具、订单生成工具。</li></ul><h4 id="_2-循环执行-直到任务完成-终止" tabindex="-1"><a class="header-anchor" href="#_2-循环执行-直到任务完成-终止" aria-hidden="true">#</a> （2）循环执行（直到任务完成/终止）</h4><figure><img src="`+p+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><p>每一轮的“思考指令”格式示例（模型输出）：</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;action&quot;</span><span class="token operator">:</span> <span class="token string">&quot;调用库存查询工具&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;parameters&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;material_type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;HRB400E钢筋&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;quantity&quot;</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
    <span class="token property">&quot;delivery_area&quot;</span><span class="token operator">:</span> <span class="token string">&quot;北京朝阳区&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;delivery_time&quot;</span><span class="token operator">:</span> <span class="token number">3</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">&quot;reason&quot;</span><span class="token operator">:</span> <span class="token string">&quot;需要先确认是否有符合数量、交货期要求的供应商，再对比报价和履约率&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>观察模块整理结果示例： “库存查询工具返回3家供应商：1. 供应商A（库存150吨，报价3700元/吨，3天达）；2. 供应商B（库存200吨，报价3800元/吨，2天达）；3. 供应商C（库存120吨，报价3600元/吨，4天达，超期）”</p></li></ul><h4 id="_3-终止条件设计" tabindex="-1"><a class="header-anchor" href="#_3-终止条件设计" aria-hidden="true">#</a> （3）终止条件设计</h4><ul><li>成功终止：完成目标（如“采购订单提交成功，供应商A将在3天内送达100吨HRB400E钢筋，总价37万元”）；</li><li>失败终止：多次迭代后无法满足目标（如“无符合‘3天达+100吨库存’的供应商，建议延长交货期至4天或更换材料型号”）。</li></ul><h3 id="_8-3-第三步-优化-react-执行效率" tabindex="-1"><a class="header-anchor" href="#_8-3-第三步-优化-react-执行效率" aria-hidden="true">#</a> 8.3 第三步：优化 ReAct 执行效率</h3><p>实际应用中，需解决“循环次数过多、工具调用错误、推理冗余”等问题，常用优化技巧：</p><ul><li>① 工具选择策略：思考模块优先选择“高优先级工具”（比如先查库存，再查履约率，避免跳过关键步骤）；</li><li>② 状态压缩：记忆模块只保留“关键信息”（比如只记“符合条件的供应商A/B”，忽略C的详细信息），减少大模型上下文压力；</li><li>③ 错误重试机制：行动失败（如工具调用超时、返回错误）时，思考模块自动调整参数（比如“重新调用库存工具，增加‘北京周边供应商’筛选条件”）；</li><li>④ 少样本示例引导：在思考模块的提示中，加入“问题+ReAct循环示例”，让模型更快掌握推理+行动的节奏（比如给一个“采购水泥”的ReAct示例，让模型模仿）。</li></ul><h2 id="_9-总结-一句话概括-react" tabindex="-1"><a class="header-anchor" href="#_9-总结-一句话概括-react" aria-hidden="true">#</a> 9. 总结：一句话概括 ReAct</h2><p><strong>ReAct 是连接“语言模型的思考能力（CoT）”与“Agent 的执行能力”的桥梁。</strong></p><p>它让大模型不仅能在语言空间中推理，还能在外部世界中行动；最后再以一张图，来重温一下ReAct</p><figure><img src="`+a+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',62);function R(v,m){const n=c("ExternalLinkIcon");return o(),s("div",null,[u,g,t("blockquote",null,[t("p",null,[t("a",A,[b,d(n)])])]),_])}const q=r(h,[["render",R],["__file","03.Agent思考框架-ReAct.html.vue"]]);export{q as default};
