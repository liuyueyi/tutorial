const e=JSON.parse('{"key":"v-73ed82b4","path":"/java/jdk/jdk21/02.%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html","title":"02.JDK21虚拟线程：重新定义Java高并发编程","lang":"zh-CN","frontmatter":{"order":2,"title":"02.JDK21虚拟线程：重新定义Java高并发编程","tag":["jdk"],"category":["Java","JDK21"],"date":"2025-02-13T11:48:09.000Z","keywords":["Java","JDK21","虚拟线程"],"description":"1. 背景：为什么需要虚拟线程？ 在传统Java并发模型中，每个java.lang.Thread都直接对应一个操作系统线程（称为平台线程）。虽然这种1:1的模型保证了可靠的并发执行，但存在两个关键瓶颈： 资源限制：操作系统线程创建成本高（默认1MB栈空间），难以支持百万级并发 上下文切换开销：线程数量激增时，CPU时间大量消耗在切换线程上下文上 开发者通常通过线程池和异步编程（如CompletableFuture）缓解这些问题，但这导致了代码复杂度上升。Project Loom应运而生，其核心成果虚拟线程在JDK19中首次预览，最终在JDK21正式发布。","head":[["meta",{"property":"og:url","content":"https://liuyueyi.github.io/tutorial/java/jdk/jdk21/02.%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html"}],["meta",{"property":"og:site_name","content":"一灰灰的站点"}],["meta",{"property":"og:title","content":"02.JDK21虚拟线程：重新定义Java高并发编程"}],["meta",{"property":"og:description","content":"1. 背景：为什么需要虚拟线程？ 在传统Java并发模型中，每个java.lang.Thread都直接对应一个操作系统线程（称为平台线程）。虽然这种1:1的模型保证了可靠的并发执行，但存在两个关键瓶颈： 资源限制：操作系统线程创建成本高（默认1MB栈空间），难以支持百万级并发 上下文切换开销：线程数量激增时，CPU时间大量消耗在切换线程上下文上 开发者通常通过线程池和异步编程（如CompletableFuture）缓解这些问题，但这导致了代码复杂度上升。Project Loom应运而生，其核心成果虚拟线程在JDK19中首次预览，最终在JDK21正式发布。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-13T08:59:24.000Z"}],["meta",{"property":"article:tag","content":"jdk"}],["meta",{"property":"article:published_time","content":"2025-02-13T11:48:09.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-13T08:59:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"02.JDK21虚拟线程：重新定义Java高并发编程\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-02-13T11:48:09.000Z\\",\\"dateModified\\":\\"2025-02-13T08:59:24.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"1. 背景：为什么需要虚拟线程？","slug":"_1-背景-为什么需要虚拟线程","link":"#_1-背景-为什么需要虚拟线程","children":[]},{"level":2,"title":"2. 原理：虚拟线程如何工作？","slug":"_2-原理-虚拟线程如何工作","link":"#_2-原理-虚拟线程如何工作","children":[{"level":3,"title":"2.1 传统线程模型 vs 虚拟线程模型","slug":"_2-1-传统线程模型-vs-虚拟线程模型","link":"#_2-1-传统线程模型-vs-虚拟线程模型","children":[]},{"level":3,"title":"虚拟线程的核心机制","slug":"虚拟线程的核心机制","link":"#虚拟线程的核心机制","children":[]},{"level":3,"title":"2.2 虚拟线程调度","slug":"_2-2-虚拟线程调度","link":"#_2-2-虚拟线程调度","children":[]},{"level":3,"title":"2.3 优势：为什么选择虚拟线程？","slug":"_2-3-优势-为什么选择虚拟线程","link":"#_2-3-优势-为什么选择虚拟线程","children":[]}]},{"level":2,"title":"3. 使用示例","slug":"_3-使用示例","link":"#_3-使用示例","children":[{"level":3,"title":"示例1：创建虚拟线程","slug":"示例1-创建虚拟线程","link":"#示例1-创建虚拟线程","children":[]},{"level":3,"title":"示例2：HTTP服务器对比","slug":"示例2-http服务器对比","link":"#示例2-http服务器对比","children":[]},{"level":3,"title":"示例3：使用虚拟线程实现归并排序","slug":"示例3-使用虚拟线程实现归并排序","link":"#示例3-使用虚拟线程实现归并排序","children":[]}]},{"level":2,"title":"4.小结","slug":"_4-小结","link":"#_4-小结","children":[{"level":3,"title":"4.1 注意事项","slug":"_4-1-注意事项","link":"#_4-1-注意事项","children":[]},{"level":3,"title":"4.2 小结","slug":"_4-2-小结","link":"#_4-2-小结","children":[]}]}],"git":{"createdTime":1739437164000,"updatedTime":1739437164000,"contributors":[{"name":"yihui","email":"bangzewu@126.com","commits":1}]},"readingTime":{"minutes":7.35,"words":2204},"filePathRelative":"java/jdk/jdk21/02.虚拟线程的原理及使用示例.md","localizedDate":"2025年2月13日","excerpt":"<h2> 1. 背景：为什么需要虚拟线程？</h2>\\n<p>在传统Java并发模型中，每个<code>java.lang.Thread</code>都直接对应一个操作系统线程（称为<strong>平台线程</strong>）。虽然这种1:1的模型保证了可靠的并发执行，但存在两个关键瓶颈：</p>\\n<ol>\\n<li><strong>资源限制</strong>：操作系统线程创建成本高（默认1MB栈空间），难以支持百万级并发</li>\\n<li><strong>上下文切换开销</strong>：线程数量激增时，CPU时间大量消耗在切换线程上下文上</li>\\n</ol>\\n<p>开发者通常通过线程池和异步编程（如CompletableFuture）缓解这些问题，但这导致了代码复杂度上升。<strong>Project Loom</strong>应运而生，其核心成果<strong>虚拟线程</strong>在JDK19中首次预览，最终在JDK21正式发布。</p>","copyright":{},"autoDesc":true}');export{e as data};
