import{_ as e,V as p,W as o,X as l,Y as n,Z as s,$ as t,a1 as i,F as c}from"./framework-094145d2.js";const d="/tutorial/hexblog/imgs/210207/00.jpg",r="/tutorial/hexblog/imgs/210207/01.jpg",u="/tutorial/hexblog/imgs/210207/02.jpg",k="/tutorial/hexblog/imgs/210207/03.jpg",h="/tutorial/hexblog/imgs/210207/04.jpg",g="/tutorial/hexblog/imgs/210207/05.jpg",m="/tutorial/hexblog/imgs/210207/06.jpg",b="/tutorial/hexblog/imgs/210207/07.jpg",v="/tutorial/hexblog/imgs/210207/08.jpg",y="/tutorial/hexblog/imgs/210207/09.jpg",f={},_=n("p",null,"最近遇到一个由于唯一性索引，导致并发插入产生死锁的场景，在分析死锁产生的原因时，发现这一块还挺有意思的，涉及到MySql中不少的知识点，特此总结记录一下",-1),w=i('<h2 id="i-mysql常见的锁" tabindex="-1"><a class="header-anchor" href="#i-mysql常见的锁" aria-hidden="true">#</a> I. MySql常见的锁</h2><p>谈到mysql的锁，可以说的就比较多了，比如行锁、表锁、页锁、元数据锁等，当然我们这里没打算把所有的都细列出来，我们这里主要针对行锁、gap锁进行拓展，以方便分析第二节中，为什么并发插入同样的数据会产生死锁的问题</p><h3 id="_0-锁分类" tabindex="-1"><a class="header-anchor" href="#_0-锁分类" aria-hidden="true">#</a> 0. 锁分类</h3><p>我们最常说的锁，可以区分为共享锁(S)和排它锁(X)，在mysql的innodb引擎中，为了解决幻读问题，引入了gap锁以及next key lock；除此之外，还有一种意向锁的，比如插入意向锁</p><p>本文将主要介绍的以下几种锁</p><ul><li>行锁(record lock): 请注意它是针对索引的锁（所以如果没有索引时，最终行锁就会导致整个表都会被锁住）</li><li>共享锁(S Lock): 也叫读锁，共享锁之间不会相互阻塞（顾名思义）</li><li>排它锁(X Lock): 也叫写锁，排它锁一次只能有一个session（或者说事务？）持有</li><li>间隙锁(gap lock): 针对索引之间的间隙</li><li>Next-key锁（Next-key lock)：可以简单理解为行锁 + 间隙锁</li></ul><p>上面虽然介绍了几种锁的基本定义，但是什么时候是行锁，怎样获取共享锁，排它锁又是在哪些场景下会产生呢？<code>gap lock/next key lock</code>又是怎样解决幻读的呢？</p><p><strong>下面所有的都是基于mysql5.7.22 innodb引擎，rr隔离级别进行说明</strong></p><h3 id="_1-共享锁与排它锁" tabindex="-1"><a class="header-anchor" href="#_1-共享锁与排它锁" aria-hidden="true">#</a> 1 共享锁与排它锁</h3><p>下表介绍我们的实际使用的sql中，是否会使用锁，以及会产生什么锁</p><p><strong>共享锁与排他锁区分</strong></p><table><thead><tr><th>sql</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td><code>select ... where</code></td><td><code>select * from table limit 1</code></td><td>基于MVCC，快照读，不加锁</td></tr><tr><td><code>select ... for update</code></td><td><code>select * from table where id=1 for update</code></td><td>排他锁</td></tr><tr><td><code>select ... lock in share mode</code></td><td><code>select * from table where id=1 lock in share mode</code></td><td>共享锁</td></tr><tr><td><code>update ... where</code></td><td><code>update table set xx=xx where id=1</code></td><td>排他锁</td></tr><tr><td><code>delete ... where</code></td><td><code>delete table where id=1</code></td><td>排它锁</td></tr></tbody></table><h3 id="_2-行锁、表锁、gap锁、next-key锁区分" tabindex="-1"><a class="header-anchor" href="#_2-行锁、表锁、gap锁、next-key锁区分" aria-hidden="true">#</a> 2. 行锁、表锁、gap锁、next-key锁区分</h3><p>这几个的区分，主要就是看我们最终锁住的效果，如</p><ul><li>没有索引，加S/X锁最终都是锁整表 （为啥？因为锁是针对索引而言的）</li><li>根据主键/唯一键锁定确定的记录：行锁</li><li>普通索引或者范围查询：gap lock / next key lock</li></ul><p>行锁和gap锁之间最大的区别是：</p><ul><li>行锁针对确定的记录</li><li>间隙锁的是两个确定记录之间的范围； next key lock则是除了间隙还包括确定的记录</li></ul><h3 id="_3-实例演示" tabindex="-1"><a class="header-anchor" href="#_3-实例演示" aria-hidden="true">#</a> 3. 实例演示</h3><p>看上面的两个说明，自然就想在实际的case中操刀分析一下，不同的sql会产生什么样的锁效果</p><ul><li>针对表中一条确定的记录加X锁，是只有行锁嘛？</li><li>针对表中多条确定的记录加X锁，又会怎样？</li><li>针对表中一条不存在的记录加X锁，会有锁产生嘛？如果是gap锁，那区间怎么定？</li><li>针对范围加X锁，产生的gap锁范围怎么确定呢？</li></ul><p>在分析上面几种case之前，我们得先有一个概念，锁是针对索引而言的，这一点非常非常重要</p><p>其次不同的索引，我们需要分别进行测试（其实就是唯一索引与普通索引）</p><h4 id="_3-1-表准备" tabindex="-1"><a class="header-anchor" href="#_3-1-表准备" aria-hidden="true">#</a> 3.1 表准备</h4><p>接下来针对上面的四种场景，设计我们的测试用例，首先我们准备三张表</p><ul><li>无索引表 TN</li><li>唯一索引表 TU</li><li>普通索引表 TI</li></ul><p>对应的表结构和初始化数据如下</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>tn<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>\n  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>uid<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>\n<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>\n\n<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>tu<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>\n  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>uid<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>\n  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>u_uid<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>uid<span class="token punctuation">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>\n\n<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>ti<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>\n  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>uid<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>\n  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>u_uid<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>uid<span class="token punctuation">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>\n\n\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>tn<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>uid<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>tu<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>uid<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>ti<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>uid<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-2-精确匹配" tabindex="-1"><a class="header-anchor" href="#_3-2-精确匹配" aria-hidden="true">#</a> 3.2 精确匹配</h4><p>即我们的sql可以精确命中某条记录时，锁情况如下</p><table><thead><tr><th>实例</th><th>TN</th><th>TU</th><th>TI</th></tr></thead><tbody><tr><td><code>select * from tx where uid=20 for update</code></td><td>锁全表</td><td>行锁 uid=20</td><td>行锁uid=20, gap锁uid=[10, 30)</td></tr></tbody></table><p>请注意上面的结论，无索引时锁全表好理解，但是普通索引的<code>TI</code>表，居然还有一个[10, 30)的gap锁就有点超乎我们的想象了；</p><p>接下来我们验证一下</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上图基本流程如</p><figure><img src="'+r+'" alt="精确命中" tabindex="0" loading="lazy"><figcaption>精确命中</figcaption></figure><p>从上面的实测也可以看出，普通索引下添加x锁，居然会加一个gap锁，而且这个gap区间是前一个记录（并包含它），到下一个记录</p><p>如 <code>uid = 20</code>， 前后两个记录为<code>(1, 10), (10, 30)</code></p><ul><li>gap lock: 范围为 [10, 30)</li><li>因此无法插入uid=[10,30)</li><li>注意，uid=10上有gap锁只是不能插入记录，但是加X锁是没有问题的（有兴趣的可以测试一下）</li></ul><h4 id="_3-3-精确查询未匹配" tabindex="-1"><a class="header-anchor" href="#_3-3-精确查询未匹配" aria-hidden="true">#</a> 3.3 精确查询未匹配</h4><p>当我们锁的记录不存在时，锁情况如下</p><table><thead><tr><th>实例</th><th>TN</th><th>TU</th><th>TI</th></tr></thead><tbody><tr><td><code>select * from tx where uid=25 for update</code></td><td>锁全表</td><td><code>gap lock uid=(20,30)</code></td><td><code>gap lock uid=(20, 30)</code></td></tr></tbody></table><p>实测case如下(TN省略，锁全表的没啥测试必要性)</p><blockquote><p>基本流程就不画图了，上面图中已经文字描述了</p></blockquote><figure><img src="'+u+'" alt="精确命中" tabindex="0" loading="lazy"><figcaption>精确命中</figcaption></figure><p>从上面的测试也可以看出，<code>uid=30</code>没有被锁住，这里只在uid=(20, 30)这一区间添加了gap锁</p><p>唯一索引与普通索引表现一致，会阻塞insert的插入意向锁（后面说这个东西）</p><h4 id="_3-4-范围查询" tabindex="-1"><a class="header-anchor" href="#_3-4-范围查询" aria-hidden="true">#</a> 3.4 范围查询</h4><p>当我们锁一段区间时，锁情况如下</p><table><thead><tr><th>实例</th><th>TN</th><th>TU</th><th>TI</th></tr></thead><tbody><tr><td><code>select * from tx where uid&gt;15 and uid&lt;25 for update</code></td><td>锁全表</td><td><code>next key lock uid=(10,30]</code></td><td><code>next key lock uid=(10, 30]</code></td></tr></tbody></table><figure><img src="'+k+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>简单来说，范围查询时，添加<code>next key lock</code>，根据我们的查询条件，找到最左边和最右边的记录区间</p><p>如 <code>uid &gt; 15 and uid &lt; 25</code>，找到的记录是 <code>(1, 10), (10, 30)</code></p><ul><li>gap锁为<code>(10, 30)</code></li><li><code>next key lock</code>会为右边添加行锁，即<code>uid=30</code>加X锁</li><li>因此针对<code>uid=30</code>记录加锁会被阻塞（但是针对uid=28,29加x锁则不会被阻塞，插入会，有兴趣的小伙伴可以实测一下）</li></ul><p><strong>说明:范围加x锁时，可能锁住不再这个区间的记录，一不小心可能导致死锁哦</strong></p><h4 id="_3-5-小结" tabindex="-1"><a class="header-anchor" href="#_3-5-小结" aria-hidden="true">#</a> 3.5 小结</h4><p>在RR隔离级别中，我们一般认为可以产生锁的语句为:</p><ul><li><code>SELECT ... FOR UPDATE</code>: X锁</li><li><code>SELECT ... LOCK IN SHARE MODE</code>: S锁</li><li><code>update/delete</code>: X锁</li></ul><table><thead><tr><th>索引</th><th>场景</th><th>锁范围</th></tr></thead><tbody><tr><td>无索引</td><td>S/X锁</td><td>锁全表</td></tr><tr><td>唯一索引</td><td>精确匹配，且命中</td><td>行锁</td></tr><tr><td>唯一索引</td><td>精确匹配，未命中</td><td>gap lock</td></tr><tr><td>唯一索引</td><td>范围查询</td><td>next key lock (上个记录下个记录的区间，左闭右开） 右边记录行锁</td></tr><tr><td>普通索引</td><td>精确匹配，且命中</td><td>行锁 + gap lock (上一个记录和下个记录区间，左闭右开，左边记录非行锁)</td></tr><tr><td>普通索引</td><td>精确匹配，未命中</td><td>gap lock</td></tr><tr><td>普通索引</td><td>范围查询</td><td>next key lock</td></tr></tbody></table><h3 id="_4-锁冲突" tabindex="-1"><a class="header-anchor" href="#_4-锁冲突" aria-hidden="true">#</a> 4. 锁冲突</h3><p>上面介绍了不同场景下会产生什么样的锁，但是看完之后会有一个疑问，针对行锁其他会话竞争的时候，可以按照X/S锁的规则来，但是这个GAP LOCK貌似只针对insert有效，insert除了加X锁之外是不是还有其他的特殊逻辑？</p><h4 id="_4-1-插入意向锁" tabindex="-1"><a class="header-anchor" href="#_4-1-插入意向锁" aria-hidden="true">#</a> 4.1 插入意向锁</h4><p>插入意向锁其实是一种特殊的 gap lock，但是它不会阻塞其他锁。假设存在值为 4 和 7 的索引记录，尝试插入值 5 和 6 的两个事务在获取插入行上的排它锁之前使用插入意向锁锁定间隙，即在（4，7）上加 gap lock，但是这两个事务不会互相冲突等待；但是如果这个区间存在gap lock，则会被阻塞；如果多个事务插入相同数据导致唯一冲突，则在重复的索引记录上加读锁</p><p>简单来说，它的属性为：</p><ul><li>它不会阻塞其他任何锁；</li><li>它本身仅会被 gap lock 阻塞</li></ul><p>其次一个重要知识点：</p><ul><li>通常insert语句，加的是行锁，排它锁</li><li>在insert之前，先通过插入意向锁，判断是否可以插入（仅会被gap lock阻塞）</li><li>当插入唯一冲突时，在重复索引上添加读锁 <ul><li>原因如下：</li><li>事务1 插入成功未提交，获取了排它锁，但是事务1最终可能会回滚，所以其他重复插入事务不应该直接失败，这个时候他们改为申请读锁（疑问点：为什么要改成读锁呢？）</li></ul></li></ul><h4 id="_4-2-锁冲突矩阵" tabindex="-1"><a class="header-anchor" href="#_4-2-锁冲突矩阵" aria-hidden="true">#</a> 4.2 锁冲突矩阵</h4><p>简单版矩阵</p><table><thead><tr><th></th><th>共享锁（S）</th><th>排他锁（X）</th></tr></thead><tbody><tr><td>共享锁（S）</td><td>兼容</td><td>冲突</td></tr><tr><td>排他锁（X）</td><td>冲突</td><td>冲突</td></tr></tbody></table><p>当我们将gap lock(间隙锁), next key lock(next-key锁), Insert Intention lock(插入意向锁)也加入矩阵时，就会复杂很多了</p><table><thead><tr><th>行：待加锁；列：存在锁</th><th>S(not gap)</th><th>S(gap)</th><th>S(next key)</th><th>X(not gap)</th><th>X(gap)</th><th>X(next key)</th><th>Insert Intention</th></tr></thead><tbody><tr><td>S(not gap)</td><td>-</td><td>-</td><td>-</td><td>冲突</td><td>-</td><td>冲突</td><td>-</td></tr><tr><td>S(gap)</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>冲突</td></tr><tr><td>S(next-key)</td><td>-</td><td>-</td><td>-</td><td>冲突</td><td>-</td><td>冲突</td><td>冲突</td></tr><tr><td>X(not gap)</td><td>冲突</td><td>-</td><td>冲突</td><td>冲突</td><td>-</td><td>冲突</td><td>-</td></tr><tr><td>X(gap)</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>冲突</td></tr><tr><td>X(next-key)</td><td>冲突</td><td>-</td><td>冲突</td><td>冲突</td><td>-</td><td>冲突</td><td>冲突</td></tr><tr><td>Insert Intention</td><td>-</td><td>冲突</td><td>冲突</td><td>-</td><td>冲突</td><td>冲突</td><td>-</td></tr></tbody></table><p><strong>说明</strong></p><ul><li>not gap: 行锁</li><li>gap: gap lock</li><li>next-key: gap + 行锁</li></ul><p><strong>小结</strong></p><p>针对上面的矩阵，理解下面几个原则即可推导上面矩阵</p><ul><li><code>gap lock</code>只会与插入意向锁冲突</li><li>X行锁会与行锁冲突</li><li><code>next key lock</code>: 行锁 + gap锁 <ul><li>锁区间内，插入冲突；</li><li>行锁的X锁冲突</li></ul></li></ul><h2 id="ii-并发插入死锁分析" tabindex="-1"><a class="header-anchor" href="#ii-并发插入死锁分析" aria-hidden="true">#</a> II. 并发插入死锁分析</h2><p>上面属于基本知识点，接下来我们看一个实际导致死锁的case</p><ul><li>并发插入相同记录导致死锁</li></ul><h3 id="_0-表准备" tabindex="-1"><a class="header-anchor" href="#_0-表准备" aria-hidden="true">#</a> 0. 表准备</h3><p>创建一个最简单最基础的表，用于演示</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">\`</span>t<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">11</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>

<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">\`</span>t<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-事务回滚的死锁问题" tabindex="-1"><a class="header-anchor" href="#_1-事务回滚的死锁问题" aria-hidden="true">#</a> 1. 事务回滚的死锁问题</h3><p>场景复现:</p><p><strong>step1:</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- session1: </span>
<span class="token keyword">begin</span><span class="token punctuation">;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">-- session2:</span>
<span class="token keyword">begin</span><span class="token punctuation">;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 阻塞</span>

<span class="token comment">-- session3:</span>
<span class="token keyword">begin</span><span class="token punctuation">;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 阻塞</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>step2:</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- session1:</span>
<span class="token keyword">rollback</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+h+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>原因分析：</strong></p><p>死锁日志查看</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SHOW</span> <span class="token keyword">ENGINE</span> <span class="token keyword">INNODB</span> <span class="token keyword">STATUS</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+g+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>step1: <ul><li>session1: 插入(id=2)，会添加一个<code>X</code> + <code>Next Lock</code>锁</li><li>session2/3: 插入(id=2)，插入意向锁被阻塞，改为持有<code>S</code> + <code>Next Lock</code>锁</li></ul></li><li>step2: <ul><li>session1: 回滚，释放X锁</li><li>session2/3: 竞争X锁，只有对方释放S锁，才能竞争成功；相互等待，导致死锁</li></ul></li></ul><h3 id="_2-delete导致死锁问题" tabindex="-1"><a class="header-anchor" href="#_2-delete导致死锁问题" aria-hidden="true">#</a> 2. delete导致死锁问题</h3><p>和前面操作基本一致，只是第一个会话是删除记录</p><p><strong>step1:</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- session1: </span>
<span class="token keyword">begin</span><span class="token punctuation">;</span> <span class="token keyword">delete</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">-- session2:</span>
<span class="token keyword">begin</span><span class="token punctuation">;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 阻塞</span>

<span class="token comment">-- session3:</span>
<span class="token keyword">begin</span><span class="token punctuation">;</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 阻塞</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>step2:</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- session1:</span>
<span class="token keyword">commit</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>原因分析和前面基本一致</p><figure><img src="'+b+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-insert加锁逻辑" tabindex="-1"><a class="header-anchor" href="#_3-insert加锁逻辑" aria-hidden="true">#</a> 3. insert加锁逻辑</h3><p>insert中对唯一索引的加锁逻辑</p><ol><li>先做UK冲突检测，如果存在目标行，先对目标行加S Next Key Lock（该记录在等待期间被其他事务删除，此锁被同时删除）</li><li>如果1成功，对对应行加X + 插入意向锁</li><li>如果2成功，插入记录，并对记录加X + 行锁（有可能是隐式锁）</li></ol><p>根据上面这个的逻辑，那么就会有一个有意思的死锁场景</p><p><strong>step1:</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- session1</span>
<span class="token keyword">begin</span><span class="token punctuation">;</span> <span class="token keyword">delete</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>


<span class="token comment">-- session2</span>
<span class="token keyword">begin</span><span class="token punctuation">;</span> <span class="token keyword">delete</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>step2:</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- session1</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>对应的死锁日志</p><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',114),x={href:"https://www.cnblogs.com/lfs2640666960/p/10881390.html",target:"_blank",rel:"noopener noreferrer"},N=n("h3",{id:"_4-怎么避免死锁呢",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_4-怎么避免死锁呢","aria-hidden":"true"},"#"),s(" 4. 怎么避免死锁呢?")],-1),E=n("ul",null,[n("li",null,"将大事务拆成小事务"),n("li",null,"添加合理的索引，走索引避免为每一行加锁，降低死锁的概率"),n("li",null,"避免业务上的循环等待（如加分布式锁之类的）"),n("li",null,"降低事务隔离级别（如RR -> RC 当然不建议这么干）"),n("li",null,"并发插入时使用replace/on duplicate也可以避免死锁")],-1),T=n("p",null,[n("strong",null,"相关博文")],-1),q={href:"https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-next-key-locks",target:"_blank",rel:"noopener noreferrer"},I={href:"https://blog.csdn.net/lslxdx/article/details/56846661",target:"_blank",rel:"noopener noreferrer"},S={href:"https://blog.csdn.net/weixin_38287269/article/details/102824620",target:"_blank",rel:"noopener noreferrer"},L={href:"https://www.cnblogs.com/lfs2640666960/p/10881390.html",target:"_blank",rel:"noopener noreferrer"},X={href:"https://opensource.actionsky.com/20190331-mysql-insert/",target:"_blank",rel:"noopener noreferrer"},R={href:"https://blog.csdn.net/lkforce/article/details/108781691",target:"_blank",rel:"noopener noreferrer"};function A(U,O){const a=c("ExternalLinkIcon");return p(),o("div",null,[_,l(" more "),w,n("p",null,[s("关于这个场景详情博文可以参考: "),n("a",x,[s("记录一次Mysql死锁排查过程"),t(a)])]),N,E,T,n("ul",null,[n("li",null,[n("a",q,[s("Mysql:innodb-next-key-locks"),t(a)])]),n("li",null,[n("a",I,[s("[MySQL][Gap Lock][Next-Key Lock]浅析"),t(a)])]),n("li",null,[n("a",S,[s("mysql记录锁（record lock）,间隙锁（gap lock）,Next-key锁（Next-key lock）亲测"),t(a)])]),n("li",null,[n("a",L,[s("记录一次Mysql死锁排查过程"),t(a)])]),n("li",null,[n("a",X,[s("故障分析 | MySQL Insert 加锁与死锁分析"),t(a)])]),n("li",null,[n("a",R,[s("MySQL死锁日志的查看和分析"),t(a)])])])])}const C=e(f,[["render",A],["__file","16.210207-MySql并发插入死锁引来的锁分析.html.vue"]]);export{C as default};
