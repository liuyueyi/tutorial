import{_ as a,V as i,W as e,Y as r}from"./framework-b1bd8911.js";const l={},d=r('<h1 id="jvm学习之内存结构" tabindex="-1"><a class="header-anchor" href="#jvm学习之内存结构" aria-hidden="true">#</a> JVM学习之内存结构</h1><p>java运行时对象创建在什么地方？堆和栈空间又有什么区别？听闻已久的Young,Old区又是什么鬼？听说有个常量池，这个又是啥</p><p>要想在脑海中清晰的布局一个java类在加载到使用的过程中，整个类生命周期中，各项数据究竟最终落在哪个板块上，就需要了解下JVM的内存区域了</p><h2 id="i-内存布局" tabindex="-1"><a class="header-anchor" href="#i-内存布局" aria-hidden="true">#</a> I. 内存布局</h2><figure><img src="https://s3.mogucdn.com/mlcdn/c45406/180313_1labe93bjle80a48b8g8l1ieikb85_1136x1150.png" alt="内存布局" tabindex="0" loading="lazy"><figcaption>内存布局</figcaption></figure><p>简单来讲，内存可以划分为三块：</p><ul><li>堆 <ul><li>最大的一块区域，创建的对象都在这个上面</li></ul></li><li>方法区 <ul><li>加载类时对应的类信息，常量，静态变量</li></ul></li><li>栈 <ul><li>虚拟机栈和本地方法栈，存储线程相关的信息</li></ul></li></ul><h2 id="ii-分区详解" tabindex="-1"><a class="header-anchor" href="#ii-分区详解" aria-hidden="true">#</a> II. 分区详解</h2><h3 id="_1-堆区" tabindex="-1"><a class="header-anchor" href="#_1-堆区" aria-hidden="true">#</a> 1. 堆区</h3><p>所有线程共享，虚拟机启动时创建，存放对象实例</p><p>垃圾回收，主要就是针对堆区而言，一般划分为年轻代，年老代</p><ul><li>Young区：Edge + From Survivor + To Sruvivor (8：1：1)</li><li>Old区</li></ul><p>对象开始在Young区，一般内存回收时，会有标记整理，就涉及到两个Survivor区的转移，对象存的时间够久之后，就会将对象塞入Old区</p><h3 id="_2-方法区" tabindex="-1"><a class="header-anchor" href="#_2-方法区" aria-hidden="true">#</a> 2. 方法区</h3><p>所有线程共享，存储JVM加载的类信息，常量，静态变量，即使编译代码</p><h3 id="_3-程序计数器" tabindex="-1"><a class="header-anchor" href="#_3-程序计数器" aria-hidden="true">#</a> 3. 程序计数器</h3><p>当前线程所执行的字节码的行号指示器，线程私有</p><p>字节码解释器，就是来改变这个计数器来选择下一条要执行的命令</p><h3 id="_4-java虚拟机栈" tabindex="-1"><a class="header-anchor" href="#_4-java虚拟机栈" aria-hidden="true">#</a> 4. Java虚拟机栈</h3><p>线程私有，描述java方法执行的内存模型，它的生命周期与线程相同</p><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><ul><li>局部变量表（所占用空间，编译期间分配完成） <ul><li>编译期可知的各种基本数据类型</li><li>对象引用</li><li>returnAddress类型（指向了一条字节码指令的地址）</li></ul></li><li>操作栈</li><li>动态链接</li><li>方法出口</li></ul><p>当栈深大于允许的高度时，会抛出StackOverflowError，常见于递归调用异常的情况</p><p>当无法申请到足够的空间时，会抛出OutOfMemoryError</p><h3 id="_5-本地方法栈" tabindex="-1"><a class="header-anchor" href="#_5-本地方法栈" aria-hidden="true">#</a> 5. 本地方法栈</h3><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务</p>',26),h=[d];function t(n,c){return i(),e("div",null,h)}const u=a(l,[["render",t],["__file","JVM学习之内存结构.html.vue"]]);export{u as default};
