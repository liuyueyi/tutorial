import{_ as t,V as i,W as l,$ as n,Y as o,F as a}from"./framework-b1bd8911.js";const r="/tutorial/imgs/column/llm/22-1.webp",c={},u=o('<p>在很多介绍中，Function Calling 被描述为：</p><blockquote><p><em>让模型调用外部函数。</em></p></blockquote><p>这个说法在概念上并没有错，但在工程上并不够准确。</p><hr><h3 id="_15-1-一个更贴近系统设计的理解" tabindex="-1"><a class="header-anchor" href="#_15-1-一个更贴近系统设计的理解" aria-hidden="true">#</a> 15.1 一个更贴近系统设计的理解</h3><p>从工程角度看，Function Calling 的作用是：</p><blockquote><p><strong>为模型提供一种“受约束的行动出口”。</strong></p></blockquote><p>这句话可以拆成两个关键维度：</p><ul><li><p><strong>行动出口</strong>：模型的 “思考” 需要转化为具体动作（比如 “查询文档”“调用审批系统”），Function Calling 就是这种转化的标准化格式</p><ul><li>—— 比如用<code>{&quot;name&quot;:&quot;search_document&quot;,&quot;parameters&quot;:{&quot;doc_type&quot;:&quot;travel_reimbursement&quot;,&quot;version&quot;:&quot;2025&quot;}}</code>表示 <code>查询 2025 版差旅报销文档</code>。</li></ul></li><li><p><strong>受约束</strong>：模型不能随意定义动作，只能从系统预定义的函数列表中选择。比如如果系统没开放 “删除审批记录” 的函数，模型就无法发起这个操作</p><ul><li>—— 这在企业场景中至关重要（想象一下，如果模型能随意调用删除函数，会带来多大风险）。</li></ul></li></ul><hr><h3 id="_15-2-function-calling-在企业知识库助手中的位置" tabindex="-1"><a class="header-anchor" href="#_15-2-function-calling-在企业知识库助手中的位置" aria-hidden="true">#</a> 15.2 Function Calling 在企业知识库助手中的位置</h3>',11),s=o('<figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在这个流程中，权责划分非常清晰：</p><ul><li>LLM 负责“判断要不要做”: 是否需要行动？需要调用哪个函数？参数是否正确？</li><li>系统负责“真正去做”: 函数调用的实际操作（如查文档、调接口）由系统完成，模型不直接接触底层资源；</li><li>结果 “闭环”：执行结果会返回给 LLM，作为下一步推理的依据（比如查到文档后，模型再基于文档内容生成回答）。</li></ul><p>举个例子：当用户问 “海外差旅报销是否需要主管审批” 时，</p><ol><li>LLM 会先判断 “需要查询 2025 版文档”，然后调用<code>search_document</code>函数；</li><li>系统执行查询后，将文档中 “审批环节” 的内容返回给 LLM；</li><li>最后 LLM 基于这些内容，整理出对用户的回答。</li></ol><hr><h3 id="_15-3-一个关键工程结论" tabindex="-1"><a class="header-anchor" href="#_15-3-一个关键工程结论" aria-hidden="true">#</a> 15.3 一个关键工程结论</h3><blockquote><p><strong>Function Calling 不是为了让模型更强，而是为了让系统更安全。</strong></p></blockquote><p>它的核心价值，是把 “系统能做什么” 的控制权牢牢握在设计者手中：</p><ul><li>想开放哪些能力（如查询、提交表单），就定义哪些函数；</li><li>想限制哪些风险（如修改数据、删除记录），就不提供对应的函数；</li><li>所有动作都有明确日志（哪个函数被调用、参数是什么），便于审计和调试。</li></ul><p>理解了这一点，我们就能明白：为什么企业场景中，Function Calling 不是 “可选功能”，而是 “必选设计”</p><p>—— 它是模型 “智能” 与系统 “安全” 之间的平衡器。</p><p>但当任务变得更复杂（比如 “先确认报销流程，再帮我提交报销申请，最后同步给我的直属领导”），单次的 Function Calling 就不够了。</p><p>此时需要的，是能协调多个函数、多步操作的 “循环机制” —— 这就是我们接下来要讨论的 Agent。</p>',14);function d(p,m){const e=a("Mermaid");return i(),l("div",null,[u,n(e,{id:"mermaid-56",code:"eJyNVV1vGkcUfc+vGCnKWxwMhISuqkRObEeV0qhK2ifUh2V3sLfZ7lrLoiRtKuE4tgHjj9ZfEaYmbrGNpRhs2RX2QsJ/iZjZ5cn9CbkzC2twcBT2aYZ77jn33DszY4Y4MY5+HL6C4HftGqJvq6S+SMq55mn6rJ6j2TTJFJyp9yQ1Yx/WzupZUrdIdo1kLdgh1g7HSaoYjw/jGJJ0Az/SZYxiiqoKV2MSvoml63HT0J9i4aoU8IdD0fZy4Jkim+NCcOL5dUNPaDKWBf8gLGK6Zg48w8rYuClEdVV2N+LKb1jwQ3Av3y8JeayHMBYL4kGPMBa6LQ12lm3CAHDIivirrsmCaSSwxx7qkF/CpSfMiYTZRYbDsRAOe2TBcBgHO8V2kX1e3SUEqj6mSN3FBHEoFvLyfyMFbkf7FPPV+UXJVHStxy08GA14BDh2q69bX02g6WZPM0T2eemjMvs66WUxPi4ahvhCCKKgRxHuZQD2K+eDeUIaU/S/Sbs0B4P58OH3dKFkL818nPnL2cqSTImkinRtH5YwmHSlQtO7sM/RQxGIRm74t1HDd4ctH2MxrmuKNsZ3zuopBttcauWT9PAVm3Oejr6pkKUd2HR2Jkl1m0xXz+rpnwVB8CZ9YOAOuvd7d5wr5y7P+whjGQ1x4+/+ATBvYL26XLV+dtbW37IEHI2gDmRvHNOFbbKxSYrzPPweY3v58e8sAjKQbFuVZmOLTlbcGJD2Et2PdMPslRJNVbmUYcXAkgl1xyd0LY6RqaOf4thgxZyP9gVZAZDVXRSX5frgHExBcjJdclvSrS8/jcAP0AfQdvCHaZLZ4/qGI61kms7todGExn3h4p5glYnr2WM9yZ62pudJ5ZRYK24mHytt8d8LXeDsw7wXIxH7qGbXCm7/ezOOPMdSwsSf0bi1oKEfvvPR1QM6XybWso8U11pTpZ6mn58gTjjCCUcjLpVdW6abeaexAs4jmDCe/DE2E4bGTE+oJrO88wcrrm3NMpm1mu/zzROLrh00TzLNkzm6Ntum9C6F884sVsBB9wggUrCa1oJL3bSy9N0WKb6GMWfmr+/bCxBacz78Cck4fJQrfsDPg71SoKklmk/atZQ7LFzYA6xhQ2QmKZqoeuNyyZi0T+VRydmFnuTsV6f0zYLnL7ovqipq1qokWecIdkNE/i8sZ9vAjrpcK5lzGrMXgDS9Rw5XmWXIHT/2DmU24HACG5k5gvEHo2j+HZwcerRKylkoyM69btZqJLMFFtDCtlP5x0eX58Ffn1PessvrbV87d5V7QaCBG+AL20NeaXZ5nxSP3fcQFLrvnjvsTmPTOa7Q5C6PVRXt6RPzhYrRIOpcdrf87Ou9S/034Im5gPB7iH7PRz9EwEP0e077IYIeot8N3w9x00P0e3T6IUJfrIPd458Aa8i9pQ=="}),s])}const h=t(c,[["render",d],["__file","22.Function Calling.html.vue"]]);export{h as default};
