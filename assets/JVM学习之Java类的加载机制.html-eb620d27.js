import{_ as a,V as l,W as i,a0 as e}from"./framework-23f3cf9b.js";const s={},r=e('<h1 id="jvm学习之java类的加载机制" tabindex="-1"><a class="header-anchor" href="#jvm学习之java类的加载机制" aria-hidden="true">#</a> JVM学习之Java类的加载机制</h1><p>平常我们使用java的多，深入到jvm层的机会却很少，平时若不关注，也不会清楚java文件编译后的class文件是如何被jvm加载到内存，如何进行初始化，如何进行运行的</p><p>因此这里主要学习的目标就是class文件的加载，会包含以下内容：</p><ul><li>什么是类加载</li><li>类加载的过程</li><li>什么时候触发类加载</li><li>类加载器</li><li>双亲委托机制</li></ul><h2 id="i-什么是类的加载" tabindex="-1"><a class="header-anchor" href="#i-什么是类的加载" aria-hidden="true">#</a> I. 什么是类的加载</h2><p>简单来讲，类加载就是将class文件中的二进制，读取到内存中，解析其中定义的数据结构，然后在运行时方法区创建对应的数据结构，在堆内创建对应的class对象，而这个class对象，就是封装了对应的数据结构，和相关数据的访问操作方法；</p><p>上面的这一段简述中，却包含以下几个点：</p><h3 id="_1-加载哪里的class文件" tabindex="-1"><a class="header-anchor" href="#_1-加载哪里的class文件" aria-hidden="true">#</a> 1. 加载哪里的class文件？</h3><p>第一步就是要明确的获取到对应的class文件了，jvm支持以下几个case中获取</p><ul><li>本地系统</li><li>从网络上获取</li><li>从数据库(or缓存等第三方存储)中获取</li><li>从jar，zip包获取（比如我们依赖的第三方jar，大部分都是这种方式了）</li><li>源码编译获取（如我们常用的Groovy脚本，源码方式存在，由GroovyEngine加载时就是源码编译成class文件之后由jvm加载的）</li></ul><h3 id="_2-数据结构" tabindex="-1"><a class="header-anchor" href="#_2-数据结构" aria-hidden="true">#</a> 2. 数据结构</h3><p>将class文件加载到内存后，一是在堆内创建class对象，一是在运行时方法区内创建对应的数据结构，具体的数据结构主要应该是类型信息</p><ul><li><p>类的方法代码，变量名，方法名，访问权限，返回值等</p></li><li><p>类(静态)变量也存储在方法区</p></li></ul><p>这一块有必要在jvm的内存分配中详细的研究下，每个存储区间到底干嘛用的，内部存写啥，先留一个坑位</p><h3 id="_3-class对象" tabindex="-1"><a class="header-anchor" href="#_3-class对象" aria-hidden="true">#</a> 3. class对象</h3><p>class对象是在堆内创建，反射机制就是主要利用它来实现，通过class对象基本可以完全的操作这个类（包括创建对象，访问成员，调用方法）</p><h2 id="ii-类加载过程" tabindex="-1"><a class="header-anchor" href="#ii-类加载过程" aria-hidden="true">#</a> II. 类加载过程</h2><p>类加载过程主要包括： 加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载</p><p>用一张图来表示整个过程，且会带上每个过程主要干嘛用的</p><figure><img src="https://s3.mogucdn.com/mlcdn/c45406/180313_49238ck3ek881b1g0adk88a33k919_990x336.jpg" alt="类加载过程" tabindex="0" loading="lazy"><figcaption>类加载过程</figcaption></figure><h3 id="_1-加载" tabindex="-1"><a class="header-anchor" href="#_1-加载" aria-hidden="true">#</a> 1. 加载</h3><p>加载作为类加载的第一个过程，主要就是将class文件代表的二进制，加载到内存中</p><ul><li>获取class对应的二进制流（可以从任何能获取到的地方读取对应的二进制流）</li><li>将二进制流的静态存储结构转换为方法区的运行时数据结构</li><li>在堆内创建class对象</li></ul><p>上面的三个过程中，最灵活的就是获取二进制的过程，可以按照你的实际场景，从各种地方捞出数据</p><h3 id="_2-验证" tabindex="-1"><a class="header-anchor" href="#_2-验证" aria-hidden="true">#</a> 2. 验证</h3><p>主要是验证class文件是否合法，有没有被篡改等，属于连接的一个过程</p><ul><li>文件格式验证：魔数校验，jdk版本校验</li><li>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证：确保解析动作能正确执行。</li></ul><h3 id="_3-准备" tabindex="-1"><a class="header-anchor" href="#_3-准备" aria-hidden="true">#</a> 3. 准备</h3><p>简单来说就是准备好静态变量的存储空间，并设置默认值，属于连接的一个过程</p><ul><li>正式为类分配内存</li><li>为类变量设置默认的初始化值（不执行实际的赋值语句，这里专指基本类型的零值，对象的null）</li><li>对static final 变量赋与代码中实际的值</li></ul><h3 id="_4-解析" tabindex="-1"><a class="header-anchor" href="#_4-解析" aria-hidden="true">#</a> 4. 解析</h3><p>简单来讲就是将常量池内的符号引用替换成实际引用，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，同样属于连接的一个过程</p><ul><li>符号引用：是一组符号来描述目标，可以是任何字面量</li><li>直接引用：是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li></ul><h3 id="_5-初始化" tabindex="-1"><a class="header-anchor" href="#_5-初始化" aria-hidden="true">#</a> 5. 初始化</h3><p>为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化</p><p>准备阶段为类变量赋上了默认值，这里则主要是初始化代码中的赋值，一般而言根据实际定义的顺序进行初始化</p><h4 id="a-初始化步骤" tabindex="-1"><a class="header-anchor" href="#a-初始化步骤" aria-hidden="true">#</a> a. 初始化步骤</h4><ul><li>若类没有被加载连接，则优先加载</li><li>若父类没有被初始化，则优先初始化父类</li><li>执行类的初始化语句（直接赋值，静态代码块）</li></ul><h4 id="b-初始化的时机" tabindex="-1"><a class="header-anchor" href="#b-初始化的时机" aria-hidden="true">#</a> b. 初始化的时机</h4><ul><li>new创建一个对象时</li><li>访问或修改类的静态变量，执行静态方法</li><li>反射调用</li><li>子类被使用</li><li>jvm启动时指定</li></ul><h3 id="_6-卸载" tabindex="-1"><a class="header-anchor" href="#_6-卸载" aria-hidden="true">#</a> 6. 卸载</h3><p>简单来说就是用完了，收拾线程的过程</p><ul><li>程序执行完成</li><li>异常</li><li>系统层面错误</li><li><code>System.exit()</code></li></ul><h3 id="iii-类加载器" tabindex="-1"><a class="header-anchor" href="#iii-类加载器" aria-hidden="true">#</a> III. 类加载器</h3><p>可以理解为类加载器就是用来加载类的工具，同一个类被不同的类加载器加载之后，也认为他们是不同的</p><p>四种类加载器：自定义类加载器，应用类加载器，扩展类加载器，启动类加载器</p><h3 id="_1-启动类加载器-bootstrap-classloader" tabindex="-1"><a class="header-anchor" href="#_1-启动类加载器-bootstrap-classloader" aria-hidden="true">#</a> 1. 启动类加载器(BootStrap ClassLoader)</h3><p>源头，根，负责加载存放在JDK\\jre\\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的<code>java.*</code>开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的</p><h3 id="_2-扩展类加载器-extension-classloader" tabindex="-1"><a class="header-anchor" href="#_2-扩展类加载器-extension-classloader" aria-hidden="true">#</a> 2. 扩展类加载器（Extension ClassLoader）</h3><p>该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\\jre\\lib\\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如<code>javax.*</code>开头的类），开发者可以直接使用扩展类加载器</p><h3 id="_3-应用类加载器-application-classloader" tabindex="-1"><a class="header-anchor" href="#_3-应用类加载器-application-classloader" aria-hidden="true">#</a> 3. 应用类加载器（Application ClassLoader）</h3><p>该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><h3 id="_4-自定义类加载器-user-classloader" tabindex="-1"><a class="header-anchor" href="#_4-自定义类加载器-user-classloader" aria-hidden="true">#</a> 4. 自定义类加载器（User ClassLoader）</h3><p>自己实现的继承ClassLoader的加载器，可以按照自己的意愿，从某些地方加载类</p><h3 id="_5-类加载机制" tabindex="-1"><a class="header-anchor" href="#_5-类加载机制" aria-hidden="true">#</a> 5.类加载机制</h3><ul><li>全盘负责 <ul><li>当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li></ul></li><li>父类委托 <ul><li>先尝试让父类加载器来加载，当父类做不到时，再自己来做</li></ul></li><li>缓存机制 <ul><li>缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li></ul></li></ul><h3 id="_6-类的加载" tabindex="-1"><a class="header-anchor" href="#_6-类的加载" aria-hidden="true">#</a> 6.类的加载</h3><p>类加载有三种方式：</p><ul><li><p>1、命令行启动应用时候由JVM初始化加载</p></li><li><p>2、通过Class.forName()方法动态加载</p><ul><li>加载class到内存，并执行static块</li></ul></li><li><p>3、通过ClassLoader.loadClass()方法动态加载</p><ul><li>只加载class文件到jvm，在<code>class.newInstance()</code>时，执行static块</li></ul></li></ul><h3 id="iv-双亲委托" tabindex="-1"><a class="header-anchor" href="#iv-双亲委托" aria-hidden="true">#</a> IV. 双亲委托</h3><p>双亲委托，就是来了一个类加载，先扔给上面去处理，层层上传，只有上面处理不了时，才自己来决定</p><p>有啥好处？</p><ul><li>系统类防止内存中出现多份同样的字节码</li><li>保证Java程序安全稳定运行</li></ul><p>说明：双亲委托机制是可以被破坏的</p>',64),d=[r];function h(c,n){return l(),i("div",null,d)}const o=a(s,[["render",h],["__file","JVM学习之Java类的加载机制.html.vue"]]);export{o as default};
