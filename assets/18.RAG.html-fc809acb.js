const e=JSON.parse('{"key":"v-6ae5a629","path":"/column/ai/llmcoding/18.RAG.html","title":"第 12 章：RAG —— 当模型“不知道”时，系统该如何补偿？","lang":"zh-CN","frontmatter":{"order":18,"title":"第 12 章：RAG —— 当模型“不知道”时，系统该如何补偿？","tag":["LLM"],"category":["LLM"],"date":"2025-12-30T16:22:07.000Z","keywords":"LLM应用开发","description":"在前面的章节中，我们已经逐步解决了： 如何约束模型行为（Prompt） 如何管理对话与上下文（Context / Memory） 但到这里，一个更根本的问题开始浮现： 如果用户的问题，本身就超出了模型的知识边界，或者企业私有知识范围，系统还能做什么？ 这就是我们前面提到 RAG（Retrieval-Augmented Generation）存在的原因。 12.1 先别急着实现：什么是 RAG","head":[["meta",{"property":"og:url","content":"https://liuyueyi.github.io/tutorial/column/ai/llmcoding/18.RAG.html"}],["meta",{"property":"og:site_name","content":"一灰灰的站点"}],["meta",{"property":"og:title","content":"第 12 章：RAG —— 当模型“不知道”时，系统该如何补偿？"}],["meta",{"property":"og:description","content":"在前面的章节中，我们已经逐步解决了： 如何约束模型行为（Prompt） 如何管理对话与上下文（Context / Memory） 但到这里，一个更根本的问题开始浮现： 如果用户的问题，本身就超出了模型的知识边界，或者企业私有知识范围，系统还能做什么？ 这就是我们前面提到 RAG（Retrieval-Augmented Generation）存在的原因。 12.1 先别急着实现：什么是 RAG"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-31T02:21:16.000Z"}],["meta",{"property":"article:tag","content":"LLM"}],["meta",{"property":"article:published_time","content":"2025-12-30T16:22:07.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-31T02:21:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第 12 章：RAG —— 当模型“不知道”时，系统该如何补偿？\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-12-30T16:22:07.000Z\\",\\"dateModified\\":\\"2025-12-31T02:21:16.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"12.1 先别急着实现：什么是 RAG","slug":"_12-1-先别急着实现-什么是-rag","link":"#_12-1-先别急着实现-什么是-rag","children":[]},{"level":2,"title":"12.2 RAG 解决的，其实是“知识时效与边界问题”","slug":"_12-2-rag-解决的-其实是-知识时效与边界问题","link":"#_12-2-rag-解决的-其实是-知识时效与边界问题","children":[]},{"level":2,"title":"12.3 从系统角度看：RAG 在整体架构中的位置","slug":"_12-3-从系统角度看-rag-在整体架构中的位置","link":"#_12-3-从系统角度看-rag-在整体架构中的位置","children":[]},{"level":2,"title":"12.4 一个常见误区：RAG ≠ 万能增强器","slug":"_12-4-一个常见误区-rag-万能增强器","link":"#_12-4-一个常见误区-rag-万能增强器","children":[]},{"level":2,"title":"12.5 文档 → Chunk → Embedding：检索效果的真正上限","slug":"_12-5-文档-→-chunk-→-embedding-检索效果的真正上限","link":"#_12-5-文档-→-chunk-→-embedding-检索效果的真正上限","children":[{"level":3,"title":"12.5.1 Chunk 设计：被严重低估的工程决策","slug":"_12-5-1-chunk-设计-被严重低估的工程决策","link":"#_12-5-1-chunk-设计-被严重低估的工程决策","children":[]},{"level":3,"title":"12.5.2 一个工程化的 Chunk 决策思路","slug":"_12-5-2-一个工程化的-chunk-决策思路","link":"#_12-5-2-一个工程化的-chunk-决策思路","children":[]}]},{"level":2,"title":"12.6 RAG工程化建设","slug":"_12-6-rag工程化建设","link":"#_12-6-rag工程化建设","children":[{"level":3,"title":"12.6.1 从“调用 RAG”到“集成 RAG”：系统视角的转变","slug":"_12-6-1-从-调用-rag-到-集成-rag-系统视角的转变","link":"#_12-6-1-从-调用-rag-到-集成-rag-系统视角的转变","children":[]},{"level":3,"title":"12.6.2 RAG 的第一个工程问题：何时触发？","slug":"_12-6-2-rag-的第一个工程问题-何时触发","link":"#_12-6-2-rag-的第一个工程问题-何时触发","children":[]},{"level":3,"title":"12.6.3 RAG 的第二个工程问题：接口如何定义？","slug":"_12-6-3-rag-的第二个工程问题-接口如何定义","link":"#_12-6-3-rag-的第二个工程问题-接口如何定义","children":[]},{"level":3,"title":"12.6.4 RAG 的第三个工程问题：模型如何“被迫使用”检索结果？","slug":"_12-6-4-rag-的第三个工程问题-模型如何-被迫使用-检索结果","link":"#_12-6-4-rag-的第三个工程问题-模型如何-被迫使用-检索结果","children":[]},{"level":3,"title":"12.6.5 RAG 的第四个工程问题：失败如何被定位？","slug":"_12-6-5-rag-的第四个工程问题-失败如何被定位","link":"#_12-6-5-rag-的第四个工程问题-失败如何被定位","children":[]},{"level":3,"title":"12.6.6 企业知识库助手中的 RAG 集成示例","slug":"_12-6-6-企业知识库助手中的-rag-集成示例","link":"#_12-6-6-企业知识库助手中的-rag-集成示例","children":[]}]},{"level":2,"title":"12.7 本章小结：RAG 是系统工程，而不是检索技巧","slug":"_12-7-本章小结-rag-是系统工程-而不是检索技巧","link":"#_12-7-本章小结-rag-是系统工程-而不是检索技巧","children":[]}],"git":{"createdTime":1767147676000,"updatedTime":1767147676000,"contributors":[{"name":"yihui","email":"bangzewu@126.com","commits":1}]},"readingTime":{"minutes":12.51,"words":3753},"filePathRelative":"column/ai/llmcoding/18.RAG.md","localizedDate":"2025年12月30日","excerpt":"<p>在前面的章节中，我们已经逐步解决了：</p>\\n<ul>\\n<li>如何约束模型行为（Prompt）</li>\\n<li>如何管理对话与上下文（Context / Memory）</li>\\n</ul>\\n<p>但到这里，一个更根本的问题开始浮现：</p>\\n<blockquote>\\n<p><strong>如果用户的问题，本身就超出了模型的知识边界，或者企业私有知识范围，系统还能做什么？</strong></p>\\n</blockquote>\\n<p>这就是我们前面提到 RAG（Retrieval-Augmented Generation）存在的原因。</p>\\n<hr>\\n<h2> 12.1 先别急着实现：什么是 RAG</h2>","copyright":{},"autoDesc":true}');export{e as data};
