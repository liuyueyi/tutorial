import{_ as e,V as o,W as p,X as n,Y as s,Z as c,a0 as a,F as i}from"./framework-23f3cf9b.js";const l={},u=a('<p>以下是关于 Kotlin 协程的深度解析，包含核心概念、线程对比、使用方式、工作原理及最佳实践：</p><h3 id="一、协程的本质与核心概念" tabindex="-1"><a class="header-anchor" href="#一、协程的本质与核心概念" aria-hidden="true">#</a> <strong>一、协程的本质与核心概念</strong></h3><p><strong>定义</strong>：协程是一种轻量级的线程替代方案，由程序控制调度，而非操作系统。它允许代码暂停（<code>suspend</code>）和恢复执行，无需阻塞线程。</p><p><strong>核心特性</strong>：</p><ul><li><strong>轻量级</strong>：单个线程可运行数千个协程，内存占用仅 ~1KB（对比线程的 MB 级）。</li><li><strong>非阻塞</strong>：协程挂起时不阻塞线程，线程可执行其他任务。</li><li><strong>结构化并发</strong>：通过作用域管理协程生命周期，避免内存泄漏。</li><li><strong>挂起函数</strong>：使用 <code>suspend</code> 标记的函数，可暂停和恢复执行。</li></ul><h3 id="二、协程-vs-线程" tabindex="-1"><a class="header-anchor" href="#二、协程-vs-线程" aria-hidden="true">#</a> <strong>二、协程 vs 线程</strong></h3><table><thead><tr><th>特性</th><th>协程（Coroutine）</th><th>线程（Thread）</th></tr></thead><tbody><tr><td><strong>调度</strong></td><td>由程序（协程调度器）控制</td><td>由操作系统内核调度</td></tr><tr><td><strong>创建成本</strong></td><td>极低（约 1KB 内存）</td><td>高（约 1MB 内存，视平台而定）</td></tr><tr><td><strong>切换开销</strong></td><td>极小（纳秒级，仅涉及上下文切换）</td><td>高（微秒级，涉及内核态切换）</td></tr><tr><td><strong>并发性</strong></td><td>单线程可运行数千个协程</td><td>受限于系统资源（通常数百个）</td></tr><tr><td><strong>阻塞影响</strong></td><td>仅挂起当前协程，不影响线程</td><td>阻塞整个线程，其他任务需等待</td></tr><tr><td><strong>适用场景</strong></td><td>I/O 密集型任务（如网络请求）</td><td>CPU 密集型任务（如计算）</td></tr></tbody></table><h3 id="三、协程的基本使用姿势" tabindex="-1"><a class="header-anchor" href="#三、协程的基本使用姿势" aria-hidden="true">#</a> <strong>三、协程的基本使用姿势</strong></h3><h4 id="_1-启动协程的方式" tabindex="-1"><a class="header-anchor" href="#_1-启动协程的方式" aria-hidden="true">#</a> <strong>1. 启动协程的方式</strong></h4><p>所有的协程必须在一个作用域内执行，使用方式为</p><p><code>作用域.launch {}</code></p><p>其中 launch 是一个函数，用于创建协程并将其函数主体的执行分派给相应的调度程序</p>',12),r={href:"http://Dispatchers.IO",target:"_blank",rel:"noopener noreferrer"},d=a(`<p>一个基础的使用示例：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span><span class="token operator">*</span>

<span class="token comment">// 1. GlobalScope.launch：非结构化，谨慎使用</span>
GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment">// 非阻塞延迟</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;GlobalScope 协程&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 2. runBlocking：阻塞当前线程，用于测试</span>
runBlocking <span class="token punctuation">{</span>
    launch <span class="token punctuation">{</span> <span class="token comment">// 默认继承 runBlocking 的协程作用域</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;runBlocking 内部协程&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 3. CoroutineScope.launch：推荐方式（结构化并发）</span>
<span class="token keyword">val</span> scope <span class="token operator">=</span> <span class="token function">CoroutineScope</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span>
scope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>
    <span class="token comment">// 协程逻辑</span>
<span class="token punctuation">}</span>
scope<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 取消所有子协程</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-挂起函数-suspend-functions" tabindex="-1"><a class="header-anchor" href="#_2-挂起函数-suspend-functions" aria-hidden="true">#</a> <strong>2. 挂起函数（Suspend Functions）</strong></h4><p>在函数前添加关键字<code>suspend</code>，声明这个函数为挂起函数； 若我们希望两个挂起函数顺序调用，在协程中，按照正常的顺序书写即可，后面的挂起函数可以正常获取前面的挂起函数，即两者是顺序执行的</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment">// 模拟网络请求</span>
    <span class="token keyword">return</span> <span class="token string-literal singleline"><span class="token string">&quot;Data&quot;</span></span>
<span class="token punctuation">}</span>

<span class="token comment">// 在协程中调用挂起函数</span>
launch <span class="token punctuation">{</span>
    <span class="token keyword">val</span> <span class="token keyword">data</span> <span class="token operator">=</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">data</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-异步任务与结果获取" tabindex="-1"><a class="header-anchor" href="#_3-异步任务与结果获取" aria-hidden="true">#</a> <strong>3. 异步任务与结果获取</strong></h4><p>若两个挂起函数之间没有依赖，我希望它们能并行调度，方便我快速获取结果，此时可以借助 <code>async</code> 来实现</p><blockquote><p>在概念上，async 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。</p></blockquote><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> coroutineScope <span class="token punctuation">{</span>
    <span class="token keyword">val</span> deferred1 <span class="token operator">=</span> async <span class="token punctuation">{</span> <span class="token function">loadData1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token comment">// 启动异步任务</span>
    <span class="token keyword">val</span> deferred2 <span class="token operator">=</span> async <span class="token punctuation">{</span> <span class="token function">loadData2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token keyword">val</span> result <span class="token operator">=</span> deferred1<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> deferred2<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 获取结果</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="四、协程的核心组件" tabindex="-1"><a class="header-anchor" href="#四、协程的核心组件" aria-hidden="true">#</a> <strong>四、协程的核心组件</strong></h3><h4 id="_1-协程作用域-coroutinescope" tabindex="-1"><a class="header-anchor" href="#_1-协程作用域-coroutinescope" aria-hidden="true">#</a> <strong>1. 协程作用域（CoroutineScope）</strong></h4><p>管理协程的生命周期，确保资源正确释放：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">class</span> MyViewModel <span class="token operator">:</span> <span class="token function">ViewModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用 viewModelScope（Android 架构组件提供）</span>
    <span class="token keyword">fun</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> viewModelScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>
        <span class="token comment">// 协程逻辑</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Android 开发过程中，我们需要理解一些协程代码运行的范围。而所有的Scope 如 <code>GlobalScope</code> 都是 <code>CoroutineScope</code> 的子类，我们的协程创建都需要这样一个 <code>CoroutineScope</code> 来启动。</p><p>一些常见的作用域 <code>CoroutineScope</code> 对象。</p><ul><li>GlobeScope：全局范围，不会自动结束执行。</li><li>MainScope：主线程的作用域，全局范围</li><li>lifecycleScope：生命周期范围，用于activity等有生命周期的组件，在DESTROYED的时候会自动结束。</li><li>viewModelScope：viewModel范围，用于ViewModel中，在ViewModel被回收时会自动结束</li></ul><p>手动创建一个作用域</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> scope <span class="token operator">=</span> <span class="token function">CoroutineScope</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_2-协程调度器-dispatchers" tabindex="-1"><a class="header-anchor" href="#_2-协程调度器-dispatchers" aria-hidden="true">#</a> <strong>2. 协程调度器（Dispatchers）</strong></h4><p>指定协程执行的线程池：</p><ul><li><code>Dispatchers.Main</code>：主线程（UI 线程），用于更新 UI。</li><li><code>Dispatchers.IO</code>：适合 I/O 密集型任务（默认 64 线程）。</li><li><code>Dispatchers.Default</code>：适合 CPU 密集型任务（默认线程数为 CPU 核心数）。</li><li><code>newSingleThreadContext</code>：创建专用单线程。</li></ul><h4 id="_3-job-与协程生命周期" tabindex="-1"><a class="header-anchor" href="#_3-job-与协程生命周期" aria-hidden="true">#</a> <strong>3. Job 与协程生命周期</strong></h4><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> job <span class="token operator">=</span> launch <span class="token punctuation">{</span>
    <span class="token comment">// 协程体</span>
<span class="token punctuation">}</span>

job<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">// 启动协程</span>
job<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 取消协程</span>
job<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 等待协程完成</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="五、协程的工作原理" tabindex="-1"><a class="header-anchor" href="#五、协程的工作原理" aria-hidden="true">#</a> <strong>五、协程的工作原理</strong></h3><ol><li><p><strong>挂起与恢复</strong>：</p><ul><li>协程通过状态机实现挂起，将局部变量保存在对象中。</li><li>挂起时释放线程，恢复时从上次暂停处继续执行。</li></ul></li><li><p><strong>Continuation Passing Style (CPS)</strong>：</p><ul><li><p>编译器将 <code>suspend</code> 函数转换为带 <code>Continuation</code> 参数的状态机。</p></li><li><p>示例：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token comment">// 原始代码</span>
<span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Before&quot;</span></span><span class="token punctuation">)</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;After&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 编译后（简化）</span>
<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>continuation<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>Unit<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> Any <span class="token punctuation">{</span>
    <span class="token keyword">when</span> <span class="token punctuation">(</span>continuation<span class="token punctuation">.</span>label<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token number">0</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Before&quot;</span></span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> continuation<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>label <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token number">1</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;After&quot;</span></span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> Unit
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong>调度器工作流程</strong>：</p><ul><li>协程调度器管理线程池，将协程任务分发给空闲线程。</li><li>非阻塞操作（如 <code>delay</code>）通过回调机制恢复执行。</li></ul></li></ol><h3 id="六、协程的异常处理" tabindex="-1"><a class="header-anchor" href="#六、协程的异常处理" aria-hidden="true">#</a> <strong>六、协程的异常处理</strong></h3><h4 id="_1-结构化异常处理" tabindex="-1"><a class="header-anchor" href="#_1-结构化异常处理" aria-hidden="true">#</a> <strong>1. 结构化异常处理</strong></h4><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token comment">// 使用 try-catch</span>
launch <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 处理异常</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用 supervisorScope 隔离子协程异常</span>
supervisorScope <span class="token punctuation">{</span>
    launch <span class="token punctuation">{</span> <span class="token comment">/* 可能抛出异常的协程 */</span> <span class="token punctuation">}</span>
    launch <span class="token punctuation">{</span> <span class="token comment">/* 不受影响的协程 */</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-全局异常处理器" tabindex="-1"><a class="header-anchor" href="#_2-全局异常处理器" aria-hidden="true">#</a> <strong>2. 全局异常处理器</strong></h4><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> exceptionHandler <span class="token operator">=</span> CoroutineExceptionHandler <span class="token punctuation">{</span> _<span class="token punctuation">,</span> throwable <span class="token operator">-&gt;</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Caught exception: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">throwable</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 应用于协程作用域</span>
<span class="token keyword">val</span> scope <span class="token operator">=</span> <span class="token function">CoroutineScope</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO <span class="token operator">+</span> exceptionHandler<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="七、协程的最佳实践" tabindex="-1"><a class="header-anchor" href="#七、协程的最佳实践" aria-hidden="true">#</a> <strong>七、协程的最佳实践</strong></h3><h4 id="_1-避免使用-globalscope" tabindex="-1"><a class="header-anchor" href="#_1-避免使用-globalscope" aria-hidden="true">#</a> <strong>1. 避免使用 GlobalScope</strong></h4><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token comment">// 错误做法</span>
GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token comment">// 正确做法</span>
<span class="token keyword">class</span> MyClass <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> scope <span class="token operator">=</span> <span class="token function">CoroutineScope</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO <span class="token operator">+</span> <span class="token function">Job</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    
    <span class="token keyword">fun</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
    
    <span class="token keyword">fun</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 生命周期结束时取消</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-选择合适的调度器" tabindex="-1"><a class="header-anchor" href="#_2-选择合适的调度器" aria-hidden="true">#</a> <strong>2. 选择合适的调度器</strong></h4><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token comment">// UI 操作在主线程</span>
<span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    textView<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;Loading...&quot;</span></span>
    <span class="token keyword">val</span> <span class="token keyword">data</span> <span class="token operator">=</span> <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token comment">// 切换到 IO 线程</span>
    textView<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token keyword">data</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-避免协程嵌套" tabindex="-1"><a class="header-anchor" href="#_3-避免协程嵌套" aria-hidden="true">#</a> <strong>3. 避免协程嵌套</strong></h4><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token comment">// 错误做法：嵌套协程</span>
launch <span class="token punctuation">{</span>
    launch <span class="token punctuation">{</span> <span class="token comment">/* 子协程 */</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 正确做法：使用 async 组合结果</span>
<span class="token keyword">val</span> result <span class="token operator">=</span> coroutineScope <span class="token punctuation">{</span>
    <span class="token keyword">val</span> deferred1 <span class="token operator">=</span> async <span class="token punctuation">{</span> <span class="token function">task1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token keyword">val</span> deferred2 <span class="token operator">=</span> async <span class="token punctuation">{</span> <span class="token function">task2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    deferred1<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> deferred2<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-处理背压-backpressure" tabindex="-1"><a class="header-anchor" href="#_4-处理背压-backpressure" aria-hidden="true">#</a> <strong>4. 处理背压（Backpressure）</strong></h4><p>当生产者速度快于消费者时，使用 <code>Channel</code> 或 <code>Flow</code>：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token comment">// 使用 buffer 处理背压</span>
flow <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token function">emit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">buffer</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// 缓冲 100 个元素</span>
    <span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span> <span class="token comment">/* 处理元素 */</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_5-资源管理" tabindex="-1"><a class="header-anchor" href="#_5-资源管理" aria-hidden="true">#</a> <strong>5. 资源管理</strong></h4><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token comment">// 使用 use 自动关闭资源</span>
<span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">File</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;data.txt&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">useLines</span> <span class="token punctuation">{</span> lines <span class="token operator">-&gt;</span>
        lines<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="八、协程的性能优化" tabindex="-1"><a class="header-anchor" href="#八、协程的性能优化" aria-hidden="true">#</a> <strong>八、协程的性能优化</strong></h3><ol><li><p><strong>减少协程创建开销</strong>：</p><ul><li>避免在循环中创建大量协程，使用 <code>map</code> + <code>awaitAll</code> 批量处理。</li></ul><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> results <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> async <span class="token punctuation">{</span> <span class="token function">process</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">awaitAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>复用调度器</strong>：</p><ul><li>避免频繁创建新的 <code>SingleThreadContext</code>，使用共享实例。</li></ul></li><li><p><strong>监控协程泄漏</strong>：</p><ul><li>使用 <code>DebugProbes</code>（测试环境）检测未完成的协程。</li></ul><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token comment">// 在测试中使用</span>
DebugProbes<span class="token punctuation">.</span><span class="token function">install</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 测试结束后检查</span>
DebugProbes<span class="token punctuation">.</span><span class="token function">assertNoActiveCoroutines</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h3 id="九、常见陷阱与注意事项" tabindex="-1"><a class="header-anchor" href="#九、常见陷阱与注意事项" aria-hidden="true">#</a> <strong>九、常见陷阱与注意事项</strong></h3><ol><li><p><strong>阻塞 vs 挂起</strong>：</p><ul><li>避免在协程中使用 <code>Thread.sleep()</code>（阻塞线程），应使用 <code>delay()</code>（挂起协程）。</li></ul></li><li><p><strong>线程安全</strong>：</p><ul><li>协程不保证线程安全，共享可变状态时需同步（如使用 <code>Mutex</code>）。</li></ul></li><li><p><strong>内存泄漏</strong>：</p><ul><li>长生命周期协程引用短生命周期对象（如 Activity）时需谨慎。</li></ul></li><li><p><strong>测试协程代码</strong>：</p><ul><li>使用 <code>TestCoroutineDispatcher</code> 控制协程执行：</li></ul><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token annotation builtin">@Test</span>
<span class="token keyword">fun</span> <span class="token function">testCoroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlockingTest <span class="token punctuation">{</span>
    <span class="token comment">// 测试协程逻辑</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h3 id="十、协程的应用场景" tabindex="-1"><a class="header-anchor" href="#十、协程的应用场景" aria-hidden="true">#</a> <strong>十、协程的应用场景</strong></h3><ol><li><p><strong>异步 I/O 操作</strong>：</p><ul><li>网络请求、文件读写等。</li></ul></li><li><p><strong>UI 响应性优化</strong>：</p><ul><li>将耗时操作放在后台协程，保持 UI 流畅。</li></ul></li><li><p><strong>并发任务处理</strong>：</p><ul><li>并行执行多个独立任务，合并结果。</li></ul></li><li><p><strong>数据流处理</strong>：</p><ul><li>使用 <code>Flow</code> 处理异步数据流。</li></ul></li><li><p><strong>状态机实现</strong>：</p><ul><li>通过协程实现复杂的状态流转逻辑。</li></ul></li></ol><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> <strong>总结</strong></h3><p>Kotlin 协程通过轻量级、非阻塞的特性，彻底改变了异步编程的体验。其核心优势在于：</p><ul><li><strong>高效资源利用</strong>：减少线程创建开销，提升系统吞吐量。</li><li><strong>简洁代码结构</strong>：使用同步写法实现异步逻辑，避免回调地狱。</li><li><strong>安全的并发模型</strong>：通过结构化并发和作用域管理，降低内存泄漏风险。</li></ul><p>掌握协程需要理解其核心概念（作用域、调度器、挂起函数）和最佳实践，避免常见陷阱。在实际项目中，协程特别适合处理 I/O 密集型任务和需要高响应性的应用场景。</p>`,52);function k(v,m){const t=i("ExternalLinkIcon");return o(),p("div",null,[u,n("p",null,[n("a",r,[s("Dispatchers.IO"),c(t)]),s(" 指示此协程应在为 I/O 操作预留的线程上执行。")]),d])}const h=e(l,[["render",k],["__file","02.Kotlin协程知识点总结.html.vue"]]);export{h as default};
