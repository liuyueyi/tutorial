<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://liuyueyi.github.io/tutorial/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://liuyueyi.github.io/tutorial/rss.xml" rel="self" type="application/rss+xml"/>
    <title>一灰灰的站点</title>
    <link>https://liuyueyi.github.io/tutorial/</link>
    <description>一灰灰的全网知识站点</description>
    <language>zh-CN</language>
    <pubDate>Tue, 23 Dec 2025 06:47:01 GMT</pubDate>
    <lastBuildDate>Tue, 23 Dec 2025 06:47:01 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>Copyright by 一灰灰blog</copyright>
    <image>
      <title>一灰灰的站点</title>
      <url>https://liuyueyi.github.io/tutorial/logo.svg</url>
      <link>https://liuyueyi.github.io/tutorial/</link>
    </image>
    <category>工具</category>
    <category>Chrome</category>
    <category>SpringAI</category>
    <category>Agent</category>
    <category>AI</category>
    <category>Kotlin</category>
    <category>SpringBoot</category>
    <category>迭代</category>
    <category>QuickMCP</category>
    <category>Java</category>
    <category>JDK21</category>
    <category>技术组件</category>
    <category>开源</category>
    <category>ElasticSearch</category>
    <category>运维</category>
    <item>
      <title>7. Chrome插件Mybatis日志转SQL语句</title>
      <link>https://liuyueyi.github.io/tutorial/tool/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/07.Myabtis%E6%97%A5%E5%BF%97%E5%90%88%E6%88%90SQL%E8%AF%AD%E5%8F%A5%E6%8F%92%E4%BB%B6.html</link>
      <guid>https://liuyueyi.github.io/tutorial/tool/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/07.Myabtis%E6%97%A5%E5%BF%97%E5%90%88%E6%88%90SQL%E8%AF%AD%E5%8F%A5%E6%8F%92%E4%BB%B6.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7. Chrome插件Mybatis日志转SQL语句</source>
      <description>开发调试与生产分析的利器：MyBatis SQL日志合并插件，让复杂日志秒变可执行SQL 一、开篇 在Java开发的世界里，MyBatis作为最受欢迎的ORM框架之一，为我们提供了灵活的SQL操作能力。然而，伴随着这种灵活性，也带来了一个让人头疼的问题：当应用在开发或生产环境中遇到SQL相关问题时，如何快速定位和分析那些被参数化的SQL日志？ 相信各位javaer都会有类似的经历：面对控制台中输出的MyBatis日志，看到类似&amp;quot;Preparing: SELECT * FROM user WHERE id = ? AND status = ?&amp;quot;和&amp;quot;Parameters: 123(Long), active(String)&amp;quot;这样的信息，却需要手动将参数值代入SQL模板中，才能知道这条SQL实际执行的是什么？这个过程不仅繁琐，而且容易出错，尤其是在处理复杂查询时。</description>
      <category>工具</category>
      <category>Chrome</category>
      <pubDate>Mon, 22 Dec 2025 19:22:29 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 开发调试与生产分析的利器：MyBatis SQL日志合并插件，让复杂日志秒变可执行SQL</h1>
<h2> 一、开篇</h2>
<p>在Java开发的世界里，MyBatis作为最受欢迎的ORM框架之一，为我们提供了灵活的SQL操作能力。然而，伴随着这种灵活性，也带来了一个让人头疼的问题：当应用在开发或生产环境中遇到SQL相关问题时，如何快速定位和分析那些被参数化的SQL日志？</p>
<p>相信各位javaer都会有类似的经历：面对控制台中输出的MyBatis日志，看到类似"Preparing: SELECT * FROM user WHERE id = ? AND status = ?"和"Parameters: 123(Long), active(String)"这样的信息，却需要手动将参数值代入SQL模板中，才能知道这条SQL实际执行的是什么？这个过程不仅繁琐，而且容易出错，尤其是在处理复杂查询时。</p>
<figure><img src="/imgs/251223/00.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>下面给大家推荐一个能彻底解决这个问题的神器——MyBatis SQL Log Merger插件，它不仅能大幅提升开发调试效率，更是生产环境SQL分析的得力助手。</p>
<h2> 二、场景痛点分析</h2>
<h3> 1. 开发阶段痛点</h3>
<p>在开发过程中，我们经常需要验证SQL的正确性，分析查询性能，或者调试业务逻辑。传统的做法是：</p>
<ol>
<li>从日志中复制SQL模板和参数信息</li>
<li>手动将参数值代入SQL模板中</li>
<li>将完整的SQL粘贴到数据库客户端执行</li>
<li>分析执行结果</li>
</ol>
<p>这个过程不仅耗时，而且容易出错，特别是当SQL包含大量参数或复杂条件时。</p>
<h3> 2. 生产阶段痛点</h3>
<p>在生产环境中，这个问题更加突出。当系统出现性能问题或异常时，比如现在出现了一个慢SQL，但是面对控制台上输出的SQL模板和传参，需要快速分析MyBatis日志，但：</p>
<ol>
<li>生产环境的SQL通常更加复杂，尤其是涉及多个表关联的场景</li>
<li>不能直接在生产数据库中执行可能影响业务的SQL（业务重放可能加剧问题的影响面）</li>
<li>需要将生产日志带回安全环境进行分析</li>
<li>手动还原SQL既耗时又可能引入错误</li>
</ol>
<p>这些痛点严重影响了问题排查效率，延长了故障恢复时间；同时也极大的降低了程序员的幸福指数</p>
<h2> 三、插件核心功能介绍</h2>
<p>MyBatis SQL Log Merger插件正是为了解决这些痛点而生</p>
<h3> 1. 一键将MyBatis日志转换为可执行SQL</h3>
<p>只需将MyBatis日志复制到插件中，即可一键生成完整的、可直接执行的SQL语句。插件会自动识别SQL模板和参数信息，并将参数值正确地代入SQL中。</p>
<p>如在监控的网页上，开启SQL提取功能，选中sql模板和sql传参，直接生成对应的sql；更能一键导航到您配置的sql管理工具站点</p>
<figure><img src="/imgs/251223/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 独立的SQL合成工具页</h3>
<p>除了上面的在目标网站上注入合成按钮之外，这个插件还提供了一个独立的页面，适用于从非浏览器场景获取Mybatis执行日志的场景，如 IDEA 的控制台日志：</p>
<figure><img src="/imgs/251223/01.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在这个独立的SQL合成工具页中，提供了两种输入方式</p>
<ul>
<li><strong>单框模式</strong>：适用于完整的MyBatis日志，插件自动解析SQL模板和参数</li>
<li><strong>双框模式</strong>：分别输入SQL模板和参数信息，提供更精确的控制</li>
</ul>
<table>
<thead>
<tr>
<th>输入模式</th>
<th>示例图</th>
</tr>
</thead>
<tbody>
<tr>
<td>单框模式</td>
<td><img src="/imgs/251223/02.webp" alt="" loading="lazy"> <br> <img src="/imgs/251223/03.webp" alt="" loading="lazy"></td>
</tr>
<tr>
<td>双框模式</td>
<td><img src="/imgs/251223/04.webp" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h3> 3. SQL格式化与语法高亮</h3>
<p>生成的SQL支持进行格式化，提高可读性，并提供语法高亮功能，方便快速识别SQL结构和潜在问题；生成的SQL可以通过一键复制到剪贴板，方便粘贴到数据库客户端或其他工具中执行。</p>
<figure><img src="/imgs/251223/05.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 本地处理，保障数据安全</h3>
<p>所有处理都在浏览器本地进行，无需上传任何数据到服务器，确保敏感的SQL信息不会泄露，特别适合处理生产环境日志。</p>
<h3> 5. 插件优势</h3>
<ul>
<li>提升开发效率
<ul>
<li>通过自动化处理SQL日志，插件可以将原本需要几分钟的手动操作缩短到几秒钟，大幅提升开发效率。开发人员可以将更多时间专注于业务逻辑的实现，而不是繁琐的日志分析。</li>
</ul>
</li>
<li>支持生产环境安全分析
<ul>
<li>插件的本地处理特性使其非常适合分析生产环境日志。无需将敏感数据上传到任何服务器，确保数据安全，同时又能高效地进行SQL分析。</li>
</ul>
</li>
<li>数据本地处理，无泄漏风险
<ul>
<li>所有处理都在浏览器本地完成，没有任何数据传输，完全避免了敏感SQL信息泄露的风险，符合企业安全要求。</li>
</ul>
</li>
<li>多语言支持
<ul>
<li>插件支持中英文界面，满足国际化团队的需求，让不同语言背景的开发人员都能方便使用。</li>
</ul>
</li>
</ul>
<h2> 四、使用方法详解</h2>
<h3> 1. 开发场景应用</h3>
<p>在开发环境中使用MyBatis SQL Log Merger非常简单：</p>
<ol>
<li><strong>安装插件</strong>：从Chrome应用商店安装 <a href="https://chromewebstore.google.com/detail/mybatis-sql-log-merger/ldlekpjpadmkfoohidfgjjcmegdbkbho" target="_blank" rel="noopener noreferrer">MyBatis SQL Log Merger</a></li>
<li><strong>获取日志</strong>：从IDE控制台或日志文件中复制MyBatis的DEBUG级别日志</li>
<li><strong>粘贴处理</strong>：打开插件界面，粘贴日志内容，点击"Process SQL/处理SQL"</li>
<li><strong>验证结果</strong>：查看生成的完整SQL，如有需要可复制到数据库客户端执行</li>
</ol>
<p>这种方式可以大大加快SQL验证和调试的速度。</p>
<figure><img src="/imgs/251223/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 生产场景应用</h3>
<p>在生产环境中分析日志时，可以这样使用(对于有网页可以直接查看服务日志的场景)</p>
<ol>
<li><strong>SQL日志查询网页</strong>：安装插件之后，建议将插件固定到外部工具栏；然后导航到目标网站</li>
<li><strong>激活提取SQL按钮</strong>：点击 Chrome 工具栏中的 <code>MyBatis SQL Log Merger</code> 图标，在弹出窗口中，点击非活动状态指示器旁边的"注入 SQL 提取按钮"切换开关</li>
<li><strong>复制SQL</strong>：直接复制包含SQL模板和SQL参数的两行日志</li>
<li><strong>提取SQL</strong>：点击右小角的提取SQL按钮，将自动得到可执行的SQL语句</li>
</ol>
<figure><img src="/imgs/251223/07.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/imgs/251223/08.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/imgs/251223/09.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这种方式既保证了生产数据的安全，又能高效地进行SQL分析。</p>
<h3> 3. 不同日志格式的支持</h3>
<p>插件支持多种MyBatis日志格式：</p>
<ul>
<li>标准MyBatis日志格式</li>
<li>带"Preparing:"和"Parameters:"前缀的日志</li>
<li>不同日志框架（Log4j、Logback等）的输出格式</li>
<li>自定义日志格式</li>
</ul>
<h2> 五、小结</h2>
<p>这个插件的优势还是比较明显的，MyBatis SQL Log Merger插件是一个真正解决开发和运维痛点的工具。它不仅在开发阶段能大幅提升调试效率，在生产环境中也能帮助快速定位和分析SQL相关问题。强烈推荐给每一个有需要的javer开发小伙伴🙂，有兴趣的小伙伴可以直接在谷歌浏览器上点进行下载体验</p>
<ul>
<li>主页：<a href="https://ai.hhui.top/mybatislog/index.html" target="_blank" rel="noopener noreferrer">MyBatis SQL 日志合并工具</a></li>
<li>谷歌插件商店：<a href="https://chromewebstore.google.com/detail/mybatis-sql-log-merger/ldlekpjpadmkfoohidfgjjcmegdbkbho" target="_blank" rel="noopener noreferrer">Chrome商店下载地址</a></li>
<li>项目源码： <a href="https://github.com/liuyueyi/ai-chrome-mysql-merge" target="_blank" rel="noopener noreferrer">ai-chrome-mysql-merge</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/251223/00.webp" type="image/webp"/>
    </item>
    <item>
      <title>15.接入OpenAI接口风格的大模型</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/15.%E6%8E%A5%E5%85%A5OpenAI%E6%8E%A5%E5%8F%A3%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/15.%E6%8E%A5%E5%85%A5OpenAI%E6%8E%A5%E5%8F%A3%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">15.接入OpenAI接口风格的大模型</source>
      <description>15.接入OpenAI接口风格的大模型 鉴于OpenAI在业内的地位，很多大模型的调用接口都是兼容OpenAI的，因此，在接入OpenAI的接口风格大模型时，若官方没有提供高可用的starter，那么直接使用OpenAI的starter就是一个非常好的选择了 接下来我们将演示一下，如何通过OpenAI的starter接入讯飞大模型 一、项目初始化 1. 项目创建 创建一个SpringBoot项目，并引入SpringAI依赖，基本流程如 创建一个SpringAI-Demo工程</description>
      <category>SpringAI</category>
      <pubDate>Tue, 26 Aug 2025 17:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 15.接入OpenAI接口风格的大模型</h1>
<p>鉴于OpenAI在业内的地位，很多大模型的调用接口都是兼容OpenAI的，因此，在接入OpenAI的接口风格大模型时，若官方没有提供高可用的starter，那么直接使用OpenAI的starter就是一个非常好的选择了</p>
<p>接下来我们将演示一下，如何通过OpenAI的starter接入讯飞大模型</p>
<h2> 一、项目初始化</h2>
<h3> 1. 项目创建</h3>
<p>创建一个SpringBoot项目，并引入SpringAI依赖，基本流程如 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 2. 添加依赖</h3>
<p>我们这里直接使用OpenAI的starter作为大模型交互的工具，因此直接在依赖中，添加对应的stater即可</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 配置文件</h3>
<p>以讯飞星火为例，我们首先当官网申请对应的apiKey，并添加到配置文件中(或者通过环境变量、启动参数的方式传入)</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意看上面的配置，参数是放在 <code>spring.ai.openai</code> 下面的</p>
<p>另外一个需要注意的点就是 <code>base-url</code></p>
<figure><img src="/imgs/column/springai/15-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>虽然官方文档中给出的地址是 <a href="https://spark-api-open.xf-yun.com/v1/" target="_blank" rel="noopener noreferrer">https://spark-api-open.xf-yun.com/v1/</a>，但是我们不需要添加 <code>/v1</code>，原因在于OpenAI的实现中，已经自动补上了这个前缀</p>
<figure><img src="/imgs/column/springai/15-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、测试验证</h2>
<p>接下来我们验证一下大模型的调用</p>
<h3> 1. 联调接口实现</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用方式和前面介绍的SpringAI大模型调用没有任何区别，直接使用注入的<code>ChatModel</code>或者基于 <code>ChatModel</code> 创建 <code>ChatClient</code></p>
<h3> 2. 访问验证</h3>
<p>接下来直接访问这个接口，看看是否可以实现大模型的对话</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/15-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 手动创建模型</h3>
<p>上面介绍的是直接使用注入的<code>ChatModel</code>或者基于 <code>ChatModel</code> 创建 <code>ChatClient</code>；若我们一个项目中，存在多个满足OpenAi风格的大模型，则直接使用上面的方式不太优雅，因此，我们可以手动创建模型</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/15-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、总结</h2>
<p>本文主要介绍符合OpenAI接口风格的大模型接入方式，直接通过SpringAI-OpenAI的starter接入，或者手动创建模型，都可以实现便捷的大模型使用</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S15-openai-style-model" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/15-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>16.异步流式模型调用</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/16.%E5%BC%82%E6%AD%A5%E6%B5%81%E5%BC%8F%E6%A8%A1%E5%9E%8B%E8%B0%83%E7%94%A8.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/16.%E5%BC%82%E6%AD%A5%E6%B5%81%E5%BC%8F%E6%A8%A1%E5%9E%8B%E8%B0%83%E7%94%A8.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">16.异步流式模型调用</source>
      <description>异步流式模型调用 前面介绍的教程中，更多的还是是同步调用，对于某些场景，同步调用可能无法满足，比如： 模型返回结果是流式数据，比如：图片生成、语音合成、视频生成等等； 模型返回结果是异步数据，比如：图片识别、语音识别、视频识别等等； 模型返回结果是分批次数据，比如：图片识别、语音识别、视频识别等等； 此外，同步调用需要等待LLM处理完，将所有的结果一并返回；因此对用户的体验并不友好，需要一直空等；因此通过流式的逐步返回，无疑是一个非常好的选择；接下来我们看一下SpringAI如何实现LLM的流式访问</description>
      <category>SpringAI</category>
      <pubDate>Thu, 11 Dec 2025 12:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 异步流式模型调用</h1>
<p>前面介绍的教程中，更多的还是是同步调用，对于某些场景，同步调用可能无法满足，比如：</p>
<ul>
<li>模型返回结果是流式数据，比如：图片生成、语音合成、视频生成等等；</li>
<li>模型返回结果是异步数据，比如：图片识别、语音识别、视频识别等等；</li>
<li>模型返回结果是分批次数据，比如：图片识别、语音识别、视频识别等等；</li>
</ul>
<p>此外，同步调用需要等待LLM处理完，将所有的结果一并返回；因此对用户的体验并不友好，需要一直空等；因此通过流式的逐步返回，无疑是一个非常好的选择；接下来我们看一下SpringAI如何实现LLM的流式访问</p>
<h2> 一、实例演示</h2>
<p>首先我们需要创建一个SpringAI的项目，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 初始化</h3>
<p>创建一个 <code>ChatController</code>，自动注入 ChatModel，并基于 <code>ChatModel</code> 实例化 <code>ChatClient</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. ChatModel流式访问</h3>
<p>对于ChatModel流式访问，与前面直接访问LLM的区别不大，只是将最后的 <code>call</code> 调用改成 <code>stream</code> 调用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 stream() 方法调用，返回的是 <code>Flux&lt;ChatResponse&gt;</code>，我们定义返回头为 <code>text/event-stream</code>，这样客户端就可以接受流式的数据返回</p>
<figure><img src="/imgs/column/springai/16-1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的截图中可以看到，返回的流式数据，每次返回一个 <code>ChatResponse</code> 对象，需要客户端从中解析 <code>output.text</code></p>
<h3> 3. ChatClient流式反问</h3>
<p>对于ChatClient的流式请求，同样是将发起请求的<code>call</code>调用改成<code>stream</code>调用</p>
<p>对于<code>ChatClient.stream()</code>后的结果调用，官方提供了三种方式</p>
<ol>
<li><code>stream().content()</code>: 返回 <code>Flux&lt;String&gt;</code></li>
<li><code>stream().chatClientResponse()</code>: 返回 <code>Flux&lt;ChatClientResponse&gt;</code></li>
<li><code>stream().chatResponse()</code>: 返回 <code>Flux&lt;ChatResponse&gt;</code></li>
</ol>
<p>下面我们使用最简单 <code>content()</code> 进行演示，只关注LLM的返回结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/16-2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 完整结果拼接</h3>
<p>对于某些场景，我们需要将流式数据拼接成完整结果然后再一次返回给客户端，即此时需要我们自己来解析 <code>Flux&lt;ChatReponse&gt;</code>，对于此，可以使用下面几种方式来实现</p>
<p>case1: 直接使用 <code>Flux.collectionList()</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>case2: 使用 <code>Flux.reduce()</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>case3: 使用 <code>subscribe() + SseEmitter</code> 实现更灵活的流式返回</p>
<p>这种方式依然是流式返回给调用方；但是借助SseEmitter，从而实现更灵活的定制化（如后台服务也希望使用LLM的返回结果，此时就可以在subscribe的逻辑中进行定制化开发）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、总结</h2>
<p>本文这里介绍了SpringAI通过stream的方式访问LLM的流式数据，从上面的实际体验来看，和同步访问相比，流式访问的体验更加友好，用户可以更早的看到结果，并且可以更灵活的定制化返回结果；但是从编码的角度出发，两者又没有太明显的区别，对于应用者而言，这一点可以说是非常友好了</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/16-1.png" type="image/png"/>
    </item>
    <item>
      <title>17.推理大模型接入与推理过程返回</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/17.%E6%8E%A8%E7%90%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E4%B8%8E%E6%8E%A8%E7%90%86%E8%BF%87%E7%A8%8B%E8%BF%94%E5%9B%9E.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/17.%E6%8E%A8%E7%90%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E4%B8%8E%E6%8E%A8%E7%90%86%E8%BF%87%E7%A8%8B%E8%BF%94%E5%9B%9E.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">17.推理大模型接入与推理过程返回</source>
      <description>17.推理大模型接入与推理过程返回 对于一些支持推理模型的LLM（如DeepSeekR1 带有推理解析器的vLLM），除了LLM的直接返回结果，推理结果往往也是一个非常有用的返回信息，对于SpringAI，我们可以通过从返回的 Metadata 中获取推理结果。 使用推理的前提是模型必须支持推理，我们可以使用阿里的 qwen-plus-latest 或者智谱的 glm-4.5-flash；这两个都是支持推理过程的模型。 一、实例演示 首先我们需要创建一个SpringAI的项目，基本流程同 创建一个SpringAI-Demo工程</description>
      <category>SpringAI</category>
      <pubDate>Thu, 11 Dec 2025 17:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 17.推理大模型接入与推理过程返回</h1>
<p>对于一些支持推理模型的LLM（如DeepSeekR1 带有推理解析器的vLLM），除了LLM的直接返回结果，推理结果往往也是一个非常有用的返回信息，对于SpringAI，我们可以通过从返回的 Metadata 中获取推理结果。</p>
<p>使用推理的前提是模型必须支持推理，我们可以使用阿里的 <code>qwen-plus-latest</code> 或者智谱的 <code>glm-4.5-flash</code>；这两个都是支持推理过程的模型。</p>
<h2> 一、实例演示</h2>
<p>首先我们需要创建一个SpringAI的项目，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 初始化</h3>
<p>我们借助OpenAI的接口风格来解析推理过程，因此需要引入对应的依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后创建一个 <code>Controller</code> 用于测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，我们基于 OpenAiApi 来创建 ChatModel，在创建创建ChatModel时，通过 <code>extraBody</code> 来传递额外参数，告诉大模型是否开启推理过程</p>
<p>但是请注意，这个推理是否开启的参数依然是取决于具体的模型提供商的要求</p>
<ul>
<li>阿里的百炼模型，推理参数为 <code>enable_thinking</code>，且必须显示传递 <code>.extraBody(Map.of("enable_thinking", true))</code></li>
<li>智谱的glm-4.5-flash模型，默认就是开启推理的，不需要额外传递参数；如果希望关闭，可以设置参数 <code>.extraBody(Map.of("thinking", Map.of("type", "disabled")))</code></li>
</ul>
<figure><img src="/imgs/column/springai/17-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 获取推理结果</h3>
<p>我们先使用同步调用智谱模型，看看表现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试一下，结果返现并没有推理过程；主要原因是推理过程需要是<code>stream()</code>方式调用，然后由用户在 <code>delta</code> 中进行获取</p>
<p>我们在改成 <code>.stream()</code> 方法来获取推理结果</p>
<p>获取推理结果的关键代码在： <code>generation.getOutput().getMetadata().get("reasoningContent");</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/17-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的结果也可以看出，对于推理过程，使用流式调用，然后再metadata中获取</p>
<p>上面是智谱的大模型；阿里百炼的模型，获取推理结果同样也是使用流式调用，区别在于，若开启了推理过程，那么必须使用流式调用；否则，会报错</p>
<h2> 二、小结</h2>
<p>本文介绍了如何与支持推理的LLM进行交互，并获取推理过程；从使用层面来看并没有太多的差异，只是需要注意</p>
<ol>
<li>推理过程需要使用流式调用</li>
<li>根据模型的传参定义，判断是否需要主动设置参数，以开启推理过程</li>
<li>从返回的<code>metadata</code>中，获取 <code>reasoningContent</code> 来获取推理过程</li>
</ol>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/17-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>01.AI Agent Google白皮书</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/01.AI%20Agent%20Google%E7%99%BD%E7%9A%AE%E4%B9%A6.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/01.AI%20Agent%20Google%E7%99%BD%E7%9A%AE%E4%B9%A6.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.AI Agent Google白皮书</source>
      <description>以下内容来自于大模型对 Agents谷歌白皮书 的翻译内容提取 1.序 人类非常擅长识别复杂的模式。他们是怎么做到的呢？ -- 借助于外部外部工具，如书籍、网络搜索或者计算器之类的工具，来补充一有的知识，然后再得出结论 对于生成式人工智能模型，同样也可以通过训练来使用工具，以此来访问实时信息或者给出行动建议，如</description>
      <category>Agent</category>
      <pubDate>Thu, 06 Nov 2025 10:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>以下内容来自于大模型对 <a href="https://drive.google.com/file/d/1oEjiRCTbd54aSdB_eEe3UShxLBWK9xkt/view" target="_blank" rel="noopener noreferrer">Agents谷歌白皮书</a> 的翻译内容提取</p>
<h2> 1.序</h2>
<p>人类非常擅长识别复杂的模式。他们是怎么做到的呢？</p>
<p>-- 借助于外部外部工具，如书籍、网络搜索或者计算器之类的工具，来补充一有的知识，然后再得出结论</p>
<p>对于生成式人工智能模型，同样也可以通过训练来使用工具，以此来访问实时信息或者给出行动建议，如</p>
<ul>
<li>利用数据库查询工具获取客户的购物历史，然后给出购物意见</li>
<li>根据用户的查询，调用相应的API，替用户回复电子邮件或者完成金融交易</li>
</ul>
<p>大模型要实现这个，则要求模型不仅需要访问外部工具，还要能够自主规划和执行任务。 这种具备了<strong>推理、逻辑和访问外部信息</strong>的生成式 AI 模型，就是 Agent 的概念；</p>
<p>换句话说，Agent <strong>是一个扩展了生成式AI模型出厂能力的程序</strong>。</p>
<h2> 2.什么是Agent</h2>
<h3> 2.1 基本概念</h3>
<p>简单说，Agent 是 “带脑子 + 带手脚 + 会规划” 的生成式 AI 应用 —— 它能自己定目标、用工具、调资源，不用人一步步指挥，就能完成任务。</p>
<ul>
<li>Agent拥有自主能力(autonnomous): 只要提供了合适的目标，它们就能独立行动，无需人类干预</li>
<li>即使是模糊的人类指令，Agent也可以推理出它接下来应该做什么，并采取行动，最终实现其目标</li>
</ul>
<h3> 2.2 认知架构(congnitive architecture)</h3>
<p>驱动Agent的行为、动作、决策（behavior, actions, decision marking）共同组合成Agent的认知架构</p>
<p>在这个架构中，有三个核心组件，如下面的认知架构图</p>
<ul>
<li>model: 模型</li>
<li>tool: 工具</li>
<li>orchestration: 编排层</li>
</ul>
<figure><img src="/imgs/column/springai/wp-00.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 2.2.1 模型 model</h4>
<p>在Agent领域中，model通常指的是用于做核心决策的语言模型(LM)</p>
<ul>
<li>可以是大模型，也可以是小模型(LLM/SLM)</li>
<li>需要遵循基于指令的推理和逻辑框架（ReAct, Chain-of-Thought, Tree-of-Thought）</li>
<li>可以是通用、多模态的模型，或者根据特定的Agent架构的需求微调的模型</li>
<li>为了获得更好的执行效果，推荐根据已有的工具、数据集、编排推理设置，对模型进行训练/微调，以此来获得更稳定表现的模型</li>
</ul>
<h4> 2.2.2 工具 tool</h4>
<p>基础模型在文本和图像生成方面非常抢单，但是无法预外部世界联动，则极大的限制了它们的能力。工具(tool)则可以解决这个问题，Agent通过工具与外部数据和服务互动，从而扩展模型的能力边界</p>
<p>工具可以有多种表现形式，最常见的是通过WEB API(如GET/POST/PATCH/DELETE等http调用) 方式提供的工具能力</p>
<h4> 2.2.3 编排层 ochestration</h4>
<p>编排层主要描述了一个循环过程，用于控制Agent如何接收消息、执行内部推理、并使用推来结果来指导下一步的行动或者决策</p>
<p>对于编排层，有两个显著的特点：</p>
<ul>
<li>通常来说，这个循环过程会持续进行，直到Agent达到其目标或触发停止条件</li>
<li>编排层的复杂性和Agent及其执行的任务直接相关，差异可能很大</li>
</ul>
<h4> 2.2.4 Agent vs Model</h4>
<p>代表对比了Agent与模型之间的区别</p>
<table>
<thead>
<tr>
<th>对比</th>
<th>模型</th>
<th>Agent</th>
</tr>
</thead>
<tbody>
<tr>
<td>知识范围</td>
<td>知识仅限于其训练数据。</td>
<td>通过工具连接外部系统，能够在模型自带的知识之外，实时、动态扩展知识。</td>
</tr>
<tr>
<td>状态与记忆</td>
<td>无状态，每次推理都跟上一次没关系，除非在外部给模型加上会话历史或上下文管理能力。</td>
<td>有状态，自动管理会话历史，根据编排自主决策进行多轮推理。</td>
</tr>
<tr>
<td>原生工具</td>
<td>无。</td>
<td>有，自带工具和对工具的支持能力。</td>
</tr>
<tr>
<td>原生逻辑层</td>
<td>无。需要借助提示词工程或使用推理框架（CoT、ReAct  等）来形成复杂提示，指导模型进行预测。</td>
<td>有，原生认知架构，内置 CoT、ReAct 等推理框架或 LangChain  等编排框架。</td>
</tr>
</tbody>
</table>
<h2> 3.认知架构：Agent如何工作</h2>
<h3> 3.1 以厨师为例，类比Agent的工作流程</h3>
<p>厨师的职责是根据顾客的菜单，烹饪对应的菜品。 这个操作流程类似上面说到的<strong>规划——执行——调整</strong>(<code>planning - execution - adjustment</code>)循环过程</p>
<ul>
<li>收集信息(输入)：顾客点的菜单，后厨现有的食材等</li>
<li>推理(思考): 根据收集的信息，判断可以做哪些采</li>
<li>做菜(执行): 切菜、烹饪、出锅</li>
</ul>
<p>在上面的每个阶段过程，厨师都需要根据实际情况进行调整，比如突然某个食材不够了，需要找顾客协商换一道菜；根据顾客的饮食偏好，添加不同的调料（如有人要清淡、有人要重口），通过这些调整，不断的完善整个做菜过程</p>
<p>这个信息接收、规划、执行和调整（information intake, planning, executing, and adjusting）的循环描述的就是一个厨师用来实现其目标的特定认知架构。</p>
<h3> 3.2 Agent 推理框架</h3>
<p>Agent的核心是编排层，负责<strong>维护记忆、状态、推理和规划</strong>（<code>memory, state, reasoning and planning</code>）</p>
<p>使用快速发展的<strong>提示词工程</strong>(prompt engineering)及相关框架来指导推理和规划，使Agent能更有效的与环境互动来完成任务</p>
<p>白皮书中提到了三种推理框架和推理计数</p>
<ul>
<li>ReAct: 为LM提供了一个思考过程的策略</li>
<li>Cot(Chain-of-Thought)：思维链，通过中间步骤实现推理能力 （有各种子技术，如自我一致性、主动提示、多模态CoT）</li>
<li>ToT(Tree-of-Thoughts)：思维树，适合探索或战略前瞻任务。概括了链式思考提示，并允许模型探索各种思考链，作为使用语言模型解决问题的中间步骤。</li>
</ul>
<h3> 3.3 ReAct示例</h3>
<p>Agent 可以使用以上一种或多种推理技术，给特定的用户请求确定下一个最佳行动。 例如，使用 ReAct 的例子</p>
<ol>
<li>用户向 Agent 发送查询。</li>
<li>Agent 开始 ReAct sequence。</li>
<li>Agent 提示模型，要求其生成下一个 ReAct 步骤及其相应的输出：
<ul>
<li>问题：提示词 + 用户输入的问题</li>
<li>思考：模型的想法：下一步应该做什么</li>
<li>行动：模型的决策：下一步要采取什么行动。这里就是可以引入工具的地方， 例如，行动可以是 <code>[Flights, Search, Code, None]</code> 中的一个，前三个代表模型可以选择的已知工具，最后一个代表“无工具选择”。</li>
<li>行动的输入：模型决定是否要向工具提供输入，如果要提供，还要确定提供哪些输入</li>
<li>观察：行动/行动输入序列的结果。根据需要，这个思考/行动/行动输入/观察<code>（thought / action / action input / observation）</code>可能会重复 N 次。</li>
<li>最终答案：模型返回对原始用户查询的最终答案。</li>
</ul>
</li>
<li>ReAct 循环结束，并将最终答案返回给用户。</li>
</ol>
<figure><img src="/imgs/column/springai/wp-01.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如上图，模型、工具和Agent配置共同工作，根据用户的输入，返回一个有根据的、简洁的响应。虽然模型第一轮根据其先前知识猜了一个答案（幻觉），但它接下来使用了一个工具（航班）来搜索实时外部信息，从而能根据真实数据做出更明智的决策，并将这些信息总结回给用户。</p>
<p>Agent 的响应质量与模型的推理能力和执行任务的能力直接相关，包括选择正确工具的能力，以及工具自身的定义的好坏（how well that tools has been defined）。就像厨师精选食材、精心做菜，并关注顾客的反馈一样，Agent 依赖于合理的推理和可靠的信息来提供最佳结果。</p>
<h2> 4.工具：模型链接真实世界的关键</h2>
<p>语言模型很擅长处理信息，但它们缺乏直接感知和影响现实世界的能力。在需要与外部系统或数据联动的情况下，这些模型的实用性就很低了。 某种意义上说，语言模型的能力<strong>受限于它们的训练数据中覆盖到的信息</strong></p>
<p>为了赋予模型与外部系统进行实时、上下文感知的互动能力，通常有下面几种方式（统称为工具 Tools）</p>
<ul>
<li>Functions</li>
<li>Extensions</li>
<li>Data Stores</li>
<li>Plugins</li>
</ul>
<h3> 4.1 Extensions</h3>
<p><code>extension</code> 是一种以标准化方式连接 <code>API</code> 与 <code>Agent</code> 的组件， 使 <code>Agent</code> 能够调用外部 API，而不用管这些 API 背后是怎么实现的。</p>
<p>假设你想创建一个帮用户预定航班的Agent，并使用Google Flights API来搜索航班信息，但不确定如何让你的Agent调用这个API</p>
<figure><img src="/imgs/column/springai/wp-02.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 4.1.1 传统方式</h4>
<p>写代码，从用户输入中解析城市等相关信息，然后调用API，如</p>
<ul>
<li>用户输入 “I want to book a flight from Austin to Zurich”（“我想从奥斯汀飞往苏黎世”）； 我们的代码需要从中提取“Austin”和“Zurich”作为相关信息，然后才能进行 API 调用。</li>
<li>但如果用户输入“I want to book a flight to Zurich”，我们就无法获得出发城市信息，进而无法成功调用 API，所以需要写很多代码来处理边界 case。</li>
</ul>
<p>显然，这种方法维护性和扩展性都很差。有没有更好的解决方式呢？ 这就轮到 exntension 出场了。</p>
<h4> 4.1.2 使用Extension</h4>
<figure><img src="/imgs/column/springai/wp-03.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如图，Extension通过以下方式将Agent与API串起来</p>
<ul>
<li>提供示例信息告诉Agent如何使用API</li>
<li>告诉Agent调用API所需的具体参数</li>
</ul>
<p><code>Extension</code> 可以独立于 <code>Agent</code> 开发，但应作为 <code>Agent</code> 配置的一部分。 <code>Agent</code> 在运行时，根据提供的示例和模型来决定使用哪个 <code>extension</code> 来处理用户的查询， 这突出了 <code>extension</code> 的一个核心优势：<code>built-in example types</code>， 允许 <code>Agent</code> 动态选择最适合所执行任务的 extension，如下图所示</p>
<figure><img src="/imgs/column/springai/wp-04.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4.2 Functions</h3>
<p>在程序员的日常工作中，“函数”指的是自包含的代码模块，用于完成特定任务，并可以复用（被不同地方的代码调用）</p>
<p>在Agent的世界中，函数的工作方式非常相似——知识将软件开发者替换为模型。模型可以设置一组已知的函数，然后就可以根据规范决定何时使用哪个函数，以及函数需要哪些参数</p>
<figure><img src="/imgs/column/springai/wp-05.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol>
<li>模型只输出函数名及参数信息，不会执行函数调用</li>
<li>函数在客户端执行，作为对比的是Extension在Agent端执行</li>
</ol>
<h4> 4.2.1 Functions vs Extention</h4>
<p>对于Function，与Extention的核心区别在于，调用实际API的逻辑和执行将从代理返回给用户，因此开发人员可以对应用程序中的数据流进行更精细的控制，常见于</p>
<ul>
<li>并不希望直接调用API，而是由应用程序的其他层来调用</li>
<li>因为安全身份校验，不支持Agent直接访问的场景</li>
<li>不希望实时调用的场景（如需要人工review执行链路）</li>
</ul>
<figure><img src="/imgs/column/springai/wp-06.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 4.2.2 示例</h4>
<p>考虑以下例子，实现一个 AI Traval Agent，它会与想要旅行的用户互动。 我们的目标是让 Agent 生成一个城市列表，然后就可以下载相应城市的图片、数据等，以供用户旅行规划使用。</p>
<p>用户输入：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>模型输出可能如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然以上输出包含了我们需要的数据（城市名称），但格式不适合解析。 通过 Function，我们可以教模型以结构化风格（如 JSON）输出，以便其他系统解析。</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个Agent应用的整体流程图如下</p>
<figure><img src="/imgs/column/springai/wp-07.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4.3 data storage</h3>
<p>语言模型就像一个大图书馆，其中包含了其训练数据（信息）。但与真实世界的图书馆不同的是，这个图书馆是静态的 —— 不会更新，只包含其最初训练时的知识。而现实世界的知识是不断在演变的，所以静态模型在解决现实世界问题时就遇到了挑战。</p>
<figure><img src="/imgs/column/springai/wp-08.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><code>Data Storage</code> 通过提供动态更新的信息来解决这一问题，</p>
<ul>
<li>允许开发人员以原始格式向 <code>Agent</code> 提供增量数据，将传入的文档转换为一组向量数据库嵌入，<code>Agent</code> 可以使用这些 <code>embedding</code> 来提取信息。</li>
<li>增量数据补充，无需耗时的数据转换、模型重新训练、微调</li>
</ul>
<h4> 4.3.1 实现与应用</h4>
<p>在生成式 AI 场景，Agent 使用的数据库一般是向量数据库 —— 它们以向量 <code>embedding</code> 的形式存储数据，这是一种高维向量或数学表示。</p>
<figure><img src="/imgs/column/springai/wp-09.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>使用语言模型与 Data Storage 的最典型例子是检索增强生成（RAG - Retrieval Augmented Generation），RAG 应用程序通过让模型访问各种格式的数据来扩展模型知识的广度和深度，如：</p>
<ul>
<li>网站内容</li>
<li>结构化数据，如pdf/word/csv/电子表格等</li>
<li>非结构化数据，如HTML/PDF/TXT等</li>
</ul>
<p>用户请求和Agent响应循环的基本过程如下图</p>
<figure><img src="/imgs/column/springai/wp-10.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol>
<li>用户请求 发送到嵌入模型(embedding model)，生成嵌入查询(query embedding)。</li>
<li>将嵌入查询与向量数据库的内容进行匹配，本质上就是在计算相似度。</li>
<li>将相似度最高的内容以文本格式发送回 <code>Agent</code>。</li>
<li><code>Agent</code> 决定响应或行动。</li>
<li>最终响应发送给用户。</li>
</ol>
<h4> 4.3.2 示例</h4>
<p>一个RAG与ReAct推理/规划的Agent示例</p>
<figure><img src="/imgs/column/springai/wp-11.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4.4 小结</h3>
<p>总结来说，Extension、Function 和 Data Storage 是 Agent 在运行时可以使用的几种不同工具类型。 每种工具都有其特定的用途，可以根据 Agent 开发人员的判断单独或一起使用。</p>
<table>
<thead>
<tr>
<th>对比</th>
<th>Extensions</th>
<th>Function Calling</th>
<th>Data Stores</th>
</tr>
</thead>
<tbody>
<tr>
<td>Execution 执行</td>
<td>Agent执行</td>
<td>Client执行</td>
<td>Agent执行</td>
</tr>
<tr>
<td>使用场景</td>
<td>- 开发人员希望 Agent 控制 API 的调用 <br> - 使用 native pre-built Extensions (i.e., Vertex Search, Code Interpreter, etc.) 时比较有用 <br> - Multi-hop planning and API calling (i.e., 下一个 action 取决于前一个 action/API call 的输出)</td>
<td>- 安全或认证等原因，导致 Agent 无法直接调用 API 的场景 <br> - 时序或者操作顺序限制，导致 Agent 无法直接事实调用 API 的场景，(i.e., batch operations, human-in-the-loop review, etc.) <br> - API 没有暴露给公网，只能在内部使用的场景。</td>
<td>RAG</td>
</tr>
</tbody>
</table>
<h2> 5.通过针对性学习提升模型性能</h2>
<p>有效使用模型的一个关键是，让模型具备在生成输出时选择正确工具的能力。虽然一般训练有助于模型获得这种技能，但现实世界的场景通常需要超出训练数据的知识。 这就像是掌握基本做菜技能和精通特定菜系之间的区别，两者都需要基础烹饪知识，但后者需要针对性学习以获得更好的垂类结果。</p>
<p>通常有下面几种方法</p>
<h3> 5.1 In-Context learnging：基于上下文学习</h3>
<p>使用通用模型，但在推理时为模型提供提示词、工具和示例，使模型其能够“即时学习”如何以及何时为特定任务使用这些工具。 如ReAct框架</p>
<h3> 5.2 Retrieval-based in-context learnging: 基于检索的上下文学习</h3>
<p>通过从外部存储中检索相关信息、工具和示例来动态填充模型提示词，如RAG</p>
<h3> 5.3 Fine-utning based learning: 基于微调的学习</h3>
<p>用大量的特定示例对模型进行训练（微调/精调），然后用微调过的模型进行推理。</p>
<p>这有助于模型在接收到任何用户查询之前，理解何时以及如何应用某些工具。</p>
<h2> 6.总结</h2>
<p>本文讨论了生成式 AI Agent 的基础构建模块及工作原理。一些关键信息：</p>
<ol>
<li>Agent 的核心价值：让生成式 AI 从 “生成内容” 升级为 “完成任务”，能自主规划、用工具、对接真实世界</li>
<li>三大关键：模型（思考）、工具（行动）、编排层（流程）</li>
<li>工具选对很重要：直接用 Extension，安全可控用 Function，需要实时 / 私有数据用 Data Store</li>
<li>推理框架：ReAct, CoT, ToT, (以及本文未提到的Plan-and-Execute)</li>
<li>未来方向：多个 Agent 分工合作（比如一个负责旅行规划，一个负责订机票，一个负责订酒店），解决更复杂的问题</li>
</ol>
<p>最后需要说明，复杂的 Agent 架构并不是一蹴而就的，需要持续迭代（iterative approach）。 给定业务场景和需求之后，不断的实验和改进是找到解决方案的关键。</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/wp-00.webp" type="image/webp"/>
    </item>
    <item>
      <title>02.Agent思考框架-CoT思维链</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/02.Agent%E6%80%9D%E8%80%83%E6%A1%86%E6%9E%B6-CoT.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/02.Agent%E6%80%9D%E8%80%83%E6%A1%86%E6%9E%B6-CoT.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">02.Agent思考框架-CoT思维链</source>
      <description>AI智能体思考框架主要是为了赋予AI智能体结构化的推理和决策能力，为AI智能体提供一套完整的方法论，指导其如何理解目标、分解任务、运用工具、处理输入，并依据环境反馈来调整资深行为 当前主流的思考框架有CoT, ReAct, ToT, Plan-and-Execute，本文将主要介绍一下CoT 思维链 1.CoT思维链 Chain-of-Thought(CoT) 来源与论文 《Chain-of-Thought Prompting Elicits Reasoning in Large Language Models》</description>
      <category>Agent</category>
      <pubDate>Thu, 06 Nov 2025 14:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>AI智能体思考框架主要是为了赋予AI智能体结构化的推理和决策能力，为AI智能体提供一套完整的方法论，指导其如何理解目标、分解任务、运用工具、处理输入，并依据环境反馈来调整资深行为</p>
<p>当前主流的思考框架有CoT, ReAct, ToT, Plan-and-Execute，本文将主要介绍一下CoT 思维链</p>
<h2> 1.CoT思维链</h2>
<p>Chain-of-Thought(CoT) 来源与论文 <a href="https://proceedings.neurips.cc/paper_files/paper/2022/file/9d5609613524ecf4f15af0f7b31abca4-Paper-Conference.pdf" target="_blank" rel="noopener noreferrer">《Chain-of-Thought Prompting Elicits Reasoning in Large Language Models》</a></p>
<p>论文中提出，CoT核心是让大模型在输出最终答案前，先用自然语言生成一步步的推理过程，就像人类解数学题时写 “解题步骤”、做决策时列 “思考清单” 一样。而这些推理的中间步骤就被称为思维链</p>
<h3> 1.1 CoT定义</h3>
<blockquote>
<p>以下内容，可来自于论文: <a href="https://arxiv.org/pdf/2311.11797" target="_blank" rel="noopener noreferrer">Igniting Language Intelligence: The Hitchhiker's Guide From Chain-of-Thought Reasoning to Language Agents</a></p>
</blockquote>
<p>区别于传统的 Prompt 从输入直接到输出的方式，CoT完成了从输入到思维链再到输出的转变，即</p>
<p>由 <code>input -&gt; output</code> 转变为 <code>input -&gt; reasoning chain -&gt; output</code></p>
<figure><img src="/imgs/column/springai/ag2-01.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如图，一个完整的包含CoT的提示词，通常由指令(Instruction), 逻辑依据(Rationale), 示例(Examplars)三部分组成</p>
<ul>
<li>指令: 用于描述问题并且告知大模型的输出格式</li>
<li>逻辑: 依据即指 CoT 的中间推理过程，可以包含问题的解决方案、中间推理步骤以及与问题相关的任何外部知识，</li>
<li>示例: 则指以少样本的方式为大模型提供输入输出对的基本格式，每一个示例都包含：问题，推理过程与答案。</li>
</ul>
<p>以是否包含示例为区分，可以将 CoT 分为 Zero-Shot-CoT 与 Few-Shot-CoT</p>
<p>在上图中，Zero-Shot-CoT 不添加示例而仅仅在指令中添加一行经典的“Let's think step by step”，就可以“唤醒”大模型的推理能力。</p>
<p>而 Few-Shot-Cot 则在示例中详细描述了“解题步骤”，让大模型参考样例进行执行，从而得到推理能力。</p>
<h3> 1.2 CoT的作用</h3>
<ol>
<li>CoT允许模型把一个复杂问题拆解成多个步骤，也就是说需要更多推理步骤的问题可以多分点计算量。</li>
<li>CoT提供了一个观察模型为何会犯错的窗口，给观测者了解模型出现幻觉的原因</li>
<li>CoT能用在数学应用题、常识推理和符号操作上，也就有可能用在任何人类通过语言能解决的问题上</li>
<li>CoT支持任何语言模型使用</li>
</ol>
<h3> 1.3 CoT的优势</h3>
<ol>
<li>提高推理性能：CoT 通过将复杂问题分解为多步骤的子问题，相当显著的增强了大模型的推理能力，也最大限度的降低了大模型忽视求解问题的“关键细节”的现象，使得计算资源总是被分配于求解问题的“核心步骤”；</li>
<li>提高可解释性：对比向大模型输入一个问题大模型为我们仅仅输出一个答案，CoT 使得大模型通过向我们展示“做题过程”，使得我们可以更好的判断大模型在求解当前问题上究竟是如何工作的，同时“做题步骤”的输出，也为我们定位其中错误步骤提供了依据；</li>
<li>提高可控性：通过让大模型一步一步输出步骤，我们通过这些步骤的呈现可以对大模型问题求解的过程施加更大的影响，避免大模型成为无法控制的“完全黑盒”</li>
<li>提高灵活性：仅仅添加一句“Let's think step by step”，就可以在现有的各种不同的大模型中使用 CoT 方法，同时，CoT 赋予的大模型一步一步思考的能力不仅仅局限于“语言智能”，在科学应用，以及 AI Agent 的构建之中都有用武之地</li>
</ol>
<h2> 2. CoT原理</h2>
<h3> 2.1 CoT生效原理</h3>
<p>大模型是如何支持CoT的呢？</p>
<p>本质是 <code>大模型支持 CoT 的本质，是通过训练或提示机制，使模型在生成过程中显式或隐式地产生中间推理步骤，从而提高复杂推理任务的可解释性与准确性。</code></p>
<h4> 2.1.1 提示级CoT：基于提示工程的显式引导</h4>
<p>最早、也是目前最常用的方式。其核心思想是不改变模型参数，而是通过提示语（prompt）设计，引导模型在推理过程中显式输出中间步骤。主要分为两类：</p>
<ul>
<li><strong>零样本 CoT（Zero-shot CoT）</strong>：仅在问题末尾添加引导语，例如 <code>Let’s think step by step</code> 或 <code>请先分析步骤，再给出结论</code>。
<ul>
<li>例如，问题“为什么夏天海滩人多？” 加上引导语后</li>
<li>模型会生成类似推理链：
<ul>
<li>第一步，夏天天气炎热，人们倾向于去水边避暑；</li>
<li>第二步，海滩具备娱乐与降温功能；</li>
<li>第三步，夏季假期增加出行需求”，最后得出结论“因此夏天海滩更受欢迎。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这种方式简单有效，但在复杂推理任务中的准确率较低，对模型语言偏好和训练语料敏感。</p>
<ul>
<li>
<p><strong>少样本 CoT（Few-shot CoT）</strong>：在提示中提供若干 <code>问题 + 推理链 + 答案</code></p>
<ul>
<li>示例，使模型通过上下文学习（In-context Learning, ICL）模仿推理模式。</li>
<li>例如在算术任务中提供示例：「问题：10 个橘子吃了 3 个，还剩几个？→ 推理：10−3=7 → 答案：7」。模型据此可类推新问题。</li>
</ul>
</li>
</ul>
<p>这种方式能显著提升推理稳定性，但需要人工构建高质量示例。</p>
<h4> 2.1.2 自举式CoT：利用模型自身能力自动生成示例</h4>
<p>人工编写少样本示例成本高，因而出现了 <strong>自动思维链（Auto-CoT）</strong> 方法。其核心思想是：让模型通过自举（bootstrapping）机制自动生成用于提示的 CoT 示例。典型流程如下：</p>
<ol>
<li><strong>问题聚类（Question Clustering）</strong>：将待解决任务划分为若干语义相近的类别（如“加法”“减法”“应用题”）。</li>
<li><strong>自动示例生成（Automatic Demonstration Generation）</strong>：从每类中选择代表性问题，利用零样本 CoT 生成高质量推理链作为示例。</li>
<li><strong>Few-shot 提示重构</strong>：将自动生成的示例嵌入提示中，引导模型处理同类问题。</li>
</ol>
<p>在实践中，Auto-CoT 常与 <strong>自一致性（Self-consistency）</strong> 策略结合，即采样多条思维链并选取最一致的答案，以减轻错误推理传播问题。
这种方法减少人工干预，能在无需重新训练的前提下，自动获得较强的推理能力。</p>
<h4> 2.1.3 模型级 CoT：在训练阶段内化推理能力</h4>
<p>现在的大模型（如 DeepSeek-R1、GPT-o1 等）已不再依赖提示引导，而是通过训练过程直接“内化”思维链能力。实现路径通常包括以下几个阶段：</p>
<ul>
<li><strong>监督微调（Supervised Fine-tuning, SFT）阶段</strong>：在训练数据中引入大量包含“推理步骤 + 最终答案”的样本，使模型学习生成中间思考过程；</li>
<li><strong>强化优化（RLHF / RLAIF）阶段</strong>：通过人类反馈或自动反馈信号，奖励“逻辑正确、步骤完整”的推理链，惩罚“跳步或错误推理”；</li>
<li><strong>过程监督（Process Supervision）与验证器机制（Verifier-based Fine-tuning）</strong>：进一步强化中间推理过程的可验证性，使模型学会自我审查与修正。</li>
</ul>
<p>经过这样的训练，模型在面对复杂推理任务时，即便没有显式提示，也能自然生成符合逻辑的思维链，表现出“内置的推理习惯”。</p>
<h4> 2.1.4 多模态 CoT：跨模态推理的思维链扩展</h4>
<p>随着多模态大模型的发展（如 GPT-4o、Gemini 2等），CoT 概念已扩展至文字与视觉等多源信息的联合推理。</p>
<p><strong>多模态 CoT（Multimodal CoT）</strong>
旨在让模型在生成答案前，整合图像特征与文本上下文，形成跨模态的推理链。</p>
<p>例如，输入一张“拥挤的海滩”图片并询问“夏天这里会更受欢迎吗？”，模型可能推理：“图片显示人群密集，当前已受欢迎；夏季天气炎热，人们更倾向于去海滩避暑；假期增多会进一步提升出游人数”，最终得出结论“夏天会更受欢迎”。</p>
<p>技术上，多模态 CoT 通过两类机制实现：</p>
<ul>
<li><strong>融合式推理（Fusion-based Reasoning）</strong>：将图像与文本 token 在同一 Transformer 层中联合建模；</li>
<li><strong>递归式推理（Iterative Reasoning）</strong>：先生成初步视觉分析，再结合语言模型多轮细化推理。</li>
</ul>
<p>这类机制显著提升了模型在视觉问答（VQA）、图文逻辑、视频理解等任务中的推理一致性与可解释性。</p>
<h4> 2.1.5 小结</h4>
<p>CoT 的演进体现了从“显式提示驱动”到“内化思维模式”的范式转变：</p>
<ul>
<li><strong>提示级 CoT</strong>：通过设计输入引导模型逐步推理；</li>
<li><strong>自举式 CoT</strong>：让模型利用自身能力自动生成推理示例；</li>
<li><strong>模型级 CoT</strong>：在训练中嵌入推理链能力，实现原生思考；</li>
<li><strong>多模态 CoT</strong>：扩展至跨模态逻辑推理，融合语言与感知信息。</li>
</ul>
<p>这一演化路径标志着大模型从“被提示思考”迈向“自主推理”的阶段性突破。</p>
<h3> 2.2 CoT推理过程</h3>
<p>CoT提示过程，更像是一种提示词工程（Prompt Engineering)，通过向大语言模型展示一些少量的 exapmles，在样例中解释推理过程，大语言模型在回答提示时也会显示推理过程。</p>
<figure><img src="/imgs/column/springai/ag2-02.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如上图，以一个数学题为例，思维链提示会在给出答案之前，还会自动给出推理步骤，基于示例的方式，得到最终的计算结果</p>
<p>请注意，很多人会把 CoT 和 “详细提示” 搞混，其实两者本质不同：</p>
<ul>
<li>普通提示（比如 “请详细回答”）：只要求模型 “把答案说详细”，但没要求 “拆步骤推理”，模型可能还是跳过关键思考环节；</li>
<li>CoT 提示：强制模型 “拆步骤想”，比如在问题结尾加 “Let’s think step by step”（零样本 CoT），或给几个 “问题 + 推理链 + 答案” 的例子（少样本 CoT），让模型模仿 “分步思考” 的模式。</li>
</ul>
<h2> 3. CoT 与 AI Agent</h2>
<p>接下来我们再来看一看CoT为什么会成为Agent的主流推理框架之一</p>
<h3> 3.1 概念层</h3>
<h4> 3.1.1 CoT</h4>
<p>上面说到了Chain-of-Thought (CoT) 是一种推理生成机制（reasoning generation mechanism），让模型在回答问题前显式地展开中间推理步骤。</p>
<p>通俗地说，它让模型不直接“给答案”，而是“先想一想再回答”。
它关注的是 “思考的路径”。</p>
<h4> 3.1.2 Agent</h4>
<p>AI Agent（智能体） 是一种具备自主决策、环境交互与长期目标优化能力的系统架构。
它不只是语言模型，而是一个具备以下循环的系统：</p>
<p>感知（Perceive）→ 推理（Reason）→ 决策（Plan）→ 执行（Act）→ 反馈（Reflect）</p>
<p>Agent 的核心特征在于它必须：</p>
<ul>
<li>面对开放环境；</li>
<li>基于上下文做多步决策；</li>
<li>能调用外部工具或环境接口；</li>
<li>能根据反馈进行自我修正。</li>
</ul>
<h4> 3.1.3 对比</h4>
<table>
<thead>
<tr>
<th>概念</th>
<th>关注点</th>
<th>核心目标</th>
<th>是否可独立存在</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CoT</strong></td>
<td>模型内部的推理路径</td>
<td>提升逻辑一致性与可解释性</td>
<td>✅（单模型即可实现）</td>
</tr>
<tr>
<td><strong>Agent</strong></td>
<td>系统级决策循环</td>
<td>实现自主任务执行</td>
<td>🚫（离不开推理机制）</td>
</tr>
</tbody>
</table>
<p><strong>结论</strong>：CoT 是 Agent 的“推理内核”，Agent 是 CoT 的“应用容器”。</p>
<h3> 3.2 技术逻辑层</h3>
<p>AI Agent 想要具备“智能决策”的能力，必须拥有**多步思考（multi-step reasoning）<strong>和</strong>动态规划（planning）**能力。
而 CoT 正是当前大模型中最有效的“多步思考表示形式”。</p>
<h4> 3.2.1 CoT 提供了 Agent 的“内在思维空间”（Internal Reasoning Space）</h4>
<p>传统语言模型输出的是单步映射：</p>
<blockquote>
<p>输入 → 输出</p>
</blockquote>
<p>但 Agent 需要一个能在内部进行反思、规划、评估的结构化思维过程。</p>
<blockquote>
<p>输入 → （思考链）→ 决策 → 动作 → 环境反馈</p>
</blockquote>
<p>在这一结构中，CoT 就是 Agent 的「<strong>思维工作记忆（Working Memory）</strong>」：
模型通过生成中间推理链，显式地表达自己“在思考什么”，
从而为后续动作提供决策依据。</p>
<p>例如：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Agent 框架中，以上 CoT 输出可直接驱动调用外部工具（日程表API、邮件系统）来执行这些步骤。</p>
<h4> 3.2.2 CoT 是“反思与规划（Reflection &amp; Planning）”机制的基础</h4>
<p>在现代 Agent 设计中，存在两种主流推理范式：</p>
<table>
<thead>
<tr>
<th>推理机制</th>
<th>核心特征</th>
<th>代表实现</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CoT（Chain-of-Thought）</strong></td>
<td>线性推理链条，显式展开思考</td>
<td>GPT-4、DeepSeek-R1</td>
</tr>
<tr>
<td><strong>ToT（Tree-of-Thought）</strong></td>
<td>树状搜索式推理，多路径评估与反思</td>
<td>Tree-of-Thoughts (Yao et al., 2023)</td>
</tr>
<tr>
<td><strong>ReAct（Reason + Act）</strong></td>
<td>推理与行动交替执行</td>
<td>LangChain / ReAct Agents</td>
</tr>
<tr>
<td><strong>Reflexion / Self-Refine</strong></td>
<td>基于 CoT 输出的自我反思与修正</td>
<td>Reflexion (Shinn et al., 2023)</td>
</tr>
</tbody>
</table>
<p>注意：这些框架<strong>都以 CoT 为基础</strong>。</p>
<ul>
<li>ReAct 将 CoT 拓展为 “推理链 + 动作链”；</li>
<li>Tree-of-Thought 则是 CoT 的并行搜索化版本；</li>
<li>Reflexion 则是在 CoT 基础上增加了 “评估与修正” 模块。</li>
</ul>
<p>因此，从技术谱系上看：</p>
<blockquote>
<p><strong>CoT → ReAct / ToT / Reflexion → Agent Frameworks（如 AutoGPT, LangGraph, Voyager 等）</strong></p>
</blockquote>
<p>这也是为什么学术界称 CoT 是 “<strong>AI Agent 的推理基石（reasoning substrate）</strong>”。</p>
<h4> 3.2.3 CoT 支撑 Agent 的“显式可解释推理”能力</h4>
<p>Agent 需要被<strong>监控、调试、解释</strong>。
如果模型的决策过程是黑箱式的 end-to-end 输出（没有中间思考过程），就无法解释为何采取某个行动。</p>
<p>而 CoT 提供了一种<strong>可追踪的决策链条</strong>：</p>
<ul>
<li>每个步骤都可以被解析、验证、修改；</li>
<li>可以通过 reward model（奖励模型）对推理链进行强化或惩罚；</li>
<li>可以为后续的 meta-agent（监督 agent）提供反思依据。</li>
</ul>
<p>例如：</p>
<blockquote>
<p>CoT 输出：“我认为这家公司明天股价会上涨，因为……”，
Agent 上层模块即可分析这条推理链的合理性，并决定是否执行交易动作。</p>
</blockquote>
<p>这也是 OpenAI、Anthropic、DeepSeek 在 2024–2025 年各自的 Agent 架构中，都将 “structured reasoning trace” 作为核心模块的原因。</p>
<h3> 3.3 架构层</h3>
<p>下图描述了 CoT 与 Agent 的架构关系（文字版示意）：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这套架构中：</p>
<ul>
<li><strong>CoT 是核心推理引擎（Reasoning Engine）</strong>；</li>
<li>它与记忆模块、工具模块交互；</li>
<li>输出的思维链结果直接影响行动决策与反馈循环；</li>
<li>高级 Agent（如反思型、自演化型 Agent）则在多轮 CoT 之上再叠加元推理（Meta-Reasoning）。</li>
</ul>
<h3> 3.4 小结</h3>
<p>CoT 作为 Agent 的主流推理框架，其主要原因如下</p>
<table>
<thead>
<tr>
<th>理由</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. CoT 提供了结构化的思维路径</strong></td>
<td>使模型从“直接反应”转为“逐步规划”</td>
</tr>
<tr>
<td><strong>2. CoT 是多步决策的基础</strong></td>
<td>Agent 的计划、反思、行动循环都依赖推理链</td>
</tr>
<tr>
<td><strong>3. CoT 支撑可解释与可控性</strong></td>
<td>让外部系统理解、修改模型思考过程</td>
</tr>
<tr>
<td><strong>4. CoT 是更复杂推理框架（ReAct、ToT、Reflexion）的母体</strong></td>
<td>所有主流 Agent 推理范式都从 CoT 演化而来</td>
</tr>
<tr>
<td><strong>5. 实践验证</strong></td>
<td>从 LangChain 到 OpenAI o1-preview，再到 DeepSeek-R1，均以 CoT 风格思维链为决策基石</td>
</tr>
</tbody>
</table>
<p>一句话总结</p>
<blockquote>
<p><strong>CoT 是 AI Agent 的思维引擎。</strong>
它将大模型从“语言生成器”变为“可思考的决策体”，
是连接自然语言理解与自主行动之间的关键逻辑桥梁。</p>
</blockquote>
<hr>
<p>参考资料:</p>
<ul>
<li><a href="https://blog.csdn.net/qq_36426650/article/details/139452817" target="_blank" rel="noopener noreferrer">大模型Chain-of-Thought（CoT）与Agent基础知识与介绍_cot 大模型-CSDN博客</a></li>
<li><a href="https://www.zhihu.com/tardis/zm/art/670907685?source_id=1003" target="_blank" rel="noopener noreferrer">一文读懂：思维链 CoT（Chain of Thought）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/629087587" target="_blank" rel="noopener noreferrer">大模型思维链（Chain-of-Thought）技术原理 - 知乎</a></li>
<li><a href="https://arxiv.org/pdf/2311.11797" target="_blank" rel="noopener noreferrer">Igniting Language Intelligence: The Hitchhiker’s Guide From Chain-of-Thought Reasoning to Language Agents</a></li>
<li><a href="https://proceedings.neurips.cc/paper_files/paper/2022/file/9d5609613524ecf4f15af0f7b31abca4-Paper-Conference.pdf" target="_blank" rel="noopener noreferrer">Chain-of-Thought Prompting Elicits Reasoning
in Large Language Models</a></li>
<li>大模型：豆包 + ChatGpt</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/ag2-01.webp" type="image/webp"/>
    </item>
    <item>
      <title>03.Agent思考框架-ReAct</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/03.Agent%E6%80%9D%E8%80%83%E6%A1%86%E6%9E%B6-ReAct.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/03.Agent%E6%80%9D%E8%80%83%E6%A1%86%E6%9E%B6-ReAct.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">03.Agent思考框架-ReAct</source>
      <description>1. 背景与起源 ReAct 框架全称为 [Reason + Act: Synergizing Reasoning and Acting in Language Models](https://react-lm.github.io/)，由 Yao et al.（2022, Google Research） 首次提出。论文标题为： ReAct: Synergizing Reasoning and Acting in Language Models</description>
      <category>Agent</category>
      <pubDate>Thu, 06 Nov 2025 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. 背景与起源</h2>
<p><strong>ReAct 框架</strong>全称为 <code>[Reason + Act: Synergizing Reasoning and Acting in Language Models](https://react-lm.github.io/)</code>，由 <strong>Yao et al.（2022, Google Research）</strong> 首次提出。论文标题为：</p>
<blockquote>
<p><a href="https://arxiv.org/pdf/2210.03629" target="_blank" rel="noopener noreferrer"><em>ReAct: Synergizing Reasoning and Acting in Language Models</em></a></p>
</blockquote>
<p>这篇论文的出发点非常直接：</p>
<blockquote>
<p>仅靠 Chain-of-Thought（CoT）能让模型“思考”，但不能“行动”；
而仅靠 Tool-use 或 Action-based Agent 能“行动”，但不会“思考”。</p>
<p><strong>ReAct 试图让模型在推理（Reason）与行动（Act）之间交替进行，从而实现真正的智能体行为。</strong></p>
</blockquote>
<figure><img src="/imgs/column/springai/ag3-01.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 2. 核心思想：让模型在「思考」与「行动」之间循环</h2>
<p>传统的 CoT 是<strong>静态推理</strong>：</p>
<blockquote>
<p>输入 → 推理链（CoT） → 答案</p>
</blockquote>
<p>而 ReAct 是<strong>动态交互式推理</strong>：</p>
<blockquote>
<p>输入 → 推理步骤（Reason） → 执行动作（Act） → 观察反馈（Observe） → 再推理（Reason） → 再行动（Act） → … → 最终答案</p>
</blockquote>
<p>这种循环让模型不只是生成一条思维链，而是能够：</p>
<ul>
<li><strong>主动与外部环境交互（通过工具或接口）</strong></li>
<li><strong>根据反馈修正推理路径</strong></li>
<li><strong>在多轮循环中完成复杂任务</strong></li>
</ul>
<p>举个例子如你想查 “北京明天是否适合户外施工”，会先想 “我需要知道明天的天气（推理）→ 打开天气 APP 查数据（行动）→ 看到明天有暴雨（观察）→ 得出‘不适合施工’的结论（再推理）”。
放在大模型 / Agent 场景中，ReAct 就是让模型不再局限于 “纯内部推理”（比如 CoT 只在脑子里想），而是通过 “调用工具、获取外部反馈” 来验证和修正推理，形成闭环：</p>
<ul>
<li>推理（Reasoning）：分析目标、拆解步骤、决定下一步 “该做什么”（比如 “用户要订建筑材料，我需要先查库存→ 调用库存工具”）；</li>
<li>行动（Acting）：执行具体操作（调用工具 API、查询数据库、发送指令等），是模型与外部世界交互的核心；</li>
<li>观察（Observation）：获取行动的结果反馈（比如库存工具返回 “钢筋库存充足”“水泥缺货”）；</li>
<li>迭代：根据观察结果调整推理，直到完成目标（比如水泥缺货→ 推理 “需要找替代供应商”→ 行动 “调用供应商匹配工具”）。</li>
</ul>
<h2> 3. ReAct 的机制结构</h2>
<h3> 3.1 核心闭环流程</h3>
<p>ReAct 的核心是一个循环式 Prompt 结构，每一轮由 3 个关键组件构成：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Reason</code></td>
<td>思考步骤</td>
<td>模型分析当前状态，推理下一步要做什么</td>
</tr>
<tr>
<td><code>Act</code></td>
<td>执行动作</td>
<td>模型根据推理结果调用外部工具、API、搜索等</td>
</tr>
<tr>
<td><code>Observe</code></td>
<td>观察反馈</td>
<td>模型读取行动结果，更新内部状态</td>
</tr>
</tbody>
</table>
<p>循环结构如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种结构兼具“推理链的透明性”与“可执行性”，是 CoT 向 Agent 推理自然演化的形式。</p>
<h3> 3.2 关键要素</h3>
<p>要想让上面的ReAct的流程跑通，必须满足三个核心条件</p>
<ol>
<li>明确的目标与终止条件：目标要可量化（如2016年、诺贝尔文学奖获得者），终止条件要清晰（找到用户，任务完成）</li>
<li>标准化的工具接口：Agent 能 “看懂并调用” 工具（网络搜索）</li>
<li>状态记忆模块：Agent 能记录每一轮的 “思考结果、行动内容、观察反馈”，避免重复劳动或者遗忘关键信息</li>
</ol>
<h2> 4. 与 CoT 的关系：ReAct = CoT + 行动接口</h2>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>Chain-of-Thought (CoT)</th>
<th>ReAct (推理行动)</th>
</tr>
</thead>
<tbody>
<tr>
<td>核心功能</td>
<td>静态推理（只思考）</td>
<td>推理 + 行动 + 反馈循环</td>
</tr>
<tr>
<td>是否交互</td>
<td>否（纯语言生成）</td>
<td>是（能调用外部工具/环境）</td>
</tr>
<tr>
<td>信息来源</td>
<td>依赖模型训练时的内部知识</td>
<td>内部知识 + 外部输入 + 工具反馈数据（调用工具获取）</td>
</tr>
<tr>
<td>可解释性</td>
<td>高（显式推理链）</td>
<td>更高（推理+行动全可追溯）</td>
</tr>
<tr>
<td>典型应用</td>
<td>逻辑推理、数学题</td>
<td>工具使用、问答、信息检索、任务规划</td>
</tr>
</tbody>
</table>
<p>可以这样理解：</p>
<blockquote>
<p><strong>CoT 让模型“会思考”；
ReAct 让模型“边思考边行动”。</strong></p>
</blockquote>
<p>ReAct 实际上是将 CoT 的“推理链”扩展为一个“推理-行动交替链（Reason–Act Loop）”，使模型能够通过外部信息验证和修正自身推理过程。</p>
<h2> 5. 典型应用场景</h2>
<p>ReAct 框架已成为众多 <strong>LLM Agent 框架的基础逻辑</strong>，例如：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>知识检索 Agent</strong></td>
<td>模型根据推理决定是否调用搜索 API，检索结果再反馈给模型</td>
</tr>
<tr>
<td><strong>任务执行 Agent</strong></td>
<td>模型通过多轮思考与动作完成复杂流程（如预定行程、分析数据）</td>
</tr>
<tr>
<td><strong>工具调用（Tool Use）</strong></td>
<td>ReAct 框架下的模型能自主判断何时调用计算器、数据库或Python执行环境</td>
</tr>
<tr>
<td><strong>多Agent协作</strong></td>
<td>多个 Agent 间通过 ReAct 循环共享中间推理结果，实现协同任务（如 AutoGen、LangGraph）</td>
</tr>
</tbody>
</table>
<p>ReAct 机制也被广泛集成在框架中：</p>
<ul>
<li><strong>LangChain / LangGraph</strong>：ReAct 是默认的 reasoning template；</li>
<li><strong>OpenAI GPTs / o1 系列</strong>：其系统提示内嵌了类似 ReAct 的隐式结构；</li>
<li><strong>DeepSeek-R1 / Claude 3.5</strong>：均具备“内隐 ReAct”式动态推理循环。</li>
</ul>
<h2> 6. ReAct 的优势</h2>
<table>
<thead>
<tr>
<th>优势</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>融合思考与行动</strong></td>
<td>不再需要人工编排先“思考”还是“执行”，模型可自动判断何时行动。</td>
</tr>
<tr>
<td><strong>支持闭环反馈</strong></td>
<td>环境结果反哺推理过程，形成自我纠错机制。 避免出现纯推理(如CoT)容易出现的“想当然”的错误</td>
</tr>
<tr>
<td><strong>可解释性强</strong></td>
<td>每一步 Reason 与 Action 都是可追踪文本，利于调试与评估。</td>
</tr>
<tr>
<td><strong>易扩展</strong></td>
<td>可嵌入任意工具调用接口（API、DB、Web 搜索等）。</td>
</tr>
<tr>
<td><strong>增强记忆与规划能力</strong></td>
<td>多轮 Reasoning 让模型能规划长序列任务，而非一次性输出。</td>
</tr>
<tr>
<td><strong>通用性强</strong></td>
<td>ReAct 不依赖特定任务或工具，只要能拆解步骤、调用工具，就能适用：比如从 “查天气” 到 “采购建筑材料”，从 “旅游规划” 到 “科研数据分析”，只需替换工具和目标，框架本身无需修改，开发效率高</td>
</tr>
</tbody>
</table>
<h2> 7. ReAct 的局限与改进方向</h2>
<table>
<thead>
<tr>
<th>局限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>推理质量依赖模型本身的 CoT 能力</strong></td>
<td>若模型的逻辑推理弱，ReAct 仍可能走错路线。</td>
</tr>
<tr>
<td><strong>长上下文管理复杂</strong></td>
<td>多轮循环可能导致上下文爆炸，需要 Memory 模块支持。</td>
</tr>
<tr>
<td><strong>计算成本高</strong></td>
<td>每轮 Reason + Act + Observe 都是一条完整的 API 调用。</td>
</tr>
<tr>
<td><strong>缺乏全局规划能力</strong></td>
<td>ReAct 是“逐步决策”，缺乏全局最优策略搜索。</td>
</tr>
</tbody>
</table>
<p>因此，后续研究提出了更高阶的扩展框架，如：</p>
<ul>
<li><strong>Tree-of-Thought (ToT)</strong>：将推理链分支化、多路径搜索；</li>
<li><strong>Reflexion / Self-Refine</strong>：在 ReAct 基础上加入“自我反思”机制；</li>
<li><strong>Graph-of-Thought (GoT)</strong>：通过图结构管理复杂的推理关系。</li>
</ul>
<p>这些框架都继承自 ReAct 的核心思想：<strong>Reason + Act 的循环推理范式</strong>。</p>
<h2> 8. ReAct在Agent中的具体应用示例</h2>
<p><code>ReAct</code> 是 <code>Agent</code> “编排层” 的核心逻辑，要在 <code>Agent</code> 中落地 <code>ReAct</code>，可以按照 “组件搭建→流程设计→优化迭代” 的三板斧进行套路</p>
<h3> 8.1 第一步：搭建Agent的ReAct核心组件</h3>
<p>前面说了ReAct的三个关键组件： Reason(思考)、Act(行动)、Observe(观察)，在具体的Agent实现中，我们还需要额外考虑上下文的管理(Memory)</p>
<p>因此一个Agent要实现ReAct，则应包含下面四个核心模块</p>
<blockquote>
<p>比如我现在给Agent下达一个任务，<code>帮用户采购 100 吨 HRB400E 钢筋，要求 3 天内送达北京朝阳区工地，预算 50 万元</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>组件</th>
<th>功能描述</th>
<th>技术实现参照</th>
</tr>
</thead>
<tbody>
<tr>
<td>思考模块（Reasoner）</td>
<td>接收目标+状态→ 拆解步骤→ 决定下一步行动（比如“调用哪个工具”“参数是什么”）</td>
<td>基于大模型实现（如GPT-4、Gemini、DeepSeek），通过提示工程引导模型生成“行动指令”（比如“调用库存工具，参数：材料型号=HRB400E，数量=100吨”）</td>
</tr>
<tr>
<td>行动执行器（Actor）</td>
<td>解析思考模块的“行动指令”→ 调用对应的工具（API、数据库、RPA等）</td>
<td>搭建工具注册中心（统一管理工具名称、输入输出格式），用函数调用（Function Call）实现模型与工具的对接（比如模型输出JSON格式的行动指令，执行器解析后调用API）</td>
</tr>
<tr>
<td>观察模块（Observer）</td>
<td>获取工具返回结果→ 整理成模型能理解的格式（比如把API返回的JSON转成自然语言）</td>
<td>设计结果标准化模板（比如工具返回“{"supplier":"A","price":3700}"→ 整理为“供应商A的HRB400E钢筋报价3700元/吨”）</td>
</tr>
<tr>
<td>状态记忆模块（Memory）</td>
<td>存储“目标+每一轮的思考/行动/观察结果”→ 为下一轮思考提供上下文</td>
<td>用向量数据库（如Milvus、FAISS）存储长上下文，支持“关键词检索”（比如快速查找“供应商A的履约率”）</td>
</tr>
</tbody>
</table>
<h3> 8.2 第二步：设计 ReAct 闭环执行流程</h3>
<p>依然以上面的建筑材料采购Agent为例</p>
<h4> （1）初始化：明确目标与工具</h4>
<ul>
<li>目标：用户输入“采购100吨HRB400E钢筋，3天内送达北京朝阳工地，预算50万”；</li>
<li>注册工具：库存查询工具、供应商履约率工具、报价对比工具、订单生成工具。</li>
</ul>
<h4> （2）循环执行（直到任务完成/终止）</h4>
<figure><img src="/imgs/column/springai/ag3-02.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>
<p>每一轮的“思考指令”格式示例（模型输出）：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>观察模块整理结果示例：
“库存查询工具返回3家供应商：1. 供应商A（库存150吨，报价3700元/吨，3天达）；2. 供应商B（库存200吨，报价3800元/吨，2天达）；3. 供应商C（库存120吨，报价3600元/吨，4天达，超期）”</p>
</li>
</ul>
<h4> （3）终止条件设计</h4>
<ul>
<li>成功终止：完成目标（如“采购订单提交成功，供应商A将在3天内送达100吨HRB400E钢筋，总价37万元”）；</li>
<li>失败终止：多次迭代后无法满足目标（如“无符合‘3天达+100吨库存’的供应商，建议延长交货期至4天或更换材料型号”）。</li>
</ul>
<h3> 8.3 第三步：优化 ReAct 执行效率</h3>
<p>实际应用中，需解决“循环次数过多、工具调用错误、推理冗余”等问题，常用优化技巧：</p>
<ul>
<li>① 工具选择策略：思考模块优先选择“高优先级工具”（比如先查库存，再查履约率，避免跳过关键步骤）；</li>
<li>② 状态压缩：记忆模块只保留“关键信息”（比如只记“符合条件的供应商A/B”，忽略C的详细信息），减少大模型上下文压力；</li>
<li>③ 错误重试机制：行动失败（如工具调用超时、返回错误）时，思考模块自动调整参数（比如“重新调用库存工具，增加‘北京周边供应商’筛选条件”）；</li>
<li>④ 少样本示例引导：在思考模块的提示中，加入“问题+ReAct循环示例”，让模型更快掌握推理+行动的节奏（比如给一个“采购水泥”的ReAct示例，让模型模仿）。</li>
</ul>
<h2> 9. 总结：一句话概括 ReAct</h2>
<p><strong>ReAct 是连接“语言模型的思考能力（CoT）”与“Agent 的执行能力”的桥梁。</strong></p>
<p>它让大模型不仅能在语言空间中推理，还能在外部世界中行动；最后再以一张图，来重温一下ReAct</p>
<figure><img src="/imgs/column/springai/ag3-03.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/ag3-01.webp" type="image/webp"/>
    </item>
    <item>
      <title>04.Agent思考框架-Plan-and-Execute</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/04.Agent%E6%80%9D%E8%80%83%E6%A1%86%E6%9E%B6-Plan-and-Execute.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/04.Agent%E6%80%9D%E8%80%83%E6%A1%86%E6%9E%B6-Plan-and-Execute.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">04.Agent思考框架-Plan-and-Execute</source>
      <description>Plan-and-Execute 框架：面向复杂任务的层次化推理与行动架构 1. 引言 随着语言模型推理能力与外部工具使用能力的增强，如何高效地解决长程、多步骤、复杂任务成为 AI Agent 的关键挑战。 传统的 Chain-of-Thought (CoT) 与 ReAct 框架虽能支持推理与行动的结合，但它们通常以逐步生成的方式执行任务，容易陷入“短视（myopic）”问题——即模型缺乏全局规划能力，只能在局部推理层面决策。</description>
      <category>Agent</category>
      <pubDate>Fri, 07 Nov 2025 09:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Plan-and-Execute 框架：面向复杂任务的层次化推理与行动架构</p>
</blockquote>
<h2> 1. 引言</h2>
<p>随着语言模型推理能力与外部工具使用能力的增强，如何高效地解决<strong>长程、多步骤、复杂任务</strong>成为 AI Agent 的关键挑战。</p>
<p>传统的 <strong>Chain-of-Thought (CoT)</strong> 与 <strong>ReAct</strong> 框架虽能支持推理与行动的结合，但它们通常以<strong>逐步生成的方式</strong>执行任务，容易陷入“短视（myopic）”问题——即模型缺乏全局规划能力，只能在局部推理层面决策。</p>
<p>基于此，就有了 <strong>Plan-and-Execute（计划–执行）框架</strong>，其核心逻辑是 <strong>“先全局规划，再分步执行，全程监控调整”</strong> —— 模仿人类处理复杂任务的模式（比如项目经理做项目计划、旅行博主规划跨城行程），先拆解出完整的任务步骤，再逐一执行，同时根据执行结果动态优化计划，避免 “边想边做” 导致的返工或偏离目标。</p>
<h2> 2. 核心思想</h2>
<p>Plan-and-Execute 的基本理念是：</p>
<blockquote>
<p><strong>让语言模型先“想清楚要做什么”，再“逐步去做”。</strong></p>
</blockquote>
<h3> 2.1 定义</h3>
<p>Plan-and-Execute（简称 “P&amp;E”）是一种 “目标驱动 + 规划先行” 的 Agent 认知架构，核心是将复杂任务拆解为 “可执行的子步骤（计划）”，再逐个执行子步骤，同时监控执行结果，若出现偏差则修正计划，直至完成整体目标。</p>
<h3> 2.2 子系统</h3>
<p>在该框架中，模型被划分为两个协作子系统：</p>
<ol>
<li><strong>Planner（规划器）</strong> —— 负责全局任务分解与阶段性目标设定；</li>
<li><strong>Executor（执行器）</strong> —— 负责逐步执行具体步骤，并根据反馈调整局部行为。</li>
</ol>
<p>相比 ReAct 的“边想边做”模式，Plan-and-Execute 更接近人类在处理复杂任务时的思维方式：</p>
<h3> 2.3 示例说明</h3>
<p>还是以上一篇ReAct中的示例进行扩展说明：<code>完成 “建筑项目跨区域材料调度”（目标：把北京项目的剩余 100 吨钢材，5 天内运到天津项目，预算 10 万元）</code></p>
<p>对于P&amp;E框架，其执行步骤如下：</p>
<ol>
<li>先规划（Plan）：拆分子步骤→
<ul>
<li>① 确认北京项目钢材库存及规格；</li>
<li>② 联系合规物流商报价；</li>
<li>③ 对比物流方案（成本、时效）；</li>
<li>④ 办理材料运输备案；</li>
<li>⑤ 安排装车运输；</li>
<li>⑥ 天津项目验收；</li>
</ul>
</li>
<li>再执行（Execute）：按步骤逐一落地，比如先调用 “库存工具” 确认钢材，再调用 “物流商工具” 报价；</li>
<li>动态调整：若执行中发现 “某物流商报价超预算”，则回到规划环节，补充 “筛选低价物流商” 子步骤，修正后继续执行。</li>
</ol>
<h2> 3. 框架结构</h2>
<h3> 3.1 流程概览</h3>
<p>Plan-and-Execute 框架的核心流程如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实践中，这两阶段通常由同一个语言模型（或多个模型）协作完成：</p>
<ul>
<li><strong>Planner</strong>：生成多步任务计划，明确每个子任务的目标；</li>
<li><strong>Executor</strong>：逐步执行每个子任务，可调用工具或环境；</li>
<li><strong>Evaluator（可选）</strong>：在执行后评估结果质量，并决定是否重新规划。</li>
</ul>
<h3> 3.2 示例</h3>
<p>假设目标：“为某地铁项目采购3类材料（1000吨HRB400E钢筋、500立方米C30混凝土、200套消防设备），要求20天内全部送达工地，预算800万元，需符合地铁工程质量标准”</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>具体操作（Agent 执行）</th>
</tr>
</thead>
<tbody>
<tr>
<td>① 目标解析（Target Parsing）</td>
<td>拆解目标关键约束：材料类型（3类）、数量、时效（20天）、预算（800万）、质量标准（地铁级）→ 明确“不可妥协条件”（质量、时效）和“可调整条件”（预算浮动5%）</td>
</tr>
<tr>
<td>② 全局规划（Plan Generation）</td>
<td>生成详细子步骤（按逻辑顺序）：<br>1. 校验3类材料的地铁级质量标准参数；<br>2. 筛选符合质量标准的供应商（每类材料≥3家）；<br>3. 向供应商询价，对比报价是否在预算内；<br>4. 确认供应商交货周期（≤20天）；<br>5. 选择最优供应商（质量+价格+时效平衡）；<br>6. 签订采购合同；<br>7. 安排分批次物流运输；<br>8. 工地验收材料（核对质量+数量）</td>
</tr>
<tr>
<td>③ 分步执行（Plan Execution）</td>
<td>按子步骤调用工具执行：<br>- 步骤1：调用“建筑质量标准工具”，获取地铁级材料参数；<br>- 步骤2：调用“供应商筛选工具”，输入参数筛选供应商；<br>- 步骤3：调用“报价工具”，向6家供应商询价；<br>（每执行完一个子步骤，记录结果）</td>
</tr>
<tr>
<td>④ 监控反馈（Monitoring &amp; Feedback）</td>
<td>检查执行结果是否符合计划要求：<br>- 发现“混凝土供应商报价超预算10%”（偏离预算约束）；<br>- 发现“消防设备供应商交货周期25天”（偏离时效约束）；<br>- 整理偏差：2个子步骤未达标，需修正</td>
</tr>
<tr>
<td>⑤ 计划修正（Plan Revision）</td>
<td>基于偏差调整计划：<br>1. 新增“混凝土供应商二次筛选”（要求报价≤预算上限）；<br>2. 新增“消防设备供应商谈判”（要求交货周期≤20天，否则更换）；<br>3. 调整步骤顺序：先谈判消防设备，再二次筛选混凝土供应商；<br>→ 修正后回到“分步执行”环节，继续推进</td>
</tr>
</tbody>
</table>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种结构清晰地展示了规划与执行的分工：Planner 负责构思路线，Executor 负责落实行动。</p>
<h3> 3.3 P&amp;E关键要素</h3>
<p>要让 P&amp;E 框架跑通，Agent 必须具备4个核心能力，对应4个关键组件：</p>
<ul>
<li>① 目标解析能力：能从模糊需求中提取“关键约束”（如质量、时效、预算）和“可调整空间”，避免规划方向跑偏（比如用户没说质量标准，Agent 需自动补充“符合项目所属行业标准”）；</li>
<li>② 规划生成能力：能拆解“颗粒度合适”的子步骤（既不能太粗，比如只拆“选供应商→采购→验收”，也不能太细，比如拆“打开供应商工具→输入参数→点击查询”），且子步骤符合逻辑顺序（如“验收”必须在“运输”之后）；</li>
<li>③ 执行调度能力：能按计划顺序调用工具，处理“并行步骤”（如钢筋和消防设备的询价可同时进行）和“依赖步骤”（如“签订合同”必须在“询价对比”之后）；</li>
<li>④ 监控修正能力：能识别“执行偏差”（如超预算、超时效），并判断是“调整子步骤”（如二次筛选供应商）还是“重新规划”（如预算严重不足，需和用户协商调整目标）。</li>
</ul>
<h2> 4. 与 ReAct 的对比</h2>
<p>P&amp;E 和 ReAct 都属于 Agent 推理框架，但适用场景完全不同，对比清晰：</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>ReAct(推理-行动)</th>
<th>Plan-and-Execute(规划-执行)</th>
</tr>
</thead>
<tbody>
<tr>
<td>推理方式</td>
<td>推理与行动交替进行</td>
<td>规划与执行分阶段进行</td>
</tr>
<tr>
<td>计划优先级</td>
<td>执行是核心，规划服务于单次执行</td>
<td>规划是核心，执行围绕规划展开</td>
</tr>
<tr>
<td>决策粒度</td>
<td>细粒度、即时决策</td>
<td>粗粒度、全局规划</td>
</tr>
<tr>
<td>步骤关联性</td>
<td>子步骤弱关联（比如查价格后可直接反馈，无需后续步骤）</td>
<td>子步骤强关联（比如 “备案” 必须在 “选物流商” 之后）</td>
</tr>
<tr>
<td>优势</td>
<td>灵活、动态响应环境</td>
<td>结构化、全局性强</td>
</tr>
<tr>
<td>局限</td>
<td>容易迷失方向、循环冗长</td>
<td>计划可能过于刚性，缺乏即时反应</td>
</tr>
<tr>
<td>适用任务</td>
<td>开放式问答、信息检索等简单、短流程、不确定性高的任务（查库存、查价格、物流跟踪）</td>
<td>长程任务、复杂流程、多阶段决策（跨项目调度、大型采购、项目管理）</td>
</tr>
</tbody>
</table>
<p>从本质上看，<strong>ReAct 偏向“思考中的即时行动”，而 Plan-and-Execute 偏向“先计划再执行的理性决策”</strong>。</p>
<p>两者可视为 AI Agent 推理架构的两种互补策略。</p>
<h2> 5. 优势分析</h2>
<p>Plan-and-Execute 的主要优势体现在以下几个方面：</p>
<table>
<thead>
<tr>
<th>优势</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>全局可控性强</strong></td>
<td>通过显式规划步骤，模型行为更可预测、更易解释。</td>
</tr>
<tr>
<td><strong>层次化推理能力</strong></td>
<td>模型能在不同抽象层次上思考任务，从全局到局部逐层细化。</td>
</tr>
<tr>
<td><strong>可复用性高</strong></td>
<td>已生成的计划可复用或共享，便于多Agent协作或任务迁移。</td>
</tr>
<tr>
<td><strong>易于监控与调试</strong></td>
<td>Planner 与 Executor 的独立性使得错误定位更清晰。</td>
</tr>
</tbody>
</table>
<h2> 6. 局限与改进方向</h2>
<p>尽管 Plan-and-Execute 提升了任务结构化程度，但也存在一些局限性：</p>
<table>
<thead>
<tr>
<th>局限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>计划僵化</strong></td>
<td>若初始计划不合理，后续执行可能陷入错误路径。</td>
</tr>
<tr>
<td><strong>缺乏动态适应能力</strong></td>
<td>对突发情况或环境变化响应较慢。</td>
</tr>
<tr>
<td><strong>计算成本高</strong></td>
<td>需要额外生成和维护计划文本。</td>
</tr>
<tr>
<td><strong>依赖任务分解质量</strong></td>
<td>Planner 的规划能力直接决定整体表现。</td>
</tr>
</tbody>
</table>
<p>为缓解这些问题，研究者提出了一系列改进版本，例如：</p>
<ul>
<li><strong>Reflexion + Plan-and-Execute</strong>：在执行后引入反思机制；</li>
<li><strong>Hierarchical Agent（分层智能体）</strong>：多层 Planner–Executor 架构；</li>
<li><strong>Adaptive Planning</strong>：执行阶段可根据观察结果动态更新计划。</li>
</ul>
<p>这些方法进一步增强了系统的鲁棒性与灵活性。</p>
<h2> 7. 应用与实践</h2>
<p>按“组件搭建→流程设计→优化迭代”三步走，每个步骤都要结合业务场景细化</p>
<h3> 7.1 第一步：搭建 Agent 的 P&amp;E 核心组件</h3>
<p>Agent 要支持 P&amp;E，必须包含5个核心模块（对应 P&amp;E 闭环流程）：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>功能描述</th>
<th>技术实现建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>目标解析模块（Target Parser）</td>
<td>提取用户需求中的“核心目标+约束条件+可调整空间”，生成标准化目标（如“采购1000吨钢筋，约束：地铁级质量、20天达、预算≤400万”）</td>
<td>基于大模型（如GPT-4、Gemini），通过提示工程引导模型识别约束（比如“从需求中提取材料类型、数量、时效、预算、质量标准”），结合行业数据库补充默认约束（如无质量标准则默认“项目所属行业国标”）</td>
</tr>
<tr>
<td>规划器（Planner）</td>
<td>基于标准化目标，生成“逻辑连贯、颗粒度合适”的子步骤计划，支持“并行/依赖步骤”标记（如“钢筋询价”和“消防设备询价”可并行，“签合同”依赖“询价对比”）</td>
<td>用大模型+少样本示例（比如给“3个采购计划示例”），引导模型生成结构化计划（如JSON格式的子步骤清单，包含“步骤ID、名称、依赖步骤、执行工具、预期结果”）</td>
</tr>
<tr>
<td>执行器（Executor）</td>
<td>按计划顺序调用工具执行子步骤，支持“并行步骤同步执行”“依赖步骤串行执行”，记录每个步骤的实际结果</td>
<td>搭建工具调度中心，管理工具调用优先级（如“验收步骤”优先级高于“询价步骤”），用函数调用（Function Call）对接工具，返回结构化执行结果（如“询价结果：供应商A报价3800元/吨，交货期15天”）</td>
</tr>
<tr>
<td>监控器（Monitor）</td>
<td>对比“执行结果”与“计划预期结果”，识别偏差（如“报价3800元/吨＞预算上限3700元/吨”“交货期15天≤预期20天”），标记偏差类型（预算偏差、时效偏差、质量偏差）</td>
<td>设定偏差阈值（如预算偏差≥5%触发警报），用规则引擎+大模型判断偏差影响（如“预算超10%需重新规划，超3%可谈判”）</td>
</tr>
<tr>
<td>修正器（Reviser）</td>
<td>基于偏差类型，调整计划：① 轻微偏差（如报价超3%）→ 新增子步骤（如“与供应商谈判降价”）；② 严重偏差（如无符合时效的供应商）→ 重新生成全局计划；③ 无法修正（如预算严重不足）→ 反馈用户</td>
<td>用大模型+行业规则，生成修正方案（如“新增谈判步骤，目标降价至3700元/吨以下，若谈判失败则二次筛选供应商”），修正后更新计划清单</td>
</tr>
</tbody>
</table>
<h3> 7.2 第二步：设计 P&amp;E 闭环执行流程（以“跨项目材料调度Agent”为例）</h3>
<h4> （1）初始化：明确目标与资源</h4>
<ul>
<li>目标：用户输入“将北京项目剩余的80吨钢筋、50吨水泥，20天内调度至天津滨海新区项目，总成本≤15万元，钢筋需符合HRB400E标准，水泥需符合P.O42.5标准”；</li>
<li>注册工具：库存盘点工具、供应商资质校验工具、物流报价工具、合规备案工具、运输跟踪工具、验收工具。</li>
</ul>
<h4> （2）闭环执行流程（可视化）</h4>
<figure><img src="/imgs/column/springai/ag4-01.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>
<p>规划器生成的“子步骤计划”示例（JSON格式）：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>监控器识别偏差示例：
“步骤3执行结果：2家物流商报价，分别为15.8万元、16.5万元，均超预算（15万元），偏差类型：预算偏差，偏差率：5.3%（轻微偏差）”</p>
</li>
<li>
<p>修正器调整计划示例：
“新增步骤4：与报价15.8万元的物流商谈判，目标降价至15万元以下；若谈判失败，新增步骤5：筛选天津本地小型物流商补充报价”</p>
</li>
</ul>
<h4> （3）终止条件设计</h4>
<ul>
<li>成功终止：所有子步骤执行完成，满足核心目标（如“材料已送达天津项目，验收合格，总成本14.8万元，耗时18天”）；</li>
<li>失败终止：多次修正后仍无法满足核心约束（如“所有物流商报价均超18万元，无法压缩至15万元内，且无替代物流方案”），反馈用户并提供备选建议（如“延长运输时间至30天，可降低成本至14.5万元”）。</li>
</ul>
<h3> 7.3 第三步：优化 P&amp;E 执行效率</h3>
<p>P&amp;E 框架的落地难点是<code>规划太复杂、执行效率低、修正频繁</code>，需通过以下技巧优化：</p>
<ul>
<li>① 分层规划（Hierarchical Planning）：把复杂计划拆分为 *<em>主计划+子计划</em>
<ul>
<li>比如“跨项目调度主计划”包含“库存盘点、物流规划、验收”3个主步骤</li>
<li>每个主步骤再拆子计划（如“物流规划”拆“询价、谈判、签约”），避免计划过于冗长；</li>
</ul>
</li>
<li>② 计划压缩（Plan Compression）：只保留<strong>关键步骤</strong>和<strong>约束条件</strong>，忽略细节（如无需在计划中写<code>打开物流工具→输入参数</code>，只需写<code>调用物流工具询价</code>），减少大模型上下文压力；</li>
<li>③ 动态资源分配：执行器支持<strong>并行步骤同步执行</strong>（如同时盘点钢筋和水泥库存），缩短整体周期；对<strong>关键步骤</strong>（如合规备案）分配更多资源（如优先调用工具、超时重试3次）；</li>
<li>④ 少样本规划引导：在规划器的提示中，加入<strong>行业相关的规划示例</strong>（如“建筑材料调度的标准步骤清单”），让模型生成的计划更贴合业务实际，减少修正次数；</li>
<li>⑤ 偏差阈值动态调整：根据任务阶段调整偏差阈值（如前期询价阶段，预算偏差阈值设为10%；后期签约阶段，阈值设为3%），避免过度修正影响效率。</li>
</ul>
<h2> 8. 总结</h2>
<p><strong>Plan-and-Execute 框架</strong> 是一种面向复杂任务的层次化推理与行动机制。</p>
<p>它通过“先规划、再执行”的解耦结构，使模型能够在全局视角下进行任务分解与多阶段执行，从而在可解释性、稳定性和任务规划性上优于 ReAct 等即时推理框架。</p>
<blockquote>
<p><strong>一句话总结：</strong>
<strong>Plan-and-Execute 是让 AI Agent 从“即兴思考者”进化为“有计划的行动者”的关键框架。</strong></p>
</blockquote>
<p>最后再以一张图，来重温一下P&amp;E</p>
<figure><img src="/imgs/column/springai/ag3-03.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/ag4-01.webp" type="image/webp"/>
    </item>
    <item>
      <title>Agent篇</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Agent篇</source>
      <description>主要介绍AI Agent相关的知识点，包括相关技术栈，应用开发等</description>
      <pubDate>Fri, 07 Nov 2025 06:15:53 GMT</pubDate>
      <content:encoded><![CDATA[<p>主要介绍AI Agent相关的知识点，包括相关技术栈，应用开发等</p>
]]></content:encoded>
    </item>
    <item>
      <title>14.创建一个Langgraph4j实例工程</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/14.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AALanggraph4j%E5%AE%9E%E4%BE%8B%E5%B7%A5%E7%A8%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/14.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AALanggraph4j%E5%AE%9E%E4%BE%8B%E5%B7%A5%E7%A8%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">14.创建一个Langgraph4j实例工程</source>
      <description>14.创建一个Langgraph4j实例工程 沿用阿里的智能体定义，我们将基于SpringAI ChatClient开发的AI应用叫做单智能体应用；对于更复杂的应用场景，比如需要多个工具辅助工作，存在工作流切换的场景（举一个例子：输入一段评价，判断是好评还是差评，如果是好评，则自动回复多谢好评；如果是差评，则提取关键信息，将评价信息转发给人工客服，进行后续的售后维护等）称为多智能体应用 对于多智能体应用，使用python开发的小伙伴，更常接触的是LangGraph；对于java的生态下，目前也有两个替代的选择项</description>
      <category>SpringAI</category>
      <pubDate>Tue, 12 Aug 2025 17:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 14.创建一个Langgraph4j实例工程</h1>
<p>沿用阿里的智能体定义，我们将基于<code>SpringAI ChatClient</code>开发的AI应用叫做单智能体应用；对于更复杂的应用场景，比如需要多个工具辅助工作，存在工作流切换的场景（举一个例子：输入一段评价，判断是好评还是差评，如果是好评，则自动回复多谢好评；如果是差评，则提取关键信息，将评价信息转发给人工客服，进行后续的售后维护等）称为多智能体应用</p>
<p>对于多智能体应用，使用python开发的小伙伴，更常接触的是<code>LangGraph</code>；对于java的生态下，目前也有两个替代的选择项</p>
<ul>
<li><a href="https://github.com/langgraph4j/langgraph4j" target="_blank" rel="noopener noreferrer">LangGraphJ</a></li>
<li><a href="https://java2ai.com/docs/1.0.0.2/get-started/agent/" target="_blank" rel="noopener noreferrer">阿里智能体</a></li>
</ul>
<p>接下来我们来体验一下如何使用<code>LangGraph4J</code>来进行多智能体的开发</p>
<h2> 一、项目创建</h2>
<h3> 1. 创建一个SpringAI项目</h3>
<p>创建一个SpringAI项目，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 2. 添加Langgraph4j依赖</h3>
<p>我们这里以智普大模型作为底层的LLM，因此对应的依赖除了langgraph4j之外就是智普的starter</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 参数配置</h3>
<p>在配置文件中 <code>application.yml</code>，设置大模型的访问密钥</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 创建工具</h3>
<p>我们这里创建一个工具类，内部提供两个工具，分别获取当前的时间和天气</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 创建智能体</h3>
<p>我们直接沿用官方的demo示例，来创建一个采用<code>langGraph4j</code>实现的基于智普大模型的智能体</p>
<figure><img src="/imgs/column/springai/14-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 测试验证</h3>
<p>在上面的Controller中，定义一个访问端点，实现智能体的访问</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/14-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的输出也可以看出，大模型有四次的工具调用，一次是获取北京当前时间，一次是获取北京当前天气，一次是获取伦敦当前时间，一次是获取伦敦当前天气</p>
<p>直接使用<code>langGraph4j</code>实现多轮对话，虽然效果是实现了，从直观感觉上和SpringAI的ChatClient好像没有太大的差别</p>
<p>对<code>langGraph4j</code>不太了解的小伙伴，可能会有很多疑问，工作流体现在什么地方呢，条件决策又该如何使用呢？这个框架是怎么工作的呢？又该如何使用它来开发Agent呢？</p>
<h2> 二、总结</h2>
<p><code>LangGraph4j</code> 是一个 Java 库，用于构建基于大型语言模型 (LLM) 的有状态多代理应用程序。它受 <code>Python</code> 库 <code>LangGraph</code> 的启发，旨在与 <code>Langchain4j</code> 和 <code>Spring AI</code> 等流行的 <code>Java LLM</code> 框架无缝协作。</p>
<p>LangGraph4j 的核心功能是定义循环图，使不同的组件（代理、工具或自定义逻辑）能够以有状态的方式进行交互</p>
<p>本文只能算是初步看了一眼<code>LangGraph4j</code>，演示了如何创建一个智能体开发的项目，接下来我们将逐渐深入探究一下这个框架的使用理念</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects/A05-agent-langgraph-simple" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/14-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>01.从0到1创建一个基于天气的旅游美食推荐智能体</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%BA%94%E7%94%A8%E7%AF%87/D01.%E4%BB%8E0%E5%88%B01%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E5%A4%A9%E6%B0%94%E7%9A%84%E6%97%85%E6%B8%B8%E7%BE%8E%E9%A3%9F%E6%8E%A8%E8%8D%90%E6%99%BA%E8%83%BD%E4%BD%93.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%BA%94%E7%94%A8%E7%AF%87/D01.%E4%BB%8E0%E5%88%B01%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E5%A4%A9%E6%B0%94%E7%9A%84%E6%97%85%E6%B8%B8%E7%BE%8E%E9%A3%9F%E6%8E%A8%E8%8D%90%E6%99%BA%E8%83%BD%E4%BD%93.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.从0到1创建一个基于天气的旅游美食推荐智能体</source>
      <description>01.从0到1创建一个基于天气的旅游美食推荐智能体 本文将演示如何借助LangGraph4j + SpringAI来开发一个完整的智能体应用，实现用户传入地址、大模型通过Function Calling来获取地址天气，调用大模型的旅游项目推荐能力、美食推荐能力，给用返回一个旅游攻略 一、项目创建 1. 工程创建 首先我们需要创建一个 LangGraph4j + SpringAI的项目，对这块不熟悉的小伙伴，请参考 创建一个Langgraph4j示例工程</description>
      <category>SpringAI</category>
      <pubDate>Wed, 13 Aug 2025 10:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 01.从0到1创建一个基于天气的旅游美食推荐智能体</h1>
<p>本文将演示如何借助LangGraph4j + SpringAI来开发一个完整的智能体应用，实现用户传入地址、大模型通过Function Calling来获取地址天气，调用大模型的旅游项目推荐能力、美食推荐能力，给用返回一个旅游攻略</p>
<h2> 一、项目创建</h2>
<h3> 1. 工程创建</h3>
<p>首先我们需要创建一个 LangGraph4j + SpringAI的项目，对这块不熟悉的小伙伴，请参考 <a href="../%E5%9F%BA%E7%A1%80%E7%AF%87/14.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AALanggraph4j%E5%AE%9E%E4%BE%8B%E5%B7%A5%E7%A8%8B">创建一个Langgraph4j示例工程</a></p>
<h3> 2. 核心依赖</h3>
<p>本工程主要使用框架为 <code>SpringAI1.0.1</code> + <code>LangGraph4j1.6.0-rc4</code> + <code>SpringBoot3.5.4</code></p>
<p>对应的大模型为： <code>zhipu</code>，通过SpringMVC提供访问接口</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 配置文件</h3>
<p>我们在配置文件<code>application.yml</code>中配置大模型密钥，使用其他大模型的小伙伴，请自行替换</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：大模型的选择时，需要判断是否支持FunctionCalling，如果不支持，则会影响本项目的实际运行效果</p>
<p>我们的密钥以启动参数的方式传递，方便测试（当然也可以直接写入配置文件、或者系统环境变量，大家按照自己的喜好即可）</p>
<h2> 二、智能体开发</h2>
<h3> 1. 核心功能描述</h3>
<p>智能体的主要功能为：</p>
<ol>
<li>用户传入地址</li>
<li>设计一个WeatherAgent，用于获取给定地方的实时天气情况</li>
<li>若不需要进行旅游推荐，则直接返回</li>
<li>若需要进行旅游推荐
<ul>
<li>调用 TravelAgent，获取给定地址的附近旅游项目推荐</li>
<li>根据选定的旅游项目，调用 FoodAgent，获取给定地址的附近美食推荐</li>
</ul>
</li>
<li>将上面的结果进行整合，以博文的方式返回给用户</li>
</ol>
<figure><img src="/imgs/column/springai/D01-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 实现通用的AgentService</h3>
<p>上面的几个Agent都需要与大模型进行交互，因此我们这里可以抽象出一个通用的AgentService，用于处理Agent与大模型的交互</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为大模型本身是无法获取天气信息的，因此我们这里使用FunctionCalling的方式，给大家装配上天气查询的能力（当然这里也可以直接使用天气相关的McpServer）</p>
<p>我们这里简单的实现一个 WeatherTools 来模拟天气的查询（真实场景中，可以实现第三方天气服务查询API）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 定义TravelState存储上下文</h3>
<p>我们这里定义一个 <code>TravelState</code> 继承自 <code>AgentState</code> 来实现多智能体之间的数据共享，由于我们这里存在4个智能体，我们为每个智能体的返回都定义一个对应的参数进行承接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面定义了五个常量，其中 <code>INPUT</code> 为最开始的输入参数， <code>WEATHER</code> 为 WeatherAgent执行后的返回的天气信息， <code>TRAVEL</code> 为 TravelRecommendAgent 执行后返回推荐游玩项目， <code>FOOD</code> 为 FoodRecommendAgent 执行后返回推荐美食， <code>BLOG</code> 为 XhsBlogGenerateAgent 执行后汇总生成的小红书风格的博文内容</p>
<p>不同的Agent返回的数据内容并不相同，可以是基本类型、字符串，也可以是集合、Java POJO对象，由于<code>LangGraphJ</code>自己实现了一套序列化协议，因此我们这里先提供一个JsonSerializer，用于非简单的对象的序列化处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 实现天气智能体 WeatherAgent</h3>
<p>接下来我们实现第一个智能体，用于获取给定地方的天气</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的整体实现比较简单，核心的在于方法 <code>callWeatherAgent</code>，我们会将它包装为<code>LangGraph4J</code>的Node，这个方法你可以理解为 <code>NodeAction</code> 的实现，对应的使用层Node的注册如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的，我们可以在 <code>TravelState</code> 中，提供一个直接获取天气的方法，返回的类型为String字符串</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 实现推荐项目智能体 TravelRecommendAgent</h3>
<p>接下来我们实现第二个智能体，用于推荐给定地点的游玩项目，具体的实现方式可以参照上面天气智能体的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在旅游项目推荐的实现中，使用了前面返回的天气信息，作为提示词的输入，将大模型的返回结果保存到State中给后续的节点使用；同样的，我们可以在 <code>TravelState</code> 中，提供获取推荐项目的方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 实现美食智能体 FoodAgent</h3>
<p>接下来我们实现第三个智能体，基于旅游项目的美食推荐（如果条件允许，当然是推荐借助百度/高德地图的MCPServer来实现），具体的实现方式可以参照上面天气智能体的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个实现，相比于前面的旅游项目Agent的实现会更复杂一点，利用了前面返回的天气和旅游项目，借助了SpringAI的提示词模板 + 结构化输出来实现美食推荐，我们可以在 <code>TravelState</code> 中，提供获取美食推荐列表的方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7. 实现小红书博文智能体 XhsBlogGenerateAgent</h3>
<p>最后我们实现第四个智能体，基于美食推荐，生成小红书的博文；我们这里做一个分支处理，如果是直接由WeatherAgent转过来的，那么我们作为一个天气预报的Agent；如果是由FoodAgent转过来的，那么我们作为一个小红书的旅游美食推荐Agent</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两个不同的分支，返回的内容稍有区别，定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的，我们可以在 <code>TravelState</code> 中，提供获取最终博文数据的方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8. TravelState序列化</h3>
<p>当上面四个智能体实现完毕之后，<code>TravelState</code>中存储的上下文也都可以确定了，接下来我们定义它的序列化方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9. 实现多智能体调用的 AgentExecutor</h3>
<p>上面的智能体实现之后，我们接下来需要实现 <code>AgentExecutor</code>，在这里定义<code>StateGraph</code>，执行多智能体的调用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的核心在与<code>GraphBuilder.build()</code>的实现，在这个实现中，定义了AgentState、Node、Edge、ConditionEdge，通过他们构建了一个有向图，我们可以通过下面这个方法打印下这个多智能体执行的PantUML</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-plantuml line-numbers-mode" data-ext="plantuml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/D01-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 10. 测试验证</h3>
<p>接下来我们实现一个端点，用于用户的推荐交互</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>小红书生成风格博文生成（传参中包含推荐二字）:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/D01-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>天气预报的信息生成（传参中不包含推荐二字）</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/D01-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、小结</h2>
<p>本文通过逐步拆解的方式，给大家演示了如何借助 <code>SpringAI</code> + <code>LangGraphJ</code> + <code>智普大模型</code> 从0到1创建一个多智能体应用，虽然现在的效果还一般，这个主要还是我的提示词和响应还不够优雅，整个业务的流程还是完整流畅的。有兴趣的小伙伴也可以实际的体验一下</p>
<p>上文虽然实现步骤相对清晰，但是内中原理和知识点，还是比较多的，对于上面实现的步骤有疑问的小伙伴，可以仔细阅读一下我的 <a href="https://hhui.top/tutorial/spring/springai/" target="_blank" rel="noopener noreferrer">SpringAI系列博文</a> 相信能解决你的大部分疑问</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/app-projects/D01-travel-recommend-agent" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/D01-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>04.使用LangGraph4J实现多轮对话</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A04.%E4%BD%BF%E7%94%A8LangGraph4J%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BD%AE%E5%AF%B9%E8%AF%9D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A04.%E4%BD%BF%E7%94%A8LangGraph4J%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BD%AE%E5%AF%B9%E8%AF%9D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">04.使用LangGraph4J实现多轮对话</source>
      <description>04.使用LangGraph4J实现多轮对话 之前介绍的多轮对话，上下文存储主要是SpringAI提供的能力支持；接下来我们看一下，在agent开发时推荐使用的框架LangGraphJ，如何实现多轮对话 一、LangGraphJ实现多轮对话 1. 创建项目 创建一个SpringAI项目，基本流程同 创建一个SpringAI-Demo工程</description>
      <category>SpringAI</category>
      <pubDate>Mon, 11 Aug 2025 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 04.使用LangGraph4J实现多轮对话</h1>
<p>之前介绍的多轮对话，上下文存储主要是SpringAI提供的能力支持；接下来我们看一下，在agent开发时推荐使用的框架LangGraphJ，如何实现多轮对话</p>
<h2> 一、LangGraphJ实现多轮对话</h2>
<h3> 1. 创建项目</h3>
<p>创建一个SpringAI项目，基本流程同  <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 2. 添加依赖</h3>
<p>在pom.xml中添加关键依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们这里直接依赖的是 <code>langgraph4j-springai-agentexecutor</code> 模块，该模块提供了基于SpringAI的AgentExecutor实现；使用的版本为当前(25/08/08)的最新版本，有需要的小伙伴根据实际情况进行调整</p>
<h3> 3. 配置</h3>
<p>在配置文件 <code>application.yml</code> 文件中，添加大模型配置，我们这里依然是使用ZhipuAI的模型进行演示</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. MemAgent实现</h3>
<p>实现一个MemAgent，用于获取对话的<code>CompileGraph</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现， <code>MemorySaver</code> 是一个 <code>BaseCheckpointSaver</code> 的实现，用于实现 Checkpoint 的保存，对话历史保存到jvm内存中；使用<code>org.bsc.langgraph4j.RunnableConfig.threadId</code>来实现不同身份的会话隔离</p>
<h3> 5. 多轮对话端点</h3>
<p>提供一个聊天接口，第一个参数为用户标识，用于区分用户的聊天记录</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/A04-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、小结</h2>
<p>本文演示了通过 LangGraphJ 实现多轮对话的实现，虽然效果是实现了，但是对LangGraphJ不太了解的小伙伴，估计会有很多疑问，这个框架是怎么工作的呢？又该如何使用它来开发Agent呢？</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects/A04-memory-agent-langgraph" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/A04-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>05.使用LangGraph4J实现Agent路由选择</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A05.%E4%BD%BF%E7%94%A8LangGraph4J%E5%AE%9E%E7%8E%B0Agent%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A05.%E4%BD%BF%E7%94%A8LangGraph4J%E5%AE%9E%E7%8E%B0Agent%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">05.使用LangGraph4J实现Agent路由选择</source>
      <description>05.使用LangGraph4J实现Agent路由选择 在 创建一个Langgraph4j示例工程 这一篇文章中，我们介绍了如何创建一个 LangGraph4j 的示例工程； 在上文中介绍到 LangGraph4j 时，就提到了它有一个重要的特性，就是可以定义循环图，使不同的组件（代理、工具或自定义逻辑）能够以有状态的方式进行交互</description>
      <category>SpringAI</category>
      <pubDate>Tue, 12 Aug 2025 11:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 05.使用LangGraph4J实现Agent路由选择</h1>
<p>在 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/14.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AALanggraph4j%E5%AE%9E%E4%BE%8B%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个Langgraph4j示例工程</a> 这一篇文章中，我们介绍了如何创建一个 LangGraph4j 的示例工程；</p>
<p>在上文中介绍到 <code>LangGraph4j</code> 时，就提到了它有一个重要的特性，就是可以定义循环图，使不同的组件（代理、工具或自定义逻辑）能够以有状态的方式进行交互</p>
<p>接下来我们来实际感受一下，上面这个重要的特性是如何表现的</p>
<h2> 一、项目创建</h2>
<h3> 1. 创建LangGraph4j + SpringAI项目</h3>
<p>具体的创建过程，与上文一致，有兴趣的小伙伴请关注 <a href="../%E5%9F%BA%E7%A1%80%E7%AF%87/14.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AALanggraph4j%E5%AE%9E%E4%BE%8B%E5%B7%A5%E7%A8%8B">创建一个Langgraph4j示例工程</a></p>
<h3> 2. 配置大模型密钥</h3>
<p>这里依然使用智谱的免费大模型，使用其他的模型时，请自行替换<code>start</code>和下面的配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、创建一个地点的旅游推荐Agent</h2>
<h3> 1. 工作流程</h3>
<p>在这里，我们设计一个简单的业务流程，开发一个旅游推荐的Agent，在这个agent中，我们需要结合旅游地点的天气，来选择不同的推荐项目</p>
<figure><img src="/imgs/column/springai/A05-1.webp" alt="由LangGraph4j生成的流程图" tabindex="0" loading="lazy"><figcaption>由LangGraph4j生成的流程图</figcaption></figure>
<p>注意上面这个流程图，虽然它是事后由<code>LangGraph4j</code>生成的，实际也是呈现我们的旅游推荐Agent的核心工作流程</p>
<ol>
<li>Weather: 根据传入的地方，获取当前的天气</li>
<li>Router: 作为一个路由节点（实际上啥也没干）
<ul>
<li>当天气为晴天时，路由到 outdoor，推荐一些室外的旅游项目</li>
<li>当天气为雨天时，路由到 indoor，推荐一些室内的旅游项目</li>
<li>当天气为其他情况时，路由到 default，直接结束</li>
</ul>
</li>
</ol>
<h3> 2. 基本概念科普</h3>
<p>在<code>LangGraph</code>中，有几个核心的概念，我们现简单来看一下；后面的实现中，会针对性的实现这些</p>
<blockquote>
<p>以下内容，来自于: <a href="https://github.com/langgraph4j/langgraph4j" target="_blank" rel="noopener noreferrer">langgraph4j</a></p>
</blockquote>
<h4> AgentState</h4>
<p>AgentState（或其扩展类）表示图的共享状态。它本质上是一个映射 (<code>Map&lt;String, Object&gt;</code>)，会在各个节点之间传递。每个节点都可以读取此状态并返回更新。</p>
<ul>
<li><code>Schema</code>：状态的结构由“Schema”定义，它是一个 <code>Map&lt;String, Channel.Reducer&gt;</code> 类型的对象。Map 中的每个键都对应状态中的一个属性。</li>
<li><code>Channel.Reducer</code>：Reducer 定义了如何处理状态属性的更新。例如，新值可能会覆盖旧值，或者添加到现有值列表中。</li>
<li><code>Channel.Default&lt;T&gt;</code>：如果状态属性尚未设置，则为其提供默认值。</li>
<li><code>Channel.Appender&lt;T&gt;</code> <code>/</code> <code>MessageChannel.Appender&lt;M&gt;</code>：一种常见的 Reducer 类型，它将新值附加到与状态属性关联的列表中。这对于累积消息、工具调用或其他数据序列非常有用。MessageChannel.Appender 专为聊天消息而设计，还可以处理通过 ID 删除消息的操作。</li>
</ul>
<h4> Nodes</h4>
<p>节点是构成图的执行操作的基石。节点通常是一个函数（或一个实现 <code>NodeAction&lt;S&gt;</code> 或 <code>AsyncNodeAction&lt;S&gt;</code> 的类），它：</p>
<ul>
<li>接收当前 <code>AgentState</code> 作为输入。</li>
<li>执行某些计算（例如，调用 LLM、执行工具、运行自定义业务逻辑）。</li>
<li>返回一个表示状态更新的 <code>Map&lt;String, Object&gt;</code> 对象。这些更新随后会根据架构的 <code>Reducer</code> 应用于 <code>AgentState</code>。</li>
</ul>
<p>节点可以是同步的，也可以是异步的（CompletableFuture）。</p>
<h4> Edges</h4>
<p>边定义节点之间的控制流。</p>
<ul>
<li>普通边：从一个节点到另一个节点的无条件转换。节点 A 完成后，控制权始终传递给节点 B。您可以使用 <code>addEdge(sourceNodeName, destinationNodeName)</code> 定义普通边。</li>
<li>条件边：下一个节点根据当前 <code>AgentState</code> 动态确定。
<ul>
<li>源节点完成后，将执行 <code>EdgeAction&lt;S&gt;</code>（或 <code>AsyncEdgeAction&lt;S&gt;</code>）函数。</li>
<li>该函数接收当前状态并返回下一个要执行的节点的名称。</li>
<li>这允许分支逻辑（例如，如果代理决定使用某个工具，则转到<code>execute_tool</code>节点；否则，转到<code>respond_to_user</code>节点）。</li>
<li>条件边使用 <code>addConditionalEdges(...)</code> 定义。</li>
</ul>
</li>
<li>入口点：您还可以使用 <code>addConditionalEntryPoint(...)</code> 为图定义条件入口点。</li>
</ul>
<h4> Compilation</h4>
<p>在 <code>StateGraph</code> 中定义好所有节点和边后，可以使用 <code>compile()</code> 将其编译为 <code>CompiledGraph&lt;S extends AgentState&gt;</code>。</p>
<p>这个编译后的图是你的逻辑的不可变且可运行的表示。编译过程会验证图的结构（例如，检查是否存在孤立节点）。</p>
<h4> Checkpoints (Persistence)</h4>
<p><code>LangGraph4j</code> 允许您在任何步骤保存（检查点）图的状态。这在以下情况下非常有用：</p>
<ul>
<li>调试：检查各个点的状态以了解发生了什么。</li>
<li>恢复：将图恢复到之前的状态并继续执行。</li>
<li>长时间运行的进程：持久化长时间运行的代理交互的状态。您通常会使用 <code>CheckpointSaver</code> 实现（例如，使用 <code>MemorySaver</code> 进行内存存储，或者您也可以自己实现持久化存储）。</li>
</ul>
<h3> 3. Node实现</h3>
<p>从上面的流程图中我们也可以看出，这里定义了四个<code>Node</code>，接下来我们分别给于实现</p>
<p><strong>WeatherNode：用于获取地区的天气</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>RouterNode: 路由节点</strong></p>
<p>这个路由节点实际上啥也没干，不要也行，这里主要是用它打印了一下 WeatherNode 的输出</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>OutdoorNode: 室外推荐节点</strong></p>
<p>在这个节点中，我们使用大模型来推荐外出旅游的项目</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>IndoorNode: 室内推荐节点</strong></p>
<p>在这个节点中，我们使用大模型来推荐适合室内游玩的项目</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到这里，我们的四个节点已经定义完成，接下来进行节点的连接</p>
<h3> 4. 节点连接</h3>
<p>节点连接，就是将节点通过<code>addEdge</code>方法进行连接，这里我们连接了四个节点，并且定义了条件边，用于判断当前节点是否需要执行</p>
<p>首先实现路由的条件边判定</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后是完成完整的节点、边定义</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 输出PlantUML</h3>
<p>在上面的节点定义完成后，我们可以通过<code>graph.getGraph()</code>方法，将节点定义转换为PlantUML格式，方便我们查看节点定义</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们拿到上面的内容之后，可以在 <a href="https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa700001" target="_blank" rel="noopener noreferrer">在线plantuml工具</a> 中查看，会生成对应的流程图</p>
<figure><img src="/imgs/column/springai/A05-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. Agent封装</h3>
<p>接下来就是将上面的实现，封装为一个完整的，对外直接使用的Agent，源码可以在最后的项目链接中获取，类名为 <code>WeatherRecommendAgent</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7. 测试验证</h3>
<p>接下来我们进行实例验证，创建一个Controller，调用<code>WeatherRecommendAgent</code>的<code>recommendByLocation</code>方法，传入地区参数，返回结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/A05-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面实际的表现结果也可以看出和我们前面定义的流程图表现一致</p>
<h2> 三、小结</h2>
<p>本文通过实现一个简单的基于地点的天气实现旅游项目推荐，演示了多个单Agent联合组装成一个更复杂、功能更强大Agent示例。</p>
<p>在这个实现过程中，我们实现或者应用了<code>LangGraph4j</code> 框架中定义的Node、边（条件边）、State等，通过这些来生成了一个 <code>CompiledGraph</code>， 通过<code>CompiledGraph</code>来实现多Agent的组合</p>
<p>虽然这个项目实现了一个多Agent的组合，但是善于思考的我们，依然会有一些疑问</p>
<ul>
<li>这里使用的是默认的<code>AgentState</code>，内部是使用Map来传递共享参数，是否有更结构化的方式?</li>
<li><code>addConditionalEdges</code> 条件边定义的具体用法说明</li>
<li><code>GraphRepresentation</code> 节点定义的输出格式，是否可以自定义？ 是否可以结构化输出？</li>
<li>上面整体的实现更多的是借助<code>langgraph4j-core</code>，对于<code>langgraph4j-springai</code>是否会有更简单的使用姿势？</li>
</ul>
<p>接下来我们将努力尝试对上面这些问题进行逐步回答，有兴趣的小伙伴可以持续关注一波</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects/A04-memory-agent-langgraph" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/A05-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>SpringAI</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">SpringAI</source>
      <description>这里主要介绍的是SpringAI进行AI应用开发的系列教程 注意：在使用SpringAI时，对jdk和springboot有最低的版本要求 jdk: 17+ SpringBoot: 3+ 核心技术栈： SpringAI 1.0.1 LangGraph4J 本篇专栏将从四个系列出发 1.基础教程 主要介绍SpringAI的基础使用，对应的项目工程以 Sxx- 开头，通过这些实例，您将掌握SpringAI的基础知识（如提示词、上下文、架构化输出、tool calling, MCP, advise, ChatClient, 多模型等），并开始使用SpringAI进行大模型应用开发</description>
      <pubDate>Fri, 08 Aug 2025 02:51:24 GMT</pubDate>
      <content:encoded><![CDATA[<p>这里主要介绍的是SpringAI进行AI应用开发的系列教程</p>
<p>注意：在使用SpringAI时，对jdk和springboot有最低的版本要求</p>
<ul>
<li>jdk: 17+</li>
<li>SpringBoot: 3+</li>
</ul>
<p>核心技术栈：</p>
<ul>
<li>SpringAI 1.0.1</li>
<li>LangGraph4J</li>
</ul>
<p>本篇专栏将从四个系列出发</p>
<h3> 1.基础教程</h3>
<p>主要介绍SpringAI的基础使用，对应的项目工程以 <code>Sxx-</code> 开头，通过这些实例，您将掌握SpringAI的基础知识（如提示词、上下文、架构化输出、tool calling, MCP, advise, ChatClient, 多模型等），并开始使用SpringAI进行大模型应用开发</p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">01.创建一个SpringAI-Demo工程.md</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/02.%E6%8F%90%E7%A4%BA%E8%AF%8D%E8%AE%BE%E7%BD%AE.html" target="blank">02.提示词的使用.md</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/03.%E7%BB%93%E6%9E%84%E5%8C%96%E8%BF%94%E5%9B%9E.html" target="blank">03.结构化返回</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/04.%E8%81%8A%E5%A4%A9%E4%B8%8A%E4%B8%8B%E6%96%87.html" target="blank">04.聊天上下文实现多轮对话</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-4" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-4"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/05.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5.html" target="blank">05.自定义大模型接入</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-5" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-5"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/06.%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8FunctionCalling.html" target="blank">06.Function Tool工具调用</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-6" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-6"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/07.%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84McpServer.html" target="blank">07.实现一个简单的McpServer</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-7" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-7"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/08.MCP%20Server%E7%AE%80%E5%8D%95%E9%89%B4%E6%9D%83%E7%9A%84%E5%AE%9E%E7%8E%B0.html" target="blank">08.MCP Server简单鉴权的实现</a>]</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-8" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-8"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/09.ChatClient%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html" target="blank">09.ChatClient使用说明</a>]</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-9" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-9"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/10.Advisor%E5%AE%9E%E7%8E%B0SpringAI%E4%BA%A4%E4%BA%92%E5%A2%9E%E5%BC%BA.html" target="blank">10.Advisor实现SpringAI交互增强</a>]</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-10" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-10"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/11.%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%9E%8B.html" target="blank">11.图像模型-生成图片</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-11" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-11"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/12.%E5%A4%9A%E6%A8%A1%E6%80%81%E5%AE%9E%E7%8E%B0%E9%A3%9F%E6%9D%90%E5%9B%BE%E7%89%87%E5%8D%A1%E8%B7%AF%E9%87%8C%E8%AF%86%E5%88%AB%E7%A4%BA%E4%BE%8B.html" target="blank">12.多模态实现食材图片卡路里识别示例</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-12" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-12"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/13.%E6%94%AF%E6%8C%81MCP%20Client%E7%9A%84AI%E5%AF%B9%E8%AF%9D%E5%AE%9E%E7%8E%B0.html" target="blank">13.支持MCP Client的AI对话实现</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-13" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-13"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/14.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AALanggraph4j%E5%AE%9E%E4%BE%8B%E5%B7%A5%E7%A8%8B.html" target="blank">14.创建一个LangGraph4J示例工程</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-14" disabled="disabled"><label class="task-list-item-label" for="task-item-14"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/12.%E9%9F%B3%E9%A2%91%E6%A8%A1%E5%9E%8B.html" target="blank">音频模型</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-15" disabled="disabled"><label class="task-list-item-label" for="task-item-15"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/08.%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E7%94%9F%E6%88%90RAG.html" target="blank">检索增强生成RAG</a></label></li>
</ul>
<h3> 2.进阶教程</h3>
<p>进阶相关将主要介绍如何更好的使用SpringAI进行大模型应用开发，对应的实例工程都放在 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects" target="_blank" rel="noopener noreferrer">advance-projects</a> 下</p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-16" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-16"> <a href="/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A01.%E4%BD%BF%E7%94%A8MySql%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html" target="blank">01.使用MySql持久化对话历史</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-17" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-17"> <a href="/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A02.%E4%BD%BF%E7%94%A8H2%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html" target="blank">02.使用H2持久化对话历史</a>]</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-18" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-18"> <a href="/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A03.%E4%BD%BF%E7%94%A8Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html" target="blank">03.使用Redis持久化对话历史</a>]</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-19" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-19"> <a href="/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A04.%E4%BD%BF%E7%94%A8LangGraph4J%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BD%AE%E5%AF%B9%E8%AF%9D.html" target="blank">04.使用LangGraph4J实现多伦对话</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-20" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-20"> <a href="/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A05.%E4%BD%BF%E7%94%A8LangGraph4J%E5%AE%9E%E7%8E%B0Agent%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9.html" target="blank">05.使用LangGraph4J实现Agent路由选择</a></label></li>
</ul>
<h3> 3.应用教程</h3>
<p>以搭建完整可用的SpringAI应用为目的，演示SpringAI的业务边界和表现，对应项目工都放在 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/app-projects" target="_blank" rel="noopener noreferrer">app-projects</a> 下</p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-21" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-21"> <a href="/tutorial/spring/springai/%E5%BA%94%E7%94%A8%E7%AF%87/D01.%E4%BB%8E0%E5%88%B01%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E5%A4%A9%E6%B0%94%E7%9A%84%E6%97%85%E6%B8%B8%E7%BE%8E%E9%A3%9F%E6%8E%A8%E8%8D%90%E6%99%BA%E8%83%BD%E4%BD%93.html" target="blank">从0到1创建一个基于天气的旅游美食推荐智能体</a></label></li>
</ul>
<h3> 4.源码解读</h3>
<p>以源码的视角，介绍SpringAI的核心实现，对应的项目工程以 <code>Yxx-</code> 开头</p>
]]></content:encoded>
    </item>
    <item>
      <title>01.创建一个SpringAI的示例工程</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.创建一个SpringAI的示例工程</source>
      <description>01. 创建一个SpringAI的示例工程 下面介绍一下，如何快速借助官方的启动方式进行快速搭建一个用于体验SpringAI的示例工程 一、项目创建 https://spring.io/projects/spring-ai 借助Spring官方提供的快速创建项目功能，创建一个SpringBoot项目，点击下面的连接进入快速创建Spring-Ai项目</description>
      <category>SpringAI</category>
      <pubDate>Fri, 11 Jul 2025 08:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 01. 创建一个SpringAI的示例工程</h1>
<p>下面介绍一下，如何快速借助官方的启动方式进行快速搭建一个用于体验SpringAI的示例工程</p>
<h2> 一、项目创建</h2>
<blockquote>
<p><a href="https://spring.io/projects/spring-ai" target="_blank" rel="noopener noreferrer">https://spring.io/projects/spring-ai</a></p>
</blockquote>
<p>借助Spring官方提供的快速创建项目功能，创建一个SpringBoot项目，点击下面的连接进入快速创建Spring-Ai项目</p>
<ul>
<li><a href="https://start.spring.io/#!type=maven-project&amp;language=java&amp;platformVersion=3.3.4&amp;packaging=jar&amp;jvmVersion=17&amp;groupId=spring.ai.example&amp;artifactId=spring-ai-demo&amp;name=spring-ai-demo&amp;description=Spring%20AI%20%2C%20getting%20started%20example%2C%20using%20Open%20AI&amp;packageName=spring.ai.example.spring-ai-demo&amp;dependencies=web,spring-ai-openai" target="_blank" rel="noopener noreferrer">start.spring.io</a></li>
</ul>
<figure><img src="/imgs/column/springai/01-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在表格中，填写关键的信息（Group, Artifact, Name, Description, Version, PackageName）</p>
<h2> 二、项目初始化</h2>
<p>将上面生成的工程，解压之后，导入IDEA开发工具，你会得到一个空的Spring项目</p>
<figure><img src="/imgs/column/springai/01-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 1. 配置账号信息</h3>
<p>上面创建的默认是OpenAI(Chatgpt)的大模型访问，这个需要我们提前备好梯子和密钥，账号充值才能使用，只需要在<code>applicatin.properties</code>文件中添加密钥即可</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote>
<p>出于安全考虑，可以通过配置环境变量的方式来配置密钥，如下</p>
</blockquote>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后设置环境变量</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 使用免费的智普大模型体验</h3>
<p>当然若条件不允许，我们可以考虑智普清言的免费大模型</p>
<p>替换依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在智普的开放平台获取密钥：<a href="https://open.bigmodel.cn/usercenter/proj-mgmt/apikeys" target="_blank" rel="noopener noreferrer">https://open.bigmodel.cn/usercenter/proj-mgmt/apikeys</a></p>
<figure><img src="/imgs/column/springai/01-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后在配置文件中，添加智普的密钥，并指定免费的大模型</p>
<blockquote>
<p>在官网的定价中可以找到免费的模型：<a href="https://www.bigmodel.cn/pricing" target="_blank" rel="noopener noreferrer">https://www.bigmodel.cn/pricing</a></p>
</blockquote>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 密钥注入方式</h3>
<p>密钥除了直接再配置文件中写死之外，也可以通过前面介绍的环境变量的方式来注入，除此之外，下面介绍一种本地开发时命令行参数注入的方式</p>
<p>为了避免<code>api-key</code>的泄露，我们借助SpEL的方式来注入，通过在启动时，添加参数来设置apiKey，如下</p>
<ul>
<li>唤起编辑启动命令行窗口</li>
<li>点击<code>Modify options</code></li>
<li>在弹窗中选中 <code>Program arguments</code>，然后会看到再启动类右边新增一个输入框</li>
<li>再输入框中添加<code>--spring.ai.zhipuai.api-key=&lt;your-zhipuai-api-key&gt;</code></li>
</ul>
<figure><img src="/imgs/column/springai/01-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>说明：为什么不建议直接在配置文件中写密钥？</strong></p>
<ul>
<li>因为非常容易泄露，本地测试时，最简单的当然是直接在配置文件中写密钥，但是当我们将项目推送到git时，很容易忘了将密钥删除，这样，密钥就泄露了（即便你后续发现了再删除，但是git的历史提交中依然能找到你的密钥，你就只能删除它了）</li>
</ul>
<h2> 三、项目运行</h2>
<p>再上面初始化完成之后，接下来我们写一个简单的Chat服务，用于体验与大模型对话的感觉</p>
<p>新建一个ChatController类，用于接收用户的提问，并返回模型生成的答案</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面分别提供同步/流式调用大模型两种方式，测试时，你可以选择任意一种方式</p>
<figure><img src="/imgs/column/springai/01-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 四、小结</h2>
<p>从本文搭建的一个示例工程可以看出，借助SpringAI与大模型进行交互可以说是非常简单了，比基于db的CURD效率要高多了。相比起我们自己的实现（比如技术派的大模型调用就是手撸的代码直接实现与大模型交互），实在是轻松太多</p>
<p>文中所有代码可以在<a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S01-chat-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a> 获取</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/01-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>02.提示词的使用</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/02.%E6%8F%90%E7%A4%BA%E8%AF%8D%E8%AE%BE%E7%BD%AE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/02.%E6%8F%90%E7%A4%BA%E8%AF%8D%E8%AE%BE%E7%BD%AE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">02.提示词的使用</source>
      <description>02. 提示词的使用 上一篇文章快速带大家基于SpringAi创建了一个调用大模型的示例工程，接下来我们将进入一些大模型交互的细节，这里主要介绍如何使用提示词，以使大模型的输出更加符合我们的需求 一、基础知识 1. 提示词（Prompt） 提示词：Prompt，也可以理解为预设，是模型在开始对话时，预先设定的一些内容，这些内容会作为模型输入，从而影响模型输出的结果。 SpringAI中，我们使用 Prompt 类来表示一个提示词，Prompt 类中包含一个 List&amp;lt;Message&amp;gt; 属性，用于表示提示词中的消息列表。</description>
      <category>SpringAI</category>
      <pubDate>Fri, 11 Jul 2025 10:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 02. 提示词的使用</h1>
<p>上一篇文章快速带大家基于SpringAi创建了一个调用大模型的示例工程，接下来我们将进入一些大模型交互的细节，这里主要介绍如何使用提示词，以使大模型的输出更加符合我们的需求</p>
<h2> 一、基础知识</h2>
<h3> 1. 提示词（Prompt）</h3>
<p>提示词：Prompt，也可以理解为预设，是模型在开始对话时，预先设定的一些内容，这些内容会作为模型输入，从而影响模型输出的结果。</p>
<p>SpringAI中，我们使用 <code>Prompt</code> 类来表示一个提示词，<code>Prompt</code> 类中包含一个 <code>List&lt;Message&gt;</code> 属性，用于表示提示词中的消息列表。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 消息（Message）</h3>
<p>用户与大模型中间的对话，通常是由一个或多个消息组成，其中每个消息都需要与一个角色关联；角色表示消息作者的角色。</p>
<p>SpringAI中，我们使用 <code>Message</code> 类来表示一个消息，<code>Message</code> 类中包含一个 <code>MessageType</code> 属性，用于表示消息的类型。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面定义的<code>MessageType</code>定义消息类型，和大模型中定义的角色进行映射，ChatGPT了解它应该如何行为以及谁在发起调用</p>
<figure><img src="/imgs/column/springai/02-1.webp" alt="https://docs.spring.io/spring-ai/reference/api/prompt.html#_prompt" tabindex="0" loading="lazy"><figcaption><a href="https://docs.spring.io/spring-ai/reference/api/prompt.html#_prompt" target="_blank" rel="noopener noreferrer">https://docs.spring.io/spring-ai/reference/api/prompt.html#_prompt</a></figcaption></figure>
<p>通常有四种角色：</p>
<ul>
<li>system: 系统角色，用于通过分配特定行为给大模型来创建对话的上下文或范围，通常我们预设的提示词会和 <code>system</code> 角色关联</li>
<li>user: 用户角色，用于表示用户输入的文本，通常我们输入的提问也会和 <code>user</code> 角色关联</li>
<li>assistant: 助手角色，用于表示模型生成的文本，通常大模型生成的答案也会和 <code>assistant</code> 角色关联</li>
<li>tool: 工具角色，用于表示模型调用的函数返回的内容，会和 <code>tool</code> 角色关联</li>
</ul>
<h3> 3. 提示词模板</h3>
<p>提示词实际上是一个字符串，若提示词全部由程序预设，会导致提示词的复用性差，因此，SpringAI提供了一种模板语法，用于生成提示词，模板语法如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>模板语法中，<code>{name}</code> 和 <code>{voice}</code> 是模板变量，模板变量的值会根据调用时传入的参数进行替换</p>
<p>关联的类定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、实例演示</h2>
<p>首先我们需要创建一个SpringAI的项目，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 提示词基础使用</h3>
<p>我们这里同样基于智普的免费大模型进行演示，首先创建一个Controller控制器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再定义一个对话的接口，还是与之前的demo工程的一样，接收用户的传入文本，不同的地方在于我们再方式实现中，显示创建一个提示词</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提示词的创建方式比较简单，直接new一个对象，如上面的示例</p>
<ul>
<li>第一个参数：string类型：默认表示用户输入的消息</li>
<li>第二个参数：ChatOptions类型：表示模型调用的参数，如模型名称、温度、用户名称等</li>
</ul>
<ol>
<li>
<p><strong><code>temperature</code> 参数作用</strong>：</p>
<ul>
<li>用于控制生成文本的<strong>随机性或创造性</strong>。</li>
<li>数值范围一般在 <code>0.0</code> 到 <code>1.0</code> 之间（有时也可超出该范围）：
<ul>
<li>当 <code>temperature</code> 接近 <code>0.0</code> 时，输出会趋于确定性和保守，通常选择概率最高的词；</li>
<li>当 <code>temperature</code> 接近 <code>1.0</code> 或更高时，输出更具多样性和创造性，可能会选择低概率但更有趣的词。</li>
</ul>
</li>
<li>示例中设置为 <code>0.7d</code>，表示适度平衡确定性与多样性。</li>
</ul>
</li>
<li>
<p><strong><code>user</code> 参数作用</strong>：</p>
<ul>
<li>用于标识请求的发起者，通常是<strong>用户的唯一标识符</strong>（如用户名、ID 等）。</li>
<li>主要用途包括：
<ul>
<li><strong>日志记录和审计</strong>：便于追踪哪个用户触发了此次 AI 调用；</li>
<li><strong>配额管理</strong>：某些平台依据 <code>user</code> 字段进行使用量统计与限制；</li>
<li><strong>行为分析</strong>：用于后续的数据分析或个性化推荐等场景。</li>
</ul>
</li>
<li>示例中设置为 <code>"一灰灰"</code>，可能代表当前请求来源的用户身份标识。</li>
</ul>
</li>
</ol>
<p>如果我们希望预设一个系统的提示词，比如给大模型定义一个身份：“你现在是一个专注于给3-5岁儿童聊天的助手”，那么我们可以这样创建一个提示词：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们访问对比一下上面两个接口的返回情况，很明显<code>childGenerate</code>生成的笑话内容更适合3-5岁小朋友</p>
<figure><img src="/imgs/column/springai/02-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>小结一下，提示词的使用方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 提示词模板</h3>
<p>接下来我们再来看一下提示词模板的使用示例，创建一个角色扮演的接口，我们预设的系统提示词模板为</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>直接借助SpringAI提供的 <code>PromptTemplate</code> 来实现提示词模板的解析，常见的使用方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们创建一个接口，接收三个参数，分别表示角色的个性、角色名称、用户角色名称，然后使用模板渲染，并创建一个系统提示词，实现与用户的对话</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们看看传入不同的参数的表现情况</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/02-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的输出也可以看出，当我传入不同的角色描述，返回的对话信息也会根据我的描述进行显著的变化</p>
<h3> 3. 提示词高级使用</h3>
<p>通过提示词模板<code>promptTemplate.create</code>创建的提示词，默认是创建<code>UserMessage</code>类型的消息；如果我们希望创建的是系统提示词呢？可以使用<code>SystemPromptTemplate</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>默认情况下，提示词模板中需要替换的内容是放在<code>{}</code>中的，当然我们也可以自定义替换的内容，比如使用<code>&lt;&gt;</code>来替换，此时我们需要在创建<code>PromptTemplate</code>的时候传入一个参数<code>delimiter</code>，表示替换内容的分隔符</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提示词的使用，除了上面的字符串硬编码方式之外，SpringAI还提供了资源注入的方式，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 三、小结</h2>
<p>本文主要介绍在SpringAI中提示词的使用方式，如最基本的大模型交互时，由SpringAI默认根据文本封装一个用户消息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当然也可以手动创建</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如提示词有复用的场景，则优先考虑提示词模板</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S02-prompt-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/02-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>03.结构化返回</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/03.%E7%BB%93%E6%9E%84%E5%8C%96%E8%BF%94%E5%9B%9E.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/03.%E7%BB%93%E6%9E%84%E5%8C%96%E8%BF%94%E5%9B%9E.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">03.结构化返回</source>
      <description>03. 结构化返回 通常情况下，在我们不显示要求大模型返回什么样的数据结构时，大模型返回的大多不是结构化的数据；对于上层的业务开发来说，将大模型返回的关键信息映射为结构化的数据模型是一个非常难受的事情 SpringAI提供了一系列的返回结果结构化转换器来实现上面的痛点；接下来我们来具体看一下，可以怎么处理返回结果 一、实例演示 首先我们需要创建一个SpringAI的项目，基本流程同 创建一个SpringAI-Demo工程</description>
      <category>SpringAI</category>
      <pubDate>Fri, 11 Jul 2025 12:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 03. 结构化返回</h1>
<p>通常情况下，在我们不显示要求大模型返回什么样的数据结构时，大模型返回的大多不是结构化的数据；对于上层的业务开发来说，将大模型返回的关键信息映射为结构化的数据模型是一个非常难受的事情</p>
<p>SpringAI提供了一系列的返回结果结构化转换器来实现上面的痛点；接下来我们来具体看一下，可以怎么处理返回结果</p>
<h2> 一、实例演示</h2>
<p>首先我们需要创建一个SpringAI的项目，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 初始化</h3>
<p>创建一个MVC的API，用于提供与大模型的交互</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. BeanOutputConverter</h3>
<p>借助<code>BeanOutputConverter</code>来实现返回结果映射为java的POJO类，首先我们定义一个提示词模板，主要用于查询某个导演的作品</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们希望返回的结构如下:</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此我们可以定义一个record，用于承接返回的结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>借助<code>ChatClient</code>来实现结果解析</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么上面的方式就可以实现结果映射为java的POJO类呢？ 我们可以debug一下<code>ChatClient.create(chatModel).prompt(prompt).call()</code>返回的对象</p>
<p>从下面的截图中可以看到，在传递给大模型的请求中，context参数中，指定了要求大模型返回的数据格式（这里基于Advisors来实现的上下文数据附加/扩充提示词的功能）</p>
<figure><img src="/imgs/column/springai/03-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>当然也可以显示使用<code>BeanOutputConverter</code>基于<code>ChatModel</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，在提示词模板中，新增了 <code>{format}</code>，其值由 <code>BeanOutputConverter</code> 的 <code>getFormat()</code> 方法获取；其实现原理是直接在提示词中添加了结构化的返回结果格式，因此，大模型返回的数据结构，会按照这个格式进行解析</p>
<p>接下来实际访问看看表现情况</p>
<figure><img src="/imgs/column/springai/03-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从多次体验的结果来看，结果的格式与定义的POJO类一致，因此，基于BeanOutputConverter的实现，可以达到我们想要的结果；但是在有限的几次访问尝试中，返现<code>ChatClient</code>方式，返回的结果中actor可能为null，没有正确获取到值，这也侧面说明，大模型返回数据的不可控性</p>
<h3> 3. 属性排序</h3>
<p>借助<code>@JsonPropertyOrder</code>来实现排序，这个注解适用于record和普通的class</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/03-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. MapOutputConverter</h3>
<p>上面介绍的是返回一个POJO，接下来看一下直接基于<code>MapOutputConverter</code>来实现用map接收返回结果</p>
<p>这里使用的是上面用过的 <code>ParameterizedTypeReference</code> 来指定返回结果的类型</p>
<p>基于 <code>ChatClient</code> 的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于<code>MapOutputConverter</code>结合<code>ChatModel</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两个接口的返回结果如下图，虽然都是返回的Map，但是仔细看之后，会发现他们的层级并不一样，基于<code>ChatClient</code>返回的层级会多一层，返回的电影被放在了<code>movie</code>属性下，以列表的方式组织；而基于<code>MapOutputConverter</code>返回的就是一层的map，key为数字；</p>
<p>至于孰优孰劣，这里就不予置评，看个人喜好了</p>
<figure><img src="/imgs/column/springai/03-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. ListOutputConverter</h3>
<p>除了上面返回Map的case之外，再看一下返回列表的场景，借助<code>ListOutputConverter</code>来实现，基本上和前面介绍的差异不大</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>返回实例如下（你会发现返回数据的不准，当然这个就不属于我们这里的范畴了）</p>
<figure><img src="/imgs/column/springai/03-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、小结</h2>
<p>本文主要介绍在SpringAI中如何结构化的处理大模型返回的结果，从使用方式来看，区分<code>ChatClient</code>和<code>ChatModel</code>两种不同的使用姿势；其中前者更简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，核心发挥作用的是<code>Converter</code>，SpringAI官方提供了下面这些具体的实现，基本上可以覆盖我们90%以上的业务场景； 若覆盖补全，则考虑通过自定义Converter来实现</p>
<figure><img src="/imgs/column/springai/03-6.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S03-structured-output" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/03-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>04.聊天上下文</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/04.%E8%81%8A%E5%A4%A9%E4%B8%8A%E4%B8%8B%E6%96%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/04.%E8%81%8A%E5%A4%A9%E4%B8%8A%E4%B8%8B%E6%96%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">04.聊天上下文</source>
      <description>04.聊天上下文 大模型本身是无状态的，即你每次和它聊天，对它而言都是一轮全新的对话。但是，这个和我们实际体验大模型产品时，似乎不一样，在聊天的过程中，大模型明显是知道我们之前的问答内容、并可以基于之前的问答进行多伦的沟通，那这是怎么实现的呢？ 具体实现的原理也很简单，你和大模型的对话时，会将你们之前的对话内容也一并传给大模型，即：对于大模型而言，你的一次新的对话，它实际上把你们之前的所有对话都过了一遍；更专业一点的说法是你们的对话 是基于一个上下文，这个上下文会包含你之前和模型交互的所有内容。 若希望实现多轮对话，则每次和模型进行对话时，需要将之前和模型交互的所有内容都传递给模型，这样模型才能基于这些内容进行多轮的沟通。</description>
      <category>SpringAI</category>
      <pubDate>Mon, 14 Jul 2025 14:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 04.聊天上下文</h1>
<p>大模型本身是无状态的，即你每次和它聊天，对它而言都是一轮全新的对话。但是，这个和我们实际体验大模型产品时，似乎不一样，在聊天的过程中，大模型明显是知道我们之前的问答内容、并可以基于之前的问答进行多伦的沟通，那这是怎么实现的呢？</p>
<p>具体实现的原理也很简单，你和大模型的对话时，会将你们之前的对话内容也一并传给大模型，即：对于大模型而言，你的一次新的对话，它实际上把你们之前的所有对话都过了一遍；更专业一点的说法是你们的对话
是基于一个上下文，这个上下文会包含你之前和模型交互的所有内容。</p>
<p>若希望实现多轮对话，则每次和模型进行对话时，需要将之前和模型交互的所有内容都传递给模型，这样模型才能基于这些内容进行多轮的沟通。</p>
<h2> 一、实例演示</h2>
<h3> 1. 基础知识点</h3>
<p>SpringAI提供了自动装备的<code>ChatMemory</code> bean供我们直接注入使用</p>
<p>默认底层使用基于内存的方式存储聊天上下文(<code>InMemoryChatMemoryRepository</code>)，除了它之外，SpringAI还提供了基于数据库的存储方式</p>
<ul>
<li><code>JdbcChatMemoryRepository</code>:
支持多种关系型数据库，适用于需要持久化存储聊天记忆的场景，使用时需要添加 <code>org.springframework.ai:spring-ai-starter-model-chat-memory-repository-jdbc</code>
的依赖</li>
<li><code>CassandraChatMemoryRepository</code>: 基于 Apache Cassandra 实现消息存储，适用于需要高可用、持久化、可扩展及利用 TTL
特性的聊天记忆持久化场景；采用时间序列
Schema，完整记录历史聊天窗口，使用时添加 <code>org.springframework.ai:spring-ai-starter-model-chat-memory-repository-cassandra</code>
的依赖</li>
<li><code>Neo4jChatMemoryRepository</code>: 利用 Neo4j 将聊天消息存储为属性图中的节点与关系，适用于需发挥 Neo4j 图数据库特性的聊天记忆持久化场景。
使用时添加 <code>org.springframework.ai:spring-ai-starter-model-chat-memory-repository-neo4j</code>的依赖</li>
</ul>
<p>为了避免对话内容超过大模型的上下文限制， 使用<code>MessageWindowChatMemory</code>实现管理对话历史，<code>MessageWindowChatMemory</code>
维护固定容量的消息窗口（默认 20 条）。当消息超限时，自动移除较早的对话消息（始终保留系统消息）。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此为 Spring AI 自动配置 ChatMemory Bean 时采用的默认消息类型。</p>
<p>在使用 <code>ChatClient API</code>时，可通过注入 <code>ChatMemory</code> 实现来维护跨多轮交互的会话上下文。接下来我们通过一个案例体验一下实际的效果</p>
<h3> 2. 项目初始化</h3>
<p>首先我们需要创建一个SpringAI的项目，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<p>创建一个MVC的API，用于提供与大模型的交互</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的初始化中，我们制定了ChatClient的默认系统角色，指定了两个<code>Advisor</code></p>
<ul>
<li>SimpleLoggerAdvisor: 主要用于打印大模型的输入输出，以及一些额外的信息</li>
<li>MessageChatMemoryAdvisor: 主要用于从默认的<code>ChatMemory</code>中获取历史消息，并将其作为消息集合注入提示词</li>
</ul>
<h3> 3. 实现测试接口</h3>
<p>基于上面实例的ChatClient，我们来创建一个与大模型进行多轮对话的接口，这个实现与前面介绍的demo并无区别</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们访问接口，并输入内容，看看效果</p>
<figure><img src="/imgs/column/springai/04-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的截图中打印的大模型交互日志也可以看出，大模型会基于我们之前输入的内容进行多轮的沟通，并返回结果</p>
<p>因为默认的ChatMemory是基于内存的（ConcurrentHashMap），所以每次重启服务，都会丢失之前的对话内容，有兴趣的小伙伴可以试试</p>
<h3> 4. 会话隔离</h3>
<p>上面虽然实现了多伦对话，但是有一个比较大的问题，就是多个用户之间会话内容会相互干扰，比如用户A和用户B进行对话，用户B的会话内容会干扰用户A的会话内容，这显然是不符合实际需求的。</p>
<p>为了做好身份隔离，我们希望在记忆库中检索历史对话时，可以有一个区分，同样是借助 <code>advisor</code> 来实现</p>
<p>为了与上面的进行区分，我们调整一下ChatClient的初始化，对话角色可以由用户自由指定</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们创建一个会话隔离的接口，这个接口会根据用户ID进行会话隔离，即同一个用户ID的会话内容不会相互干扰</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/04-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的实现也可以看出，通过设置会话ID，实现了会话的隔离，用户A和用户B的会话内容不会相互干扰</p>
<h3> 5. ChatModel显示管理上下文</h3>
<p>上面介绍的是封装后的ChatClient，我们也可以直接使用<code>ChatModel</code>进行会话，显示管理上下文</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 其他Advisor</h3>
<p>上面介绍的是基于<code>MessageChatMemoryAdvisor</code>将ChatMemory注入到大模型，除此之外，SpringAI还内置了</p>
<ul>
<li><code>PromptChatMemoryAdvisor</code>: 区别于<code>MessageChatMemoryAdvisor</code>将多伦对话（包含内容、角色）返回给大模型，<code>PromptChatMemoryAdvisor</code>主要是将消息内容以文本的方式追加到系统提示词中</li>
<li><code>VectorStoreChatMemoryAdvisor</code>: 通过指定 <code>VectorStore</code> 实现管理会话记忆。每次交互时从向量存储检索历史对话，并以纯文本形式追加至系统（system）消息。</li>
</ul>
<p>还是根据一个实际的对比看看<code>MessageChatMemoryAdvisor</code>与<code>PromptChatMemoryAdvisor</code>的区别：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/04-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>系统提示词的文本内容如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的内容也可以看出，<code>PromptChatMemoryAdvisor</code>将多轮对话（包含内容、角色）拼接成文本的方式，放进了系统提示词中；从数据结构上看 <code>List&lt;Message&gt;</code> 只有两个，一个是System消息，一个是用户新加的User消息</p>
<h2> 二、小结</h2>
<p>本文主要从使用层面介绍了SpringAI中如何实现多伦对话，其中有几个关键概念</p>
<ul>
<li>ChatMemory: 会话记忆，SpringAI内置了基于内存的会话记忆，也可以基于其他数据源进行会话记忆，如向量存储、数据库、Redis等</li>
<li>ChatMemoryRepository：会话记忆的存储，SpringAI内置了基于内存的会话记忆存储，默认使用基于<code>ConcurrentHashMap</code>的会话记忆存储 <code>InMemoryChatMemoryRepository</code>
<ul>
<li>对于有持久化诉求的，可以考虑 <code>JdbcChatMemoryRepository</code>, <code>CassandraChatMemoryRepository</code>, <code>Neo4jChatMemoryRepository</code></li>
</ul>
</li>
<li>MessageWindowChatMemory：会话记忆的窗口</li>
<li>Advisor: 会话记忆的注入，SpringAI内置了多种会话记忆的注入方式，常见的有<code>MessageChatMemoryAdvisor</code>、<code>PromptChatMemoryAdvisor</code>、<code>VectorStoreChatMemoryAdvisor</code></li>
</ul>
<p>使用<code>ChatMemory</code>进行会话记忆时，推荐使用<code>ChatClient</code>方式，借助<code>Advisor</code>进行注入</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S04-chat-memory" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/04-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>05.自定义大模型接入</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/05.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/05.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">05.自定义大模型接入</source>
      <description>05.自定义大模型接入 SpringAI已经集成了很多主流大模型的交互，封装成starter供我们直接使用；比如前面几篇的demo使用的智普大模型，就是直接利用spring-ai-starter-model-zhipuai来进行大模型的交互 但总有例外，比如星火的免费模型Spark Lite(非免费的也没有😂)，在官方的教程中我们就没有找到可以直接使用的starter 接下来我们看一下，基于SpringAI，如果我们要接入一个自定义的大模型，可以怎么处理 一、大模型接入申请 首先是准备好大模型需要的信息(核心就是apiKey)</description>
      <category>SpringAI</category>
      <pubDate>Mon, 21 Jul 2025 14:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 05.自定义大模型接入</h1>
<p>SpringAI已经集成了很多主流大模型的交互，封装成starter供我们直接使用；比如前面几篇的demo使用的智普大模型，就是直接利用<code>spring-ai-starter-model-zhipuai</code>来进行大模型的交互</p>
<p>但总有例外，比如星火的免费模型Spark Lite(非免费的也没有😂)，在官方的教程中我们就没有找到可以直接使用的starter</p>
<p>接下来我们看一下，基于SpringAI，如果我们要接入一个自定义的大模型，可以怎么处理</p>
<h2> 一、大模型接入申请</h2>
<p>首先是准备好大模型需要的信息(核心就是apiKey)</p>
<h3> 1. 星火ApiKey申请</h3>
<p>注册、登录账号相关流程省略，请直接在官网自助完成</p>
<p>进入开放平台: <a href="https://console.xfyun.cn/services/cbm" target="_blank" rel="noopener noreferrer">https://console.xfyun.cn/services/cbm</a></p>
<figure><img src="/imgs/column/springai/05-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>选择 Spark Lite 模型，上图中因为我已经开通了；对于没有开通的场景，可以看到上图中 <code>领取无限量</code> 这个按钮是激活状态，点击之后对于已认证账号即可获取了（未认证的，直接跳转到认账账号进行认证，支持个人/企业认证）</p>
<p>领取之后，在右边的缱绻信息中，将 ApiPassword 复制出来待用</p>
<h3> 2. 阅读官方接口文档</h3>
<p>由于并不是所有的大模型的规范都一样，无法确保它们都能直接适配SpringAI的传入/传出，因此在后续的接入需要重点阅读官方接口文档，对大模型的交互进行适配</p>
<p>所以，我们这里就以星火模型为例，阅读官方接口文档，这里我们使用的是Spark Lite模型，文档地址为：<a href="https://www.xfyun.cn/doc/spark/HTTP%E8%B0%83%E7%94%A8%E6%96%87%E6%A1%A3.html" target="_blank" rel="noopener noreferrer">https://www.xfyun.cn/doc/spark/HTTP调用文档.html</a></p>
<h2> 二、项目创建</h2>
<p>项目创建方式与之前并无差别，创建一个SpringBoot项目，并引入SpringAI的依赖，有需要的小伙伴参考 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 依赖配置</h3>
<p>由于我们不直接使用官方的starter, 因此需要主动依赖SpringAI的一些核心包</p>
<p>在pom配置文件中添加</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置参数</h3>
<p>同样的，我们可以将大模型的一些参数，统一维护在<code>application.yml</code>配置文件中，关键的信息为 <code>api-key</code></p>
<p>关于配置的维护，我们可以直接参考官方提供的starter的实现（比如智普的starter）</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：本文以实现一个最基础的大模型交互为例，因此更多的参数相关组织配置，将留待后续的文章进行扩充实现；这里只介绍最核心的参数</p>
<h3> 3. 实现大模型接口</h3>
<p>对于自定义的大模型的接口实现，最最核心的，就是实现<code>ChatModel</code>接口，这个接口定义了模型交互的参数，以及模型交互的返回结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于这个<code>ChatModel</code>的实现，关键在于 <code>public ChatResponse call(Prompt prompt)</code> 这个方法的实现，其他的都非必须</p>
<p>对于<code>call(Prompt prompt)</code>方法，内部需要实现的就是和大模型的交互，以同步的http协议的方式，我们需要干的事情，就三个</p>
<ul>
<li>将 <code>prompt</code> 转换为大模型的传入参数</li>
<li>发起<code>http</code>请求</li>
<li>将大模型的返回对象封装为 <code>ChatResponse</code> 对象</li>
</ul>
<p>在上面的具体实现中，我们直接使用Spring的<code>restClient</code>作为http交互的工具(对于需要流式异步交互的场景，可以考虑WebClient)，麻烦的点(或者说脏活累活)就是请求返回的解析映射</p>
<p>对于此，我们定义一个<code>SparkPOJO</code>来保存讯飞大模型的返回结果；</p>
<p>如下面这个json为大模型的真实返回结果</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于上面的json，我们你定义的POJO，可以分为</p>
<ul>
<li><code>ChatCompletionChunk</code>对应完整的返回</li>
<li><code>Choice</code> 对应大模型返回结果中的<code>choices</code>数组，<code>SparkMsg</code>对应choices数组中的message元素；</li>
<li><code>Usage</code> 对应大模型返回结果中的<code>usage</code>元素</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义 <code>POJOConvert</code> 来实现请求返回的对象转换为 <code>ChatResponse</code></p>
<ul>
<li><code>List&lt;Generation&gt;</code> 生成的结果
<ul>
<li>ChatGenerationMetadata： 返回的元数据</li>
<li>AssistantMessage：包含具体返回的文本</li>
</ul>
</li>
<li><code>ChatResponseMetadata</code>: 返回的元数据</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 大模型使用示例</h3>
<p>上面完成了自定义大模型的交互，接下来我们试试效果；使用方法基本上和前面介绍的没有任何区别</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/05-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、小结</h2>
<p>本文通过非官方提供的start，实现了一个自定义大模型的接入过程，其核心关键在于 <code>ChatModel</code> 接口的实现，小结一下自定义大模型接入的关键点</p>
<ul>
<li>继承 <code>ChatModel</code> 接口，实现 <code>ChatModel</code> 接口的 <code>call</code> 方法，返回 <code>ChatResponse</code> 对象</li>
<li>实现SpringAI定义的<code>Prompt</code>对象转大模型传参</li>
<li>实现大模型的返回结果转 <code>ChatResponse</code></li>
</ul>
<p>本文仅作为参考，目前只实现了基础的大模型聊天问答，接下来我们将介绍了SpringAI的更多高级功能（比如Function tool工具调用, 多模态, MCP, RAG等）；</p>
<p>同时也会在介绍这些高级功能时 ，给出自定义的大模型接入的相关能力扩展，辅助加深理解。</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S05-self-model" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/05-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>06.工具调用 FunctionCalling</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/06.%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8FunctionCalling.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/06.%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8FunctionCalling.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">06.工具调用 FunctionCalling</source>
      <description>06.工具调用 FunctionCalling 我们知道大模型是基于一系列数据进行训练的，且每次训练的成本很高；那么大模型是怎么样表现得十八般武艺样样精通的呢？ function calling就是设计出来给大模型当外挂的瑞士工具包，通过给大模型设计一个与外部工具进行交互的方式，来扩展大模型在训练时缺失或者不够与时俱进的能力 一、工作原理 SpringAi 提供了完备工具调用封装，可以非常方便的将本地方法封装成工具，供大模型调用 1. 工具调用流程 Spring AI工具调用流程</description>
      <category>SpringAI</category>
      <pubDate>Mon, 28 Jul 2025 08:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 06.工具调用 FunctionCalling</h1>
<p>我们知道大模型是基于一系列数据进行训练的，且每次训练的成本很高；那么大模型是怎么样表现得十八般武艺样样精通的呢？</p>
<p>function calling就是设计出来给大模型当外挂的瑞士工具包，通过给大模型设计一个与外部工具进行交互的方式，来扩展大模型在训练时缺失或者不够与时俱进的能力</p>
<h2> 一、工作原理</h2>
<p>SpringAi 提供了完备工具调用封装，可以非常方便的将本地方法封装成工具，供大模型调用</p>
<h3> 1. 工具调用流程</h3>
<figure><img src="/imgs/column/springai/06-1.webp" alt="Spring AI工具调用流程" tabindex="0" loading="lazy"><figcaption>Spring AI工具调用流程</figcaption></figure>
<p>工具调用流程如下：</p>
<ol>
<li>在向大模型发起请求时，将工具信息传递给大模型
<ul>
<li>每个工具的定义都包含名称、描述、输入参数</li>
</ul>
</li>
<li>大模型根据工具信息，会发送包含工具名称、亲求参数的请求给工具服务</li>
<li>应用程序根据工具名称，识别到对应的工具，调用工具方法</li>
<li>工具执行结果返回给应用程序进行处理（可能是直接返回给用户，也可能是返回给大模型）</li>
<li>应用程序将工具执行结果返回给大模型</li>
<li>大模型利用工具返回的结果，构建返回结果给用户</li>
</ol>
<h3> 2. SpringAI关键实现</h3>
<p>SpringAI主要提供了两种内置方式将本地方法封装成工具</p>
<ul>
<li>声明式：通过注解 <code>@Tool</code></li>
<li>编程式：通过底层的 <code>MethodToolCallback</code> <code>FunctionToolCallback</code></li>
</ul>
<figure><img src="/imgs/column/springai/06-2.webp" alt="https://java2ai.com/docs/dev/tutorials/function-calling/" tabindex="0" loading="lazy"><figcaption><a href="https://java2ai.com/docs/dev/tutorials/function-calling/" target="_blank" rel="noopener noreferrer">https://java2ai.com/docs/dev/tutorials/function-calling/</a></figcaption></figure>
<p>上图中橙色的部分，就是SpringAI将我们本地方法封装成工具，供大模型进行交互；接下来我们看一下SpringAI的关键类</p>
<h4> a. ToolCallback</h4>
<p>ToolCallback 接口提供了定义 AI 模型可调用工具的方式，包含工具定义和执行逻辑。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SpringAI提供了两种内置实现</p>
<ul>
<li>MethodToolCallback: 将本地方法定义为AI模型可调用的工具</li>
<li>FunctionToolCallback: 将函数定义为AI模型可调用的工具</li>
</ul>
<h4> b. ToolDefinition</h4>
<p>ToolDefinition 接口提供 AI 模型识别工具可用性所需的信息，包括工具名称、描述及输入模式。每个 ToolCallback 实现必须提供 ToolDefinition 实例来定义工具。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>若需要手动创建的工具定义，可以使用<code>ToolDefinition.Builder</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了上面的方式，对于本地java方法，可以直接通过反射的方式来生成基于方法的工具定义</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> c. JSON Schema</h4>
<p>向 AI 模型提供工具时，模型需要知道工具调用输入类型的模式，Spring AI 通过 JsonSchemaGenerator 类内置支持生成工具输入类型的 JSON Schema</p>
<p>下面是一个json schema的示例（在前面<a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/03.%E7%BB%93%E6%9E%84%E5%8C%96%E8%BF%94%E5%9B%9E.html" target="blank">结构化返回</a>中，实际上也用到了 JSON Schema，用于告知大模型如何返回我们希望格式的数据）</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的json schema主要用于方法/函数调用的传参定义，SpringAI内置支持下面四种基于注解升成输入参数描述、是否必传</p>
<ul>
<li><code>Spring AI</code> 的 <code>@ToolParam(description = "…", required=false)</code>： 参数描述 + 是否必传</li>
<li><code>Jackson</code> 的 <code>@JsonClassDescription(description = "…)</code>: 参数描述</li>
<li><code>Jackson</code> 的 <code>@JsonPropertyDescription(description = "…")</code> : 参数描述</li>
<li><code>Jackson</code> 的 <code>@JsonProperty(required = false)</code> : 参数是否必传</li>
<li><code>Swagger</code> 的<code> @Schema(description = "…", required = false)</code> ： 参数描述 + 是否必传</li>
<li><code>Spring</code> 的 <code>@Nullable</code> ： 参数是否必传</li>
</ul>
<p>示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> d. 结果转换</h4>
<p>通常方法/函数返回的是Object对象，需要转换给大模型使用，SpringAI定义<code>ToolCallResultConverter</code>对返回进行序列化，实现将返回结果转换为String对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SpringAI默认的结果转换为基于Jackson的json序列化（<code>DefaultToolCallResultConverter</code>），当然如果你喜欢，也可以换成gson、fastjson或者自定义的转换实现</p>
<h4> e. ToolContext</h4>
<p>Spring AI 支持通过 <code>ToolContext</code> API向工具传递额外的上下文信息，ToolContext 中的数据由用户调用 ChatClient 时提供。后面的使用示例会进行案例介绍</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ToolContext的实现也非常简单，一个不可变对象Map来承接工具调用上下文数据</p>
<h2> 二、使用示例</h2>
<h3> 1. 项目创建</h3>
<p>项目创建方式与之前并无差别，创建一个SpringBoot项目，并引入SpringAI的依赖，有需要的小伙伴参考 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<p>在pom中添加相关依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们这里使用智谱的免费大模型，虽然免费但它依然支持工具调用（请注意，并不是所有的模型都支持工具调用的，在使用之前到官方的说明确认是否支持）</p>
<h3> 2. 声明式使用方式</h3>
<p>我们定义一个简单、基础可用的工具方法，主要用于获取当前时间，核心点就是在方法上添加注解 <code>@Tool</code></p>
<ul>
<li>注解的 description 属性非常重要，用于知道模型判断何时调用这个工具；当描述不够清晰时，可能导致模型在该调用工具时没有调用，或者调用错了工具</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于使用 <code>ChatClient</code> 来使用工具调用，就非常简单了，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面有提供了两个接口， getTime 接口使用了工具，getTimeNoTools 接口没有使用工具；使用方式形如</p>
<ul>
<li><code>chatClient.prompt().tools(xxx)</code>：通过tools方法注入工具</li>
</ul>
<p>接下来我们看一下表现情况</p>
<figure><img src="/imgs/column/springai/06-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p>说明：虽然上面的访问对比中，在请求 <code>time</code> 接口时，正确的返回了时间，但是大模型并不总是和我们预期的一致，同样的提问，它有时不会主动调用我们注入的工具</p>
</blockquote>
<h3> 3. 带参数的工具方法</h3>
<p>前面定义的工具没有参数，接下来我们在看一下带参数的工具方法</p>
<p>在方法参数上，可以通过 <code>@ToolParam</code> 注解对参数进行解释说明（这个注解是非必填的）,注解内有两个属性</p>
<ul>
<li><code>description</code>：参数描述，用于帮助模型更准确地理解如何使用该参数。例如：参数格式要求、允许取值范围等。</li>
<li><code>required</code>：指定参数是否为必需项（默认值：<code>true</code>，即所有参数默认必需）。</li>
</ul>
<p>比如我现在定义一个返回不同时区的当前时间的工具，供大模型调用，参数是时区，同样放在 <code>DateTimeTools</code> 类中，这样就可以直接使用上面的api</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/06-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的访问示例也可以看出，我们询问某个地区的时间时，大模型会自动根据地区找到时区，然后调用我们的工具返回结果</p>
<p>但是一个问题来了，直接问时间时，它不会调用我们之前定义的那个方法，返回时间，这是为什么呢？</p>
<p>我们尝试调整一下，之前定义获取当前时间的工具方法说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再多问几次，你就会发现大模型会主动调用我们定义的这个方法，返回时间（但是并不能始终保证它总是表现正确）</p>
<ul>
<li>所以一个何时的、精确的工具描述，对于大模型的决策是否调用，非常重要</li>
</ul>
<figure><img src="/imgs/column/springai/06-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 添加默认工具</h3>
<p>上面介绍的是在用户发起对话时，设置Prompt时指定工具调用，同样的，SpringAI也提供了默认工具的设置方式，在<code>ChatClient</code>创建时，指定默认的工具，这样只要用这个<code>ChatClient</code>进行对话，这些工具都会提供给大模型，而不在需要单独进行设置</p>
<p>使用方式形如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个就不做具体的演示了，没有什么特殊的地方</p>
<h3> 5. ChatModel 添加工具</h3>
<p>如果某些场景下，我们不是通过<code>ChatClent</code>而是直接借助<code>ChatModel</code>进行对话，同样也可以添加工具，通过 ChatOptions 来实现</p>
<p>具体的使用姿势如下，借助<code>ToolCallbacks</code>来获取工具集，借助<code>ToolCallingChatOptions</code>来添加工具集</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 编程式使用方式</h3>
<p>前面介绍的都是基于<code>@Tool</code>注解的声明式定义工具，这种适用于工具实现完全由我们掌控的场景；对于一些非控制的工具实现（如三方sdk），或者需要动态获取工具参数的场景，我们可以使用编程式定义工具</p>
<p>编程式的使用方式，主要是借助<code>MethodToolCallback.Builder</code>来构建我们需要的<code>MethodToolCallback</code></p>
<p>使用这种方式时，需要重点看一下前面第一节的内容，<code>ToolCallback</code> <code>ToolDefinition</code>的类结构定义，清楚之后，再看下面的参数设置就会更轻轻松（也知道为什么要这么实现）</p>
<ul>
<li><code>toolDefinition</code>：定义工具名称、描述及输入模式的 <code>ToolDefinition</code> 实例（必需项）
<ul>
<li>可通过 <code>ToolDefinition.Builder</code> 类构建。</li>
</ul>
</li>
<li><code>toolMetadata</code>: 定义额外设置的 <code>ToolMetadata</code> 实例，非必需
<ul>
<li>可通过 <code>ToolMetadata.Builder</code> 类构建</li>
<li>returnDierect<code>: 是否直接返回结果（默认为 </code>false`），为true时表示直接将结果返回给用户、而不是给大模型进行调用</li>
</ul>
</li>
<li><code>toolMethod</code>: 工具方法的<code>Method</code>实例 （必需项）</li>
<li><code>toolObject</code>: 包含工具方法的对象实例（若方法为静态方法则可省略此参数）</li>
<li><code>toolCallResultConverter</code>：用于将工具调用结果转换为 <code>String</code> 对象并返回 AI 模型
<ul>
<li><code>ToolCallResultConverter</code> 实例（未配置时默认使用 <code>DefaultToolCallResultConverter</code>）。</li>
</ul>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在使用方法工具时，需要注意一些限制</p>
<p>以下类型目前不支持作为工具方法的参数或返回类型：</p>
<ul>
<li>Optional</li>
<li>异步类型（如 CompletableFuture、Future）</li>
<li>响应式类型 （如 Flow、Mono、Flux）</li>
<li>函数式类型（如 Function、Supplier、Consumer）</li>
</ul>
<h3> 7. 函数作为工具调用的使用示例</h3>
<p>到现在为止，我们都是将方法作为工具给大模型进行调用，在java8+之后，除了方法还有些函数式接口，比如<code>Function</code>、<code>Consumer</code>、<code>Supplier</code>、<code>Predicate</code>等，这些函数式接口也可以作为工具进行调用，使用方式如下：</p>
<p>通过 <code>FunctionToolcallback</code> 来将函数式类型，转换为工具</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体的使用方式，和上面介绍的方法的编程式相差不大，但是有一个需要格外注意的事项</p>
<ul>
<li>函数输入和输出可以是 Void 或 POJO。输入和输出的 POJO 必须是可序列化的，因为结果将被序列化并发送回模型。</li>
<li>函数及输入输出类型必须是 public 的。</li>
</ul>
<p>以下类型目前不支持作为工具函数的输入或输出类型：</p>
<ul>
<li>基本类型</li>
<li>Optional</li>
<li>集合类型 （如 List、Map、Array、Set）</li>
<li>异步类型（如 CompletableFuture、Future）</li>
<li>响应式类型（如 Flow、Mono、Flux）</li>
</ul>
<h3> 8. 动态范式 @Bean</h3>
<p>这种类似于声明式的函数工具，Spring AI 通过 <code>ToolCallbackResolver</code> 接口（SpringBeanToolCallbackResolver具体实现），在运行时动态解析</p>
<p>可以将任意 <code>Function</code>、<code>Supplier</code>、<code>Consumer</code> 或 <code>BiFunction</code> 类型的 <code>Bean</code> 作为工具使用。</p>
<ul>
<li><code>Bean</code> 名称将作为工具名称`</li>
<li><code>Spring Framework</code> 的 <code>@Description</code> 注解提供工具描述</li>
</ul>
<p>实测，没有成功，待后续确认这个逻辑是否和官网说的一致</p>
<h2> 三、小结</h2>
<p>本篇文章主要介绍了SpringAI如何定义、使用工具调用，包括方法工具/函数工具两类，有基于@Tool注解的声明式，也有借助 <code>MethodToolCallback</code> 和 <code>FunctionToolCallback</code> 实现的编程式</p>
<p>在工具的定义上，我们需要额外关注工具的描述，传参和返回；其中传参是通过 <code>Json Schema</code> 的形式给到的大模型</p>
<p>默认行为时，Spring AI 会自动拦截模型的工具调用请求，执行工具并将结果返回模型。这些操作均由各 ChatModel 实现通过 ToolCallingManager 透明完成，如下图</p>
<figure><img src="/imgs/column/springai/06-6.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol>
<li>当需要向模型提供工具时，我们将其定义包含在聊天请求（Prompt）中，并调用 ChatModel API 将请求发送至 AI 模型。</li>
<li>当模型决定调用工具时，它会发送包含工具名称及符合定义模式的输入参数的响应（ChatResponse）。</li>
<li>ChatModel 将工具调用请求发送至 ToolCallingManager API。</li>
<li>ToolCallingManager 负责识别需调用的工具并使用提供的输入参数执行该工具。</li>
<li>工具调用结果返回至 ToolCallingManager。</li>
<li>ToolCallingManager 将工具执行结果返回给 ChatModel。</li>
<li>ChatModel 将工具执行结果返回AI模型（ToolResponseMessage）。</li>
<li>AI 模型利用工具调用结果作为附加上下文生成最终响应，并通过 ChatClient 将其返回调用方（ChatResponse）。</li>
</ol>
<p>目前与模型交互的工具执行，是由SpringAI托管的，内部的工具选择等逻辑对用户是不透明的，当然也可以通过将 <code>ToolCallingChatOptions</code> 的 <code>internalToolExecutionEnabled</code> 属性设为 <code>false</code>，来实现自行控制工具执行的生命周期；这块的内容，将在下一章节进行介绍</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S06-function-tool" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/06-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>07.实现一个查询不同时区当前时间的MCP Server</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/07.%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84McpServer.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/07.%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84McpServer.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">07.实现一个查询不同时区当前时间的MCP Server</source>
      <description>07.实现一个查询不同时区当前时间的MCP Server MCP可以说是25年最火的协议来了，MCP（Model Context Protocol，模型上下文协议）是由 Anthropic 公司于 2024 年底开源的标准化通信协议，旨在解决大模型与外部工具、数据源之间的碎片化集成问题，被誉为 “AI 领域的 USB-C 接口”。 其核心作用是通过统一的协议规范，让大模型（如 Claude、GPT-4、LLaMA 等）能够安全、高效地连接任意工具和数据，而无需为每个系统单独开发适配代码 一、MCP简介 在正式创建一个MCP Server之前，我们先了解一下mcp的相关概念</description>
      <category>SpringAI</category>
      <pubDate>Mon, 28 Jul 2025 11:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 07.实现一个查询不同时区当前时间的MCP Server</h1>
<p>MCP可以说是25年最火的协议来了，MCP（Model Context Protocol，模型上下文协议）是由 Anthropic 公司于 2024 年底开源的标准化通信协议，旨在解决大模型与外部工具、数据源之间的碎片化集成问题，被誉为 “AI 领域的 USB-C 接口”。</p>
<p>其核心作用是通过统一的协议规范，让大模型（如 Claude、GPT-4、LLaMA 等）能够安全、高效地连接任意工具和数据，而无需为每个系统单独开发适配代码</p>
<h2> 一、MCP简介</h2>
<p>在正式创建一个MCP Server之前，我们先了解一下mcp的相关概念</p>
<h3> 1.1 MCP是什么</h3>
<blockquote>
<p>MCP （Model Context Protocol，模型上下文协议），它提供了一个通用的开放标准，用于将 AI 系统与数据源连接起来，用单一协议取代碎片化的集成。结果是一种更简单、更可靠的方法，使 AI 系统能够访问所需的数据。这是一种将 AI 助手连接到数据所在的系统（包括内容存储库、业务工具和开发环境）的新标准。其目的是帮助前沿模型产生更好、更相关的响应。</p>
</blockquote>
<p>简单来讲，mcp就是定义了标准，对于所有希望给大模型提供能力的小伙伴来说，只要按照这个标准完成能力封装，那么大模型就可以直接加载这些能力从而实现某些特定的功能。</p>
<p>举一个例子，usb大家应该都不陌生，如果你只买一个台式机主机，这个时候你会发现我除了按它的开关按钮之外，好像什么也干不了。然后我买了键盘、鼠标、显示器、摄像头等外设，然后通过usb接口插上之后就可以操作电脑了，电脑是怎么识别这些外接设备（键盘、鼠标、摄像头等）的呢？ 这就是usb协议的作用了，外接设备和电脑，都遵循usb协议，然后大家就可以在同一个频道进行交流了；同样的MCP就是为了干这件事情，让大模型和给大模型提供增强能力的服务能同频进行交流</p>
<figure><img src="/imgs/column/springai/07-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 1.2 MCP总体架构</h3>
<p>MCP遵循客户端-服务端（CS）的架构，一个主机可以连接多个MCP服务端</p>
<figure><img src="/imgs/column/springai/07-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的描述和整体架构图，可以看到在MCP的架构中，有三个重要的角色</p>
<ul>
<li>MCP Hosts(MCP主机)： 通过mcp协议获取数据的程序（比如 Claude Desktop, IDE 或者 ai工具）</li>
<li>MCP Clients(MCP客户端): mcp协议客户端，作为调用者，通常与mcp服务端是成对出现，用于连接mcp server，实现双方通信</li>
<li>MCP Servers(MCP服务端): mcp协议服务端，作为提供者，实现MCP协议提供特定的功能</li>
</ul>
<p>除了上面三个角色之外，在架构图中，还有两个</p>
<ul>
<li>Local Data Sources: MCPServer所在的计算机上本地的资源信息，如文件、数据库、应用服务等，即MCP通过操作(读取、访问、写入等)这些本地资源来提供特定能力</li>
<li>Remote Service: MCPServer通过调用远程的服务来提供能力</li>
</ul>
<h3> 1.3 MCP工作原理</h3>
<p>mcp只是一个协议，和http协议一样，本身不直接提供能力或者服务，我们能实际感知到的服务表现只是协议上层的应用封装</p>
<p>比如http协议，常见的工作流程是我们打开浏览器，点开网页，通过http协议访问到对应的后台服务器，然后对方将网页信息传输到我们的浏览器上展示为可视化的网页内容，从而实现信息的曝光</p>
<p>那么mcp协议是怎么工作的呢？</p>
<ol>
<li>用户通过客户端发起提问</li>
<li>客户端将问题传递给 LLM</li>
<li>LLM 分析并选择合适的工具</li>
<li>通过 MCP 协议向服务端发送工具执行指令</li>
<li>工具执行后结果返回给 LLM</li>
<li>LLM 生成最终回复</li>
<li>回复通过客户端展示给用户</li>
</ol>
<figure><img src="/imgs/column/springai/07-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 1.4 SpringAI MCP 实现</h3>
<p>SpringAI提供了MCP的Client/Server的集成，对于上层业务而言，要想实现一个MCP Server/Client比较简单</p>
<p><strong>MCP客户端</strong></p>
<p>MCP 客户端是 Model Context Protocol（MCP）架构的核心组件，负责建立并管理与 MCP 服务器的连接。它实现协议的客户端逻辑，主要处理以下功能：</p>
<ul>
<li>协议版本协商以确保与服务器的兼容性</li>
<li>功能协商以确定可用特性</li>
<li>消息传输及 JSON-RPC 通信</li>
<li>工具发现与执行</li>
<li>资源访问与管理</li>
<li>提示词系统交互</li>
<li>可选功能
<ul>
<li>根目录管理</li>
<li>采样支持</li>
</ul>
</li>
<li>同步与异步操作</li>
<li>传输协议选项：
<ul>
<li>基于 Stdio 的进程间通信传输协议</li>
<li>基于 Java HttpClient 的 SSE 客户端传输协议</li>
<li>WebFlux SSE 客户端传输协议（用于响应式 HTTP 流式通信）</li>
</ul>
</li>
</ul>
<figure><img src="/imgs/column/springai/07-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>MCP服务端</strong></p>
<p>MCP 服务器是 Model Context Protocol（MCP）架构的基础组件，用于向客户端提供工具、资源和功能。它实现协议的服务端逻辑，主要职责包括：</p>
<ul>
<li>服务端协议操作的实现
<ul>
<li>工具暴露与发现</li>
<li>基于 URI 的资源管理及访问</li>
<li>提示（Prompt）模板的提供与处理</li>
<li>与客户端的功能协商</li>
<li>结构化日志记录与通知</li>
</ul>
</li>
<li>并发客户端连接管理</li>
<li>同步与异步 API 支持</li>
<li>传输协议实现：
<ul>
<li>基于 Stdio 的进程间通信传输协议</li>
<li>基于 Servlet 的 SSE 服务器传输协议</li>
<li>WebFlux SSE 服务器传输协议（用于响应式 HTTP 流式通信）</li>
<li>WebMVC SSE 服务器传输协议（用于基于 Servlet 的 HTTP 流式通信）</li>
</ul>
</li>
</ul>
<figure><img src="/imgs/column/springai/07-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、创建一个MCP Server</h2>
<p>接下来我们进入正文，如何创建一个MCP Server，并且让我们的大模型能够访问这个MCP Server</p>
<h3> 1. 项目创建</h3>
<p>项目创建方式与之前并无差别，创建一个SpringBoot项目，并引入SpringAI的依赖，有需要的小伙伴参考 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 依赖配置</h3>
<p>在pom配置文件中需要添加核心的依赖，这里是 <code>spring-ai-starter-mcp-server-webmvc</code></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在<code>application.yml</code>配置文件中，设置MVC Server的相关参数 (下面基本都是默认配置)</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点参数说明：</p>
<ul>
<li>sse-endpoint: 用于 <code>Web</code> 传输的自定义 <code>SSE</code> 端点路径，MCP Client主要连接的就是这个端点</li>
<li>sse-message-endpoint: 客户端用于发送消息的端点路径,如后续大模型调用工具时，走的就是这个端点</li>
<li>type: 服务器类型（同步/异步）</li>
</ul>
<h3> 2. 创建一个MCP Server</h3>
<p>对于SpringAI而言，创建MCP Server和Function calling有点相似，也是通过 <code>@Tool</code> 注解将方法声明为工具，区别是一个作为mcp的工具，一个是作为function calling的回调方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后将这个工具注册为MCP工具暴露给大模型</p>
<p>SpringAI的自动配置将检测并注册来自以下组件的所有工具回调</p>
<ul>
<li>独立的 ToolCallback Bean</li>
<li>ToolCallback Bean 列表</li>
<li>ToolCallbackProvider Bean</li>
</ul>
<p>工具按名称去重，每个工具名称仅保留首次出现的实例，如下创建一个<code>ToolCallbackProvider</code>的 <code>@Bean</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 启动项目</h3>
<p>启动项目，访问<a href="http://localhost:8080/sse" target="_blank" rel="noopener noreferrer">http://localhost:8080/sse</a>, 可以看到MCP Server已经启动了</p>
<figure><img src="/imgs/column/springai/07-6.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. Trae配置MCP</h3>
<p>接下来我们使用Trae来连接上面实现的mcp server，并使用mcp server提供的工具</p>
<p>以 TraeCN 2.0 为例，下面介绍下具体的配置过程</p>
<figure><img src="/imgs/column/springai/07-7.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>需要贴在trae中的mcp server的json配置如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再来访问看看实际的效果</p>
<figure><img src="/imgs/column/springai/07-8.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>大模型准确的调用了我们刚才创建的MCPServer，分别返回了伦敦和巴黎的时间</p>
<h3> 5. 小结</h3>
<p>到这里我们已经实现了一个功能齐备的MCPServer，整体的代码实现非常简单，在需要作为MCP工具的，在方法上添加<code>@Tool</code>注解，然后借助创建<code>ToolCallbackProvider</code>将这些工具注册出来即可</p>
<p>本文介绍的是MCP通过http sse实现的，创建MCP Server的实现方式有很多种，这里只是介绍最简单的一种web同步请求，且没有权限管控</p>
<p>在创建一个生成可用的mcp server，目前还缺一个非常关键的认证机制，这个会在接下来的文章进行说明</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S07-mcp-server" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/07-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>08.MCPServer简单鉴权的实现</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/08.MCP%20Server%E7%AE%80%E5%8D%95%E9%89%B4%E6%9D%83%E7%9A%84%E5%AE%9E%E7%8E%B0.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/08.MCP%20Server%E7%AE%80%E5%8D%95%E9%89%B4%E6%9D%83%E7%9A%84%E5%AE%9E%E7%8E%B0.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">08.MCPServer简单鉴权的实现</source>
      <description>08.MCPServer简单鉴权的实现 上面一篇 实现一个简单的McpServer 带大家构建了一个自己的McpServer，其功能非常简单，接下来我们尝试逐步进行补全，我们下来看一下，如何给其加上权限管控，避免服务被白嫖 一、MCP Server搭建</description>
      <category>SpringAI</category>
      <pubDate>Mon, 28 Jul 2025 14:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 08.MCPServer简单鉴权的实现</h1>
<p>上面一篇 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/07.%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84McpServer.html" target="blank">实现一个简单的McpServer</a> 带大家构建了一个自己的McpServer，其功能非常简单，接下来我们尝试逐步进行补全，我们下来看一下，如何给其加上权限管控，避免服务被白嫖</p>
<h2> 一、MCP Server搭建</h2>
<p>我们直接在前面的搭建的McpServer基础上进行能力扩展，因此整个项目的搭建和相关配置与上文一致，这里不再赘述过程，只贴下核心的信息</p>
<h3> 1. 项目配置</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置文件指定mcp server相关参数：<code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. MCP Server创建</h3>
<p>一个根据传入时区，返回对应的时间的工具</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、权限管控</h2>
<h3> 1. 权限管理</h3>
<p>我们这里直接采用Http的权限管控，即在请求头中添加<code>Authorization</code>字段，值为<code>Bearer &lt;token&gt;</code> 或者 <code>Basic &lt;user:password&gt;</code>方式</p>
<p>为了针对MCP Server的权限进行管理，我们考虑通过自定义的<code>Filter</code>来实现，具体的逻辑为：</p>
<ul>
<li>拦截 <code>/sse</code>, <code>/mcp/messages</code>请求</li>
<li>校验请求头中的<code>Authorization</code>字段，判断是否满足要求</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的实现中，注意两点：</p>
<ul>
<li>注解<code>@WebFilter</code>，表示这是一个过滤器，并且异步支持（这个异步支持必须开启，否则mcp客户端无法正常连接）</li>
<li>拦截的url为<code>/sse</code>或者<code>/mcp/messages</code>: 这里我们分别处理sse请求和mcp请求，将他们与其他的请求区分开
<ul>
<li>鉴权逻辑：从请求头中获取<code>Authorization</code>字段，判断是否满足要求</li>
</ul>
</li>
</ul>
<p>然后调整启动类，支持扫描自定义的过滤器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. Trae调整MCP配置</h3>
<p>因为添加了权限管控，所以需要调整MCP的配置，在之前的基础上，加一个请求头</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来走一个验证对比，分别是没有添加权限的以及加了权限管控的</p>
<figure><img src="/imgs/column/springai/08-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>说明：如果是用户名+密码的鉴权方式，则可以将上面json配置中的 <code>Authorization</code>相关内容替换为:</p>
<ul>
<li><code>"Authorization": "Basic eWlodWk6MTIzNDU2Nzg="</code></li>
<li><code>eWlodWk6MTIzNDU2Nzg=</code> 为用户名密码的base64编码，解码之后为 <code>yihui:12345678</code></li>
</ul>
<h3> 3. 小结</h3>
<p>这里我们实现了一个简单的权限管控，通过自定义的过滤器来实现，具体的逻辑为：</p>
<ul>
<li>拦截 <code>/sse</code>, <code>/mcp/messages</code>请求</li>
<li>校验请求头中的<code>Authorization</code>字段，判断是否满足要求</li>
<li>添加权限的MCP配置</li>
</ul>
<p>当然，这里只是简单的实现，实际生产中，我们可以通过数据库来实现权限的存储和查询，也可以通过其他方式来实现权限的验证，例如通过JWT+OAuth2.0的方式来实现；不管是哪种方式，核心的原理依然是web应用鉴权这一套，无非是应用的场景不同，一个是web用户、一个是mcp客户端而已</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S08-mcp-server-basic-auth" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/08-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>09.ChatClient使用说明</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/09.ChatClient%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/09.ChatClient%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">09.ChatClient使用说明</source>
      <description>09.ChatClient使用说明 SpringAI中，ChatModel作为与大模型交互的具体实现，更上一层的应用推荐则是使用ChatClient，特别是在结构化输出、多轮对话的场景，ChatClient提供了更方便的调用方式 如结构化输出，两者的写法对比如下 // 结构化返回场景: // chatModel方式 BeanOutputConverter&amp;lt;ActorsFilms&amp;gt; beanOutputConverter = new BeanOutputConverter&amp;lt;&amp;gt;(ActorsFilms.class); String format = beanOutputConverter.getFormat(); PromptTemplate template = new PromptTemplate(&amp;quot;&amp;quot;&amp;quot; 帮我返回五个{actor}导演的电影名 {format} &amp;quot;&amp;quot;&amp;quot;); Prompt prompt = template.create(Map.of(&amp;quot;actor&amp;quot;, actor, &amp;quot;format&amp;quot;, format)); Generation generation = chatModel.call(prompt).getResult(); if (generation == null) { return null; } return beanOutputConverter.convert(generation.getOutput().getText()); // ChatClient方式 PromptTemplate template = new PromptTemplate(&amp;quot;帮我返回五个{actor}导演的电影名，要求中文返回&amp;quot;); Prompt prompt = template.create(Map.of(&amp;quot;actor&amp;quot;, actor)); ActorsFilms films = ChatClient.create(chatModel).prompt(prompt).call().entity(ActorsFilms.class);</description>
      <category>SpringAI</category>
      <pubDate>Fri, 01 Aug 2025 18:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 09.ChatClient使用说明</h1>
<p>SpringAI中，<code>ChatModel</code>作为与大模型交互的具体实现，更上一层的应用推荐则是使用<code>ChatClient</code>，特别是在结构化输出、多轮对话的场景，<code>ChatClient</code>提供了更方便的调用方式</p>
<p>如结构化输出，两者的写法对比如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 一、基本使用</h2>
<h3> 1. 创建ChatClient</h3>
<p><strong>使用自动配置的<code>ChatClient.Builder</code></strong></p>
<p>如果你的项目中，只有一个大模型使用，且使用的是官方提供的<code>starter</code>进行的接入，那么你可以直接使用SpringBoot自动装配的<code>ChatClient.Builder</code>来创建<code>ChatClient</code></p>
<p>如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，请注意，当一个应用中需要使用多个聊天模型时，则不能使用上面这种方式了，因为很难知道底层到底用的是哪个模型，此时则建议使用<code>ChatModel</code>进行创建</p>
<p><strong>使用ChatModel创建ChatClient</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. OpenAI兼容API的客户端初始化方式</h3>
<p>借助 <code>OpenAiApi</code> 与 <code>OpenAiChatModel</code> 类提供的 mutate() 方法，来实现兼容OpenAI API 的调用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 提示词传入</h3>
<p>创建<code>ChatClient</code>时，需要传入的<code>Prompt</code>对象用于和大模型进行交互，提供了三种方式</p>
<p><strong>直接接收String</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这种表示传入的文本，作为用户消息传送给大模型</p>
<p><strong>接收Prompt对象</strong></p>
<p>直接接收<code>Prompt</code>对象，具体的交互信息封装在<code>Prompt</code>对象中，由用户来管控</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>Fluent式</strong></p>
<p>通过无参方式启动FluentAPI，支持逐步构建系统消息、用户消息提示词</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 响应</h3>
<p>AI 模型返回的 <code>ChatResponse</code> 对象，封装了模型返回的 <code>Generation</code> 对象，以及一些元数据、token统计</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如我们希望获取用户的token情况，则可以在元数据中获取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>获取返回的消息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结构化输出，如需将返回的String映射为实体类，则可以考虑使用 <code>entity()</code> 来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/09-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>当然，前面介绍的结构化输出时，也提到了可以借助 <code>ParameterizedTypeReference</code> 来实现泛型等复杂类型的指定，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/09-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 流式调用</h3>
<p>流式调用，前面介绍的通过<code>call</code>方法实现同步请求大模型，等待模型返回结果，然后进行结果处理。我们平时使用大模型时，更常见的是流式的交互方式，问一个问题，对方一点一点的返回结果</p>
<p>对于<code>ChtClient</code>而言，要想实现流式调用，则需要借助<code>stream()</code>方法，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>访问示例如下：</p>
<figure><img src="/imgs/column/springai/09-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、进阶使用</h2>
<h3> 1. 提示词模板</h3>
<p><code>ChatClient</code> <code>Fluent</code> 式 API 支持提供含变量的用户/系统消息模板，运行时进行替换。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>默认使用的是 <code>{}</code> 的模板变量替换，当然如果你有诉求，想用 <code>&lt;&gt;</code> 进行替换（如提示词中包含json时，<code>{}</code>的方式可能不太适合了），可以如下进行调整</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. stream结构化返回</h3>
<p>使用 <code>call()</code> 同步调用时，结构化输出比较简单，直接通过 <code>entity()</code> 方法传入对象类型即可；对于流式的场景，由于大模型是逐步返回的，没有获取到完整的内容直接转换为目标对象，基本就是序列化异常了</p>
<p>对于 <code>stream</code> 方式，需要接过话输出时，可以考虑使用下面的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 默认值</h3>
<p>我们可以在<code>ChatClient</code>创建时，使用一些默认的系统消息、提示词设置（通过 <code>defaultXxx</code> 的方式）</p>
<p>如下面给出了提供默认的消息提示词（支持带参数） 和默认的模型参数设置</p>
<ul>
<li>说明：默认的配置，可以通过不带 <code>default</code> 前缀的相同方法进行覆盖</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/09-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. Advisor</h3>
<p><code>Advisor</code> API 为 Spring 应用中的 AI 驱动交互提供灵活强大的拦截、修改和增强能力。这个思路基本和AOP 类似，但是 <code>Advisor</code> 允许在运行时动态修改方法调用，从而实现更灵活的逻辑处理。</p>
<p>如我们希望在用户消息基础上追加或增强上下文数据时</p>
<ul>
<li>可以是RAG技术给大模型喂资料</li>
<li>也可以是集成聊天历史，实现多轮对话</li>
</ul>
<p>比如之前在介绍聊天上下文时，提到的借助<code>MessageChatMemoryAdvisor</code>来实现多轮对话</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/09-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>除了上面这个之外，另外一个记录<code>ChatClient</code>请求和返回的 <code>SimpleLoggerAdvisor</code> 也是常用的增强</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要查看日志，需要调整 advisor 包的日志级别设为 <code>DEBUG</code>，如下设置即可</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果觉得默认的输出不合心意，也可以在创建时，指定传参、返回的打印方式，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，当传入多个 <code>advisor</code> 时，传入的顺序很重要，决定了它们的执行顺序。每个 Advisor 都会以某种方式修改提示词或上下文，且一个 Advisor 所做的更改会传递给链中的下一个 Advisor。</p>
<h2> 三、小结</h2>
<p>本文的内容主要是相对成体系的介绍了一下前面几篇文章示例中的 <code>ChatClient</code> 的使用方式，同时也将前面的内容或多或少都覆盖了一部分。 通常来讲，我们与大模型之间的交互，更推荐的是基于<code>ChatClient</code>来实现,SpringAI对其上层使用，封装的很是齐全了，有兴趣的小伙伴可以赶紧体验一下</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S09-chat-client" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/09-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>10.Advisor实现SpringAI能力增强</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/10.Advisor%E5%AE%9E%E7%8E%B0SpringAI%E4%BA%A4%E4%BA%92%E5%A2%9E%E5%BC%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/10.Advisor%E5%AE%9E%E7%8E%B0SpringAI%E4%BA%A4%E4%BA%92%E5%A2%9E%E5%BC%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">10.Advisor实现SpringAI能力增强</source>
      <description>10.Advisor实现SpringAI能力增强 SpringAI通过Advisor API为拦截、修改、增强Spring应用中的AI交互提供了灵活且强大的能力支撑 核心优势在于：封装可复用的生成式AI模式、转换与大语言模型（LLM）交互的数据、实现跨模型与用例的可移植性。 一、基础知识 1. 核心组件 因为大模型一般支持同步/异步流式两种访问方式，相应的SpringAI也提供同步调用call 和 流式调用 stream 两种方式；</description>
      <category>SpringAI</category>
      <pubDate>Mon, 04 Aug 2025 14:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 10.Advisor实现SpringAI能力增强</h1>
<p>SpringAI通过<code>Advisor API</code>为拦截、修改、增强Spring应用中的AI交互提供了灵活且强大的能力支撑</p>
<p>核心优势在于：封装可复用的生成式AI模式、转换与大语言模型（LLM）交互的数据、实现跨模型与用例的可移植性。</p>
<h2> 一、基础知识</h2>
<h3> 1. 核心组件</h3>
<p>因为大模型一般支持同步/异步流式两种访问方式，相应的SpringAI也提供同步调用<code>call</code> 和 流式调用 <code>stream</code> 两种方式；</p>
<p>这两种不同的方式，对应的<code>Advisor</code>也不太一样</p>
<ul>
<li>流式：<code>StreamAdvisor</code> 和 <code>StreamAdvisorChain</code></li>
<li>非流式：<code>CallAdvisor</code> 和 <code>CallAdvisorChain</code></li>
</ul>
<p>接口定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>ChatClientRequest</code>表示未密封的请求参数，<code>ChatClientResponse</code>表示的聊天完成响应的结果</p>
<figure><img src="/imgs/column/springai/10-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的继承关系图也可以看出，核心的方法为 <code>adviseCall</code> 和 <code>adviseStream</code>，在这两个方法内，执行检查未密封的 Prompt 数据、定制与增强 Prompt 内容、调用 Advisor 链中的下一实体、选择性阻断请求、分析聊天完成响应，并通过抛出异常标识处理错误等步骤</p>
<ul>
<li>getOrder() 方法决定 Advisor 在链中的执行顺序</li>
<li>getName() 则提供唯一的 Advisor 标识名称</li>
</ul>
<h3> 2. Advisor执行流程</h3>
<p>下面流程图展示了 <code>Advisor</code> 链与聊天模型的交互过程：</p>
<figure><img src="/imgs/column/springai/10-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol>
<li>封装用户的提示词，创建 <code>ChatClientRequest</code> 对象，并创建一个空的 <code>Advisor</code>上下文对象</li>
<li>链中每个 <code>Advisor</code> 依次处理请求并可进行修改，也可选择阻断请求（不调用下一实体）。若选择阻断，该 <code>Advisor</code> 需负责填充响应内容。</li>
<li>链中的最后一个 <code>Advisor</code> 调用模型</li>
<li>聊天模型响应结果返回给 <code>Advisor Chain</code>，并被转换为包含共享 AdvisorContext 实例的 AdvisedResponse 对象。</li>
<li>链中每个 <code>Advisor</code> 一次处理或修改响应</li>
<li>通过提取 <code>ChatCompletion</code> 内容，最终生成的 <code>ChatClientResponse</code> 将返回给客户端</li>
</ol>
<h3> 3. 执行顺序</h3>
<p>链中 Advisor 的执行顺序由 getOrder() 方法决定</p>
<ol>
<li>数值越小，优先级越高</li>
<li><code>Advisor</code> 链采用栈式结构运作
<ul>
<li>链首的 <code>Advisor</code> 优先处理请求</li>
<li>链尾的 <code>Advisor</code> 优先处理响应</li>
</ul>
</li>
<li>控制执行顺序
<ul>
<li>通过调整 <code>order</code> 值，来控制执行顺序</li>
<li>当多个<code>Advisor</code>的<code>order</code>值相同时，则无法完全确认执行顺序</li>
</ul>
</li>
</ol>
<h2> 二、自定义<code>Advisor</code>开发</h2>
<p>接下来我们通过实现一个自定义的 <code>Advisor</code> 来实现大模型交互的耗时统计</p>
<h3> 1. 耗时统计Advisor</h3>
<p>接下来，我们实现一个简单的 <code>advisor</code> 用于统计大模型的耗时情况。首先创建一个 <code>CostAdvisor</code> 分别实现 <code>CallAdvisor</code> 和 <code>StreamAdvisor</code> 接口，让它同时适用于同步/流式场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来是关键的类实现，既然是耗时统计，那就设定这个 <code>Advisor</code> 优先级最高，在执行前后分别计时，用于获取耗时情况；并将相关信息写入到上下文中</p>
<p>因此一个完整的实现可以如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同步的实现比较好理解，重点说一下流式调用中，耗时时间的打印情况，这里借助的<code>MessageAggregator</code>工具类，用于将 Flux 响应聚合为 <code>AdvisedResponse</code>。适用于观察完整响应（即回答完毕之后），记录耗时时间</p>
<p>其次就是上下文的传递，可以通过 <code>chatClientRequest.context().put("start-time", start);</code> 和 <code>response.context().put("end-time", end);</code> 方式设置用于共享的上下文参数</p>
<h3> 2. 测试验证</h3>
<p>写一个简单的端点用于验证 CostAdvisor</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/10-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的访问截图也可以看出，<code>CostAdvisor</code> 拦截了请求，并记录了耗时情况，并打印在控制台</p>
<h2> 三、小结</h2>
<p>本篇文章主要介绍了SpringAI如何通过 <code>Advisor</code> 来实现大模型交互能力的增强，并通过实现了一个简单的 <code>CostAdvisor</code> 演示如何实现自定义的advisor</p>
<p>SpringAI 内置了一些常用的 advisor， 比如我们之前介绍过的上下文、日志打印等</p>
<ol>
<li>对话历史相关</li>
</ol>
<ul>
<li><code>MessageChatMemoryAdvisor</code>
<ul>
<li>检索记忆并将其作为信息集合添加到提示中。这种方法可以保持对话历史的结构。注意，并非所有人工智能模型都支持这种方法。</li>
</ul>
</li>
<li><code>PromptChatMemoryAdvisor</code>
<ul>
<li>检索记忆内容并将其整合到提示词的系统文本中。</li>
</ul>
</li>
<li><code>VectorStoreChatMemoryAdvisor</code>
<ul>
<li>从向量存储库检索记忆内容并注入提示词的系统文本。该 Advisor 能高效搜索海量数据集中的相关信息。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>问答相关</li>
</ol>
<ul>
<li><code>QuestionAnswerAdvisor</code>
<ul>
<li>该 Advisor 通过向量存储实现问答功能，采用检索增强生成（RAG）模式。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>内容安全</li>
</ol>
<ul>
<li><code>SafeGuardAdvisor</code>
<ul>
<li>基础防护型 Advisor，用于阻止模型生成有害或不恰当内容。</li>
</ul>
</li>
</ul>
<p>此外需要重点注意的是，我们实现的 <code>advisor</code> 需要同时考虑同步和流式的两种方式</p>
<figure><img src="/imgs/column/springai/10-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>非流式 Advisor 处理完整请求与响应。</li>
<li>流式 Advisor 采用响应式编程理念（如 Flux 处理响应），以连续流形式处理请求与响应。</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S10-cost-advise" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/10-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>11.图像模型生成图片</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/11.%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%9E%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/11.%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%9E%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">11.图像模型生成图片</source>
      <description>11.图像模型生成图片 截止到目前为止，我们所有的体验的还仅限于聊天模型，一问一答，且都是基于文本的交互方式；现在主流的模型的应用场景，涉及图像识别、图像生成、图像检索、图像处理等等，SpringAI也提供了相应的模型接口，方便开发者进行图像模型应用的开发 接下来我们通过一个实例，来看一下在SpringAI中，如何接入图像模型 一、准备工作 首先还是得准备一个大模型的开发者账号，同样的为了简化大家的使用成本，我们依然采用免费的大模型 - 智谱 来完成</description>
      <category>SpringAI</category>
      <pubDate>Mon, 04 Aug 2025 15:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 11.图像模型生成图片</h1>
<p>截止到目前为止，我们所有的体验的还仅限于聊天模型，一问一答，且都是基于文本的交互方式；现在主流的模型的应用场景，涉及图像识别、图像生成、图像检索、图像处理等等，SpringAI也提供了相应的模型接口，方便开发者进行图像模型应用的开发</p>
<p>接下来我们通过一个实例，来看一下在SpringAI中，如何接入图像模型</p>
<h2> 一、准备工作</h2>
<p>首先还是得准备一个大模型的开发者账号，同样的为了简化大家的使用成本，我们依然采用免费的大模型 - <a href="https://www.bigmodel.cn/pricing" target="_blank" rel="noopener noreferrer">智谱</a> 来完成</p>
<h3> 1. 模型选择</h3>
<p>智谱官方提供了两个免费的多模态模型，分别为</p>
<ul>
<li>CogView-3-Flash: 生成图片</li>
<li>CogVideoX-Flash: 生成视频</li>
</ul>
<figure><img src="/imgs/column/springai/11-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 创建密钥</h3>
<p>在智普的开放平台获取密钥：<a href="https://open.bigmodel.cn/usercenter/proj-mgmt/apikeys" target="_blank" rel="noopener noreferrer">https://open.bigmodel.cn/usercenter/proj-mgmt/apikeys</a></p>
<figure><img src="/imgs/column/springai/01-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后在配置文件中，添加智普的密钥</p>
<h3> 3. 配置密钥</h3>
<p>在配置文件 <code>application.yml</code> 中，指定密钥和默认的模型</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的 model，这里使用是图像生成的模型，与前面介绍的聊天模型中的 <code>GLM-4-Flash</code> 不一致</p>
<h2> 二、图像模型使用</h2>
<p>接下来我们正式进入图像模型的使用环节，具体的项目创建过程，与之前的并无差别，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 依赖配置</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 创建一个控制器</h3>
<p>我们创建一个文生图的控制器，定义一个基于智谱图像模型的端点 <code>/genImg</code>， 生成之后，将返回的图片链接下载图片文件，直接返回给前端</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p>
<ul>
<li>具体的使用方式，直接基于 <code>ImageModel</code> 的调用来实现图片生成</li>
<li>实测： <code>ImageOptions</code> 中 <code>model</code> 参数，比填，不然不会使用配置中默认指定的 <code>CogView-3-Flash</code></li>
</ul>
<p>官方实现这里存在bug，由于传参没指定model，被sdk中默认的<code>cogview-3</code>给覆盖了（而不是默认选项中的 <code>CogView-3-Flash</code>）</p>
<figure><img src="/imgs/column/springai/11-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/imgs/column/springai/11-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 测试验证</h3>
<p>接下来我们启动项目，验证一下图像模型的实际表现</p>
<figure><img src="/imgs/column/springai/11-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>题外话：生成的卡通图片还差强人意，如果换成写实风，这个模型的表现效果就很不理想了😂 （不过毕竟是免费的，还能要求啥呢~）</p>
<p>请重点注意： 智谱的 <code>ImageModel</code> 的实现是不支持生成视频的，最直接的证据就是 <code>ZhiPuAiImageApi</code> 的实现中访问的path路径是 <code>/v4/images/generations</code>，而视频的访问路径应该是 <code>/v4/videos/generations</code>，且交互方式也不一致（视频是异步查询返回结果）;</p>
<p>目前<code>1.0.0</code>版本以及<code>1.1.0-SNAPSHOT</code>的<code>spring-ai-zhipuai</code>客户端，没有实现视频模型的访问；如有需要，需自己实现</p>
<h2> 三、小结</h2>
<p>本文主要介绍了图像模型的使用，虽然是以智谱为例进行的实例介绍；其他的模型使用姿势，实际也差不多，通用的使用方式如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S11-image-model" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/11-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>12.多模态实现图片卡路里识别</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/12.%E5%A4%9A%E6%A8%A1%E6%80%81%E5%AE%9E%E7%8E%B0%E9%A3%9F%E6%9D%90%E5%9B%BE%E7%89%87%E5%8D%A1%E8%B7%AF%E9%87%8C%E8%AF%86%E5%88%AB%E7%A4%BA%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/12.%E5%A4%9A%E6%A8%A1%E6%80%81%E5%AE%9E%E7%8E%B0%E9%A3%9F%E6%9D%90%E5%9B%BE%E7%89%87%E5%8D%A1%E8%B7%AF%E9%87%8C%E8%AF%86%E5%88%AB%E7%A4%BA%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">12.多模态实现图片卡路里识别</source>
      <description>12.多模态实现图片卡路里识别 现在大模型的快速发展，已经让其不仅只接受文本，也可以接受图像、音频、视频等多模态数据，SpringAI也提供了相应的模型接口，方便开发者进行多模态模型应用开发 如如 OpenAI 的GPT-4o、Google 的Vertex AI Gemini 1.5、Anthropic 的 Claude3，以及开源模型 Llama3.2、LLaVA 和 BakLLaVA，都能接受文本、图像、音频和视频等多种输入，并通过整合这些输入生成文本响应。 SpringAI提供了非常简单的多模态输入集成，接下来我们通过一个简单实例，来看一下在SpringAI中，如何接入多模态模型</description>
      <category>SpringAI</category>
      <pubDate>Mon, 04 Aug 2025 17:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 12.多模态实现图片卡路里识别</h1>
<p>现在大模型的快速发展，已经让其不仅只接受文本，也可以接受图像、音频、视频等多模态数据，SpringAI也提供了相应的模型接口，方便开发者进行多模态模型应用开发</p>
<p>如如 OpenAI 的GPT-4o、Google 的Vertex AI Gemini 1.5、Anthropic 的 Claude3，以及开源模型 Llama3.2、LLaVA 和 BakLLaVA，都能接受文本、图像、音频和视频等多种输入，并通过整合这些输入生成文本响应。</p>
<p>SpringAI提供了非常简单的多模态输入集成，接下来我们通过一个简单实例，来看一下在SpringAI中，如何接入多模态模型</p>
<h2> 一、准备工作</h2>
<p>首先还是得准备一个大模型开发者账号，同样的为了简化大家使用的成本，我们依然采用免费的大模型 - <a href="https://www.bigmodel.cn/pricing" target="_blank" rel="noopener noreferrer">智谱</a> 来完成</p>
<h3> 1. 模型选择</h3>
<p>我们这里选择的是官方提供的免费图像理解模型 <code>GLM-4V-Flash</code>，基于它来做一个食物图片的分类和卡路里计算</p>
<h3> 2. 项目创建</h3>
<p>创建一个SpringBoot项目，并引入SpringAI依赖，基本流程如 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：我们这里使用 huttol-http 进行互联网的图片下载</p>
<h3> 3. 密钥配置</h3>
<p>在配置文件中，指定密钥和默认的模型</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、多模态使用</h2>
<p>接下来我们进入多模态的实例开发</p>
<h3> 1. 图片识别控制器</h3>
<p>定义一个图片识别控制器，接收图片的URL，并返回识别结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的实现方式也可以看出，多模态的使用方式与<code>ChatModel</code>的使用方式基本一致，只是在构建用户消息的时候，携带了一个 <code>Media</code> 类型的输入</p>
<h3> 2. 测试</h3>
<p>为了测试，使用大模型帮我们生成一张食物图，避免版权纷争</p>
<figure><img src="/imgs/column/springai/12-1.webp" alt="待识别图" tabindex="0" loading="lazy"><figcaption>待识别图</figcaption></figure>
<p>然后访问测试接口，传入图片的URL，并指定识别的提示语</p>
<div class="language-curl line-numbers-mode" data-ext="curl"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/12-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 结构化输出</h3>
<p>上面直接返回的文本，不太方便我们的业务使用，因此可以考虑将返回结果进行结构化约束，比如，定义我们希望接受的对象（通过 <code>@JsonPropertyDescription</code> 注解来约束字段描述，在生成jsonSchema给大模型时，会将这些描述信息返回给模型）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后调整下多模态的调用，通过<code>entity()</code>来定义返回</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/12-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、小结</h2>
<p>本文主要介绍了多模态的使用，虽然以智谱为例进行了实例介绍；其他的模型使用姿势，实际也差不多，基本上都是<code>ChatModel/ChatClient</code>的使用方式，通过在构建用户消息的时候，携带一个 <code>Media</code> 类型的图片或者音视片资源，即可实现多模态的调用</p>
<p>但是，请注意，在使用多模态之前，前先确认对应的大模型是否支持多模态的调用，否则，可能会导致调用失败</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S12-multimodality-model" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/12-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>13.支持MCP Client的AI对话实现</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/13.%E6%94%AF%E6%8C%81MCP%20Client%E7%9A%84AI%E5%AF%B9%E8%AF%9D%E5%AE%9E%E7%8E%B0.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/13.%E6%94%AF%E6%8C%81MCP%20Client%E7%9A%84AI%E5%AF%B9%E8%AF%9D%E5%AE%9E%E7%8E%B0.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">13.支持MCP Client的AI对话实现</source>
      <description>13.支持MCP Client的AI对话实现 前面介绍了通过SpringAI来实现MCP Server，接下来我们再看一下，通过SpringAI来实现一个支持上次实现的MCP Client的AI对话 一、项目初始化 SpringAI MCP客户端的starter，提供了MCP客户端的自动配置，支持多种传输方式（本地+网络），支持同步、异步的调用 1. 项目创建 创建一个SpringBoot项目，并引入SpringAI依赖，基本流程如 创建一个SpringAI-Demo工程</description>
      <category>SpringAI</category>
      <pubDate>Tue, 05 Aug 2025 17:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 13.支持MCP Client的AI对话实现</h1>
<p>前面介绍了通过SpringAI来实现MCP Server，接下来我们再看一下，通过SpringAI来实现一个支持上次实现的<code>MCP Client</code>的<code>AI</code>对话</p>
<h2> 一、项目初始化</h2>
<p>SpringAI MCP客户端的starter，提供了MCP客户端的自动配置，支持多种传输方式（本地+网络），支持同步、异步的调用</p>
<h3> 1. 项目创建</h3>
<p>创建一个SpringBoot项目，并引入SpringAI依赖，基本流程如 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>spring-ai-starter-mcp-client</code>依赖，提供了MCP客户端的starter，使用的是智谱的免费大模型<code>GLM-4-Flash</code></p>
<p>其次我们使用 <code>thymeleaf + htmx</code> 来实现一个简单的聊天界面</p>
<h3> 2. 项目配置</h3>
<p>在配置文件中，除了指定大模型的密钥、模型之外，还需要配置MCP客户端的参数</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们这里的使用的<code>MCP Server</code>为<a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S07-mcp-server" target="_blank" rel="noopener noreferrer">S07-mcp-server</a>中实现的根据地区获取当前时间的服务</p>
<h2> 二、MCP Client实现</h2>
<p>SpringAI 对MCP Client 的实现封装的非常好了，对于上层应用而言，直接可以通过自定注入的 <code>ToolCallbackProvider</code>，将mcp client作为大模型的工具调用添加到模型中，然后通过模型调用，即可完成MCP的使用演示</p>
<h3> 1. 初始化ChatClient</h3>
<p>直接通过模型和<code>ToolCallbackProvider</code>，来创建支持mcp调用的 <code>ChatClient</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 实现聊天对话</h3>
<p>聊天对话的实现，非常简单，通过 <code>ChatClient</code> 调用模型，并返回结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 前端聊天页面实现</h3>
<p>聊天主页 index.html</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对话历史 <code>chat.html</code></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 使用测试</h3>
<p>首先，启动mcp server， 然后再启动聊天对话框；然后开始对话</p>
<figure><img src="/imgs/column/springai/13-1.webp" alt="直接询问当前时间" tabindex="0" loading="lazy"><figcaption>直接询问当前时间</figcaption></figure>
<figure><img src="/imgs/column/springai/13-2.webp" alt="业务场景中携带时间" tabindex="0" loading="lazy"><figcaption>业务场景中携带时间</figcaption></figure>
<h2> 三、小结</h2>
<p>本文主要介绍将MCP Client的使用，整体应用起来，比较简单，甚至是比function calling更简单（因为自动将mcp服务注入为<code>ToolCallbackProvider</code>，可以直接传入<code>ChatClient</code>用作大模型的工具调用）</p>
<p>当然除了上面这种方式之外，我们也可以直接使用MCP Client来进行交互</p>
<blockquote>
<p>MCPClient 使用姿势参考官方文档： <a href="https://modelcontextprotocol.io/sdk/java/mcp-client" target="_blank" rel="noopener noreferrer">java-mcp-client</a></p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/13-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S13-mcp-client-chat" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/13-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>基础篇</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">基础篇</source>
      <description>主要介绍SpringAI的基础使用，对应的项目工程以 Sxx- 开头，通过这些实例，您将掌握SpringAI的基础知识（如提示词、上下文、架构化输出、tool calling, MCP, advise, ChatClient, 多模型等），并开始使用SpringAI进行大模型应用开发</description>
      <pubDate>Fri, 08 Aug 2025 02:51:24 GMT</pubDate>
      <content:encoded><![CDATA[<p>主要介绍SpringAI的基础使用，对应的项目工程以 <code>Sxx-</code> 开头，通过这些实例，您将掌握SpringAI的基础知识（如提示词、上下文、架构化输出、tool calling, MCP, advise, ChatClient, 多模型等），并开始使用SpringAI进行大模型应用开发</p>
]]></content:encoded>
    </item>
    <item>
      <title>应用篇</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%BA%94%E7%94%A8%E7%AF%87/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%BA%94%E7%94%A8%E7%AF%87/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">应用篇</source>
      <description>以搭建完整可用的SpringAI应用为目的，演示SpringAI的业务边界和表现</description>
      <pubDate>Fri, 08 Aug 2025 02:51:24 GMT</pubDate>
      <content:encoded><![CDATA[<p>以搭建完整可用的SpringAI应用为目的，演示SpringAI的业务边界和表现</p>
]]></content:encoded>
    </item>
    <item>
      <title>源码篇</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E6%BA%90%E7%A0%81%E7%AF%87/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E6%BA%90%E7%A0%81%E7%AF%87/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">源码篇</source>
      <description>以源码的视角，介绍SpringAI的核心实现</description>
      <pubDate>Fri, 08 Aug 2025 02:51:24 GMT</pubDate>
      <content:encoded><![CDATA[<p>以源码的视角，介绍SpringAI的核心实现</p>
]]></content:encoded>
    </item>
    <item>
      <title>01.使用数据库持久化对话历史</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A01.%E4%BD%BF%E7%94%A8MySql%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A01.%E4%BD%BF%E7%94%A8MySql%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.使用数据库持久化对话历史</source>
      <description>01.使用数据库持久化对话历史 本文作为SpringAI的进阶篇，将介绍一些在实际应用中，可能用到的小技巧。在基础篇的 04.聊天上下文 中，介绍并演示了基于 InMemoryChatMemoryRepository 来存储对话历史，从而实现多轮对话 在实际的业务场景中，用InMemoryChatMemoryRepository的场景可能还会更少一点，毕竟上下文放在内存中，不利于后续的审计以及应用重启之后数据就丢失了</description>
      <category>SpringAI</category>
      <pubDate>Thu, 07 Aug 2025 10:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 01.使用数据库持久化对话历史</h1>
<p>本文作为SpringAI的进阶篇，将介绍一些在实际应用中，可能用到的小技巧。在基础篇的 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/04.%E8%81%8A%E5%A4%A9%E4%B8%8A%E4%B8%8B%E6%96%87.html" target="blank">04.聊天上下文</a>
中，介绍并演示了基于 <code>InMemoryChatMemoryRepository</code> 来存储对话历史，从而实现多轮对话</p>
<p>在实际的业务场景中，用<code>InMemoryChatMemoryRepository</code>的场景可能还会更少一点，毕竟上下文放在内存中，不利于后续的审计以及应用重启之后数据就丢失了</p>
<p>那么如何将对话持久化存储呢?</p>
<p>本文将介绍基于数据库的持久方案，将从两个方面进行介绍</p>
<ol>
<li>通过实例演示数据库的持久化使用方式</li>
<li>介绍一些关键的实现技术点</li>
</ol>
<h2> 一、项目演示</h2>
<h3> 1. 创建项目</h3>
<p>创建一个SpringAI项目，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 2. 添加依赖</h3>
<p>在pom.xml中添加关键依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 配置数据库连接</h3>
<p>在配置文件 <code>application.yml</code> 文件中，指定SpringAI配置 + 数据库连接信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于<code>spring.ai.chat.memory.repository.jdbc</code>的配置进行一些必要的说明</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
<th>取值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>spring.ai.chat.memory.repository.jdbc.initialize-schema</code></td>
<td>控制什么时候初始化schema</td>
<td>embeded(默认)/always/never</td>
</tr>
<tr>
<td><code>spring.ai.chat.memory.repository.jdbc.schema</code></td>
<td>指定数据库的schema的位置</td>
<td><code>classpath:org/springframework/ai/chat/memory/repository/jdbc/schema-@@platform@@.sql</code></td>
</tr>
<tr>
<td><code>spring.ai.chat.memory.repository.jdbc.platform</code></td>
<td>数据库平台，如mysql/h2/postgresql等</td>
<td>默认会自动检测</td>
</tr>
</tbody>
</table>
<p>在上面的配置中，我们的 <code>initialize-schema</code> 配置为 <code>always</code>，表示在启动的时候会自动创建数据库表（即便表存在，也会尝试执行脚本；我们这里使用的是MySql，因此需要自动创建表<code>SPRING_AI_CHAT_MEMORY</code>）</p>
<ol>
<li>ALWAYS</li>
</ol>
<ul>
<li>无论何时都会执行数据库初始化</li>
<li>即使数据库已存在，也会尝试运行初始化脚本</li>
<li>适用于每次启动都需要重新初始化数据库的场景</li>
</ul>
<ol start="2">
<li>EMBEDDED</li>
</ol>
<ul>
<li>仅在使用嵌入式数据库时执行初始化</li>
<li>对于H2、HSQL、Derby等嵌入式数据库会自动初始化</li>
<li>对于外部数据库（如MySQL、PostgreSQL）则跳过初始化</li>
<li>这是大多数情况下的推荐设置</li>
</ul>
<ol start="3">
<li>NEVER</li>
</ol>
<ul>
<li>从不执行数据库初始化</li>
<li>完全跳过所有数据库schema和data脚本的执行</li>
<li>适用于生产环境或已有数据库结构的情况</li>
</ul>
<p>对应的Schema所在的位置如下图</p>
<figure><img src="/imgs/column/springai/A01-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 初始化 ChatMemory</h3>
<p>当我们引入 <code>spring-ai-starter-model-chat-memory-repository-jdbc</code> 之后，会自动注入 <code>ChatMemoryRepository</code>
的bean对象，我们接下来基于它来创建<code>ChatMemory</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. ChatClient 配置</h3>
<p>然后通过<code>MessageChatMemoryAdvisor</code>来为<code>ChatClient</code>提供聊天历史能力支撑</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 示例测试</h3>
<p>提供一个聊天接口，第一个参数为用户标识，用于区分用户的聊天记录</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/A01-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、关键技术点</h2>
<p>使用MySql来存储用户与大模型的对话情况，从使用角度来看，还比较简单；接下来我们抓一下技术要点，从疑问出发，看下能否完成解惑</p>
<ol>
<li>持久化的数据表结构是如何设计的？</li>
<li>数据库表是如何初始化的？</li>
<li>又是如何实现自动识别数据库平台的？</li>
<li>如果想使用自定义的数据库表，替代默认的，可以怎么实现？</li>
</ol>
<h3> 1. 默认的表结构设计</h3>
<p>关于这个一点，前面介绍配置的时候也提到了，在<code>spring-aimodel-chat-memory-repository-jdbc</code>的包中，提供了5个schema文件，对应的源码工程结果如下</p>
<figure><img src="/imgs/column/springai/A01-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>以mysql为例，对应的schema如下</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义了四个字段，分别为：</p>
<ul>
<li><code>conversation_id</code>: 会话ID，用于区分不同的会话</li>
<li><code>content</code>: 会话内容，可以是用户输入，也可以是模型输出</li>
<li><code>type</code>: 会话类型，可以是用户输入，也可以是模型输出，也可以是系统信息，也可以是工具信息</li>
<li><code>timestamp</code>: 会话时间，用于排序</li>
</ul>
<h3> 2. 数据库初始化</h3>
<p>通过配置 <code>spring.ai.chat.memory.repository.jdbc.initialize-schema</code> 来控制； 为 <code>always</code>，会自动创建数据库表（即便表存在，也会尝试执行脚本）</p>
<p>这里主要是通过<code>JdbcChatMemoryRepositorySchemaInitializer</code>来实现schema脚本的初始化行为，依赖的是Spring Boot 中用于数据库初始化的组件<code>DataSourceScriptDatabaseInitializer</code></p>
<ul>
<li>检查数据库初始化模式（DatabaseInitializationMode）</li>
<li>根据配置查找相应的 SQL 脚本文件</li>
<li>使用配置的 DataSource 连接数据库</li>
<li>按顺序执行 schema 脚本和 data 脚本</li>
<li>处理脚本执行过程中的异常</li>
</ul>
<h3> 3. 自动识别数据库平台</h3>
<p>关键实现逻辑  <code>org.springframework.ai.chat.memory.repository.jdbc.JdbcChatMemoryRepositoryDialect.from</code></p>
<figure><img src="/imgs/column/springai/A01-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>根据数据库连接来判断当前使用的是哪个数据库，默认的是 <code>postgresql</code></p>
<h3> 4. 自定义数据库表结构</h3>
<p>默认的表结构满足大部分场景，如果需要自定义表结构，可以通过实现 <code>JdbcChatMemoryRepositoryDialect</code> 接口来自定义，并注册到 Spring 容器中</p>
<p>比如默认的MySql相关sql如下，若需要调整表名、字段名，替换下面的这个类，然后注册到 <code>JdbcChatMemoryRepository</code> 中即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点说明：换表名、字段名还好，如果我想额外存储用户的token使用情况，可行吗？</p>
<p>从源码来看，不可行，上面的 <code>Dialect</code> 中的<code>insert</code>，已经绑定了字段，无法进行动态扩展</p>
<figure><img src="/imgs/column/springai/A01-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、小结</h2>
<p>本文介绍的是基于MySql持久化对话历史的实现方案，Spring AI 默认使用 JdbcChatMemoryRepository 来实现，基于 MySql 的表结构，可以满足大部分场景，如果需要自定义表结构，可以通过实现 <code>JdbcChatMemoryRepositoryDialect</code> 接口来自定义</p>
<p>通过使用实例和一些关键性的技术说明，对于官方未直接支持的数据库，我们也可以很方便的进行扩展；当然现在的实现还存在一点缺陷，那就是无法自定义持久化的信息</p>
<p>接下来一篇博文，我们将实例演示，如何使用 h2 数据库进行持久化</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects/A01-memory-jdbc-mysql" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/A01-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>02.使用H2持久化对话历史</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A02.%E4%BD%BF%E7%94%A8H2%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A02.%E4%BD%BF%E7%94%A8H2%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">02.使用H2持久化对话历史</source>
      <description>02.使用H2持久化对话历史 上面一篇文章介绍了 SpringAI官方提供的 jdbc start来实现持久化对话历史 使用MySql持久化对话历史，官方实现的几个数据库已经很有代表性了，接下来我们将看一下，如果沿用官方的思路，来为h2添加持久化对话历史功能。</description>
      <category>SpringAI</category>
      <pubDate>Thu, 07 Aug 2025 11:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 02.使用H2持久化对话历史</h1>
<p>上面一篇文章介绍了 SpringAI官方提供的 jdbc start来实现持久化对话历史 <a href="/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A01.%E4%BD%BF%E7%94%A8MySql%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html" target="blank">使用MySql持久化对话历史</a>，官方实现的几个数据库已经很有代表性了，接下来我们将看一下，如果沿用官方的思路，来为h2添加持久化对话历史功能。</p>
<h2> 一、H2持久化对话历史</h2>
<h3> 1. 创建项目</h3>
<p>创建一个SpringAI项目，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 2. 添加依赖</h3>
<p>在pom.xml中添加关键依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 配置数据库连接</h3>
<p>在配置文件 <code>application.yml</code> 文件中，指定SpringAI配置 + 数据库连接信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明，虽然我们这里使用的是 H2，但是 <code>spring.ai.chat.memory.repository.jdbc.initialize-schema</code> 配置项，还是建议选择 <code>always</code>，因为上面配置的是使用文件来存储db；如果使用内存 <code>jdbc:h2:mem</code> 的方式，则这里可以选择 <code>embedded</code></p>
<figure><img src="/imgs/column/springai/A02-1.webp" alt="embeded是否创建表的关键判断逻辑" tabindex="0" loading="lazy"><figcaption>embeded是否创建表的关键判断逻辑</figcaption></figure>
<p>其次就是我们需要指定 <code>schema</code> 文件，这个文件，就是用来创建数据库表结构，这里我们使用 <code>h2</code> 的默认结构，因此这里我们使用 <code>classpath:schema-h2.sql</code></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 初始化 ChatMemory</h3>
<p>因为我们使用的是系统未提供支持的h2，因此无法使用自动注入的<code>ChatMemoryRepository</code>，因为它选择的Dialect是 <code>PostgresChatMemoryRepositoryDialect</code>，无法支持h2的使用场景</p>
<p>我们这里直接使用<code>MysqlChatMemoryRepositoryDialect</code>来作为h2的Dialect（当然也可以自行实现一个Dialect）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. ChatClient 配置</h3>
<p>然后通过<code>MessageChatMemoryAdvisor</code>来为<code>ChatClient</code>提供聊天历史能力支撑</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 示例测试</h3>
<p>提供一个聊天接口，第一个参数为用户标识，用于区分用户的聊天记录</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动成功之后，我们可以在h2-console中看到新增了一个表 <code>SPRING_AI_CHAT_MEMORY</code></p>
<figure><img src="/imgs/column/springai/A02-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后进行多轮对话，看看效果，表现和我们预期一致，聊天记录被保存在数据库中</p>
<figure><img src="/imgs/column/springai/A02-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、小结</h2>
<p>本文介绍的是如何借助 <code>spring-ai-starter-model-chat-memory-repository-jdbc</code> 来实现自定义的对话持久化，通过实现h2的Dialect，我们可以轻松实现自定义的持久化逻辑；若希望了解持久化的更多实现细节，可以查看上篇 <a href="/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A01.%E4%BD%BF%E7%94%A8MySql%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html" target="blank">使用MySql持久化对话历史</a></p>
<p>这里实现的是基于数据库来进行持久化，那么如果我不是用数据库，比如希望用文件或者redis来实现，又可以怎么做呢？</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects/A02-memory-jdbc-h2" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/A02-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>03.使用Redis持久化对话历史</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A03.%E4%BD%BF%E7%94%A8Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A03.%E4%BD%BF%E7%94%A8Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">03.使用Redis持久化对话历史</source>
      <description>03.使用Redis持久化对话历史 前面介绍了使用关系数据库来存储对话历史，接下来我们更进一步，通过扩展ChatMemoryRepository来实现基于Redis的持久化 一、Redis持久化对话历史 1. 创建项目 创建一个SpringAI项目，基本流程同 创建一个SpringAI-Demo工程</description>
      <category>SpringAI</category>
      <pubDate>Thu, 07 Aug 2025 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 03.使用Redis持久化对话历史</h1>
<p>前面介绍了使用关系数据库来存储对话历史，接下来我们更进一步，通过扩展<code>ChatMemoryRepository</code>来实现基于Redis的持久化</p>
<h2> 一、Redis持久化对话历史</h2>
<h3> 1. 创建项目</h3>
<p>创建一个SpringAI项目，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 2. 添加依赖</h3>
<p>在pom.xml中添加关键依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接依赖<code>spring-ai-starter-model-chat-memory</code>来实现聊天记录，这里采用redis来进行持久化，因此我们添加redis的相关依赖（这里一jedis客户端为例，对于lettuce或者redisson实际上没有太大的差别）</p>
<h3> 3. 配置</h3>
<p>在配置文件 <code>application.yml</code> 文件中，指定redis相关配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们这里使用单节点的redis进行演示；对于集群的场景，除了配置不一样之外，实际上对于我们的实现并没有太大的差别（因为我们利用的是Spring封装的RedisTemplate进行操作，因此对于集群的场景，实际上也是可以的）</p>
<h3> 4. 实现RedisChatMemoryRepository</h3>
<p>通过实现接口<code>ChatMemoryRepository</code>来完成我们的 RedisChatMemoryRepository</p>
<p>对于用户聊天记录，我们采用redis的列表的数据结构进行存储(具体实现除了这种方案之外，也可以使用hash数据结构来存储，field为会话id，value为对话记录)</p>
<ul>
<li>key: <code>chat:${conversationId}</code></li>
<li>value: [] , 消息列表</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于redis的存储实现相对来讲并不算复杂，无非就是Message的读取与写入，这里我们采用json进行序列化与反序列化</p>
<p>我们实现一个自定义的反序列化策略，在获取数据时，只要Message中的 <code>messageType</code> + <code>text</code>，因为这些会一并传递给大模型，其他的元数据并没有太大意义，还会消耗我们的token</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的JsonUtil的实现则比较基础，一个统一的json工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 定义ChatMemory</h3>
<p>定义一个自定义的ChatMemory，这里我们使用 <code>RedisChatMemoryRepository</code> 来作为消息的存储仓库</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 示例测试</h3>
<p>提供一个聊天接口，第一个参数为用户标识，用于区分用户的聊天记录</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/A03-1.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、小结</h2>
<p>本文介绍的是如何通过实现SpringAI定义的<code>ChatMemoryRepository</code>接口来完成自定义的对话记录持久化，通过这种方式，可以实现更灵活的上下文管控</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects/A03-memory-redis" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/A03-1.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>进阶篇</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">进阶篇</source>
      <description>进阶相关将主要介绍如何更好的使用SpringAI进行大模型应用开发</description>
      <pubDate>Fri, 08 Aug 2025 02:51:24 GMT</pubDate>
      <content:encoded><![CDATA[<p>进阶相关将主要介绍如何更好的使用SpringAI进行大模型应用开发</p>
]]></content:encoded>
    </item>
    <item>
      <title>7. 基于AI开发三端产品-文渊阁原型设计</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aicoding/07.%E5%9F%BA%E4%BA%8EAI%E5%BC%80%E5%8F%91%E4%BA%A7%E5%93%81-%E6%96%87%E6%B8%8A%E9%98%81%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aicoding/07.%E5%9F%BA%E4%BA%8EAI%E5%BC%80%E5%8F%91%E4%BA%A7%E5%93%81-%E6%96%87%E6%B8%8A%E9%98%81%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7. 基于AI开发三端产品-文渊阁原型设计</source>
      <description>一恍惚25年就已经过了一半，上半年借助AI开发工具也做了不少小玩具；在下半年，给自己订一个小目标，做一个完整功能更完整的产品，计划做三端（PC、小程序、APP），并且包含独立的后端服务能力。 实际上我个人也没有特别想做的东西，正好小朋友最近开始学习识字、背诗，那就做一个中华文化知识相关的产品得了 一、 前置准备 有想法之后，第一件事情，当然是全网搜一下，有没有类似的可以学习致敬（抄袭）的竞品 知乎上有一个挺好的话题，- 有没有公认比较好的诗词APP推荐？ - 知乎</description>
      <category>AI</category>
      <pubDate>Tue, 08 Jul 2025 07:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>一恍惚25年就已经过了一半，上半年借助AI开发工具也做了不少小玩具；在下半年，给自己订一个小目标，做一个完整功能更完整的产品，计划做三端（PC、小程序、APP），并且包含独立的后端服务能力。</p>
<p>实际上我个人也没有特别想做的东西，正好小朋友最近开始学习识字、背诗，那就做一个中华文化知识相关的产品得了</p>
<h2> 一、 前置准备</h2>
<p>有想法之后，第一件事情，当然是全网搜一下，有没有类似的可以学习致敬（抄袭）的竞品</p>
<p>知乎上有一个挺好的话题，- <a href="https://www.zhihu.com/question/21528388" target="_blank" rel="noopener noreferrer">有没有公认比较好的诗词APP推荐？ - 知乎</a></p>
<p>推荐的产品还挺多，app/网站/小程序均有，下面是摘抄目录</p>
<figure><img src="/imgs/column/ai/7-1.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>产品有一些可以学习的对象；接下来再看看开源社区上是否有可以拿来当“基座”的原型😊</p>
<p>比如一些数据源：</p>
<ul>
<li><a href="https://github.com/caoxingyu/chinese-gushiwen" target="_blank" rel="noopener noreferrer">caoxingyu/chinese-gushiwen: 中华古诗文数据库和API。包含10000首古文(诗、词、歌、赋以及其它形式的文言文)，近4000名作者，10000名句</a></li>
<li><a href="https://github.com/chanind/hanzi-writer-data" target="_blank" rel="noopener noreferrer">chanind/hanzi-writer-data: The data used by Hanzi Writer</a></li>
</ul>
<p>一些可用的产品：</p>
<ul>
<li><a href="https://github.com/hefengbao/jingmo/tree/main" target="_blank" rel="noopener noreferrer">hefengbao/jingmo: 『京墨』开源的中华文化宝典 APP，诗（词）文（名句）、汉字、成语、词语、歇后语、绕口令、传统节日、传统色、节气、人物等。</a></li>
<li><a href="https://github.com/a2636340559/YaFeng" target="_blank" rel="noopener noreferrer">a2636340559/YaFeng: “雅风”古诗词APP</a></li>
<li><a href="https://github.com/SongC1229/song" target="_blank" rel="noopener noreferrer">SongC1229/song: 基于Flutter框架的诗词app,采用sqlite数据库</a></li>
</ul>
<h2> 二、 原型设计</h2>
<p>基于上面的过程我们大概知道自己想做些啥，但是具体的产品设计这块由于并不专业不知道该怎么做，既然我不会，那就借助一下AI来帮我整一下</p>
<p>直接大力出奇迹，对于小白完全不考虑什么提示词</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/ai/7-2.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>省略调整的过程，看看AI生成的原型方案</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然对于一个研发而言，上面的这套设计方案仅使用参考，我还是更喜欢可视化的交互页面</p>
<h2> 三、快速原型实现</h2>
<p>使用AI体验最好的就在这里了，我可以直接让它快速将上面的设计实现一个demo出来看看效果</p>
<figure><img src="/imgs/column/ai/7-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这个生成的网页效果实际上超出了我的预期，至少我自己是设计不出来的。 接下来我们就是基于这个原型进行丰富补全</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/ai/7-1.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>1. “绝对色感”的闯关游戏（一）</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aigame/01.%E7%BB%9D%E5%AF%B9%E8%89%B2%E6%84%9F%E7%9A%84%E9%97%AF%E5%85%B3%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aigame/01.%E7%BB%9D%E5%AF%B9%E8%89%B2%E6%84%9F%E7%9A%84%E9%97%AF%E5%85%B3%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1. “绝对色感”的闯关游戏（一）</source>
      <description>作为一个游戏开发门外汉，接下来我将挑战一下，从0到1，完整记录一下如何借助AI来生成一个完整的可上架的游戏APP 一、游戏产品设计 首先明确一下我们要做什么，产品的核心玩法： 一个简单的闯关游戏，每一关中由系统自动生成一些色块，其中只要一个色块的颜色与其他的不一样，只有选中不一样颜色的色块才会进入下一关 关卡难度设计：随着关卡的增加，色块数变多； 不同颜色的色块与其他颜色的rgb差值更小 关卡本身功能比较简单，我们需要为它添加一个排行榜竞技/或者在线PK的功能，增加互动性 接下来就是确定研发路线</description>
      <category>AI</category>
      <pubDate>Wed, 09 Jul 2025 07:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>作为一个游戏开发门外汉，接下来我将挑战一下，从0到1，完整记录一下如何借助AI来生成一个完整的可上架的游戏APP</p>
<h2> 一、游戏产品设计</h2>
<p>首先明确一下我们要做什么，产品的核心玩法：</p>
<p>一个简单的闯关游戏，每一关中由系统自动生成一些色块，其中只要一个色块的颜色与其他的不一样，只有选中不一样颜色的色块才会进入下一关</p>
<ul>
<li>关卡难度设计：随着关卡的增加，色块数变多； 不同颜色的色块与其他颜色的rgb差值更小</li>
</ul>
<p>关卡本身功能比较简单，我们需要为它添加一个排行榜竞技/或者在线PK的功能，增加互动性</p>
<p>接下来就是确定研发路线</p>
<p>借助trae/cursor来实现代码编程，技术栈选择uniapp来实现实现一次编写，多端运行</p>
<h2> 二、项目初始化与快速原型设计</h2>
<h3> 2.1 项目初始化</h3>
<p>使用uniapp进行开发，首先需要安装HBuilder，这里省略安装步骤；接下来我们创建一个空的项目</p>
<figure><img src="/imgs/column/aigame/1-01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>使用Cursor打开项目，快速实现一个应用原型</p>
<figure><img src="/imgs/column/aigame/1-02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2.2 快速原型设计</h3>
<p>首次提交信息时，cursor只会帮我们输出一个空的架子，接下来我们回复确认让它补全具体的游戏逻辑，快速实现一个基础可运行的原型</p>
<figure><img src="/imgs/column/aigame/1-03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>全部接受之后，我们通过uniapp体验一下实际的效果</p>
<figure><img src="/imgs/column/aigame/1-04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后一个核心游戏玩法的应用基本算是完成了</p>
<figure><img src="/imgs/column/aigame/1-05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、验证可行性、制定迭代计划</h2>
<p>从上面的流程也可以看出，借助cursor快速设计一个原型用于我们的想法验证，成本非常低；现在ai对于普通人的一个友好点在于可以快速的让我们脑子里的想法先落地，不管它靠不靠谱</p>
<p>接下来就是实际体验一下，看看我们的想法是否靠谱，以及这个原型还有哪些需要改进和优化的地方</p>
<p>从原型的交互体验来看，核心玩法没问题，生成色块、选择、进入下一关；但是从实际体验来看，玩法比较单调、且后面关卡的色块rgb差异太小了，肉眼太难识别了</p>
<p>因此后面的迭代方向可以分为两块：</p>
<ol>
<li>游戏策略</li>
</ol>
<ul>
<li>设计更优雅的难度升级策略</li>
</ul>
<ol start="2">
<li>游戏可玩性</li>
</ol>
<ul>
<li>增加游戏的可玩性/竞技性 - 比如排行榜，在线PK，每一关添加倒计时增加紧迫感，当思考方式太久/闯关失败时输出一些嘲讽意味强的弹幕？闯过一些特定关卡时，增加一些喝彩的氛围</li>
<li>单纯的色块可能吸引力不够，那么是否可以在色块中放一些漂亮的小姐姐图片？</li>
</ul>
<p>前期准备工作就绪，接下来我们开始进入游戏的调教正文</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/aigame/1-01.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>AI游戏开发</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aigame/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aigame/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">AI游戏开发</source>
      <description>氛围编程 借助AiCoding（如cursor windsurf trae copilot）来实现低门槛的编程</description>
      <pubDate>Wed, 09 Jul 2025 09:51:04 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 氛围编程</h1>
<p>借助AiCoding（如cursor windsurf trae copilot）来实现低门槛的编程</p>
]]></content:encoded>
    </item>
    <item>
      <title>1. 首个完全由AI生成的APP-ColorPicker上架啦</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aicoding/01.%E9%A6%96%E4%B8%AA%E5%AE%8C%E5%85%A8%E7%94%B1AI%E7%94%9F%E6%88%90%E7%9A%84APP%E4%B8%8A%E6%9E%B6%E5%95%A6.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aicoding/01.%E9%A6%96%E4%B8%AA%E5%AE%8C%E5%85%A8%E7%94%B1AI%E7%94%9F%E6%88%90%E7%9A%84APP%E4%B8%8A%E6%9E%B6%E5%95%A6.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1. 首个完全由AI生成的APP-ColorPicker上架啦</source>
      <description>hello大家好，我是一灰灰，距离上一次和大家分享技术相关内容已经过去了两年多了；若不是最近AICoding的大火，估计也不会继续发文啦。最近这个月深度体验了ai coding的能力，也借助字节的Trae完成了几个产品，借着首个app上架一周的时间、并获得首个自然用户的评价（虽然是个差评）这个时机，给大家分享一下我最近在筹划的一个专栏 -- 《人人都是程序员》 第一手原文：首个完全由AI生成的APP-ColorPicker上架啦 | 一灰灰blog的公众号</description>
      <category>AI</category>
      <pubDate>Mon, 24 Mar 2025 21:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>hello大家好，我是一灰灰，距离上一次和大家分享技术相关内容已经过去了两年多了；若不是最近AICoding的大火，估计也不会继续发文啦。最近这个月深度体验了ai coding的能力，也借助字节的Trae完成了几个产品，借着首个app上架一周的时间、并获得首个自然用户的评价（虽然是个差评）这个时机，给大家分享一下我最近在筹划的一个专栏 -- 《人人都是程序员》</p>
<blockquote>
<p>第一手原文：<a href="https://mp.weixin.qq.com/s/qtxF-vnUeKrp9BZZRaeeSw" target="_blank" rel="noopener noreferrer">首个完全由AI生成的APP-ColorPicker上架啦 | 一灰灰blog的公众号</a></p>
</blockquote>
<figure><img src="/imgs/column/ai/1_1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>确实是没想到外国人也会因为语言问题给差评，谁说欧洲人素质高来着😡</p>
<h2> 1. ColorPicker上架谷歌应用市场</h2>
<p>最近这段时间的各种AI工具的使用，加上首个99%以上内容由AI生成的APP（ColorPicker）在谷歌应用市场的成功上线，忽然意识到“人人都是程序员”这一现实好像在加速到来。</p>
<p>还记得我在初入这一行时，当时的TL推荐我们程序员要有产品思维，多看看《人人都是产品经理》这一本书，没想到今天我要开始着手准备《人人都是程序员》了。</p>
<p>首先给大家看一下这个完全由AI完成的APP（3.17号上架通过）</p>
<figure><img src="/imgs/column/ai/1_2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>下面是实际的体验效果（整体功能齐全啦）</p>
<blockquote>
<p>点击查看原文：<a href="https://mp.weixin.qq.com/s/qtxF-vnUeKrp9BZZRaeeSw" target="_blank" rel="noopener noreferrer">演示视频原文</a></p>
</blockquote>
<p>希望体验h5的小伙伴可以访问下面两个地址（一个是自己的域名，一个是白嫖的cloudflare服务），或者直接点击文末的访问原文直达</p>
<ul>
<li><a href="http://cdn.hhui.top/app/color-picker/index.html#/" target="_blank" rel="noopener noreferrer">http://cdn.hhui.top/app/color-picker/index.html#/</a></li>
<li><a href="https://colorpicker-bpx.pages.dev/#/" target="_blank" rel="noopener noreferrer">https://colorpicker-bpx.pages.dev/#/</a></li>
</ul>
<p><strong>1. 主要的业务逻辑：</strong></p>
<p>• 照相 + 本地相册读取图片，识别图片颜色
• 支持颜色分组，收藏
• 颜色详情，支持全屏显示
• 系统推荐色彩专栏
• APP国际化</p>
<p><strong>2. 集成谷歌Admob广告，支持变现</strong></p>
<p><strong>3. 多端支持</strong></p>
<p>•android 版本 （已上架）
•ios 版本（没有苹果应用账号，因此没上架）
•h5/pc 版本: 已上线   <a href="https://colorpicker-bpx.pages.dev/#/" target="_blank" rel="noopener noreferrer">https://colorpicker-bpx.pages.dev/#/</a>
•小程序版（未备案，所以未上线）</p>
<h2> 2. AI生成APP的契机</h2>
<p>ColorPicker的诞生也比较偶然，今年年初的DeepSeek掀起AI届的新一轮高潮，好久没怎么学习的我也凑了一波热闹，借助字节提供的免费AI编辑器Trae，看一下现在的ai工具代码到底写得怎么样。</p>
<p>如到现在，基于Trae我共实现了三个应用：</p>
<h3> 2.1. 像素图填色游戏</h3>
<blockquote>
<p>源码：<a href="https://liuyueyi.github.io/ai-web-case/" target="_blank" rel="noopener noreferrer">https://liuyueyi.github.io/ai-web-case/</a></p>
</blockquote>
<p>1.一个简单的单页面web应用，通过解析给定的配置文件，生成像素图；用户可以根据自己选择的颜色对像素进行填色
2.特点：页面布局单一、业务逻辑简单，交互不多</p>
<figure><img src="/imgs/column/ai/1_3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这个web页面的开发过程非常顺利，基本上没有什么特别糟心的事情，整个实现也就两天的时间（关于将图片转换为用于渲染像素图的二维矩阵花了我一天，这块还是借助我的老本行java实现的😂），接下来我就想上点难度，看下AICoding的能力在哪里，接下来就有了下面的AI对战游戏</p>
<h3> 2.2. AI人机对战棋牌游戏</h3>
<p>1.人机对战的棋牌游戏，原定计划实现 五子棋、黑白棋、三子/九子棋、中国象棋、国际象棋等经典棋牌的人机方式
2.最终结果：完成五子棋、黑白棋、三子棋的基础实现
3.特点：布局相对复杂（比如三子棋盘的绘制），算法要求高（AI下棋策略，人机交互策略）</p>
<figure><img src="/imgs/column/ai/1_4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>相较于像素填色，这个AI棋盘对战的开发过程就比较难受了，不管是棋盘的布局（尤其是三子棋的棋盘，反复修改调整)、AI的游戏策略/判定策略调教，都不是一个轻松的活，原定计划的中国象棋和国际象棋也没有耐心继续调教了。</p>
<p>这个游戏差不多花了我一周的时间，做完之后，感受就是AICoding确实方便，虽然离取代资深程序员还是有不小的距离，但是对初级程序员的挑战就很非常大了。这个项目做完之后，我就萌生了一个“人人都是程序员”的想法，这好像并不是不可能</p>
<h3> 2.3. ColorPicker 图片颜色提取APP</h3>
<blockquote>
<p>源码 <a href="https://github.com/liuyueyi/ai-color-picker" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/ai-color-picker</a></p>
</blockquote>
<p>接下来就准备开始验证这个“人人都是程序员”是否属于我的异想天开了。</p>
<p>直接在应用市场，按照工具类进行下载、好评进行搜索，然后看到了一个百万下载量，而且功能不复杂应用，看到它的时候我就深信这个app完全可以有AI来生成，于是就有了下面的Ai生成应用</p>
<figure><img src="/imgs/column/ai/1_5.png" alt="AI致敬版，百万下载量的高分APP" tabindex="0" loading="lazy"><figcaption>AI致敬版，百万下载量的高分APP</figcaption></figure>
<figure><img src="/imgs/column/ai/1_6.webp" alt="AI生成的ColorPicker" tabindex="0" loading="lazy"><figcaption>AI生成的ColorPicker</figcaption></figure>
<p>AI生成的ColorPicker 谷歌市场下载地址 -&gt; <a href="https://play.google.com/store/apps/details?id=com.git.hui.colorpicker.google" target="_blank" rel="noopener noreferrer">https://play.google.com/store/apps/details?id=com.git.hui.colorpicker.google</a></p>
<ol>
<li>根据上传的图片，识别指定位置的图片颜色的工具</li>
<li>特点：一个完全由AI设计原型、实现业务逻辑细节，并且最终打包为Android APP，集成Admob广告，并上架谷歌应用市场，走通app的开发到上线全流程</li>
</ol>
<h2> 3. ColorPicker的历程</h2>
<p>接下来我将回顾一下 ColorPicker 的诞生历程 <a href="https://github.com/liuyueyi/ai-color-picker/commits/main/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/ai-color-picker/commits/main/</a></p>
<figure><img src="/imgs/column/ai/1_7.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol>
<li>
<p>3.11 号确定应用的主体功能、展现形式，开始编码
• a. 功能：图片提色
• b. 展现形式：wap应用 + 小程序 + app
• c. 技术栈：基于uniapp的技术栈来实现一套代码，多端生成
• d. 编程工具：HBuilder + AndroidStudio + Trae</p>
</li>
<li>
<p>3.12 号完成主体业务功能</p>
</li>
<li>
<p>3.13 号打包到apk，到android进行运行，尝试集成谷歌广告；并提交谷歌应用市场</p>
</li>
<li>
<p>3.14 号谷歌应用市场审批通过；开始第二版的迭代更新 a. 第二版新增：颜色搜索功能、分组、系统推荐色等能力</p>
</li>
<li>
<p>3.15 号解决uniapp上架到谷歌应用市场之后下载安装白屏问题（uniapp的bug)</p>
</li>
</ol>
<p>从想法诞生到最终的落地实现，基本上在五天内（其中app的相干样式适配、广告集成等问题最少花了两天😂），排除android相关的一些改造，其他的内容99.9%的内容全部由Trae来提供支撑，通过实际体验，“人人都是程序员”好像还挺容易成真的；</p>
<p>事后我重新复盘了一下这个开发过程，我将尝试以最大的可能性，给不是程序员这一行的小伙伴，介绍一条可以完全按照自己的想法设计app的小路，让你的创业不再停留在“就缺一个程序员”上了</p>
<h2> 4. 人人都是程序员专栏</h2>
<p>按照个人经验，拟定的专栏内容如下：（当然什么时候更新，我也无法给出肯定的承诺，欢迎关注公众号“一灰灰blog”蹲守第一手信息）</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/ai/1_1.webp" type="image/webp"/>
    </item>
    <item>
      <title>2. 图文手把手教你由0到1基于AI完成“垃圾消除小游戏”</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aicoding/02.%E4%BB%8E0%E5%88%B01%E5%9F%BA%E4%BA%8EAI%E7%94%9F%E6%88%90%E5%B0%8F%E6%B8%B8%E6%88%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aicoding/02.%E4%BB%8E0%E5%88%B01%E5%9F%BA%E4%BA%8EAI%E7%94%9F%E6%88%90%E5%B0%8F%E6%B8%B8%E6%88%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2. 图文手把手教你由0到1基于AI完成“垃圾消除小游戏”</source>
      <description>上一篇文章 首个完全由AI生成的APP上架啦 - ColorPicker 被喷得有点惨，本来是想分享一下最近使用AiCoding的探索发现，结果被好些大佬说是 “毫无技术含量、全是生产互联网垃圾”。说实话，看到这些评论还有点伤心，毕竟八年技术分享无人问，一朝水文大众喷。 虽然不被技术大咖认可，但我的初衷依然和上篇文章回复保持一致</description>
      <category>AI</category>
      <pubDate>Sat, 29 Mar 2025 21:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇文章  <a href="https://mp.weixin.qq.com/s/qtxF-vnUeKrp9BZZRaeeSw" target="_blank" rel="noopener noreferrer">首个完全由AI生成的APP上架啦 - ColorPicker</a>  被喷得有点惨，本来是想分享一下最近使用AiCoding的探索发现，结果被好些大佬说是 “毫无技术含量、全是生产互联网垃圾”。说实话，看到这些评论还有点伤心，毕竟八年技术分享无人问，一朝水文大众喷。</p>
<p>虽然不被技术大咖认可，但我的初衷依然和上篇文章回复保持一致</p>
<figure><img src="/imgs/column/ai/2-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>既然大家都说没有技术难度、是在制造互联网垃圾，那正好可以拿这个主题来校验一下，搞一个毫无技术难度的垃圾消除游戏，下面完整记录这个AICoding生成的游戏全过程，给对这方面感兴趣的小伙伴一个路线参考</p>
<p>全程挑战一下，由AI来生成一个毫无技术难度的小游戏 -- 羊了个羊-垃圾消除版，并分别生成wap版/小程序版/apk版输出</p>
<blockquote>
<p>点击试玩： <a href="https://ai.hhui.top/sheepgame/#/" target="_blank" rel="noopener noreferrer">https://ai.hhui.top/sheepgame/#/</a></p>
</blockquote>
<p>首先是技术栈与开发工具如下：</p>
<p>Uniapp</p>
<p>HBuilder + Trae + Android Studio + 微信小程序开发</p>
<h2> 一、初始化一个项目工程</h2>
<p>打开HBuilder，依次点击：</p>
<h3> 1. 新建项目</h3>
<p>方案1：文件 -&gt; 新建 -&gt; 项目</p>
<figure><img src="/imgs/column/ai/2-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>方案2：点击快速创建项目的按钮，如下图</p>
<figure><img src="/imgs/column/ai/2-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 指定项目信息</h3>
<ul>
<li>由于我们希望一套代码，多端运行（wap--手机浏览器，小程序，APP），因此最左边选择 uni-app</li>
<li>输入项目名、存储路径，选择应用模板</li>
</ul>
<figure><img src="/imgs/column/ai/2-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 使用Trae加载上面的工程</h3>
<ul>
<li>打开应用，会看到下面的截图</li>
<li>然后点击打开文件夹 -- 找到上面生成工程指定的文件夹，选中即可</li>
</ul>
<p><img src="/imgs/column/ai/2-5.webp" alt="" loading="lazy">
<img src="/imgs/column/ai/2-6.webp" alt="" loading="lazy"></p>
<p>此时我们的前置准备工作已经完成，即将进入正式的AICoding阶段</p>
<h2> 二、AICoding阶段</h2>
<h3> 1. 首先在HBuilder上运行一下项目</h3>
<ol>
<li>点击下图中所示的播放图标</li>
<li>在弹出的下拉框中，选择 运行到 Chrome</li>
</ol>
<figure><img src="/imgs/column/ai/2-7.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后你就会看到一个自动打开了一个浏览器，内容长下面这样</p>
<figure><img src="/imgs/column/ai/2-8.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>因为我们的目标输出是基于手机玩耍的小游戏，因此我们可以在浏览器这里按住F12/或者鼠标右键，点击检查，进入开发者模式</p>
<figure><img src="/imgs/column/ai/2-9.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>按照下图的方式进入移动视角</p>
<figure><img src="/imgs/column/ai/2-10.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 进入Trae，让他帮我们生成小游戏</h3>
<ol>
<li>在编辑器的右边AI对话框中，选择 Builder模式，大模型选择 Claude-3.7-Sonnet</li>
</ol>
<figure><img src="/imgs/column/ai/2-11.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="2">
<li>开始提问，给出我们的诉求，下面的描述文案没有任何修辞，就是普通的大白话(毫无技巧可言）</li>
</ol>
<figure><img src="/imgs/column/ai/2-12.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后我们就等待大模型帮我们生成各种代码，在这个过程中，会不断的出现下面这种询问你<strong>是否接受</strong>的情况，一路无脑选择<strong>全部接受</strong>即可</p>
<figure><img src="/imgs/column/ai/2-13.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在最后输出完成之后，它想要运行项目，查看实现的羊了个羊游戏效果；因为我们是HBuilder进行预览，所以直接拒绝它就行</p>
<figure><img src="/imgs/column/ai/2-14.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后我们切换回上一步打开的Chrome浏览器，看看效果；结果很不幸的是并不是我们预期的内容</p>
<figure><img src="/imgs/column/ai/2-15.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 错误调试阶段</h3>
<blockquote>
<p>小概率情况，首次生成的内容不可用，我们需要将对应的错误喂给大模型，让他自己去修复</p>
</blockquote>
<p>上面这种样式，表示生成的代码有问题，那么我们就直接告诉它，修改这些问题</p>
<ul>
<li>将上面的错误截图，丢到对话框，直接让Claude来修正</li>
</ul>
<figure><img src="/imgs/column/ai/2-16.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如果你有编程经验的话，上面这种问题实际上也很好发现，如我们看下它生成的代码</p>
<ul>
<li>正常的代码，标签都是配套出现的，这里 只有<code>&lt;script&gt;</code> 没有<code>&lt;/script&gt;</code>； 只有 <code>&lt;/style&gt;</code> 没有开头的<code>&lt;style&gt;</code></li>
</ul>
<figure><img src="/imgs/column/ai/2-17.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>等上面修复完毕之后，我们在看看Chrome浏览器的运行情况</p>
<ul>
<li>第一张图，为启动页</li>
<li>第二张图为开始游戏之后的页面（没有出现预期的游戏画面，需要我们继续进行调试）</li>
<li>第三张图为游戏介绍页面</li>
</ul>
<figure><img src="/imgs/column/ai/2-18.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>虽然功能还不齐全，但至少没有报错了，UI美化的问题我们放在最后；接下来我们重点调教一下游戏界面</p>
<h3> 4. 游戏界面显示调教</h3>
<p>我们直接对话让它进行修改，这个过程可能需要多轮对话（对于小白而言，这个过程就只能看玄学了，当然如果你掌握一些编程基础，也可以快速发现问题，让后针对性的让AI进行修正）</p>
<figure><img src="/imgs/column/ai/2-19.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>实际不展示游戏区域的原因并不是上面第一轮截图提示的钩子问题，而是样式的问题（大多数白屏都是样式原因导致的）</p>
<figure><img src="/imgs/column/ai/2-20.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>当我们将游戏区域换出来之后发现底部的候选区域当前页显示不出来，还需要下滑；说明游戏区域太大了，我们可以调整一下游戏区域的高度，比如最高占屏幕的 2/3； 其次就是每个卡片太大了，也需要调整一下</p>
<p>然后开始新一轮的样式调整</p>
<figure><img src="/imgs/column/ai/2-21.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>调整完毕之后再看看效果，比之前要好一点了，当然依然存在问题，部分卡片超出游戏区域了，没关系继续让它调整</p>
<figure><img src="/imgs/column/ai/2-22.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 游戏逻辑调教</h3>
<p>我们需要修复一些游戏性的问题：</p>
<ul>
<li>如游戏模式，取消倒计时；改为候选区域填满表示游戏失败</li>
<li>比如同一层的卡片，不应该存在位置重叠的情况</li>
<li>为了更好的游戏性，可以固定限制相邻两层的间距为1/2个卡片</li>
</ul>
<figure><img src="/imgs/column/ai/2-23.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后再游戏试玩的过程中，你还会发现其他的一些问题，比如（底部卡槽填满了，没有告诉用户失败； 卡片明显被遮挡但是又可以被选中等）</p>
<ul>
<li>发现问题不要怕，一给个让它改就行，默默安慰自己享受老板吩咐人干活的快感吧~</li>
</ul>
<figure><img src="/imgs/column/ai/2-24.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>下面是一些游戏逻辑相关的改造问答，就不详细列举了</p>
<figure><img src="/imgs/column/ai/2-25.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>一些调整之后，我们再看看最终的效果</p>
<figure><img src="/imgs/column/ai/2-26.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. UI样式调整</h3>
<p>到应用商店，找一下羊了个羊的官方宣传图，或者下载游戏截个图，丢给trae来调整下整体布局样式，使其更美观一点</p>
<figure><img src="/imgs/column/ai/2-27.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>整体调整之后，比之前稍微好看一点了，不满意的小伙伴可以继续进行调教； 为了更贴合主题，我们将卡片的icon，从现在的动物换成各种垃圾</p>
<figure><img src="/imgs/column/ai/2-28.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>最后再整体调整一下游戏的各个布局（包括开始界面，游戏卡片中图标的大小，游戏logo等），改完之后我们完整的体验一下这个 “垃圾消除游戏”</p>
<p>找豆包，帮我生成icon的文生图提示词；然后再用豆包的文生图获取我们的游戏logo</p>
<figure><img src="/imgs/column/ai/2-29.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>第一次生成的图片不适合作为app的icon，需要更简约一点，就简单的调整下,一次不行多试几次</li>
</ul>
<p>基本功能完成，接下来我们整体体验一下这个垃圾小游戏</p>
<blockquote>
<p>打开公众号原文，体验视频的演示效果： <a href="https://mp.weixin.qq.com/s/mu9l0y18mNE3PlI8EQhrYw" target="_blank" rel="noopener noreferrer">
毫无技术难度：由0到1基于AI完成“垃圾消除小游戏”
</a></p>
</blockquote>
<h2> 三、小结</h2>
<p>这一篇主要通过图文的方式，演示了如何借助Trae来从0到1实现一个小游戏；接下来我们如何将同样通过图文的方式，手把手教你将上面实现的小游戏，打包上线，请看下一篇</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/ai/2-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>3. 图文教你打包基于AI完成“垃圾消除小游戏”</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aicoding/03.%E4%BB%8E0%E5%88%B01%E6%95%99%E4%BD%A0%E6%89%93%E5%8C%85AI%E7%94%9F%E6%88%90%E7%9A%84%E5%B0%8F%E6%B8%B8%E6%88%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aicoding/03.%E4%BB%8E0%E5%88%B01%E6%95%99%E4%BD%A0%E6%89%93%E5%8C%85AI%E7%94%9F%E6%88%90%E7%9A%84%E5%B0%8F%E6%B8%B8%E6%88%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3. 图文教你打包基于AI完成“垃圾消除小游戏”</source>
      <description>上一篇使用图文的方式演示了如何从0到1借助ai生成一个可运行的小游戏，接下来我将通过图文的方式，手把手教你将上面生成的小游戏，打包出来供其他人玩耍 接下来将分别介绍常见的三种打包发行方式 接下来的动作将主要在HBuilder中执行 一、打包成H5游戏 h5游戏，主要用于浏览器直接访问玩耍，需要配置域名，没有域名的小伙伴，可以考虑一些云服务的PAGES服务来实现，接下来介绍下Cloudflare的托管部署方式 Step1. 打包 Hbuilder ，一次点击 发行 -&amp;gt; 网站PC Web 或手机H5 如果出现下面的异常，则按照下图方式进行修正</description>
      <category>AI</category>
      <pubDate>Sat, 29 Mar 2025 21:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇使用图文的方式演示了如何从0到1借助ai生成一个可运行的小游戏，接下来我将通过图文的方式，手把手教你将上面生成的小游戏，打包出来供其他人玩耍</p>
<p>接下来将分别介绍常见的三种打包发行方式</p>
<blockquote>
<p>接下来的动作将主要在HBuilder中执行</p>
</blockquote>
<h2> 一、打包成H5游戏</h2>
<p>h5游戏，主要用于浏览器直接访问玩耍，需要配置域名，没有域名的小伙伴，可以考虑一些云服务的PAGES服务来实现，接下来介绍下Cloudflare的托管部署方式</p>
<h3> Step1. 打包</h3>
<p>Hbuilder ，一次点击 发行 -&gt; 网站PC Web 或手机H5 如果出现下面的异常，则按照下图方式进行修正</p>
<figure><img src="/imgs/column/ai/3-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>打开项目下的 manifest.json 文件</li>
<li>在右边的视图中，点击重新获取按钮
<ul>
<li>如果没有登录的，会让你输入unicod的账号密码，登录即可</li>
<li>成功之后，就会得到下面3所示的AppID</li>
</ul>
</li>
</ul>
<figure><img src="/imgs/column/ai/3-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面问题修复之后，再次进行打包，正确的样式如下</p>
<ul>
<li>因为接下来的演示是基于Cloudflare进行托管，所以下面的域名可以先随便填一个</li>
</ul>
<figure><img src="/imgs/column/ai/3-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后进入上面的输出目录，将目录下的内容打包为zip文件，如下图操作</p>
<figure><img src="/imgs/column/ai/3-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Step2. 发行Cloudflare</h3>
<blockquote>
<p>没有账号的小伙伴自行注册，后续教程给出完整的注册使用流程，敬请蹲守一波😄</p>
</blockquote>
<ul>
<li>直接进入 Workers &amp; Pages 目录</li>
<li>点击create按钮，进入创建应用页面</li>
<li>切换Tab页到Pages -&gt; 点击Upload assets -&gt; 进入发布页面</li>
<li>输入项目名，此时会自动给你分配一个访问域名</li>
<li>接着上传zip压缩包</li>
<li>最后点击发布按钮</li>
</ul>
<figure><img src="/imgs/column/ai/3-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>发布成功的页面如下，我们可以直接点击域名，看一下效果（重点说明一下：上传的压缩包，请确保index.html在最外层）</p>
<figure><img src="/imgs/column/ai/3-6.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>直接点击上面的域名，就可以访问我们的小游戏啦</p>
<ul>
<li>域名是： <a href="https://sheepremove.pages.dev/" target="_blank" rel="noopener noreferrer">https://sheepremove.pages.dev/</a></li>
</ul>
<figure><img src="/imgs/column/ai/3-7.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Step3. 发行到自己的服务器或者OSS托管</h3>
<p>当然如果你有自己的服务器或者OSS，也是可以将h5游戏部署上去的，下面简单介绍下将H5游戏托管到免费的七牛云空间下</p>
<ol>
<li>首先在oss上，创建对应的目录空间，如 /app/sheepremove</li>
</ol>
<figure><img src="/imgs/column/ai/3-8.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="2">
<li>修改HBuilder中web打包的输出前缀</li>
</ol>
<ul>
<li>manifest.json 文件 -&gt; web配置 -&gt; 运行的基础路径</li>
<li>启用https协议这个看你自己的托管域名，支不支持https，支持就选中；不支持就取消</li>
<li>然后重新发行一次： 菜单发行 -&gt; 网站-PC</li>
</ul>
<figure><img src="/imgs/column/ai/3-9.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="3">
<li>上传文件到七牛云</li>
</ol>
<blockquote>
<p>注意此时是文件的形式上传，不用之前的zip压缩包了</p>
</blockquote>
<figure><img src="/imgs/column/ai/3-10.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="4">
<li>体验一下</li>
</ol>
<blockquote>
<p><a href="http://cdn.hhui.top/app/sheepremove/index.html" target="_blank" rel="noopener noreferrer">http://cdn.hhui.top/app/sheepremove/index.html</a></p>
</blockquote>
<figure><img src="/imgs/column/ai/3-11.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、打包成微信小游戏</h2>
<blockquote>
<p>接下来我们看一下将上面的垃圾小游戏生成微信小游戏来体验一下，此时我们需要借助微信开发工具</p>
</blockquote>
<h3> Step1: 微信开发者工具，生成appid</h3>
<ul>
<li>将生成的appid记录出来，后续打包时会用到</li>
<li>注意：这里选择小程序，如果选择小游戏时，uniapp输出到微信时会报错</li>
</ul>
<figure><img src="/imgs/column/ai/3-12.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Step2: 打包微信小程序</h3>
<p>配置小程序AppID</p>
<figure><img src="/imgs/column/ai/3-13.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>case1：运行小程序</strong></p>
<figure><img src="/imgs/column/ai/3-14.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后hbuilder会自动打开微信开发者工具，启动我们的 垃圾消除游戏 , 如下图</p>
<figure><img src="/imgs/column/ai/3-15.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p>说明：多平台时，可能出现各种奇怪的问题，需要针对性的进行提问解决 如：在微信小程序运行时，也出现了一个小问题，游戏区域未显示，同样将问题抛给Trae来修复</p>
</blockquote>
<figure><img src="/imgs/column/ai/3-16.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>case2: 发行小程序</strong></p>
<p>这种场景适用于我们开发完毕，准备提交给微信后台去申请上线，流程如下（由于没准备上线小程序，所以就不演示小程序上线流程了，放在后续的教程进行介绍）</p>
<figure><img src="/imgs/column/ai/3-17.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、打包成Android app</h2>
<p>接下来我们再来演示一下如何将上面的小游戏打包成android 应用包</p>
<h3> Step1: uniapp开发者后台配置签名</h3>
<p>首先进入开发者后台：<a href="https://dev.dcloud.net.cn/pages/app/list" target="_blank" rel="noopener noreferrer">https://dev.dcloud.net.cn/pages/app/list</a></p>
<p>然后点击应用，进入详情：</p>
<ul>
<li>各平台信息 -&gt; 点击新增</li>
<li>进入编辑页，依次补齐下面几个信息</li>
<li>Android App</li>
<li>正式版/测试版 -- 都可以</li>
<li>包名：打包出来的签名，按照惯性约定命名即可</li>
<li>应用签名 SHA1, SHA256 ---&gt; 这个是基于你打包时的签名证书生成的 （后续android输出篇教程详细介绍）</li>
</ul>
<figure><img src="/imgs/column/ai/3-18.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>配置完毕之后，点击提交，返回应用列表</p>
<ul>
<li>点击创建离线Key，再弹窗中点击创建</li>
<li>然后应用列表的按钮变成查看离线key</li>
<li>然后保存弹窗出来的appid</li>
</ul>
<figure><img src="/imgs/column/ai/3-19.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Step2: 打包生成Android的离线资源</h3>
<ul>
<li>菜单点击发行</li>
<li>依次执行 App-Andoird/IOS-本地打包 -&gt; 生成本地打包App资源</li>
</ul>
<figure><img src="/imgs/column/ai/3-20.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Step3: AndroidStudio实现apk输出</h3>
<p>这里直接使用我已经封装好的Android基础工程，跳过基于uniapp的原始项目工程的改造过程；我们接下来看一下如何基于这个基础工程来生成我们的apk包</p>
<p>1.拷贝资源</p>
<ul>
<li>进入android项目的 simpleDemo/src/main/assets/apps 目录</li>
<li>删除目录下的文件</li>
<li>将上面hbuilder生成的资源拷贝进来</li>
</ul>
<figure><img src="/imgs/column/ai/3-21.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="2">
<li>修改data/dcloud_control.xml中的appid</li>
</ol>
<p>将appid改为上面文件夹名（也可以直接在uniapp的后台查看appid)</p>
<figure><img src="/imgs/column/ai/3-22.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="3">
<li>修改AndroidManifest.xml中包名和dcloud_appkey</li>
</ol>
<ul>
<li>package：Step2中填的包名</li>
<li>appKey: Step2中获取的离线key</li>
</ul>
<figure><img src="/imgs/column/ai/3-23.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="4">
<li>修改build.gradle中的包名</li>
</ol>
<ul>
<li>Namespace: 上面的包名</li>
<li>applicationid：上面的包名</li>
</ul>
<figure><img src="/imgs/column/ai/3-24.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="5">
<li>修改应用名和logo</li>
</ol>
<ul>
<li>应用名：res/values/strings.xml 文件中 app_name</li>
</ul>
<figure><img src="/imgs/column/ai/3-25.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>logo:  res/drawable 下的 icon.9.png</li>
</ul>
<p>将前面生成的icon，拷贝到上面的drawable目录下，然后删除原来的icon.9.png</p>
<figure><img src="/imgs/column/ai/3-26.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="6">
<li>打包 - 步骤如下：</li>
</ol>
<ul>
<li>菜单，点击 Build</li>
<li>在下拉框中，选择 Generate Signed App Bundle/APK</li>
<li>选择APK</li>
<li>点击Next</li>
<li>输入打包证书地址、密码、别名等信息</li>
<li>选择release</li>
<li>点击create，等待下面打包成功的提示</li>
<li>在 simpleDemo/release 目录下可以看到输出的apk包</li>
</ul>
<figure><img src="/imgs/column/ai/3-27.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Step4：安装体验</h3>
<p>直接用手机安装一下上面的apk，下面是实际的体验视频（在视频中你也会发现打开会有版本的弹窗提示，这个是uniapp的提醒，可以消除掉；以及android端的样式还需要调整下，这里就不详细展开了）</p>
<p>有兴趣体验的小伙伴，可以下载apk:（说明，这个安装包中集成了谷歌的测试广告，后续在apk打包篇中会介绍如何给应用加上广告变现）</p>
<ul>
<li><a href="http://cdn.hhui.top/app/sheepremove/%E5%9E%83%E5%9C%BE%E6%B6%88%E9%99%A4%E5%B0%8F%E6%B8%B8%E6%88%8F.apk" target="_blank" rel="noopener noreferrer">APK下载地址: </a></li>
</ul>
<p>演示视频，原文查看: - <a href="https://mp.weixin.qq.com/s/mu9l0y18mNE3PlI8EQhrYw" target="_blank" rel="noopener noreferrer">毫无技术难度：由0到1基于AI完成“垃圾消除小游戏”</a></p>
<h2> 四、小结</h2>
<p>这个垃圾消除小游戏的开动到apk的手机完整运行，再加上完成本篇文章，总计耗时 5 小时左右，说长不长，说短不短。</p>
<p>上面小游戏的所有代码全部由AI生成，我主要发挥的作用就是给ai喂我的想法、以及适当的告诉它怎么解决问题（有时候ai解决问题的速度有点让人难受），一个完整的流程下来，编程小白想要完成一个自己的h5/小程序/app游戏可能有点挑战，但是耐心怼一波，也不是不可能出现奇迹</p>
<p>最后我想说的一点是，AI正在飞速发展，作为一个十年的互联网的coder真心希望所有的程序员不要傲慢，你可能认为AICoding还很初级、经常制造各种垃圾，但不得不说现如今AiCoding已经对初级程序员已经发起了挑战，同时也为所有的非程序员，打开了一个实现自己想法/产品的大门。</p>
<p>我是一灰灰，后续我将会给大家带来更多的AICoding的系列教程，比如上面提到但是没有展开的</p>
<p>• 各编程工具的安装、调试、基本使用姿势介绍
• 项目开发管理的阶段性保存方案
• H5托管相关知识点：CloudFlare、GitHub Pages、自己专属服务器托管，接入Google AdSense变现
• 微信小程序的发包上线全流程
• Android的广告集成相关</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/ai/3-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>4. 不借助AI也可以实现图片转线稿</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aicoding/04.%E4%B8%8D%E5%80%9F%E5%8A%A9AI%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AC%E7%BA%BF%E7%A8%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aicoding/04.%E4%B8%8D%E5%80%9F%E5%8A%A9AI%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AC%E7%BA%BF%E7%A8%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4. 不借助AI也可以实现图片转线稿</source>
      <description>最近准备实现一个根据图片生成简笔画的应用，研究了下现在的ai能力，在使用百度的图片提取线稿的时候发现AI处理能力是真的强，比如下面是几个提取case 从整体的实现效果来看，还是非常不错的，对于现实人物、3d图、2d卡通、建筑的线稿提取结果可以说几近完美了。唯一的小问题就是处理时间长了一点，也不免费... 那么有没有其他开源的工具可以直接使用呢，发现了两个有意思的开源项目，一个是基于机器学习训练结果的，另一个则是直接使用算法(代码行&amp;lt;50行)进行提取转换</description>
      <category>AI</category>
      <pubDate>Wed, 11 Jun 2025 10:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>最近准备实现一个根据图片生成简笔画的应用，研究了下现在的ai能力，在使用百度的图片提取线稿的时候发现AI处理能力是真的强，比如下面是几个提取case</p>
<figure><img src="/imgs/column/ai/4-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从整体的实现效果来看，还是非常不错的，对于现实人物、3d图、2d卡通、建筑的线稿提取结果可以说几近完美了。唯一的小问题就是处理时间长了一点，也不免费...</p>
<p>那么有没有其他开源的工具可以直接使用呢，发现了两个有意思的开源项目，一个是基于机器学习训练结果的，另一个则是直接使用算法(代码行&lt;50行)进行提取转换</p>
<h3> 基于训练模型 rocca/informative-drawings-line-art-onnx</h3>
<p>模型地址-&gt; <a href="https://huggingface.co/rocca/informative-drawings-line-art-onnx" target="_blank" rel="noopener noreferrer">https://huggingface.co/rocca/informative-drawings-line-art-onnx</a></p>
<p>项目源码：<a href="https://github.com/josephrocca/image-to-line-art-js" target="_blank" rel="noopener noreferrer">https://github.com/josephrocca/image-to-line-art-js</a></p>
<p>使用约17兆的模型即可实现线图提取功能，下面是官方的demo表现情况</p>
<figure><img src="/imgs/column/ai/4-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的处理结果也可以看出，对于卡通图像的转换效果还是可以的；但是对于显示人物、建筑之类的效果就一一般般了</p>
<h3> 算法提取</h3>
<p>项目源码：<a href="https://github.com/FlandreDaisuki/Outline-Extractor" target="_blank" rel="noopener noreferrer">Outline-Extractor</a></p>
<p>核心算法</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在线体验地址: <a href="https://ai.hhui.top/app/imgline.html" target="_blank" rel="noopener noreferrer">https://ai.hhui.top/app/imgline.html</a></p>
<p>整体表现效果如下:</p>
<figure><img src="/imgs/column/ai/4-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从实际的效果来看，和上面的训练模型的处理结果半斤八两，不过好处也很明显，处理效率明显更高，且无外部依赖</p>
<h3> 小结</h3>
<p>下面是具体的对照结果，对于卡通图片，如果希望提取线稿，会发现即便不使用大模型、机器学习的能力，借助最基础的算法处理，不超过50行的代码也可以实现相对理想的效果</p>
<table>
<thead>
<tr>
<th>原图</th>
<th>百度提取线图</th>
<th>训练模型处理</th>
<th>算法提取</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/imgs/column/ai/4-4-0.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-b-0.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-t-0.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-s-0.jpg" alt="" loading="lazy"></td>
</tr>
<tr>
<td><img src="/imgs/column/ai/4-4-1.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-b-1.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-t-1.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-s-1.jpg" alt="" loading="lazy"></td>
</tr>
<tr>
<td><img src="/imgs/column/ai/4-4-2.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-b-2.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-t-2.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-s-2.jpg" alt="" loading="lazy"></td>
</tr>
<tr>
<td><img src="/imgs/column/ai/4-4-3.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-b-3.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-t-3.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-s-3.jpg" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/ai/4-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>5. 浏览器中跑大模型-搭建一个自动抠图服务</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aicoding/05.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%B7%91%E5%A4%A7%E6%A8%A1%E5%9E%8B-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E6%8A%A0%E5%9B%BE%E6%9C%8D%E5%8A%A1.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aicoding/05.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%B7%91%E5%A4%A7%E6%A8%A1%E5%9E%8B-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E6%8A%A0%E5%9B%BE%E6%9C%8D%E5%8A%A1.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5. 浏览器中跑大模型-搭建一个自动抠图服务</source>
      <description>抠图的场景大家应该很熟悉了，使用大模型来抠图也属于很常见的功能了，但是在操作一些相对隐私的图片总会有一点点担心。那么在自己的电脑上跑一个大模型？ 电脑的性能够呛！ 难道就没有什么离线的大模型可以用嘛？ 相信很多小伙伴都听过Transformers.js，一个JavaScript库，它允许开发者在浏览器或Node.js环境中使用Hugging Face的预训练机器学习模型，无需服务器支持 最近花了一点时间（主要是借助豆包）来写了一个网页，支持在浏览器本地直接跑RMBG V1.4模型，实现离线的智能抠图功能。 下来看看整体的表现情况</description>
      <category>AI</category>
      <pubDate>Fri, 13 Jun 2025 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>抠图的场景大家应该很熟悉了，使用大模型来抠图也属于很常见的功能了，但是在操作一些相对隐私的图片总会有一点点担心。那么在自己的电脑上跑一个大模型？ 电脑的性能够呛！ 难道就没有什么离线的大模型可以用嘛？</p>
<p>相信很多小伙伴都听过<code>Transformers.js</code>，一个JavaScript库，它允许开发者在浏览器或Node.js环境中使用Hugging Face的预训练机器学习模型，无需服务器支持</p>
<p>最近花了一点时间（主要是借助豆包）来写了一个网页，支持在浏览器本地直接跑RMBG V1.4模型，实现离线的智能抠图功能。 下来看看整体的表现情况</p>
<figure><img src="/imgs/column/ai/5-1.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>支持本地上传图片、粘贴上传图片、拖拽上传图片三种方式；首次访问网页时，会自动下载大模型(约40M)，下载成功之后会在提示区域显示“模型已加载完成”，之后所有的操作将基于用户的浏览器进行操作，无后端交互，隐私无忧</p>
<figure><img src="/imgs/column/ai/5-2.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 实际体验</h3>
<p>有兴趣的小伙伴可以实际体验，访问地址：<a href="https://ai.hhui.top/app/rmBg.html" target="_blank" rel="noopener noreferrer">https://ai.hhui.top/app/rmBg.html</a></p>
<p>它的核心玩法很简单粗暴：</p>
<ol>
<li>打开网页。</li>
<li>选择本地图片（或拖拽或粘贴一个图片）。</li>
<li>点击开始处理图片</li>
<li>几秒后（看图片大小和机器性能），抠好的图直接显示/下载。</li>
</ol>
<figure><img src="/imgs/column/ai/5-3.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>这体验就丝滑了：</strong></p>
<ul>
<li><strong>速度起飞：</strong> 省了上传下载的大头时间，处理速度就看用户本机CPU/GPU了。</li>
<li><strong>隐私拉满：</strong> 用户数据本地处理，安全感爆棚，合规风险骤降。</li>
<li><strong>零成本调用：</strong> 对开发者/服务提供方来说，没有图片传输的带宽成本，没有按次调用的API费用，服务器压力？不存在的！</li>
<li><strong>开箱即用：</strong> 用户不用装软件，不用注册，打开就用，用完就走。</li>
</ul>
<h3> 关键技术说明</h3>
<p>怎么做到的？关键点在这儿（技术老铁们看过来）：</p>
<ol>
<li><strong>模型本地化：</strong> 这个网页背后，在首次加载时（或按需），把训练好的抠图模型（onnx）<strong>直接下载到了用户的浏览器缓存里</strong>。模型大小约40M，百兆网速的小伙伴也就是几秒的加载时间。</li>
<li><strong>浏览器内推理引擎：</strong> 依靠的是强大的 <strong><code>transformers.js</code></strong> 。它们提供了在浏览器JavaScript环境中直接加载和运行AI模型的能力。</li>
</ol>
<p>对咱们开发者有啥启发？</p>
<ol>
<li><strong>边缘计算的魅力：</strong> 这就是“边缘计算”在Web端的生动体现啊！把计算负载从中心服务器下放到终端设备（浏览器），解决延迟、隐私、成本问题。想想看，除了抠图，像简单的图像分类、风格迁移、文本摘要、甚至轻量级的语音识别，是不是都有可能搬到浏览器里？</li>
<li><strong>Web ML 生态成熟：</strong> <code>transformers.js</code>、ONNX Runtime Web、TensorFlow.js 这些工具链越来越成熟，让在Web端部署和运行（尤其是优化后的）模型不再是天方夜谭。前端工程师的武器库又丰富了！</li>
<li><strong>用户体验新思路：</strong> 对于需要处理用户本地数据的应用（图片、文档、音视频片段），<strong>“本地优先”</strong> 的处理策略能极大提升用户体验和信任度。这个抠图工具就是个很好的样板。</li>
<li><strong>模型优化是王道：</strong> 浏览器环境资源有限（内存、算力），模型必须<strong>轻量化、高效化</strong>。这倒逼我们在模型设计、剪枝、量化、格式转换上做更多优化工作。</li>
</ol>
<p><strong>值得一试吗？</strong></p>
<p>当然！无论你是：</p>
<ul>
<li><strong>好奇宝宝：</strong> 想看看浏览器里跑模型到底啥感觉？</li>
<li><strong>前端攻城狮：</strong> 想探索Web ML的可能性边界？</li>
<li><strong>后端/全栈：</strong> 在琢磨如何降低服务端负载、优化成本结构？</li>
<li><strong>产品经理：</strong> 在寻找提升用户体验、增强隐私卖点的方案？</li>
</ul>
<p>这个网页都值得你点开玩一玩：<strong><a href="https://ai.hhui.top/app/rmBg.html" target="_blank" rel="noopener noreferrer">https://ai.hhui.top/app/rmBg.html</a></strong></p>
<p><strong>实际体验感受：</strong></p>
<ul>
<li>首次加载可能需要下载模型（40MB级别），有点耐心。</li>
<li>抠图速度取决于你电脑性能，实测普通照片几秒到十几秒搞定，效果在浏览器里跑成这样相当不错了（当然不能和顶级桌面软件比）。</li>
<li>最大的爽点：图片真的没上传！打开浏览器开发者工具 - 网络（Network）标签页，你会看到除了加载网页本身和模型文件，<strong>处理过程中没有任何图片上传的请求！</strong> 这感觉，踏实。</li>
</ul>
<p><strong>最后叨叨：</strong></p>
<p>这个网页虽然是个工具，但它展示的思路非常有价值。随着Web ML技术的进步和终端设备算力的提升，<strong>把更多AI能力“沉”到浏览器端</strong>，会是优化用户体验、降低成本、保护隐私的一个重要方向。对于隐私优先的小伙伴，不妨收藏一波😊</p>
<p><strong>链接再放一次，动手试试吧：</strong>
<a href="https://ai.hhui.top/app/rmBg.html" target="_blank" rel="noopener noreferrer">https://ai.hhui.top/app/rmBg.html</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/ai/5-1.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>6. 基于Trae开发android原生应用，顺利上架谷歌应用市场</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aicoding/06.%E5%9F%BA%E4%BA%8ETrae%E5%BC%80%E5%8F%91android%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E5%B9%B6%E4%B8%8A%E6%9E%B6%E5%BA%94%E7%94%A8%E5%B8%82%E5%9C%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aicoding/06.%E5%9F%BA%E4%BA%8ETrae%E5%BC%80%E5%8F%91android%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E5%B9%B6%E4%B8%8A%E6%9E%B6%E5%BA%94%E7%94%A8%E5%B8%82%E5%9C%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6. 基于Trae开发android原生应用，顺利上架谷歌应用市场</source>
      <description>之前使用Trae开发的项目主要是基于web技术栈来搭建的，借助uniapp的生态体系，来生成多端可运行的应用，整体实现链路还是很顺畅的。但是最近准备开发一个android的小部件，需要使用原生的kotlin进行开发，发现直接使用Trae做原生开发，也意外的顺利 下来进行简单的记录一下，使用Trae进行原生开发的过程 一、应用预览 需要开发的应用本身比较简单，主要是为用户提供两种类型的小组件，文本小组件 + 计时小组件 支持用户在手机桌面上，添加一些豆腐块的文案/倒计时，用于装饰or提醒</description>
      <category>AI</category>
      <pubDate>Mon, 16 Jun 2025 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>之前使用Trae开发的项目主要是基于web技术栈来搭建的，借助uniapp的生态体系，来生成多端可运行的应用，整体实现链路还是很顺畅的。但是最近准备开发一个android的小部件，需要使用原生的kotlin进行开发，发现直接使用Trae做原生开发，也意外的顺利</p>
<p>下来进行简单的记录一下，使用Trae进行原生开发的过程</p>
<h2> 一、应用预览</h2>
<p>需要开发的应用本身比较简单，主要是为用户提供两种类型的小组件，文本小组件  + 计时小组件</p>
<p>支持用户在手机桌面上，添加一些豆腐块的文案/倒计时，用于装饰or提醒</p>
<figure><img src="https://ai.hhui.top/static/textwidget/s0.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>app体验地址： <a href="https://play.google.com/store/apps/details?id=com.github.hui.textwidget" target="_blank" rel="noopener noreferrer">https://play.google.com/store/apps/details?id=com.github.hui.textwidget</a></p>
<figure><img src="/imgs/column/ai/6-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、原生开发流程</h2>
<p>接下来我们看一下使用trae进行原生开发的流程，基本思路和之前介绍的 <a href="https://mp.weixin.qq.com/s/mu9l0y18mNE3PlI8EQhrYw" target="_blank" rel="noopener noreferrer">毫无技术难度：由0到1基于AI完成“垃圾消除小游戏”</a> 一致，只是部分具体的操作有些差异</p>
<h3> 1. 新建项目</h3>
<p>使用android studio创建一个空的项目</p>
<figure><img src="/imgs/column/ai/6-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在弹窗中，输入项目相关信息</p>
<figure><img src="/imgs/column/ai/6-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 使用Trae打开项目</h3>
<p>使用trae打开刚才创建的项目，然后进行初始化</p>
<figure><img src="/imgs/column/ai/6-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>首先声明项目类型，然后给出指令，让trae帮我们自动生成对应的界面；</p>
<p>需要注意的时，首次进行kotlin开发时，trae对kotlin语言的支持不够友好，我们需要在插件市场中安装相关插件</p>
<figure><img src="/imgs/column/ai/6-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 基于对话的功能实现</h3>
<p>因为这个app的设计非常简单，一个文本小部件、一个计时小部件；</p>
<p>因此核心的功能实现分两块</p>
<ul>
<li>小部件设置相关</li>
<li>小部件展示相关</li>
</ul>
<p>其中小部件的设置，主要是支持用户设置自己想要展示的文本、倒计时还是正计时，背景颜色、文字颜色、对齐方式等</p>
<figure><img src="/imgs/column/ai/6-6.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>小部件因为有两种不同的类型：文本 + 计时，因此我们也需要实现两个小部件</p>
<figure><img src="/imgs/column/ai/6-7.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p>说明：由于原生开发不像页面开发可以直接浏览器实时预览效果；原生开发过程中，我们需要不断的使用android studio查看生成的代码是否存在语法问题，借助Android Studio的模拟器来预览生成的效果</p>
</blockquote>
<figure><img src="/imgs/column/ai/6-8.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 打包上传</h3>
<p>相比较于uniapp的打包，原生开发就简单很多了，无需额外操作；直接在原生项目中打包即可</p>
<figure><img src="/imgs/column/ai/6-9.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、上架应用市场</h2>
<p>上架应用市场的流程之前介绍过，有兴趣的小伙伴可以翻一下</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/e3wZ7wMnKepm6R1Cz2DbAw?token=32118257&amp;lang=zh_CN" target="_blank" rel="noopener noreferrer">AI生成的垃圾小游戏-上架谷歌应用市场全流程-图文介绍</a></li>
</ul>
<p>我们在上架之前，先集成一下admob广告（赚一点是一点嘛），这里的广告集成与之前介绍的有一些区别，因为原生开发主要是基于Jetpack来实现的，因此我们的广告sdk的集成方式也需要相应的进行调整</p>
<p>比如新增一个底部的banner广告 ，直接在官方的demo扣过来，让trae进行二次改造</p>
<figure><img src="/imgs/column/ai/6-10.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 四、小结</h2>
<p>作为一个业余前端选手，借助热火朝天的“氛围编程”也实现了一些没什么鸟用的应用，没有太大障碍的完成了webapp、网页开发、浏览器插件、基于uniapp的跨端开发(小程序、h5、安卓应用)，现在也完成了基于原生kotlin的app开发全流程，整体感受就是只要你愿意折腾，技术的门槛是越来越低的</p>
<p>下面是一些借助Trae进行开发的过程，有兴趣的小伙伴可以看看</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487677&amp;idx=1&amp;sn=3cb47b3c8d84c7f3d299174205bdaa07&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">首个完全由AI生成的APP上架啦 - ColorPicker</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487748&amp;idx=1&amp;sn=eac77c82547603cd19725260d1bb584a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">毫无技术难度：由0到1基于AI完成“垃圾消除小游戏”</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487847&amp;idx=1&amp;sn=ee5bea7a986f364314c50f667bbe9dfb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">AI生成的垃圾小游戏-上架谷歌应用市场全流程-图文介绍</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487868&amp;idx=1&amp;sn=2a80743e416a3b00e3c66421547c5c94&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">AI 生成 web 应用，如何通过广告变现 “钱” 景无限</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487901&amp;idx=1&amp;sn=d7130ffcb19fde9d7ac23cdc529c08df&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">AI生成APP-接入谷歌变现图文攻略</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487950&amp;idx=1&amp;sn=09a9823ebdee85fb2d5bf0331504b48b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">借助AI赚美刀-谷歌广告收款攻略</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487936&amp;idx=1&amp;sn=eafd7f1c95e06fff4f5ed1092ae68508&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">借助Trae的智能体完成我的浏览器主页个性化改造图文全流程</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247488002&amp;idx=1&amp;sn=5400567e26ca17710b923b3fb119b873&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">AI生成插件上架Chrome应用商店全流程</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247488089&amp;idx=1&amp;sn=8c57c677237861f88f705918186b7b4c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">浏览器里直接跑大模型抠图？试试这个借助transform.js搭建网页神器吧</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://ai.hhui.top/static/textwidget/s0.webp" type="image/webp"/>
    </item>
    <item>
      <title>AI专栏</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">AI专栏</source>
      <description>AI专栏 氛围编程 | 人人都是程序员</description>
      <pubDate>Fri, 30 May 2025 08:22:22 GMT</pubDate>
      <content:encoded><![CDATA[<h1> AI专栏</h1>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> <a href="/tutorial/column/ai/aicoding/" target="blank">氛围编程 | 人人都是程序员</a></label></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>人人都是程序员</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aicoding/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aicoding/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">人人都是程序员</source>
      <description>氛围编程 借助AiCoding（如cursor windsurf trae copilot）来实现低门槛的编程</description>
      <pubDate>Fri, 30 May 2025 08:22:22 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 氛围编程</h1>
<p>借助AiCoding（如cursor windsurf trae copilot）来实现低门槛的编程</p>
]]></content:encoded>
    </item>
    <item>
      <title>3. Kotlin Lambda表达式</title>
      <link>https://liuyueyi.github.io/tutorial/codelan/kotlin/03.Kotlin%20Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/codelan/kotlin/03.Kotlin%20Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3. Kotlin Lambda表达式</source>
      <description>以下是关于 Kotlin Lambda 表达式的深度解析，包含核心概念、使用方式、工作原理及最佳实践： 一、Lambda 表达式的本质 定义：Lambda 是一个匿名函数，可作为参数传递或赋值给变量。 Kotlin 中的 Lambda 是函数式编程的核心工具，用于简化代码和实现高阶函数。 基本语法： { 参数列表 -&amp;gt; 函数体 } // 示例：加法 Lambda val sum: (Int, Int) -&amp;gt; Int = { a, b -&amp;gt; a + b }</description>
      <category>Kotlin</category>
      <pubDate>Thu, 22 May 2025 08:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>以下是关于 Kotlin Lambda 表达式的深度解析，包含核心概念、使用方式、工作原理及最佳实践：</p>
<h3> <strong>一、Lambda 表达式的本质</strong></h3>
<p><strong>定义</strong>：Lambda 是一个<strong>匿名函数</strong>，可作为参数传递或赋值给变量。</p>
<p>Kotlin 中的 Lambda 是<strong>函数式编程</strong>的核心工具，用于简化代码和实现高阶函数。</p>
<p><strong>基本语法</strong>：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>二、Lambda 的使用方式</strong></h3>
<h4> <strong>1. 作为函数参数</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>2. 集合操作（最常见场景）</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>3. 作用域函数（let/run/with/apply/also）</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>4. 替代接口实现（SAM 转换）</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>三、Lambda 的关键特性</strong></h3>
<h4> <strong>1. 自动推断参数类型</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>2. 单个参数的隐式名称 <code>it</code></strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>3. 闭包特性（捕获外部变量）</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>4. 匿名函数（Lambda 的变体）</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>四、Lambda 的工作原理</strong></h3>
<h4> <strong>1. 编译后的实现</strong></h4>
<ul>
<li><strong>非内联 Lambda</strong>：编译为实现 <code>FunctionN</code> 接口的匿名类（如 <code>Function0</code>、<code>Function1</code>）。<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li><strong>内联 Lambda</strong>：编译时直接替换函数体，避免类创建（见下文）。</li>
</ul>
<h4> <strong>2. 闭包的实现</strong></h4>
<ul>
<li>捕获的变量被封装在一个对象中，Lambda 持有该对象的引用。<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h3> <strong>五、内联 Lambda（性能优化）</strong></h3>
<p><strong>问题</strong>：普通 Lambda 会生成匿名类，带来额外内存开销。<br>
<strong>解决方案</strong>：使用 <code>inline</code> 关键字消除此类开销。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>限制</strong>：</p>
<ul>
<li>内联 Lambda 中不能使用非局部返回（除非用 <code>crossinline</code>）。</li>
<li>大型 Lambda 可能导致代码膨胀。</li>
</ul>
<h3> <strong>六、常见陷阱与注意事项</strong></h3>
<h4> <strong>1. 非局部返回</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>2. 内存泄漏风险</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>3. 过度使用 Lambda 导致可读性下降</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>七、最佳实践推荐</strong></h3>
<h4> <strong>1. 优先使用 Lambda 简化代码</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>2. 避免长 Lambda，保持简洁</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>3. 利用 Lambda 实现 DSL</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>4. 合理使用内联优化性能</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>八、Lambda 与其他 Kotlin 特性的结合</strong></h3>
<h4> <strong>1. 与委托属性结合</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>2. 与协程结合</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>3. 与集合操作结合</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>九、性能考量</strong></h3>
<ol>
<li><strong>普通 Lambda</strong>：每次调用创建新对象，适合低频场景。</li>
<li><strong>内联 Lambda</strong>：避免对象创建，适合高频场景（如集合操作）。</li>
<li><strong>静态 Lambda</strong>：使用 <code>@JvmStatic</code> 注解减少实例创建（Kotlin/Java 互操作）。</li>
</ol>
<h3> <strong>总结</strong></h3>
<p>Kotlin Lambda 是函数式编程的核心工具，通过简洁的语法和强大的功能大幅提升代码可读性和生产力。其核心优势在于：</p>
<ul>
<li><strong>简化代码</strong>：替代冗长的匿名类和循环结构。</li>
<li><strong>高阶函数</strong>：支持将函数作为一等公民传递。</li>
<li><strong>闭包特性</strong>：自然捕获和操作外部变量。</li>
<li><strong>性能优化</strong>：通过内联消除运行时开销。</li>
</ul>
<p>掌握 Lambda 需要理解其语法糖背后的实现原理，避免常见陷阱（如非局部返回、内存泄漏），并结合内联等特性优化性能。在实际项目中，Lambda 特别适合集合操作、异步回调和 DSL 构建等场景。</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.Spring7.0特性预览</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E8%BF%AD%E4%BB%A3/01.Spring7.0%E7%89%B9%E6%80%A7%E9%A2%84%E8%A7%88.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E8%BF%AD%E4%BB%A3/01.Spring7.0%E7%89%B9%E6%80%A7%E9%A2%84%E8%A7%88.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.Spring7.0特性预览</source>
      <description>Spring 官方已经发布了 Spring Boot 4.0 的快照版本，内置 Spring Framework 7.0。 接下来我们快速预览一下Spring7.0又带来了哪些改变 以下所有内容来自官方WiKi: Spring-Framework-7.0-Release-Notes</description>
      <category>SpringBoot</category>
      <category>迭代</category>
      <pubDate>Fri, 30 May 2025 12:55:36 GMT</pubDate>
      <content:encoded><![CDATA[<p>Spring 官方已经发布了 Spring Boot 4.0 的快照版本，内置 Spring Framework 7.0。</p>
<p>接下来我们快速预览一下Spring7.0又带来了哪些改变</p>
<blockquote>
<p>以下所有内容来自官方WiKi: <a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-7.0-Release-Notes" target="_blank" rel="noopener noreferrer">Spring-Framework-7.0-Release-Notes</a></p>
</blockquote>
<h2> 1. 最低环境要求</h2>
<p>JDK的版本要求没有变更， JDK 17-27 均支持</p>
<ul>
<li>Jakarta EE 11 (Tomcat 11+)</li>
<li>Kotlin 2.x</li>
<li>JSONassert 2.0</li>
<li>GraalVM 23</li>
</ul>
<h2> 2. 移除的API</h2>
<h3> 2.1 Spring JCL 停用</h3>
<p><code>Java Commons Logging（JCL）</code> 是 Apache 提供的日志门面（Facade），允许开发者通过统一接口调用不同底层日志框架;</p>
<h3> 2.2 移除 <code>javax.annotation</code> 和 <code>javax.inject</code>注解</h3>
<p>这两个包下我们常见的注解有 <code>@Resource</code> ， <code>@PostConstruct</code>, <code>@Inject</code>，这些在SpringBoot2+的生态下，应该是非常常见的使用注解了，如果你在SpringBoot4(Spring7)之后继续使用，那么需要改成 <code>jakarta.annotation</code> 和 <code>jakarta.inject packages</code>下的依赖</p>
<h3> 2.3 路径映射选项删除</h3>
<p>自 6.0 版本以来，多个路径映射选项已被标记为删除。 下面这些选项现已被彻底删除。 其中包括：</p>
<ol>
<li><code>suffixPatternMatch</code>/<code>registeredSuffixPatternMatch</code> 注解控制方法</li>
</ol>
<p>控制是否允许通过 <strong>URL 路径后缀</strong>（如 .json、.xml）匹配控制器方法。</p>
<ul>
<li><code>suffixPatternMatch=true</code>：允许通过后缀匹配（例如 /data.json 映射到 @RequestMapping("/data")）。</li>
<li><code>registeredSuffixPatternMatch=true</code>：仅允许匹配已注册的后缀（需配合 ContentNegotiationManager 配置）。</li>
</ul>
<p>一个简单使用场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong>：</p>
<ul>
<li>启用后缀匹配可能导致安全风险（如通过 .jsp 访问未授权资源），建议结合白名单使用。</li>
<li>默认情况下，registeredSuffixPatternMatch 为 false。</li>
</ul>
<ol start="2">
<li><code>trailingSlashMatch</code> （AbstractHandlerMapping 扩展）</li>
</ol>
<p><strong>作用</strong>：
控制是否忽略 URL 末尾的斜杠（/）。</p>
<ul>
<li>trailingSlashMatch=true：/path 和 /path/ 视为同一路径。</li>
<li>trailingSlashMatch=false：严格区分末尾斜杠。</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意事项</strong>：
Spring Boot 2.3+ 默认禁用末尾斜杠匹配，需手动启用。</p>
<ol start="3">
<li>内容协商配置</li>
</ol>
<p><strong>favorPathExtension / ignoreUnknownPathExtensions</strong></p>
<p><em>作用</em>：</p>
<ul>
<li>favorPathExtension=true：优先通过 URL 后缀（如 .json）决定响应内容类型。</li>
<li>ignoreUnknownPathExtensions=true：忽略未识别的后缀（返回默认内容类型）。</li>
</ul>
<p><em>关联策略类</em>：</p>
<ul>
<li>PathExtensionContentNegotiationStrategy：基于路径后缀协商。</li>
<li>ServletPathExtensionContentNegotiationStrategy：基于 Servlet 容器特性协商。</li>
</ul>
<p><em>Java Config 示例</em>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em>MVC Java Config</em></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4">
<li>路径模式解析配置</li>
</ol>
<p><strong><code>matchOptionalTrailingSeparator</code> in <code>PathPatternParser</code></strong></p>
<p><em>作用</em>：
控制路径匹配时是否允许可选的尾部斜杠。</p>
<ul>
<li>true：/path 和 /path/ 匹配同一控制器方法。</li>
<li>false：严格区分尾部斜杠。</li>
</ul>
<p><em>配置示例</em>（Spring Boot 2.3+）</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>需配合 PathPatternParser 使用（默认策略为 AntPathMatcher）</p>
<h2> 3.弃用</h2>
<ol>
<li>Spring MVC 的 <code>&lt;mvc:*&gt;</code> XML 配置命名空间现已弃用，推荐改用 Java 配置方式。目前暂无完全移除 XML 配置的计划，但后续更新将不再适配 Java 配置模型。其他命名空间（如 <code>&lt;bean&gt;</code>）未弃用。</li>
<li>Kotlin 团队计划在未来的 Kotlin 2.x 版本中移除对 JSR 223 的支持，因此 Spring 中针对 Kotlin 脚本的模板功能已被标记为弃用。</li>
<li>Spring TestContext Framework 对 JUnit 4 的支持已弃用，推荐使用 JUnit Jupiter 的 SpringExtension。<br>
弃用的类包括：
<ul>
<li>SpringRunner</li>
<li>SpringClassRule</li>
<li>SpringMethodRule</li>
<li>AbstractJUnit4SpringContextTests</li>
<li>AbstractTransactionalJUnit4SpringContextTests及相关支持类。</li>
</ul>
</li>
<li>Jackson 2.x 的支持已弃用，推荐迁移到 Jackson 3.x</li>
</ol>
<h2> 4. Null安全</h2>
<p>新版本采用 JSpecify 注解来声明 API 的空值安全性，使用 @Nullable 表示可为 Null，使用 @NonNull 表示不能为空，并且会通过 Idea 配合提示警告或错误信息，例如以下代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5. HTTP代理</h2>
<p>新版本提供了 @ImportHttpServices 注解，让你为 HTTP 接口创建代理更加容易，示例代码如下（它允许您轻松声明、检测和配置整个 HTTP 服务组）：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 6. Bean注入</h2>
<p>Bean 注册器实现使用 BeanRegistry 和 Environment API，以简洁灵活的方式通过编程方式注册 Bean。例如，它允许通过 if 表达式、for 循环等进行自定义注册。</p>
<p>在之前，我们使用Configuration来注册bean，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在则可以通过实现<code>BeanRegistrar</code>来实现更灵活的bean注册</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 7. 接口版本控制</h2>
<p>新版本引入了优雅的 API 版本控制支持，允许开发者通过 @RequestMapping 注解中的 version 参数来实现版本控制，如下代码所示</p>
<blockquote>
<p><a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-7.0-Release-Notes" target="_blank" rel="noopener noreferrer">https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-7.0-Release-Notes</a></p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>匹配任何版本</li>
<li>匹配 version 1.1</li>
<li>匹配 1.2 and above</li>
<li>匹配 1.5</li>
</ol>
<p>然后通过请求参数来控制不同的版本，v1/v2的请求分别为</p>
<ul>
<li><a href="http://localhost:8080/account/1?version=1" target="_blank" rel="noopener noreferrer">http://localhost:8080/account/1?version=1</a>  getAccount()</li>
<li><a href="http://localhost:8080/account/1?version=1.1" target="_blank" rel="noopener noreferrer">http://localhost:8080/account/1?version=1.1</a>   对应 getAccount1_1()</li>
<li><a href="http://localhost:8080/account/1?version=1.3" target="_blank" rel="noopener noreferrer">http://localhost:8080/account/1?version=1.3</a>   对应 getAccount1_2()， 因为没有直接的1.3版本，因此找最近的一个满足的</li>
<li><a href="http://localhost:8080/account/1?version=1.5" target="_blank" rel="noopener noreferrer">http://localhost:8080/account/1?version=1.5</a>   对应 getAccount1_5()</li>
<li><a href="http://localhost:8080/account/1?version=1.6" target="_blank" rel="noopener noreferrer">http://localhost:8080/account/1?version=1.6</a>   正常1、3都可以匹配，但是因为有了4对应的1.5版本，但是没有1.6版本，则1、3都无法正确响应，返回400错误
<ul>
<li>这种场景表示当前请求的版本比我们服务提供的最大版本还高，不响应</li>
</ul>
</li>
</ul>
<h2> 8.其他优化</h2>
<ol>
<li>SPEL 表达式升级：SPEL 表达式中支持空安全和 Elvis 运算符，例如以下代码：</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它表示，将注入系统属性 pop3.port 的值，如果未定义该属性值，注入 25 这个值。</p>
<ol start="2">
<li>
<p>GraalVM 原生应用支持：借助 Spring AOT 技术，将应用编译成原生镜像，极大地缩短了启动时间。</p>
</li>
<li>
<p>支持 Jackson 3.x：放弃对 Jackson 2.x 的支持，升级为 Jackson 3.x。</p>
</li>
<li>
<p>Servlet 和 WebSocket 版本升级：使用 Servlet 6.1 和 WebSocket 2.2 作为 Web 应用程序的底层实现，这意味着应用程序应该部署在最新的 Servlet 容器上，比如 Tomcat 11+ 和 Jetty 12.1+。</p>
</li>
<li>
<p>HttpHeaders 优化：HttpHeaders 操作如下：</p>
</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 9.小结</h2>
<p>SpringBoot3+都还没尝上鲜，这下4.0就来了，还在用java8的小伙伴，你们还学得动吗😭</p>
]]></content:encoded>
    </item>
    <item>
      <title>Spring迭代记录</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E8%BF%AD%E4%BB%A3/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E8%BF%AD%E4%BB%A3/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Spring迭代记录</source>
      <pubDate>Fri, 30 May 2025 07:04:38 GMT</pubDate>
    </item>
    <item>
      <title>编程语言</title>
      <link>https://liuyueyi.github.io/tutorial/codelan/</link>
      <guid>https://liuyueyi.github.io/tutorial/codelan/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">编程语言</source>
      <description>Kotlin专栏 kotlin编程语言</description>
      <pubDate>Wed, 21 May 2025 11:07:19 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Kotlin专栏</h2>
<p><a href="/tutorial/codelan/kotlin/" target="blank">kotlin编程语言</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>1. Kotlin基础语法的核心总结</title>
      <link>https://liuyueyi.github.io/tutorial/codelan/kotlin/01.Kotlin%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93.html</link>
      <guid>https://liuyueyi.github.io/tutorial/codelan/kotlin/01.Kotlin%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1. Kotlin基础语法的核心总结</source>
      <description>1. 变量与数据类型 // 不可变变量（推荐优先使用） val name: String = &amp;quot;John&amp;quot; val age = 30 // 类型自动推断 // 可变变量 var score: Double = 95.5 var isActive = true // 布尔类型 // 空安全 var nullableStr: String? = null // 允许为 null val length = nullableStr?.length ?: 0 // 安全调用 + Elvis 操作符</description>
      <category>Kotlin</category>
      <pubDate>Wed, 21 May 2025 21:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 1. 变量与数据类型</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 函数</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 条件表达式</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 循环</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 集合</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 类与对象</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7. 空安全</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8. 扩展函数 / 属性</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9.高阶函数与 Lambda</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 10. 异常处理</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 11. 作用域函数</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 12. main启动</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 13. 其他特性</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>2. Kotlin协程</title>
      <link>https://liuyueyi.github.io/tutorial/codelan/kotlin/02.Kotlin%E5%8D%8F%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.html</link>
      <guid>https://liuyueyi.github.io/tutorial/codelan/kotlin/02.Kotlin%E5%8D%8F%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2. Kotlin协程</source>
      <description>以下是关于 Kotlin 协程的深度解析，包含核心概念、线程对比、使用方式、工作原理及最佳实践： 一、协程的本质与核心概念 定义：协程是一种轻量级的线程替代方案，由程序控制调度，而非操作系统。它允许代码暂停（suspend）和恢复执行，无需阻塞线程。 核心特性： 轻量级：单个线程可运行数千个协程，内存占用仅 ~1KB（对比线程的 MB 级）。 非阻塞：协程挂起时不阻塞线程，线程可执行其他任务。 结构化并发：通过作用域管理协程生命周期，避免内存泄漏。 挂起函数：使用 suspend 标记的函数，可暂停和恢复执行。</description>
      <category>Kotlin</category>
      <pubDate>Wed, 21 May 2025 22:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>以下是关于 Kotlin 协程的深度解析，包含核心概念、线程对比、使用方式、工作原理及最佳实践：</p>
<h3> <strong>一、协程的本质与核心概念</strong></h3>
<p><strong>定义</strong>：协程是一种轻量级的线程替代方案，由程序控制调度，而非操作系统。它允许代码暂停（<code>suspend</code>）和恢复执行，无需阻塞线程。</p>
<p><strong>核心特性</strong>：</p>
<ul>
<li><strong>轻量级</strong>：单个线程可运行数千个协程，内存占用仅 ~1KB（对比线程的 MB 级）。</li>
<li><strong>非阻塞</strong>：协程挂起时不阻塞线程，线程可执行其他任务。</li>
<li><strong>结构化并发</strong>：通过作用域管理协程生命周期，避免内存泄漏。</li>
<li><strong>挂起函数</strong>：使用 <code>suspend</code> 标记的函数，可暂停和恢复执行。</li>
</ul>
<h3> <strong>二、协程 vs 线程</strong></h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>协程（Coroutine）</th>
<th>线程（Thread）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>调度</strong></td>
<td>由程序（协程调度器）控制</td>
<td>由操作系统内核调度</td>
</tr>
<tr>
<td><strong>创建成本</strong></td>
<td>极低（约 1KB 内存）</td>
<td>高（约 1MB 内存，视平台而定）</td>
</tr>
<tr>
<td><strong>切换开销</strong></td>
<td>极小（纳秒级，仅涉及上下文切换）</td>
<td>高（微秒级，涉及内核态切换）</td>
</tr>
<tr>
<td><strong>并发性</strong></td>
<td>单线程可运行数千个协程</td>
<td>受限于系统资源（通常数百个）</td>
</tr>
<tr>
<td><strong>阻塞影响</strong></td>
<td>仅挂起当前协程，不影响线程</td>
<td>阻塞整个线程，其他任务需等待</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>I/O 密集型任务（如网络请求）</td>
<td>CPU 密集型任务（如计算）</td>
</tr>
</tbody>
</table>
<h3> <strong>三、协程的基本使用姿势</strong></h3>
<h4> <strong>1. 启动协程的方式</strong></h4>
<p>所有的协程必须在一个作用域内执行，使用方式为</p>
<p><code>作用域.launch {}</code></p>
<p>其中 launch 是一个函数，用于创建协程并将其函数主体的执行分派给相应的调度程序</p>
<p><a href="http://Dispatchers.IO" target="_blank" rel="noopener noreferrer">Dispatchers.IO</a> 指示此协程应在为 I/O 操作预留的线程上执行。</p>
<p>一个基础的使用示例：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>2. 挂起函数（Suspend Functions）</strong></h4>
<p>在函数前添加关键字<code>suspend</code>，声明这个函数为挂起函数； 若我们希望两个挂起函数顺序调用，在协程中，按照正常的顺序书写即可，后面的挂起函数可以正常获取前面的挂起函数，即两者是顺序执行的</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>3. 异步任务与结果获取</strong></h4>
<p>若两个挂起函数之间没有依赖，我希望它们能并行调度，方便我快速获取结果，此时可以借助 <code>async</code> 来实现</p>
<blockquote>
<p>在概念上，async 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。</p>
</blockquote>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>四、协程的核心组件</strong></h3>
<h4> <strong>1. 协程作用域（CoroutineScope）</strong></h4>
<p>管理协程的生命周期，确保资源正确释放：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Android 开发过程中，我们需要理解一些协程代码运行的范围。而所有的Scope 如 <code>GlobalScope</code> 都是 <code>CoroutineScope</code> 的子类，我们的协程创建都需要这样一个 <code>CoroutineScope</code> 来启动。</p>
<p>一些常见的作用域 <code>CoroutineScope</code> 对象。</p>
<ul>
<li>GlobeScope：全局范围，不会自动结束执行。</li>
<li>MainScope：主线程的作用域，全局范围</li>
<li>lifecycleScope：生命周期范围，用于activity等有生命周期的组件，在DESTROYED的时候会自动结束。</li>
<li>viewModelScope：viewModel范围，用于ViewModel中，在ViewModel被回收时会自动结束</li>
</ul>
<p>手动创建一个作用域</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> <strong>2. 协程调度器（Dispatchers）</strong></h4>
<p>指定协程执行的线程池：</p>
<ul>
<li><code>Dispatchers.Main</code>：主线程（UI 线程），用于更新 UI。</li>
<li><code>Dispatchers.IO</code>：适合 I/O 密集型任务（默认 64 线程）。</li>
<li><code>Dispatchers.Default</code>：适合 CPU 密集型任务（默认线程数为 CPU 核心数）。</li>
<li><code>newSingleThreadContext</code>：创建专用单线程。</li>
</ul>
<h4> <strong>3. Job 与协程生命周期</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>五、协程的工作原理</strong></h3>
<ol>
<li>
<p><strong>挂起与恢复</strong>：</p>
<ul>
<li>协程通过状态机实现挂起，将局部变量保存在对象中。</li>
<li>挂起时释放线程，恢复时从上次暂停处继续执行。</li>
</ul>
</li>
<li>
<p><strong>Continuation Passing Style (CPS)</strong>：</p>
<ul>
<li>
<p>编译器将 <code>suspend</code> 函数转换为带 <code>Continuation</code> 参数的状态机。</p>
</li>
<li>
<p>示例：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p><strong>调度器工作流程</strong>：</p>
<ul>
<li>协程调度器管理线程池，将协程任务分发给空闲线程。</li>
<li>非阻塞操作（如 <code>delay</code>）通过回调机制恢复执行。</li>
</ul>
</li>
</ol>
<h3> <strong>六、协程的异常处理</strong></h3>
<h4> <strong>1. 结构化异常处理</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>2. 全局异常处理器</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>七、协程的最佳实践</strong></h3>
<h4> <strong>1. 避免使用 GlobalScope</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>2. 选择合适的调度器</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>3. 避免协程嵌套</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>4. 处理背压（Backpressure）</strong></h4>
<p>当生产者速度快于消费者时，使用 <code>Channel</code> 或 <code>Flow</code>：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>5. 资源管理</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>八、协程的性能优化</strong></h3>
<ol>
<li>
<p><strong>减少协程创建开销</strong>：</p>
<ul>
<li>避免在循环中创建大量协程，使用 <code>map</code> + <code>awaitAll</code> 批量处理。</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p><strong>复用调度器</strong>：</p>
<ul>
<li>避免频繁创建新的 <code>SingleThreadContext</code>，使用共享实例。</li>
</ul>
</li>
<li>
<p><strong>监控协程泄漏</strong>：</p>
<ul>
<li>使用 <code>DebugProbes</code>（测试环境）检测未完成的协程。</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h3> <strong>九、常见陷阱与注意事项</strong></h3>
<ol>
<li>
<p><strong>阻塞 vs 挂起</strong>：</p>
<ul>
<li>避免在协程中使用 <code>Thread.sleep()</code>（阻塞线程），应使用 <code>delay()</code>（挂起协程）。</li>
</ul>
</li>
<li>
<p><strong>线程安全</strong>：</p>
<ul>
<li>协程不保证线程安全，共享可变状态时需同步（如使用 <code>Mutex</code>）。</li>
</ul>
</li>
<li>
<p><strong>内存泄漏</strong>：</p>
<ul>
<li>长生命周期协程引用短生命周期对象（如 Activity）时需谨慎。</li>
</ul>
</li>
<li>
<p><strong>测试协程代码</strong>：</p>
<ul>
<li>使用 <code>TestCoroutineDispatcher</code> 控制协程执行：</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h3> <strong>十、协程的应用场景</strong></h3>
<ol>
<li>
<p><strong>异步 I/O 操作</strong>：</p>
<ul>
<li>网络请求、文件读写等。</li>
</ul>
</li>
<li>
<p><strong>UI 响应性优化</strong>：</p>
<ul>
<li>将耗时操作放在后台协程，保持 UI 流畅。</li>
</ul>
</li>
<li>
<p><strong>并发任务处理</strong>：</p>
<ul>
<li>并行执行多个独立任务，合并结果。</li>
</ul>
</li>
<li>
<p><strong>数据流处理</strong>：</p>
<ul>
<li>使用 <code>Flow</code> 处理异步数据流。</li>
</ul>
</li>
<li>
<p><strong>状态机实现</strong>：</p>
<ul>
<li>通过协程实现复杂的状态流转逻辑。</li>
</ul>
</li>
</ol>
<h3> <strong>总结</strong></h3>
<p>Kotlin 协程通过轻量级、非阻塞的特性，彻底改变了异步编程的体验。其核心优势在于：</p>
<ul>
<li><strong>高效资源利用</strong>：减少线程创建开销，提升系统吞吐量。</li>
<li><strong>简洁代码结构</strong>：使用同步写法实现异步逻辑，避免回调地狱。</li>
<li><strong>安全的并发模型</strong>：通过结构化并发和作用域管理，降低内存泄漏风险。</li>
</ul>
<p>掌握协程需要理解其核心概念（作用域、调度器、挂起函数）和最佳实践，避免常见陷阱。在实际项目中，协程特别适合处理 I/O 密集型任务和需要高响应性的应用场景。</p>
]]></content:encoded>
    </item>
    <item>
      <title>1. MCP协议</title>
      <link>https://liuyueyi.github.io/tutorial/git/mcp/01.MCP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/git/mcp/01.MCP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1. MCP协议</source>
      <description>本文主要内容来自官方文档，按照更适合国人的阅读习惯进行重整，介绍一下MCP协议的具体的内容 官方文档 Introduction - Model Context Protocol 1. 整体介绍 1.1 MCP是什么 MCP （Model Context Protocol，模型上下文协议），它提供了一个通用的开放标准，用于将 AI 系统与数据源连接起来，用单一协议取代碎片化的集成。结果是一种更简单、更可靠的方法，使 AI 系统能够访问所需的数据。这是一种将 AI 助手连接到数据所在的系统（包括内容存储库、业务工具和开发环境）的新标准。其目的是帮助前沿模型产生更好、更相关的响应。</description>
      <category>QuickMCP</category>
      <pubDate>Tue, 13 May 2025 07:26:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文主要内容来自官方文档，按照更适合国人的阅读习惯进行重整，介绍一下MCP协议的具体的内容</p>
<blockquote>
<p>官方文档 <a href="https://modelcontextprotocol.io/introduction" target="_blank" rel="noopener noreferrer">Introduction - Model Context Protocol</a></p>
</blockquote>
<h2> 1. 整体介绍</h2>
<h3> 1.1 MCP是什么</h3>
<blockquote>
<p>MCP （Model Context Protocol，模型上下文协议），它提供了一个通用的开放标准，用于将 AI 系统与数据源连接起来，用单一协议取代碎片化的集成。结果是一种更简单、更可靠的方法，使 AI 系统能够访问所需的数据。这是一种将 AI 助手连接到数据所在的系统（包括内容存储库、业务工具和开发环境）的新标准。其目的是帮助前沿模型产生更好、更相关的响应。</p>
</blockquote>
<p>简单来讲，mcp就是定义了标准，对于所有希望给大模型提供能力的小伙伴来说，只要按照这个标准完成能力封装，那么大模型就可以直接加载这些能力从而实现某些特定的功能。</p>
<p>举一个例子，usb大家应该都不陌生，如果你只买一个台式机主机，这个时候你会发现我除了按它的开关按钮之外，好像什么也干不了。然后我买了键盘、鼠标、显示器、摄像头等外设，然后通过usb接口插上之后就可以操作电脑了，电脑是怎么识别这些外接设备（键盘、鼠标、摄像头等）的呢？ 这就是usb协议的作用了，外接设备和电脑，都遵循usb协议，然后大家就可以在同一个频道进行交流了；同样的MCP就是为了干这件事情，让大模型和给大模型提供增强能力的服务能同频进行交流</p>
<figure><img src="/imgs/column/mcp/02-mcp协议类比.jpg" alt="mcp整体架构" tabindex="0" loading="lazy"><figcaption>mcp整体架构</figcaption></figure>
<h3> 1.2 MCP总体架构</h3>
<p>MCP遵循客户端-服务端（CS）的架构，一个主机可以连接多个MCP服务端</p>
<figure><img src="/imgs/column/mcp/01-mcp整体架构.jpg" alt="mcp整体架构" tabindex="0" loading="lazy"><figcaption>mcp整体架构</figcaption></figure>
<p>从上面的描述和整体架构图，可以看到在MCP的架构中，有三个重要的角色</p>
<ul>
<li>MCP Hosts(MCP主机)： 通过mcp协议获取数据的程序（比如 Claude Desktop, IDE 或者 ai工具）</li>
<li>MCP Clients(MCP客户端): mcp协议客户端，作为调用者，通常与mcp服务端是成对出现，用于连接mcp server，实现双方通信</li>
<li>MCP Servers(MCP服务端): mcp协议服务端，作为提供者，实现MCP协议提供特定的功能</li>
</ul>
<p>除了上面三个角色之外，在架构图中，还有两个</p>
<ul>
<li>Local Data Sources: MCPServer所在的计算机上本地的资源信息，如文件、数据库、应用服务等，即MCP通过操作(读取、访问、写入等)这些本地资源来提供特定能力</li>
<li>Remote Service: MCPServer通过调用远程的服务来提供能力</li>
</ul>
<h3> 1.3 MCP工作原理</h3>
<p>mcp只是一个协议，和http协议一样，本身不直接提供能力或者服务，我们能实际感知到的服务表现只是协议上层的应用封装</p>
<p>比如http协议，常见的工作流程是我们打开浏览器，点开网页，通过http协议访问到对应的后台服务器，然后对方将网页信息传输到我们的浏览器上展示为可视化的网页内容，从而实现信息的曝光</p>
<p>那么mcp协议是怎么工作的呢？</p>
<ol>
<li>用户通过客户端发起提问</li>
<li>客户端将问题传递给 LLM</li>
<li>LLM 分析并选择合适的工具</li>
<li>通过 MCP 协议向服务端发送工具执行指令</li>
<li>工具执行后结果返回给 LLM</li>
<li>LLM 生成最终回复</li>
<li>回复通过客户端展示给用户</li>
</ol>
<figure><img src="/imgs/column/mcp/03-mcp工作原理.jpg" alt="mcp工作原理" tabindex="0" loading="lazy"><figcaption>mcp工作原理</figcaption></figure>
<h3> 1.4</h3>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/mcp/02-mcp协议类比.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>MCP</title>
      <link>https://liuyueyi.github.io/tutorial/git/mcp/</link>
      <guid>https://liuyueyi.github.io/tutorial/git/mcp/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">MCP</source>
      <description>MCP协议 官方文档：modelcontextprotocol</description>
      <pubDate>Wed, 21 May 2025 11:07:19 GMT</pubDate>
      <content:encoded><![CDATA[<p>MCP协议</p>
<p>官方文档：<a href="https://modelcontextprotocol.io/" target="_blank" rel="noopener noreferrer">modelcontextprotocol</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>01.Java 9新集合工厂方法：开启高效编程新时代</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/01.Java9%EF%BC%9A%E6%96%B0%E9%9B%86%E5%90%88%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/01.Java9%EF%BC%9A%E6%96%B0%E9%9B%86%E5%90%88%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.Java 9新集合工厂方法：开启高效编程新时代</source>
      <description>嘿，各位Java开发者！是不是每次看到代码里那些冗长的集合初始化，就感觉像是在做“体力活”？别担心，Java 9带着它的集合工厂方法来拯救我们啦！这就好比是给你配了一把“魔法棒”，轻轻一挥，集合就创建好了，再也不用写那些繁琐的代码了。接下来，就让我们一起探索Java 9集合工厂方法的神奇之处吧！ Java 9之前的集合创建方式：累觉不爱 在Java 9出现之前，创建集合简直就像是一场“苦力之旅”。比如，创建一个List，你得先创建一个ArrayList对象，然后一个接一个地往里加元素。看看下面这串代码，是不是感觉有点“眼熟”？</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 08:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>嘿，各位Java开发者！是不是每次看到代码里那些冗长的集合初始化，就感觉像是在做“体力活”？别担心，Java 9带着它的集合工厂方法来拯救我们啦！这就好比是给你配了一把“魔法棒”，轻轻一挥，集合就创建好了，再也不用写那些繁琐的代码了。接下来，就让我们一起探索Java 9集合工厂方法的神奇之处吧！</p>
<h2> Java 9之前的集合创建方式：累觉不爱</h2>
<p>在Java 9出现之前，创建集合简直就像是一场“苦力之旅”。比如，创建一个<code>List</code>，你得先创建一个<code>ArrayList</code>对象，然后一个接一个地往里加元素。看看下面这串代码，是不是感觉有点“眼熟”？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这还不算完，要是创建一个<code>Set</code>，你也得先实例化一个<code>HashSet</code>，再逐个添加元素。而<code>Map</code>就更麻烦了，得先创建一个<code>HashMap</code>，然后用<code>put</code>方法一个一个塞进去。这就好比是让你用勺子一勺一勺地往桶里装水，效率低得可怜！</p>
<p>而且，这种方式创建的集合，一旦初始化完成，要是想改点东西，还得小心翼翼，生怕出错。这就好比是用橡皮泥捏了个小雕塑，稍微一动，可能就变形了。Java 9的集合工厂方法，就是来解决这些问题的！</p>
<h2> Java 9集合工厂方法闪亮登场：魔法棒上线！</h2>
<h3> （一）List集合的of方法：一键搞定</h3>
<p>Java 9的<code>List.of</code>方法，简直就是给<code>List</code>集合插上了“翅膀”。只需要一行代码，就能创建一个不可变的<code>List</code>集合。看看下面这串代码，是不是感觉眼前一亮？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这就好比是用魔法棒一挥，一个装满水果的篮子就出现了！而且，这个方法还能创建空的集合，就像变出一个空篮子一样简单：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要是你想创建一个超大的集合，<code>List.of</code>也完全没问题！你可以直接传入一堆参数，或者把多个<code>List.of</code>组合起来，再用<code>Stream</code>拼成一个大集合。这就好比是把几个小篮子合并成一个大篮子，超方便！</p>
<h3> （二）Set集合的of方法：拒绝“撞衫”</h3>
<p><code>Set.of</code>方法也超级厉害！它不仅能让你快速创建一个不可变的<code>Set</code>集合，还能自动帮你检查重复元素。要是你不小心传了重复的元素，它就会直接“抗议”，抛出一个<code>IllegalArgumentException</code>异常。看看下面这串代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要是你写成这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它就会直接“炸毛”，告诉你不能有重复元素。这就好比是去参加派对，坚决不允许“撞衫”，保证了集合的“独一无二”。</p>
<h3> （三）Map集合的of和ofEntries方法：键值对的“完美搭档”</h3>
<p>对于<code>Map</code>集合，Java 9提供了两个超厉害的方法：<code>of</code>和<code>ofEntries</code>。<code>Map.of</code>方法适合创建包含少量键值对的不可变<code>Map</code>，而且键值对必须成对出现。看看下面这串代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这就好比是把名字和分数一一对应起来，超直观！不过，要是你传了重复的键，它也会直接“抗议”，抛出<code>IllegalArgumentException</code>异常。</p>
<p>要是你想创建一个超大的<code>Map</code>，<code>Map.ofEntries</code>方法就派上用场了。你可以传入一堆<code>Map.Entry</code>对象，轻松搞定。看看下面这串代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就好比是把一堆“名字 - 国籍”的卡片整齐地排列起来，超方便！</p>
<h2> 对比：新老方法的差异与优势</h2>
<h3> （一）代码简洁性与可读性：从“长篇大论”到“一句话搞定”</h3>
<p>Java 9的集合工厂方法，简直是把代码简洁性提升到了一个新的高度。以前创建一个<code>List</code>，得写一大堆代码；现在只需要一行代码。这就好比是从写一篇长篇大论，变成了只说一句话就能搞定。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这种简洁的写法，不仅减少了代码量，还让代码结构更加清晰，一眼就能看出集合里有什么东西。这就好比是把一堆杂物整齐地摆放在柜子里，一目了然。</p>
<h3> （二）性能与不可变性：多线程的“守护神”</h3>
<p>Java 9的集合工厂方法创建的集合是不可变的，这意味着一旦创建，就不能再修改。这在多线程环境中简直是“神器”！因为不可变集合不需要额外的同步机制来保证线程安全。比如，在一个多线程读取集合的场景中，使用不可变集合就不用担心数据不一致的问题。</p>
<p>而且，不可变集合在内存管理上也更有优势。JVM可以对它们进行优化，比如缓存哈希码。这就好比是给集合穿上了一件“保护衣”，让它们在运行时更加高效。</p>
<h3> （三）开发效率提升：从“搬砖”到“魔法”</h3>
<p>使用Java 9的集合工厂方法，开发效率简直提升了一个档次！以前创建集合，得像搬砖一样，一个一个往里加元素；现在只需要“魔法棒”一挥，集合就创建好了。这就好比是从“人力运输”升级到了“传送门”，效率提升可不是一点半点。</p>
<p>而且，简洁的代码也减少了出错的概率，调试起来也更轻松。这就好比是少走了很多弯路，直接到达目的地。</p>
<h2> 使用注意事项：别踩“雷区”</h2>
<h3> （一）不可变性：别试图“逆天改命”</h3>
<p>使用<code>List.of</code>、<code>Set.of</code>和<code>Map.of</code>方法创建的集合是不可变的，这意味着一旦创建，就不能再添加、删除或修改元素。要是你试图这么做，就会直接“触雷”，抛出<code>UnsupportedOperationException</code>异常。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，使用这些方法时，一定要想清楚集合的内容是否还会变化。如果还会变，那就老老实实使用传统的集合创建方式。</p>
<h3> （二）元素的唯一性：别“撞车”</h3>
<p>对于<code>Set</code>和<code>Map</code>集合，Java 9的工厂方法会严格检查元素的唯一性。如果传入了重复的元素或键，就会直接“抗议”，抛出<code>IllegalArgumentException</code>异常。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这就好比是开车时不能“撞车”，否则就会直接“报废”。</p>
<h3> （三）空值的处理：别“放空炮”</h3>
<p>在使用集合工厂方法时，<code>List.of</code>和<code>Set.of</code>都不允许传入<code>null</code>元素，<code>Map.of</code>的键和值也不允许是<code>null</code>。要是你传了<code>null</code>，就会直接“放空炮”，抛出<code>NullPointerException</code>异常。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，使用这些方法时，一定要确保传入的元素都是有效的，别让<code>null</code>来“搅局”。</p>
<h2> 实际应用场景举例：魔法棒的“实战演练”</h2>
<h3> （一）数据初始化：轻松搞定</h3>
<p>在很多业务场景中，我们需要初始化一些固定的数据集合。比如在一个电商系统中，商品分类是固定的。使用Java 9的集合工厂方法，就可以轻松搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这就好比是用魔法棒一挥，一个装满商品分类的“宝箱”就出现了，而且保证了这些分类不会被误改，超安全！</p>
<h3> （二）配置文件读取：清晰明了</h3>
<p>在读取配置文件时，我们常常需要把配置信息存储在集合中。比如一个数据库连接配置，使用<code>Map.of</code>方法就可以清晰地搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就好比是把配置信息整齐地摆放在一个“展示柜”里，一目了然，再也不用担心配置错误了。</p>
<h3> （三）常量定义：稳如泰山</h3>
<p>在定义常量集合时，Java 9的集合工厂方法也超有用。比如在一个游戏开发项目中，定义游戏角色的属性集合：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这就好比是给游戏角色的属性加上了一层“保护罩”，保证了它们的“独一无二”和“不可篡改”，让游戏运行得更稳定。</p>
<h2> 总结与展望：魔法棒的“未来篇章”</h2>
<p>Java 9的集合工厂方法，无疑是Java集合框架发展历程中的一个重要里程碑。它就像是一把“魔法棒”，让集合的创建变得简洁、高效，还自带“保护罩”，让数据更安全。无论是代码的可读性、性能，还是开发效率，都提升了一个档次。</p>
<p>通过实际应用场景的举例，我们可以看到，Java 9的集合工厂方法在各个领域都能轻松应对，无论是数据初始化、配置文件读取还是常量定义，都能发挥出强大的作用。</p>
<p>展望未来，随着Java版本的不断更新，我们有理由期待它会带来更多“魔法”功能，让集合操作更加简单高效。也许有一天，我们真的可以用魔法棒一挥，就能搞定一切！让我们一起期待吧！</p>
]]></content:encoded>
    </item>
    <item>
      <title>02.Java 9新玩法：Stream API的超能力进化</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/02.Java9%EF%BC%9AStream%20API%E7%9A%84%E8%B6%85%E8%83%BD%E5%8A%9B%E8%BF%9B%E5%8C%96.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/02.Java9%EF%BC%9AStream%20API%E7%9A%84%E8%B6%85%E8%83%BD%E5%8A%9B%E8%BF%9B%E5%8C%96.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">02.Java 9新玩法：Stream API的超能力进化</source>
      <description>嘿，朋友们！今天咱们来聊聊Java开发中的一个超级神器——Stream API。如果你是Java开发者，那你肯定知道，每次JDK版本更新都像是给开发者们打开了一扇新世界的大门，带来各种新特性和优化。而JDK 9的发布，简直就是Java开发界的“大事件”，尤其是Stream API的增强，更是让无数开发者眼前一亮。 想象一下，你手头有一堆数据，比如一堆水果，你得挑出所有的苹果，还得把它们按大小排个序。用传统的Java代码，你可能得写一大堆循环和条件判断，代码又长又难懂。但有了Stream API，这一切都变得简单了！它就像一个超级智能的助手，帮你轻松搞定这些繁琐的任务。</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 09:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>嘿，朋友们！今天咱们来聊聊Java开发中的一个超级神器——Stream API。如果你是Java开发者，那你肯定知道，每次JDK版本更新都像是给开发者们打开了一扇新世界的大门，带来各种新特性和优化。而JDK 9的发布，简直就是Java开发界的“大事件”，尤其是Stream API的增强，更是让无数开发者眼前一亮。</p>
<p>想象一下，你手头有一堆数据，比如一堆水果，你得挑出所有的苹果，还得把它们按大小排个序。用传统的Java代码，你可能得写一大堆循环和条件判断，代码又长又难懂。但有了Stream API，这一切都变得简单了！它就像一个超级智能的助手，帮你轻松搞定这些繁琐的任务。</p>
<p>那么，JDK 9到底给Stream API带来了哪些新花样呢？接下来，咱们就一起探索一下，看看这些新特性到底有多厉害！</p>
<h2> JDK 8中Stream API基础回顾</h2>
<figure><img src="/imgs/column/java/jdk8_stream.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在JDK 8时代，Stream API横空出世，彻底改变了Java开发者处理集合数据的方式。它就像一个神奇的魔法棒，让代码变得简洁又高效。用Stream API，你可以轻松地对集合进行过滤、映射、归约等操作。比如，你想从一堆水果里挑出苹果，用<code>filter</code>方法，告诉Stream“我只要苹果”，它就能帮你搞定。是不是很神奇？</p>
<p>再比如，你手头有一个员工信息列表，你想把每个员工的工资提取出来，用<code>map</code>方法，就能轻松得到一个工资列表。要是想计算工资总和，<code>reduce</code>方法也能帮你搞定。这比传统的循环累加方式简洁多了，代码可读性也高了不少。</p>
<p>总之，JDK 8的Stream API已经很厉害了，但JDK 9又给它加了不少新功能。接下来，咱们来看看JDK 9到底带来了哪些惊喜！</p>
<h2> JDK 9中Stream API的增强特性</h2>
<h3> takeWhile：精准提取流元素</h3>
<p>想象一下，你手头有一串数字，比如1到10，你只想挑出小于5的那些。在JDK 9之前，你可能得写个循环，一个个判断，代码又长又麻烦。但JDK 9的<code>takeWhile</code>方法，就像一个聪明的“筛选器”，能帮你轻松搞定。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“从头开始，只要数字小于5，就把它挑出来。”一旦遇到不小于5的数字，它就会停下来。这比<code>filter</code>方法更高效，因为<code>filter</code>会检查整个列表，而<code>takeWhile</code>一旦找到不满足条件的数字就直接“刹车”。</p>
<p><strong>小贴士</strong>：<code>takeWhile</code>特别适合处理大数据量的流，因为它能提前结束操作，节省时间和资源。</p>
<h3> dropWhile：反向筛选流数据</h3>
<p><code>dropWhile</code>和<code>takeWhile</code>正好相反，它会从流的开头开始，删掉满足条件的元素，直到遇到第一个不满足条件的元素。比如，你还是想处理1到10的数字，但这次你想去掉所有小于5的数字。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“从头开始，把小于5的数字都删掉。”这样一来，结果就只剩下5到10的数字了。这在处理日志数据时特别有用，比如跳过开头的无用信息，直接处理有用的部分。</p>
<h3> ofNullable：优雅处理空值流</h3>
<p>在实际开发中，空值（<code>null</code>）总是让人头疼。不小心碰到<code>null</code>，代码就可能直接崩溃。JDK 9的<code>ofNullable</code>方法，就像一个“保镖”，帮你安全地处理空值。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码中，<code>ofNullable</code>会检查<code>name</code>是否为<code>null</code>。如果是<code>null</code>，它就生成一个空流；如果不是<code>null</code>，就生成一个包含<code>name</code>的流。这样一来，你就不怕空指针异常了。</p>
<p><strong>小贴士</strong>：<code>ofNullable</code>是处理空值的神器，能让你的代码更安全、更健壮。</p>
<h3> iterate：灵活迭代流数据</h3>
<p>在JDK 8中，<code>iterate</code>方法只能生成无限流，用起来有点局限。但在JDK 9中，<code>iterate</code>变得更强大了，你可以给它设置一个结束条件。</p>
<p>比如，你想生成斐波那契数列，直到某个数字超过100：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“从<code>[0, 1]</code>开始，每次生成新的数对，直到第一个数字超过100为止。”这样一来，你就能灵活地生成和处理各种序列了。</p>
<h3> Optional与Stream的深度融合</h3>
<p>在JDK 9中，<code>Optional</code>和<code>Stream</code>也“牵手”了。<code>Optional</code>新增了<code>stream()</code>方法，可以把它转换成Stream，然后继续用Stream的各种方法。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“把<code>Optional</code>里的字符串转成大写，然后打印出来。”如果<code>Optional</code>是空的，<code>stream()</code>方法会返回一个空流，后续操作也不会执行，完美避免了空指针异常。</p>
<p><strong>小贴士</strong>：<code>Optional</code>和<code>Stream</code>的结合，让代码更简洁、更安全。用起来就像“双剑合璧”，威力倍增！</p>
<h2> 增强特性在实际开发中的应用场景</h2>
<h3> 数据处理与分析</h3>
<p>在大数据时代，处理海量数据是家常便饭。JDK 9的Stream API增强特性，让这些任务变得简单又高效。</p>
<p>比如，你手头有一个员工信息列表，你想找出年龄大于30岁、工资高于5000元的员工，并按工资从高到低排序。用JDK 9的Stream API，几行代码就能搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“筛选出符合条件的员工，按工资排序，然后收集到一个列表里。”是不是很简洁？</p>
<p>再比如，你想把一个数字列表分成每10个一组，用<code>takeWhile</code>和<code>dropWhile</code>也能轻松搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“每次跳过已经处理过的数字，然后取出10个一组的数字。”这样一来，分组处理就变得超简单了。</p>
<h3> 集合操作优化</h3>
<p>在日常开发中，集合操作是家常便饭。JDK 9的Stream API增强特性，让这些操作变得更简单、更高效。</p>
<p>比如，你想处理一个字符串列表，直到遇到第一个空字符串为止。用<code>takeWhile</code>方法，几行代码就能搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“从头开始，打印出所有非空字符串，直到遇到第一个空字符串。”这样一来，集合操作就变得更灵活了。</p>
<p><strong>小贴士</strong>：<code>takeWhile</code>和<code>dropWhile</code>是处理集合的利器，能让你的代码更简洁、更高效。</p>
<h2> 性能与代码简洁性分析</h2>
<h3> 性能表现</h3>
<p>咱们来对比一下JDK 8和JDK 9的性能。假设你有一个包含10000个数字的列表，你想计算所有偶数的和。用JDK 8的代码可能长这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而在JDK 9中，你可以用<code>takeWhile</code>优化一下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际测试发现，JDK 9的<code>takeWhile</code>方法在处理大数据量时更快，因为它能提前结束操作，避免不必要的计算。</p>
<h3> 代码简洁性</h3>
<p>再看看代码简洁性。比如，你想从员工列表中筛选出年龄大于30岁、工资高于5000元的员工，并按工资排序。用JDK 8的代码可能长这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而在JDK 9中，你可以用<code>dropWhile</code>进一步简化代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“跳过年龄小于等于30岁的员工，然后筛选出工资高于5000元的员工，按工资排序。”这样一来，代码不仅更简洁，逻辑也更清晰。</p>
<p><strong>小贴士</strong>：JDK 9的Stream API增强特性，让代码更简洁、更高效。用起来就像“开了挂”，能让你的开发效率直线提升！</p>
<h2> 总结与展望</h2>
<p>JDK 9的Stream API增强特性，简直就是Java开发界的“超级英雄”。从精准提取数据，到优雅处理空值，再到强大的迭代和融合能力，这些新特性让我们的代码更简洁、更优雅、更健壮。</p>
<p>在实际开发中，这些特性已经展现出了巨大的优势。它们不仅能帮助我们高效处理海量数据，还能优化集合操作，提升代码的可读性和可维护性。无论是新手还是老司机，都能从这些增强特性中受益。</p>
<p>那么，你还在等什么呢？赶紧在你的项目中试试JDK 9的Stream API增强特性吧！相信我，一旦你用上了，就会发现它的魅力和价值。</p>
<p>最后，如果你对Stream API的更多高级用法感兴趣，我建议你去读读《Java Stream API Cookbook》这本书，里面有不少实用的案例和技巧，能帮你进一步提升开发技能。</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/java/jdk8_stream.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>03.Java 10：集合能力大升级，开发效率狂飙！</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/03.Java10%EF%BC%9A%E9%9B%86%E5%90%88%E8%83%BD%E5%8A%9B%E5%8D%87%E7%BA%A7.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/03.Java10%EF%BC%9A%E9%9B%86%E5%90%88%E8%83%BD%E5%8A%9B%E5%8D%87%E7%BA%A7.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">03.Java 10：集合能力大升级，开发效率狂飙！</source>
      <description>嘿，Java开发者们！是不是觉得每次Java版本更新都像是拆盲盒，不知道里面藏着什么惊喜？今天咱们就来聊聊Java 10，这个在2018年3月21日发布的版本，虽然新特性不多，但每一个都超有用，尤其是集合能力的升级，简直是开发效率的加速器！ 不可变集合创建的进化 Java 9的基础：of()方法 想象一下，你手头有一个水果列表，想把它变成一个不可变的集合，防止别人乱改。在Java 9之前，这事儿可麻烦了，得用Collections.unmodifiableXXX方法。代码长这样：</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 10:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>嘿，Java开发者们！是不是觉得每次Java版本更新都像是拆盲盒，不知道里面藏着什么惊喜？今天咱们就来聊聊Java 10，这个在2018年3月21日发布的版本，虽然新特性不多，但每一个都超有用，尤其是集合能力的升级，简直是开发效率的加速器！</p>
<h2> 不可变集合创建的进化</h2>
<h3> Java 9的基础：<code>of()</code>方法</h3>
<p>想象一下，你手头有一个水果列表，想把它变成一个不可变的集合，防止别人乱改。在Java 9之前，这事儿可麻烦了，得用<code>Collections.unmodifiableXXX</code>方法。代码长这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉有点绕？Java 9终于“开窍”了，直接引入了<code>of()</code>方法，几行代码就能搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>简单吧！而且<code>Set</code>和<code>Map</code>也有类似的<code>of()</code>方法，创建不可变集合就像点外卖一样方便。</p>
<p><strong>小贴士</strong>：不可变集合一旦创建，就不能修改，这在多线程环境下超有用，不用担心数据被乱改。</p>
<h3> Java 10的拓展：<code>copyOf()</code>方法</h3>
<p>Java 10又给我们加了个“新玩具”——<code>copyOf()</code>方法。假设你已经有一个集合，可能是可变的，也可能是不可变的，现在想把它变成不可变的副本，<code>copyOf()</code>就派上用场了。</p>
<p>比如，你有一个可变的水果列表：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>immutableCopy</code>现在就是不可变的了，别人想改？没门！而且，如果原集合本身就是不可变的，<code>copyOf()</code>会直接返回原集合，效率超高。</p>
<p><strong>小贴士</strong>：<code>copyOf()</code>方法不仅能帮你快速创建不可变副本，还能避免重复创建不必要的集合，节省内存。</p>
<h2> 流操作与不可变集合的融合</h2>
<p>Java 10还把流操作和不可变集合“拉郎配”了。比如，你有一个字符串列表，想过滤出长度大于3的字符串，然后收集为不可变集合。以前可能得写一堆代码，现在一行搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉代码瞬间清爽多了？要是想收集为不可变的<code>Set</code>或<code>Map</code>，也有对应的<code>Collectors.toUnmodifiableSet()</code>和<code>Collectors.toUnmodifiableMap()</code>方法。</p>
<p><strong>小贴士</strong>：流操作和不可变集合的结合，让代码不仅简洁，还更安全。再也不用担心数据被误改了！</p>
<h2> 集合能力增强的优势</h2>
<h3> 安全性提升</h3>
<p>为啥不可变集合这么重要？想象一下，你在一个电商系统里，有个商品类别集合，里面装着电子产品、服装、食品等。如果这个集合是可变的，万一某个模块不小心删了某个类别，整个页面可能就乱了。而不可变集合就像给数据加了个“保护罩”，别人想改都改不了。</p>
<p>在多线程环境下，不可变集合更是“救星”。以前，多个线程读取共享数据时，得小心翼翼地同步，不然就容易出错。现在，有了不可变集合，线程们可以放心大胆地读，不用担心数据被改，简直是多线程开发的“福音”。</p>
<h3> 代码简洁性</h3>
<p>Java 10的集合增强，让代码简洁到飞起。以前创建不可变集合，得先创建可变集合，再包装，代码又长又复杂。现在，<code>List.of()</code>和<code>List.copyOf()</code>几行代码就能搞定，简直不要太爽！</p>
<p><strong>小贴士</strong>：简洁的代码不仅开发效率高，还更容易维护。少写代码，少出错，何乐而不为呢？</p>
<h2> 实际开发案例</h2>
<h3> 案例一：配置信息管理</h3>
<p>假设你有个应用程序，配置信息都存在一个<code>properties</code>文件里。以前，读取配置文件后，可能会不小心改了配置信息，导致程序出错。现在，用Java 10的集合增强特性，可以这样写：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样一来，<code>configMap</code>就是不可变的了，不用担心被误改，配置信息的安全性瞬间拉满。</p>
<h3> 案例二：数据处理流程</h3>
<p>再比如，你有个学生成绩的CSV文件，想读取数据，计算每个学科的平均分。用Java 10的集合增强特性，可以这样写：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉代码清晰又高效？不可变集合让数据处理结果更安全，再也不用担心数据被误改了。</p>
<h2> 总结与展望</h2>
<p>Java 10的集合能力增强，简直是开发者的“超级英雄”。不可变集合的创建更简单，流操作和不可变集合的结合更无缝，代码不仅更安全，还更简洁。这些改进在实际开发中超有用，能让你的开发效率狂飙！</p>
<p>最后，如果你在使用Java集合时有什么有趣的经验，或者遇到过什么坑，欢迎在评论区分享哦！</p>
]]></content:encoded>
    </item>
    <item>
      <title>04.Java 11新宠：异步 HTTP 客户端，你的网络请求加速神器！</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/04.Java11%EF%BC%9A%E5%BC%82%E6%AD%A5HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/04.Java11%EF%BC%9A%E5%BC%82%E6%AD%A5HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">04.Java 11新宠：异步 HTTP 客户端，你的网络请求加速神器！</source>
      <description>嘿，Java开发者们！是不是每次看到HTTP请求处理就头大？以前用HttpURLConnection，那复杂的设置步骤、繁琐的参数配置，还有对异步操作的不友好，简直能把人逼疯！每次发起请求，都像是在写一篇冗长的小说，从打开连接到处理响应，每一步都要小心翼翼，稍不留神就可能出错。 但现在，Java 11像是派来了一个超级英雄，带来了全新的异步HTTP客户端。这玩意儿简直太厉害了！它把HTTP请求处理变得像点外卖一样简单，不仅高效、简洁，还充满了现代感。再也不用为复杂的连接设置烦恼，也不用在多线程环境下为异步操作绞尽脑汁。Java 11的异步HTTP客户端，就是你的网络请求加速神器！接下来，咱们就一起看看它是怎么做到的。</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 12:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>嘿，Java开发者们！是不是每次看到HTTP请求处理就头大？以前用<code>HttpURLConnection</code>，那复杂的设置步骤、繁琐的参数配置，还有对异步操作的不友好，简直能把人逼疯！每次发起请求，都像是在写一篇冗长的小说，从打开连接到处理响应，每一步都要小心翼翼，稍不留神就可能出错。</p>
<p>但现在，Java 11像是派来了一个超级英雄，带来了全新的异步HTTP客户端。这玩意儿简直太厉害了！它把HTTP请求处理变得像点外卖一样简单，不仅高效、简洁，还充满了现代感。再也不用为复杂的连接设置烦恼，也不用在多线程环境下为异步操作绞尽脑汁。Java 11的异步HTTP客户端，就是你的网络请求加速神器！接下来，咱们就一起看看它是怎么做到的。</p>
<h2> 传统HTTP客户端的困境</h2>
<p>想象一下，你手头有个任务，需要从网上抓取一些数据。你打开IDE，开始用<code>HttpURLConnection</code>写代码。是不是瞬间感觉头皮发麻？看看这段代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉像在做复杂的拼图游戏？仅仅是发送一个GET请求，就得写这么多代码！而且，要是网络不好，或者服务器不给力，你的程序就得卡在那里，啥也干不了。这就好比你在网上下单买东西，然后一直盯着物流信息，直到快递送到家门口。这体验，太差了！</p>
<p><strong>小贴士</strong>：如果你还在用<code>HttpURLConnection</code>，那可真是太委屈自己了。Java 11的异步HTTP客户端，能让你的代码瞬间清爽起来！</p>
<h2> Java 11 HTTP客户端特性大揭秘</h2>
<h3> 现代化API，简洁又强大</h3>
<p>Java 11的异步HTTP客户端，就像是给你的代码装上了“超能力”。它的API非常简洁，用起来就像搭积木一样简单。看看下面的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉清爽多了？几行代码就搞定了！而且，它的设计非常现代化，支持链式调用，让你的代码不仅简洁，还超容易读。</p>
<p><strong>小贴士</strong>：<code>HttpRequest.newBuilder()</code>是创建请求的神器，用它来设置URI、头信息和请求方法，简直不要太方便！</p>
<h3> 异步加持，并发性能飞升</h3>
<p>Java 11的异步HTTP客户端，最大的亮点就是支持异步操作。这意味着你可以同时发起多个请求，而不用傻等一个完成后再处理下一个。就像你在网上买东西，下单后可以继续干别的事，快递到了自然会有通知。看看这个异步请求的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是很酷？用<code>sendAsync</code>方法发起请求后，程序可以继续干别的事，等响应到了再处理。这不仅让代码更高效，还能大大提升用户体验。</p>
<p><strong>小贴士</strong>：<code>CompletableFuture</code>是异步操作的“瑞士军刀”，用它来处理异步响应，简直不要太方便！</p>
<h3> HTTP/2原生支持，速度飙升</h3>
<p>Java 11的HTTP客户端还支持HTTP/2协议，这可是个大杀器！HTTP/2采用了二进制分帧、多路复用等技术，能让数据传输速度飞起来。就好比在高速公路上开了多车道，多个请求可以同时传输，再也不用排队等了。</p>
<p><strong>小贴士</strong>：HTTP/2的多路复用技术，能让你的程序在高并发场景下表现得超棒！</p>
<h3> 其他贴心特性</h3>
<p>Java 11的HTTP客户端还有很多贴心的小功能。比如，它原生支持WebSocket，让你轻松实现客户端和服务器之间的实时通信。还有，它支持自动重定向，再也不用手动处理那些繁琐的重定向逻辑了。</p>
<p><strong>小贴士</strong>：WebSocket是实时通信的“神器”，用Java 11的HTTP客户端，实现起来超简单！</p>
<h2> 实战演练：异步HTTP客户端上手</h2>
<h3> 环境搭建</h3>
<p>在开始之前，先确保你的开发环境已经配置好Java 11。要是还没装，赶紧去Oracle官网下载吧！安装完成后，用下面的命令检查一下版本：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要是看到Java 11或更高版本，那就万事俱备，只欠东风了！</p>
<h3> 发送GET请求</h3>
<p>咱们先从最简单的GET请求开始。看看下面的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉超简单？几行代码就搞定了！<code>HttpClient.newHttpClient()</code>是创建客户端的入口，<code>HttpRequest.newBuilder()</code>是构建请求的神器，<code>sendAsync</code>是发起异步请求的关键方法。</p>
<p><strong>小贴士</strong>：<code>sendAsync</code>方法返回的是一个<code>CompletableFuture</code>对象，用它来处理异步响应，简直不要太方便！</p>
<h3> 发送POST请求</h3>
<p>要是需要发送POST请求，也是一样简单。看看下面的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉超爽？几行代码就搞定了一个POST请求！<code>HttpRequest.BodyPublishers.ofString</code>是设置请求体的神器，用它来发送JSON数据，简直不要太方便！</p>
<p><strong>小贴士</strong>：发送POST请求时，别忘了设置<code>Content-Type</code>头信息，否则服务器可能会懵圈。</p>
<h2> 与其他HTTP客户端的较量</h2>
<p>Java 11的异步HTTP客户端并不是唯一的HTTP客户端，Apache HttpClient和OkHttp也很厉害。但Java 11的异步HTTP客户端有它的独特优势。</p>
<h3> 性能对比</h3>
<p>在高并发场景下，Java 11的异步HTTP客户端表现超棒！因为它支持异步操作，程序可以在等待响应时干别的事，大大提高了效率。HTTP/2的多路复用技术也让它在高并发场景下表现得超给力！</p>
<p><strong>小贴士</strong>：如果你的应用需要处理大量并发请求，Java 11的异步HTTP客户端绝对是你的不二之选！</p>
<h3> 功能特性对比</h3>
<p>Java 11的异步HTTP客户端API超简洁，用起来就像搭积木一样简单。而且，它原生支持WebSocket和HTTP/2，功能强大到飞起！相比之下，Apache HttpClient和OkHttp虽然也很厉害，但Java 11的异步HTTP客户端绝对是“开挂”一样的存在！</p>
<p><strong>小贴士</strong>：如果你还在犹豫用哪个HTTP客户端，试试Java 11的异步HTTP客户端吧！它绝对会让你眼前一亮！</p>
<h2> 实际应用场景探索</h2>
<h3> 微服务架构中的通信</h3>
<p>在微服务架构中，各个服务之间需要频繁通信。Java 11的异步HTTP客户端就像是服务之间的“快递小哥”，能高效地传递数据。比如，订单服务需要调用库存服务查询库存，用Java 11的异步HTTP客户端，订单服务可以在等待库存服务响应时，继续处理其他任务，大大提高了效率。</p>
<p><strong>小贴士</strong>：在微服务架构中，异步通信是提升性能的关键，Java 11的异步HTTP客户端能帮你轻松搞定！</p>
<h3> 数据抓取与处理</h3>
<p>如果你需要从网上抓取数据，Java 11的异步HTTP客户端也能大显身手。比如，你需要从多个新闻网站抓取最新资讯，用异步HTTP客户端可以同时向多个网站发送请求，大大提高了抓取效率。</p>
<p><strong>小贴士</strong>：异步抓取数据，效率飞起！试试Java 11的异步HTTP客户端吧，绝对让你爽到飞起！</p>
<h2> 总结与展望</h2>
<p>Java 11的异步HTTP客户端，绝对是Java开发者的新宠！它不仅解决了传统HTTP客户端的痛点，还带来了超强大的异步处理能力和超简洁的API。无论是微服务架构中的通信，还是数据抓取与处理，它都能帮你轻松搞定。</p>
<p>展望未来，Java网络编程还会带来更多惊喜。比如，Java HTTP客户端可能会在性能优化和功能拓展上继续发力，进一步提升它的表现。作为开发者，我们一定要紧跟技术发展的步伐，不断学习和探索，让Java网络编程变得更强大！</p>
<p>最后，如果你在使用Java 11的异步HTTP客户端时有任何有趣的经验，或者遇到过什么坑，欢迎在评论区分享哦！</p>
]]></content:encoded>
    </item>
    <item>
      <title>05.Java 9+：日期时间的焕新升级，你跟上了吗？</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/05.Java9_%EF%BC%9A%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E8%BF%AD%E4%BB%A3.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/05.Java9_%EF%BC%9A%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E8%BF%AD%E4%BB%A3.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">05.Java 9+：日期时间的焕新升级，你跟上了吗？</source>
      <description>嘿，Java开发者们！是不是每次看到日期时间处理就头大？别担心，Java 9+来帮你搞定！今天咱们就聊聊Java日期时间处理的前世今生，顺便看看Java 9+给我们带来了哪些惊喜。 1. Java日期时间处理的前世今生 想象一下，你正在开发一个电商系统，突然老板说：“嘿，我们的订单日期处理太慢了，能不能优化一下？”你心里想：“这不就是Java的老毛病吗？”别急，Java 9+已经帮你解决了这些问题。 在Java早期，我们主要靠java.util.Date和java.util.Calendar来处理日期时间。但这两个家伙实在是让人头疼。Date类是可变的，多线程环境下很容易出问题；它的很多方法还被弃用了，用起来特别不方便。Calendar类虽然功能多一些，但API设计太繁琐，代码写起来又长又容易出错。</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 13:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>嘿，Java开发者们！是不是每次看到日期时间处理就头大？别担心，Java 9+来帮你搞定！今天咱们就聊聊Java日期时间处理的前世今生，顺便看看Java 9+给我们带来了哪些惊喜。</p>
<h2> 1. Java日期时间处理的前世今生</h2>
<p>想象一下，你正在开发一个电商系统，突然老板说：“嘿，我们的订单日期处理太慢了，能不能优化一下？”你心里想：“这不就是Java的老毛病吗？”别急，Java 9+已经帮你解决了这些问题。</p>
<p>在Java早期，我们主要靠<code>java.util.Date</code>和<code>java.util.Calendar</code>来处理日期时间。但这两个家伙实在是让人头疼。<code>Date</code>类是可变的，多线程环境下很容易出问题；它的很多方法还被弃用了，用起来特别不方便。<code>Calendar</code>类虽然功能多一些，但API设计太繁琐，代码写起来又长又容易出错。</p>
<p>举个栗子，以前你想获取当前日期，<code>Date</code>类会给你一个包含日期和时间的完整信息，你还得费劲巴拉地提取日期部分。这就好比你只想知道今天是几号，但它却告诉你：“今天是2024年10月25日，星期五，下午3点45分。”你心里想：“我要这么多信息干啥？”</p>
<p><strong>小贴士</strong>：如果你还在用<code>java.util.Date</code>或<code>Calendar</code>，那可真是太委屈自己了。Java 8之后的日期时间API绝对会让你眼前一亮！</p>
<h2> 2. Java 8日期时间API基础回顾</h2>
<p>Java 8终于“开窍”了，引入了全新的<code>java.time</code>包，彻底改变了日期时间处理的现状。这个包借鉴了第三方库Joda - Time的设计思想，用起来特别顺手。</p>
<h3> 2.1 核心类介绍</h3>
<p>Java 8的日期时间API里，<code>LocalDate</code>、<code>LocalTime</code>和<code>ZonedDateTime</code>是最常用的三个类。</p>
<ul>
<li><code>LocalDate</code>只表示日期，不包含时间和时区信息。比如，你想记录今天是几号，用<code>LocalDate</code>就够了。</li>
<li><code>LocalTime</code>只表示时间，也不包含日期和时区信息。比如，你想记录某件事情发生的具体时间，用它就合适。</li>
<li><code>ZonedDateTime</code>则是日期、时间和时区的“全家桶”，特别适合处理跨国业务。</li>
</ul>
<p>这些类都是不可变的，线程安全，用起来特别放心。比如，多个线程同时读取当前日期，<code>LocalDate</code>的不可变特性保证了每个线程看到的日期都是一样的。</p>
<p><strong>小贴士</strong>：<code>LocalDate</code>和<code>LocalTime</code>是处理日常日期时间问题的“瑞士军刀”，用起来特别方便。</p>
<h3> 2.2 常用操作示例</h3>
<h4> 日期解析</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 日期格式化</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 日期增减</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些操作是不是特别简单？Java 8的日期时间API就是这么贴心！</p>
<h2> 3. Java 9+对日期时间的优化亮点</h2>
<p>Java 9+在Java 8的基础上又加了不少新功能，让日期时间处理变得更强大。</p>
<h3> 3.1 Java9 新增方法增强功能</h3>
<h4> truncatedTo方法</h4>
<p>Java 9+在日期时间类中新增了很多实用方法。比如，<code>LocalDateTime</code>的<code>truncatedTo</code>方法可以截断时间到指定单位。你想把时间截断到小时？几行代码搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还有<code>OffsetDateTime</code>的<code>withOffsetSameInstant</code>方法，可以更改时区偏移量，同时保持时间不变。这在处理跨国业务时特别有用。</p>
<p><strong>小贴士</strong>：<code>truncatedTo</code>方法是处理日期时间的“剪刀”，用它来裁剪多余的时间部分，特别方便。</p>
<h4> datesUntil方法</h4>
<p>从Java 9开始，<code>LocalDate</code>类中新增了一个超实用的方法——<code>datesUntil()</code>。这个方法可以生成一个日期范围内的所有日期序列，就像一个“日期生成器”。它特别适合处理日期范围的场景，比如计算两个日期之间的所有日期，或者生成未来一段时间内的日期列表。</p>
<p><strong>用法示例</strong></p>
<p>假设你想生成从今天开始，未来一周内的所有日期，用<code>datesUntil()</code>方法可以轻松搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“从今天开始，生成到一周后的所有日期。”<code>datesUntil()</code>方法返回一个<code>Stream&lt;LocalDate&gt;</code>，你可以用<code>forEach</code>打印出来，或者用<code>collect</code>收集到一个列表中。</p>
<p><strong>小贴士</strong>：<code>datesUntil()</code>方法返回的是一个流（<code>Stream</code>），这意味着你可以用流的操作（比如<code>filter</code>、<code>map</code>）来处理日期序列。超灵活！</p>
<h3> 3.2 Java 16中的 <code>InstantSource</code> 接口</h3>
<h4> <code>InstantSource</code>是啥？</h4>
<p>从Java 16开始，Java日期时间API又新增了一个接口——<code>InstantSource</code>。这个接口的作用是提供一个统一的方式来获取当前时间戳（<code>Instant</code>）。它特别适合在需要动态获取时间戳的场景中使用。</p>
<h4> 用法示例</h4>
<p>假设你想在代码中动态获取当前时间戳，但又不想直接调用<code>Instant.now()</code>，可以用<code>InstantSource</code>来实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“通过<code>InstantSource</code>获取当前时间戳。”<code>InstantSource</code>是一个函数式接口，可以用Lambda表达式实现。</p>
<h3> 3.3 性能与内存优化</h3>
<p>Java 9+在性能和内存方面也做了不少优化。比如，创建<code>LocalDate</code>对象的速度更快了，处理大量日期时间数据时，性能提升特别明显。</p>
<p>举个栗子，你想计算100万个日期的下一天，Java 9+的代码不仅更简洁，运行速度也更快。不信？你可以试试！</p>
<h3> 3.4 时区处理的改进</h3>
<p>Java 9+对时区处理也做了优化。比如，获取时区规则的速度更快了，而且对历史时区数据的更新也更灵活。这意味着，即使某个地区的夏令时规则变了，Java 9+也能及时调整，不会出错。</p>
<p><strong>小贴士</strong>：时区处理是全球化业务的“刚需”，Java 9+绝对能帮你搞定！</p>
<h2> 4. 实际应用案例与代码演示</h2>
<h3> 4.1 业务场景中的优化体现</h3>
<h4> 电商订单处理</h4>
<p>假设你正在开发一个电商系统，需要计算订单的预计发货时间。Java 8的代码可能有点复杂，但Java 9+的代码更简洁：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java 9+的<code>truncatedTo</code>方法让代码更清晰，逻辑也更简单。</p>
<h4> 金融交易记录</h4>
<p>假设你需要将纽约时区的交易时间转换为上海时区的时间。Java 9+的代码更简洁：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java 9+的<code>withOffsetSameInstant</code>方法让时区转换变得超简单！</p>
<h4> 实际场景：计算工作日</h4>
<p>假设你想计算从今天开始，未来一周内的所有工作日（排除周末），可以用<code>datesUntil()</code>结合流操作来实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“从今天开始，生成未来一周内的所有日期，然后过滤掉周末。”是不是超方便？</p>
<h4> 实际场景：测试和模拟</h4>
<p><code>InstantSource</code>在测试和模拟场景中特别有用。比如，你想在测试中模拟一个固定的时间戳，可以用<code>InstantSource</code>来实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“通过<code>InstantSource</code>模拟一个固定的时间戳。”这样，你就可以在测试中控制时间戳，而不用担心实际时间的变化。</p>
<p><strong>小贴士</strong>：<code>InstantSource</code>是Java 16的新特性，如果你还在用Java 9 - 15，可以考虑升级到Java 16，或者用其他方式实现类似的功能。</p>
<h3> 4.2 性能对比</h3>
<p>我们来做一个简单的性能测试，看看Java 9+的优势。比如，计算100万个日期的下一天，Java 9+的代码不仅更简洁，运行速度也更快。</p>
<p>Java 8 的代码实现如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java9+ 的代码实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>测试次数</th>
<th>Java 8 耗时（毫秒）</th>
<th>Java 9 + 耗时（毫秒）</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1234</td>
<td>987</td>
</tr>
<tr>
<td>2</td>
<td>1198</td>
<td>1023</td>
</tr>
<tr>
<td>3</td>
<td>1210</td>
<td>995</td>
</tr>
<tr>
<td>4</td>
<td>1205</td>
<td>1002</td>
</tr>
<tr>
<td>5</td>
<td>1222</td>
<td>1010</td>
</tr>
</tbody>
</table>
<p>测试结果表明，Java 9+的性能确实更优！</p>
<h2> 5. 开发者如何平滑过渡与升级</h2>
<h3> 5.1 升级步骤与注意事项</h3>
<p>从Java 8迁移到Java 9+，你需要检查项目中所有使用日期时间API的代码。虽然Java 9+的API和Java 8基本一致，但新增的方法可以让代码更高效。</p>
<p><strong>小贴士</strong>：升级前，一定要仔细阅读Java 9+的官方文档，了解API的变化和兼容性问题。别忘了检查第三方库是否支持Java 9+，否则可能会出问题。</p>
<h3> 5.2 学习资源推荐</h3>
<p>如果你还想了解更多关于Java 9+日期时间优化的内容，我推荐你看看这些资源：</p>
<ol>
<li>Java官方文档：最权威的学习资料，详细介绍了Java 9+的新特性和优化点。</li>
<li>技术博客：比如InfoQ、开源中国等，有很多技术专家分享的实战经验。</li>
<li>专业书籍：《Java核心技术》和《Effective Java》都更新了相关内容，特别值得一读。</li>
</ol>
<h2> 6. 总结与展望</h2>
<p>Java 9+的日期时间优化，绝对能让你的代码更高效、更简洁。新增的方法、性能优化和时区处理改进，让日期时间处理变得超简单。无论是电商、金融还是其他业务场景，Java 9+都能帮你轻松搞定。</p>
<p>所以，如果你还在用Java 8的日期时间API，不妨试试Java 9+。相信我，它绝对会让你眼前一亮！</p>
<p>最后，如果你在使用Java 9+日期时间API时有任何有趣的经验，或者遇到过什么坑，欢迎在评论区分享哦！</p>
]]></content:encoded>
    </item>
    <item>
      <title>06.Java 10新特性：局部变量类型推断，让代码飞起来！</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/06.Java10%EF%BC%9A%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/06.Java10%EF%BC%9A%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">06.Java 10新特性：局部变量类型推断，让代码飞起来！</source>
      <description>引言 嘿，Java开发者们！是不是每次写代码，都要在类型声明上浪费好多时间？比如，声明一个变量，还得写上长长的类型名，感觉特别繁琐？别担心，Java 10来救场啦！它带来了一个超酷的新特性——局部变量类型推断。用var关键字，编译器就能自动帮你搞定类型声明，代码瞬间变得简洁又清爽！今天，咱们就来聊聊这个新特性，看看它是怎么让代码“飞起来”的。 什么是局部变量类型推断 传统局部变量声明方式回顾 想象一下，你正在写代码，突然需要声明一个整型变量。你得这么写： int num = 10;</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 14:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 引言</h2>
<p>嘿，Java开发者们！是不是每次写代码，都要在类型声明上浪费好多时间？比如，声明一个变量，还得写上长长的类型名，感觉特别繁琐？别担心，Java 10来救场啦！它带来了一个超酷的新特性——局部变量类型推断。用<code>var</code>关键字，编译器就能自动帮你搞定类型声明，代码瞬间变得简洁又清爽！今天，咱们就来聊聊这个新特性，看看它是怎么让代码“飞起来”的。</p>
<h2> 什么是局部变量类型推断</h2>
<h3> 传统局部变量声明方式回顾</h3>
<p>想象一下，你正在写代码，突然需要声明一个整型变量。你得这么写：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>是不是感觉有点多余？再看看声明一个字符串变量：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要是类型更复杂，比如声明一个存储整数的<code>ArrayList</code>，代码就更长了：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这代码写起来是不是有点累？要是类型声明能简单点就好了，对吧？</p>
<h3> Java 10的变革：<code>var</code>关键字登场</h3>
<p>Java 10终于“开窍”了！它引入了<code>var</code>关键字，让你再也不用显式声明变量类型。编译器会自动根据变量的初始值推断类型。比如，上面的代码可以改写成这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是瞬间清爽多了？编译器会根据右侧的值推断出变量的类型，<code>num</code>是<code>int</code>，<code>str</code>是<code>String</code>，<code>list</code>是<code>ArrayList&lt;Integer&gt;</code>。这不仅减少了代码冗余，还让代码更易读。</p>
<p><strong>小贴士</strong>：<code>var</code>是Java 10的新宠，用它来简化代码，绝对让你爽到飞起！</p>
<h2> 局部变量类型推断的工作原理</h2>
<h3> 编译器如何推断类型</h3>
<p>编译器是怎么做到的呢？其实很简单，它会根据变量初始化表达式的右侧值来推断类型。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>编译器看到<code>10</code>是一个整数，就会推断<code>num</code>是<code>int</code>类型。再复杂一点：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>编译器会根据<code>new ArrayList&lt;Integer&gt;()</code>推断出<code>list</code>是<code>ArrayList&lt;Integer&gt;</code>类型。</p>
<p>要是不信，可以反编译代码看看。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>反编译后，代码会变成这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是很神奇？编译器在编译阶段就把<code>var</code>替换成了具体类型。</p>
<h3> 静态类型语言的本质未变</h3>
<p>虽然有了<code>var</code>，但Java依然是静态类型语言。变量的类型在编译时就已经确定，不是运行时才决定的。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器会报错，因为<code>num</code>的类型已经被推断为<code>int</code>，你不能给它赋一个字符串值。这就是Java的静态类型特性，即使用了<code>var</code>，代码依然安全可靠。</p>
<p><strong>小贴士</strong>：<code>var</code>只是让代码更简洁，Java的类型安全依然有保障！</p>
<h2> <code>var</code>的使用场景</h2>
<h3> 基础类型变量声明</h3>
<p>声明基础类型变量时，<code>var</code>让代码更简洁。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别清爽？类型一目了然，代码也更紧凑。</p>
<h3> 泛型类型变量声明</h3>
<p>对于复杂的泛型类型，<code>var</code>的优势更明显。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要是不用<code>var</code>，就得写<code>Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();</code>，代码瞬间变长。</p>
<p><strong>小贴士</strong>：<code>var</code>是处理复杂类型的好帮手，用它来简化代码，特别方便！</p>
<h3> 循环中的应用</h3>
<p>在循环中，<code>var</code>也能大显身手。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>i</code>的类型被推断为<code>int</code>，代码更简洁。在增强的<code>for</code>循环中：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>item</code>的类型会根据<code>list</code>的元素类型被推断为<code>String</code>，代码看起来更自然。</p>
<h3> 方法中的局部变量与返回值</h3>
<p>在方法内部，<code>var</code>也能让代码更清晰。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉代码瞬间清爽多了？</p>
<h3> 三元运算结果存储</h3>
<p>使用三元运算符时，<code>var</code>也能派上用场。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器会根据三元运算的结果类型推断出<code>result</code>是<code>String</code>类型，代码更简洁。</p>
<h3> 流操作中的应用</h3>
<p>在流操作中，<code>var</code>也能简化代码。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>var</code>让流操作的代码更简洁流畅，不用再写长长的类型声明。</p>
<h2> 使用<code>var</code>的注意事项和限制</h2>
<h3> 必须初始化变量</h3>
<p>用<code>var</code>声明变量时，必须同时初始化，因为编译器需要通过初始值来推断类型。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但下面的代码会报错：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：用<code>var</code>时，记得初始化变量，否则编译器会懵圈。</p>
<h3> 不能用于特定场景</h3>
<p>虽然<code>var</code>很强大，但它不能用于所有场景。比如，它不能用于类的实例变量、方法参数、方法返回类型、<code>catch</code>块或<code>lambda</code>表达式中。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些场景还是得用传统的显式类型声明。</p>
<p><strong>小贴士</strong>：<code>var</code>是局部变量的专属，其他地方别乱用哦！</p>
<h3> 避免影响代码可读性</h3>
<p>虽然<code>var</code>能简化代码，但过度使用可能会让代码难以理解。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果方法的返回类型很复杂，用<code>var</code>可能会让读者摸不着头脑。所以，类型不明显时，还是老老实实写类型吧。</p>
<p><strong>小贴士</strong>：用<code>var</code>要适度，别让代码变得晦涩难懂。</p>
<h2> 总结与展望</h2>
<p>Java 10的局部变量类型推断功能，绝对是Java开发者的福音！用<code>var</code>关键字，代码不仅更简洁，还保持了Java的类型安全性。在实际开发中，合理使用<code>var</code>，能让代码更易读，开发效率也更高。</p>
<p>不过，用<code>var</code>时，记得遵循它的规则和限制，避免滥用。比如，记得初始化变量，别在不适用的场景中乱用，类型不明显时别偷懒。</p>
<p>如果你对<code>var</code>还有疑问，或者在实际开发中遇到过有趣的场景，欢迎在评论区分享哦！</p>
]]></content:encoded>
    </item>
    <item>
      <title>07.Java 15新特性：文本块，代码书写的新利器</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/07.Java15%EF%BC%9A%E6%96%87%E6%9C%AC%E5%9D%97.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/07.Java15%EF%BC%9A%E6%96%87%E6%9C%AC%E5%9D%97.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">07.Java 15新特性：文本块，代码书写的新利器</source>
      <description>Java 15新特性：文本块，代码书写的新利器！ 传统字符串拼接的痛点 嘿，Java开发者们！有没有遇到过这样的烦恼：写代码时，字符串拼接写得自己都快崩溃了？比如，写SQL查询语句或者HTML代码片段，一不小心就拼错，还得花时间去排查问题。这事儿是不是特别烦人？ 想象一下，你正在写一个SQL查询语句，代码可能是这样的： String sql = &amp;quot;SELECT * FROM users &amp;quot; + &amp;quot;WHERE age &amp;gt; 18 &amp;quot; + &amp;quot;AND gender = &amp;apos;male&amp;apos; &amp;quot; + &amp;quot;ORDER BY username;&amp;quot;;</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 15:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 15新特性：文本块，代码书写的新利器！</h1>
<h2> 传统字符串拼接的痛点</h2>
<p>嘿，Java开发者们！有没有遇到过这样的烦恼：写代码时，字符串拼接写得自己都快崩溃了？比如，写SQL查询语句或者HTML代码片段，一不小心就拼错，还得花时间去排查问题。这事儿是不是特别烦人？</p>
<p>想象一下，你正在写一个SQL查询语句，代码可能是这样的：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉代码特别冗长，还容易出错？要是SQL语句更复杂，那代码简直就像“迷宫”一样，让人摸不着头脑。</p>
<p>再看看HTML代码片段的拼接：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种拼接方式不仅代码结构不清晰，还特别容易漏掉某个连接符。要是字符串里有特殊字符，还得用转义字符，比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>是不是感觉特别麻烦？这些痛点不仅让代码看起来很乱，还容易出错，降低开发效率。那有没有更好的办法呢？别急，Java 15的文本块来救场啦！</p>
<h2> Java 15文本块闪亮登场</h2>
<h3> 文本块是什么</h3>
<p>Java 15引入了一个超酷的新特性——文本块（Text Blocks）。它就像一个“魔法盒子”，能让你用更直观、更简洁的方式定义多行字符串。简单来说，文本块就是用三个双引号（<code>"""</code>）作为分隔符的字符串。在这对分隔符之间的所有内容，都会被视为字符串的一部分，而且会保留文本的格式和缩进。</p>
<p>举个栗子，上面的SQL查询语句用文本块写起来就超简单：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是瞬间清爽多了？代码不仅更短，还一目了然。</p>
<h3> 文本块的使用规则</h3>
<p>使用文本块时，有几条简单的规则：</p>
<ol>
<li><strong>分隔符</strong>：文本块以三个双引号（<code>"""</code>）开始，以三个双引号结束。开始和结束的<code>"""</code>必须单独成行，中间不能有其他字符（除了空格和换行符）。</li>
<li><strong>内容</strong>：在三个双引号内，可以插入任何字符，包括换行符、制表符等。这让你定义多行文本时特别自然。</li>
<li><strong>缩进</strong>：文本块支持缩进，缩进会被保留在最终的字符串中。这对于保持代码的结构和格式特别有帮助。</li>
<li><strong>转义字符</strong>：虽然文本块减少了对转义字符的需求，但仍然可以使用<code>\</code>来转义特殊字符，比如<code>\"</code>表示双引号，<code>\\</code>表示反斜杠。</li>
</ol>
<h3> 示例代码</h3>
<p>看看下面这些示例，感受一下文本块的强大：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行这段代码，你会发现输出的字符串完美地保留了你在文本块中定义的格式，是不是很神奇？</p>
<p><strong>小贴士</strong>：文本块特别适合处理多行文本，比如SQL语句、HTML代码、JSON和XML等，让代码更清晰、更易读。</p>
<h2> 文本块在实际开发中的强大应用</h2>
<h3> SQL语句编写</h3>
<p>想象一下，你正在写一个复杂的SQL查询语句，用传统方式拼接字符串，代码可能会变成这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉代码特别乱？要是用文本块，代码瞬间变清爽：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别清晰？文本块不仅让代码更简洁，还减少了出错的可能性。</p>
<h3> HTML代码构建</h3>
<p>再看看HTML代码的构建。传统方式拼接字符串，代码可能是这样的：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别冗长？用文本块，代码瞬间变清爽：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别清晰？文本块不仅让代码更简洁，还减少了出错的可能性。</p>
<h3> 其他场景应用拓展</h3>
<p>除了SQL语句和HTML代码，文本块在其他场景中也特别有用。比如，写JSON字符串：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者写配置文件内容：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些示例展示了文本块的强大功能。无论是处理结构化文本还是复杂的字符串内容，文本块都能让代码更简洁、更易读，提高开发效率和代码质量。</p>
<p><strong>小贴士</strong>：文本块特别适合处理多行文本，让代码更清晰、更易读。用它来写SQL、HTML、JSON和XML，绝对让你爽到飞起！</p>
<h2> 文本块与传统字符串的深度对比</h2>
<h3> 代码简洁性</h3>
<p>文本块在代码简洁性方面绝对秒杀传统字符串拼接。比如，写SQL语句，传统方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用文本块：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉文本块特别清爽？代码量瞬间减少，逻辑也更清晰。</p>
<h3> 可读性</h3>
<p>代码的可读性对于开发和维护特别重要。传统字符串拼接方式在处理多行文本时，代码逻辑结构特别模糊。比如，写JSON字符串，传统方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>用文本块：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉文本块特别清晰？代码结构一目了然，开发人员可以轻松理解和修改内容。</p>
<h3> 维护难度</h3>
<p>当代码需要修改时，维护的难度就特别明显。对于传统字符串拼接的代码，如果需要修改某一部分，比如修改SQL语句中的一个条件，传统方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别麻烦？还得小心连接符和空格。用文本块：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别简单？直接修改就行，不用担心连接符和转义字符。</p>
<h2> 总结与展望</h2>
<p>Java 15的文本块特性绝对是个“神器”，它解决了传统字符串拼接的痛点，让代码更简洁、更易读、更易维护。无论是写SQL语句、HTML代码，还是处理JSON和XML，文本块都能让你的代码瞬间“飞起来”。</p>
<p>未来，Java还会带来更多实用的新特性。希望你在新项目中，或者在合适的旧项目重构中，积极尝试使用文本块，让代码更优雅、更高效。</p>
<p>最后，如果你在使用文本块时有任何有趣的经验，或者遇到过什么坑，欢迎在评论区分享哦！</p>
]]></content:encoded>
    </item>
    <item>
      <title>08.Java 16纪录类：告别繁琐，让代码起飞</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/08.Java16%EF%BC%9A%E7%BA%AA%E5%BD%95%E7%B1%BB.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/08.Java16%EF%BC%9A%E7%BA%AA%E5%BD%95%E7%B1%BB.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">08.Java 16纪录类：告别繁琐，让代码起飞</source>
      <description>告别繁琐！Java 16记录类让代码起飞 一、引言：Java 16的新成员 嘿，Java开发者们！是不是每次写代码，都要在数据类上浪费好多时间？构造函数、getter/setter、equals、hashCode、toString……这些代码写起来特别繁琐，还容易出错。Java 16终于“开窍”了！它带来了一个超酷的新特性——记录类（Record Classes）。用它，你只需要一行代码，就能搞定一个数据类！是不是很爽？接下来，咱们就一起看看这个新特性到底有多厉害！</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 16:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 告别繁琐！Java 16记录类让代码起飞</h1>
<h2> 一、引言：Java 16的新成员</h2>
<p>嘿，Java开发者们！是不是每次写代码，都要在数据类上浪费好多时间？构造函数、<code>getter/setter</code>、<code>equals</code>、<code>hashCode</code>、<code>toString</code>……这些代码写起来特别繁琐，还容易出错。Java 16终于“开窍”了！它带来了一个超酷的新特性——记录类（Record Classes）。用它，你只需要一行代码，就能搞定一个数据类！是不是很爽？接下来，咱们就一起看看这个新特性到底有多厉害！</p>
<h2> 二、传统Java类的痛点</h2>
<p>想象一下，你正在写一个表示用户信息的类，包含用户名、年龄和邮箱。按照传统的Java类定义方式，代码可能是这样的：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别繁琐？写完这些代码，估计你都快累死了。而且，要是类的属性变了，你还得挨个修改这些方法，维护成本特别高。</p>
<p><strong>小贴士</strong>：传统Java类的痛点就是代码繁琐、容易出错、维护成本高。Java 16的记录类就是来解决这些问题的！</p>
<h2> 三、记录类初体验</h2>
<h3> （一）基本语法与定义</h3>
<p>Java 16的记录类简直是“代码减负神器”。用它定义数据类，只需要一行代码！比如，上面的<code>User</code>类用记录类来写，就变成了这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>是不是瞬间清爽多了？记录类会自动帮你生成构造函数、访问器方法、<code>equals</code>、<code>hashCode</code>和<code>toString</code>方法。你再也不用写那些繁琐的代码了！</p>
<h3> （二）自动生成的方法</h3>
<h4> 构造函数</h4>
<p>记录类会自动生成一个构造函数，参数和属性顺序一致。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 访问器方法</h4>
<p>记录类会为每个属性生成访问器方法，方法名和属性名一样。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是特别简洁？再也不用写那些冗长的<code>getUsername()</code>方法了。</p>
<h4> equals和hashCode方法</h4>
<p>记录类的<code>equals</code>和<code>hashCode</code>方法会自动比较所有属性值。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> toString方法</h4>
<p>记录类的<code>toString</code>方法会返回一个包含所有属性值的字符串。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类自动生成的方法，让你的代码不仅简洁，还功能完整。再也不用担心忘记写某个方法了！</p>
<h2> 四、记录类的特性深度剖析</h2>
<h3> （一）不可变性</h3>
<p>记录类的实例是不可变的，这意味着一旦对象被创建，属性值就不能被修改。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>不可变性的好处特别多。首先，代码更安全，不用担心属性被误改；其次，在多线程环境下，不可变对象天生就是线程安全的，不用担心数据一致性问题。</p>
<p><strong>小贴士</strong>：不可变性是记录类的核心特性之一，它让代码更安全、更可靠。</p>
<h3> （二）构造器的奥秘</h3>
<h4> 标准构造器</h4>
<p>记录类会自动生成一个标准构造器，参数和属性顺序一致。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 紧凑构造器</h4>
<p>记录类还支持紧凑构造器，可以省略形参列表和字段赋值语句。比如，你可以在这里加一些参数校验：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：紧凑构造器让你在创建对象时进行必要的校验，同时保持代码简洁。</p>
<h3> （三）成员声明规则</h3>
<h4> 字段声明</h4>
<p>记录类中只能声明静态变量，不能声明实例变量。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 方法声明</h4>
<p>记录类中可以声明实例方法和静态方法，但不能声明抽象方法或原生方法。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类的成员声明规则既保证了不可变性，又提供了足够的扩展能力。</p>
<h3> （四）实现接口</h3>
<p>记录类可以实现接口，这让你可以在保持简洁的同时，扩展更多的功能。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类实现接口，让你的代码更灵活，应用场景更广泛。</p>
<h2> 五、实际应用场景</h2>
<h3> （一）数据传输对象（DTO）</h3>
<p>在企业级开发中，DTO是一种常用的设计模式。以前，定义一个DTO类需要写一大堆代码，现在用记录类，一行代码搞定！比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在Spring MVC中，你可以这样接收前端数据：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类作为DTO，代码简洁，不可变性还保证了数据的安全性。</p>
<h3> （二）配置项表示</h3>
<p>记录类特别适合表示配置项。比如，加载数据库配置信息：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类的不可变性确保了配置在运行期间不会被误改，提高了系统的稳定性。</p>
<h3> （三）日志记录</h3>
<p>记录类也可以用来表示日志条目。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在业务代码中：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类的不可变性和自动生成的<code>toString</code>方法，让日志记录更安全、更清晰。</p>
<h2> 六、与其他技术的结合</h2>
<h3> （一）Lombok对比</h3>
<p>Lombok是一个流行的Java库，通过注解自动生成样板代码。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然Lombok也很方便，但记录类是Java语言层面的解决方案，不需要额外依赖。而且，记录类的代码更简洁，访问器方法更直观。</p>
<p><strong>小贴士</strong>：记录类和Lombok都能减少样板代码，但记录类更简洁、更安全。</p>
<h3> （二）在Spring框架中的应用</h3>
<h4> Spring Boot配置类</h4>
<p>记录类可以简化Spring Boot的配置类。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 数据访问层</h4>
<p>记录类也可以和Spring Data JPA结合。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类和Spring框架结合，让你的代码更简洁、更高效。</p>
<h2> 七、总结与展望</h2>
<p>Java 16的记录类绝对是Java开发者的“减负神器”。它不仅减少了样板代码，还让代码更安全、更易读。不可变性、自动生成的方法、灵活的构造器……这些特性让记录类在数据传输、配置管理、日志记录等多个场景中都能大显身手。</p>
<p>未来，Java语言还会不断进化，记录类也可能会带来更多惊喜。如果你还在用Java 16及以上版本，不妨大胆尝试记录类，相信它会给你带来全新的编程体验！</p>
<p>最后，如果你在使用记录类时有任何有趣的经验，或者遇到过什么坑，欢迎在评论区分享哦！</p>
]]></content:encoded>
    </item>
    <item>
      <title>09.Java 16 密封类：代码安全与可维护性的新利器</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/09.Java16%EF%BC%9A%E5%AF%86%E5%B0%81%E7%B1%BB.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/09.Java16%EF%BC%9A%E5%AF%86%E5%B0%81%E7%B1%BB.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">09.Java 16 密封类：代码安全与可维护性的新利器</source>
      <description>解锁Java 16密封类：代码安全与可维护性的新利器 一、Java 16那些事儿 嘿，Java爱好者们！2021年3月16日，Java 16像是一位带着宝藏的探险家，突然闯进了我们的编程世界。它带来了17个新特性，从语言到库，从性能优化到各种小惊喜，每个都像是给开发者准备的礼物🎁。其中，密封类（Sealed Classes）作为第二次预览特性，特别亮眼，就像夜空中最闪亮的星星✨。 想象一下，你正在写代码，突然发现某个类被继承得乱七八糟，继承体系完全失控。是不是特别烦？Java 16的密封类就是来解决这个问题的。它能给类的继承体系“上锁”，让继承变得可控。接下来，咱们就一起看看这个“秩序守护者”到底有多厉害！</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 17:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 解锁Java 16密封类：代码安全与可维护性的新利器</h1>
<h2> 一、Java 16那些事儿</h2>
<p>嘿，Java爱好者们！2021年3月16日，Java 16像是一位带着宝藏的探险家，突然闯进了我们的编程世界。它带来了17个新特性，从语言到库，从性能优化到各种小惊喜，每个都像是给开发者准备的礼物🎁。其中，密封类（Sealed Classes）作为第二次预览特性，特别亮眼，就像夜空中最闪亮的星星✨。</p>
<p>想象一下，你正在写代码，突然发现某个类被继承得乱七八糟，继承体系完全失控。是不是特别烦？Java 16的密封类就是来解决这个问题的。它能给类的继承体系“上锁”，让继承变得可控。接下来，咱们就一起看看这个“秩序守护者”到底有多厉害！</p>
<h2> 二、密封类初印象</h2>
<h3> （一）密封类是啥</h3>
<p>在Java里，类的继承就像家族传承。但如果家族成员随便加入，就会乱成一团。密封类就是给这个家族传承加上“锁”的存在。它用<code>sealed</code>关键字修饰，通过<code>permits</code>子句列出允许继承的子类，从而控制继承体系。</p>
<p>举个栗子，假设你正在写一个图形绘制系统，有一个<code>Shape</code>类作为所有图形的基类。正常情况下，你只希望<code>Circle</code>（圆形）和<code>Rectangle</code>（矩形）能继承它。这时候，就可以把<code>Shape</code>类定义为密封类，并在<code>permits</code>子句中列出<code>Circle</code>和<code>Rectangle</code>。其他类就无法随意继承<code>Shape</code>类了，继承体系瞬间变得清晰又稳定。</p>
<h3> （二）密封类语法大揭秘</h3>
<p>密封类的语法其实很简单，就像给类加上了一个“允许继承名单”。定义一个密封类的语法如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>子类在继承密封类时，需要根据需求使用不同的关键字来声明：</p>
<ul>
<li><code>final</code>关键字修饰的子类：表示这个子类不能再被继承，就像家族的分支到这儿就结束了。比如：</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>sealed</code>关键字修饰的子类：表示这个子类仍然是密封的，还可以继续限制自己的子类。比如：</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>non - sealed</code>关键字修饰的子类：表示这个子类打破了密封限制，恢复成普通类，可以被任意类继承。比如：</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：密封类的语法就像给类的继承体系画了一张“家谱图”，让你一眼就能看清楚谁可以继承谁。</p>
<h2> 三、密封类的超能力</h2>
<h3> （一）控制继承结构</h3>
<p>想象一下，你的代码就像一个精心规划的家族树，每个分支都清晰明确。密封类就像是家族树的规划师，能严格控制类的继承结构。</p>
<p>比如，在一个图形绘制系统中，<code>Shape</code>类作为所有图形的基类，定义了一些通用属性和方法。如果不使用密封类，任何类都可以继承<code>Shape</code>类，继承体系可能会变得混乱。但有了密封类，你可以明确指定哪些类可以继承它，比如<code>Circle</code>和<code>Rectangle</code>。这样一来，其他类就无法随意继承<code>Shape</code>类，继承体系瞬间变得清晰又稳定。</p>
<p><strong>小贴士</strong>：密封类让继承体系变得可控，就像给家族树画了一道“安全线”，防止乱七八糟的分支出现。</p>
<h3> （二）提升代码安全性</h3>
<p>密封类不仅能控制继承结构，还能提升代码的安全性。想象一下，你的代码就像一个城堡，而密封类就是坚固的城墙，能有效防止恶意子类的入侵。</p>
<p>比如，在一个权限管理系统中，有一个<code>Permission</code>类用于验证用户权限。如果不使用密封类，恶意子类可能会继承<code>Permission</code>类并重写验证方法，导致权限验证失效。但如果你把<code>Permission</code>类定义为密封类，并只允许一些受信任的子类继承它，就能防止恶意子类的出现，确保权限验证逻辑的安全性。</p>
<p><strong>小贴士</strong>：密封类就像给代码加了一把“安全锁”，只有经过授权的子类才能进入继承体系。</p>
<h3> （三）增强代码可维护性</h3>
<p>在大型项目中，代码的可维护性就像城市的交通规划一样重要。密封类就像是城市交通的指示牌，能让代码结构更清晰，便于理解和维护。</p>
<p>比如，在一个企业级应用中，有一个<code>BusinessObject</code>类作为业务对象的基类。如果你把它定义为密封类，并且只允许几个特定的业务对象类继承它，比如<code>Customer</code>和<code>Order</code>，其他开发者在查看代码时就能一眼明白这个继承体系的结构，快速定位和修改相关代码。</p>
<p><strong>小贴士</strong>：密封类让代码结构更清晰，就像一个整洁的书架，每本书都放在合适的位置，方便你快速找到需要的信息。</p>
<h2> 四、密封类实战演练</h2>
<h3> （一）简单示例走一波</h3>
<p>理论讲了这么多，是不是有点懵？别急，咱们来看一个简单的代码示例。</p>
<p>假设你正在写一个图形绘制系统，有一个<code>Shape</code>类作为所有图形的基类，它有两个子类：<code>Circle</code>（圆形）和<code>Rectangle</code>（矩形）。用密封类来实现，代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们可以在测试类中使用这些类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是特别简单？密封类让代码结构清晰，逻辑一目了然。</p>
<h3> （二）复杂场景也不怕</h3>
<p>在实际项目中，密封类的应用场景往往更复杂。比如，你正在开发一个2D游戏，游戏中有不同类型的角色，每个角色都有自己的行为和属性。可以用密封类来组织这些角色，代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在游戏场景中，可以这样使用这些角色类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是特别清晰？密封类让代码结构一目了然，逻辑清晰，维护起来也特别方便。</p>
<h2> 五、避坑指南</h2>
<h3> （一）常见错误及解决</h3>
<p>使用密封类时，可能会遇到一些常见的坑。别怕，咱们来一一解决！</p>
<h4> 子类未按规定修饰</h4>
<p>如果子类没有使用<code>final</code>、<code>sealed</code>或<code>non - sealed</code>关键字修饰，编译器会报错。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决方法：根据需求，为子类添加合适的修饰关键字。比如，如果<code>Circle</code>类不需要再被继承，可以用<code>final</code>修饰：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 未在permits子句中列出子类</h4>
<p>如果密封类的<code>permits</code>子句中没有列出允许继承的子类，其他类即使符合条件也无法继承该密封类。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决方法：在密封类的<code>permits</code>子句中明确列出允许继承的子类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 子类不在同一包中</h4>
<p>如果允许子类扩展密封类，那么子类必须和密封类定义在同一个包中。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决方法：将子类<code>Circle</code>移动到与密封类<code>Shape</code>相同的包中。</p>
<h3> （二）注意事项要牢记</h3>
<h4> 密封类与其他特性的结合使用</h4>
<p>密封类可以和Java的其他特性结合使用，比如模式匹配、泛型、注解等。但在结合使用时，需要注意它们之间的相互影响和兼容性。比如，泛型类型参数的声明和使用需要保持一致，否则可能会出现编译错误。</p>
<h4> 密封类的性能影响</h4>
<p>虽然密封类本身不会对性能产生显著的负面影响，但过度使用可能会让代码变得复杂，影响扩展性和灵活性。所以，使用密封类时，要根据具体需求合理权衡。</p>
<h2> 六、密封类与其他特性的梦幻联动</h2>
<h3> （一）和模式匹配的默契配合</h3>
<p>密封类和模式匹配就像是一对默契十足的搭档，能让代码变得更加简洁高效。</p>
<p>比如，在一个图形绘制系统中，你有一个密封类<code>Shape</code>和它的子类<code>Circle</code>、<code>Rectangle</code>和<code>Square</code>。现在需要一个方法来描述不同形状的信息。如果不使用密封类和模式匹配，代码可能是这样的：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码看起来特别繁琐，还容易出错。但如果使用密封类和模式匹配，代码就变得简洁明了：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是特别清爽？密封类和模式匹配的结合，让代码不仅简洁，还更安全。</p>
<h3> （二）与其他特性的协同作战</h3>
<p>密封类不仅能和模式匹配配合，还能和访问修饰符、泛型、注解等其他特性一起使用，打造出更强大的代码。</p>
<p>比如，你可以用自定义注解标记密封类的子类，然后在运行时通过反射读取这些注解信息，实现动态行为。或者，你可以定义一个泛型密封类，用于表示不同类型的数据集合，同时限制只有特定的子类可以继承它。</p>
<p><strong>小贴士</strong>：密封类和其他特性的结合，就像给你的代码加上了“超级外挂”，让代码更强大、更灵活。</p>
<h2> 七、总结与展望</h2>
<p>Java 16的密封类就像是一把“继承控制钥匙”，能让你在管理类的继承结构时更加得心应手。它不仅能控制继承体系，还能提升代码的安全性和可维护性。在实际项目中，密封类已经展现出了它的强大魅力，无论是在简单的图形绘制系统，还是复杂的游戏开发场景中，都能帮助你更好地组织代码。</p>
<p>如果你还在用Java 16及以上版本，不妨大胆尝试密封类，相信它会给你带来全新的编程体验。同时，也可以期待Java在未来的版本中，继续完善和扩展与密封类相关的特性。</p>
<p>最后，如果你在使用密封类时有任何有趣的经验，或者遇到过什么坑，欢迎在评论区分享哦！</p>
]]></content:encoded>
    </item>
    <item>
      <title>10.JDK 21新特性揭秘：字符串模板，Java编程的华丽升级</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/10.Java21%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/10.Java21%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">10.JDK 21新特性揭秘：字符串模板，Java编程的华丽升级</source>
      <description>嘿，各位Java开发者们！是不是每天都在和那些繁琐的代码打交道，感觉有点疲惫了？别担心，JDK 21带着它的新特性来拯救我们啦！今天，咱们就来聊聊其中最让人眼前一亮的字符串模板（String Templates）。这玩意儿可真是给Java字符串操作这块“老古董”注入了一股新鲜血液，让咱们处理字符串的时候能轻松不少。别着急，接下来我带你一起走进JDK 21字符串模板的奇妙世界，保证让你眼前一亮！ 传统字符串拼接的“囧境” 在深入了解字符串模板之前，咱们先来回顾一下传统字符串拼接方式的那些“囧事”，相信你在日常开发中肯定没少遇到。</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 18:01:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>嘿，各位Java开发者们！是不是每天都在和那些繁琐的代码打交道，感觉有点疲惫了？别担心，JDK 21带着它的新特性来拯救我们啦！今天，咱们就来聊聊其中最让人眼前一亮的字符串模板（<code>String Templates</code>）。这玩意儿可真是给Java字符串操作这块“老古董”注入了一股新鲜血液，让咱们处理字符串的时候能轻松不少。别着急，接下来我带你一起走进JDK 21字符串模板的奇妙世界，保证让你眼前一亮！</p>
<h2> 传统字符串拼接的“囧境”</h2>
<p>在深入了解字符串模板之前，咱们先来回顾一下传统字符串拼接方式的那些“囧事”，相信你在日常开发中肯定没少遇到。</p>
<h3> （一）繁琐的加号拼接</h3>
<p>在Java里，用<code>+</code>号拼接字符串是最基础的方式。可一旦拼接的变量多了，代码就像“面条”一样，又长又乱，读起来费劲得很。比如，我们要拼接用户的个人信息：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码虽然能实现功能，但你看看，这代码量，这可读性，简直让人头疼！而且，每用一次+号拼接，就会创建一个新的<code>String</code>对象，性能开销大得很，简直是在“拖累”程序。</p>
<h3> （二）StringBuilder的无奈</h3>
<p>为了解决<code>+</code>号拼接的性能问题，我们通常会用<code>StringBuilder</code>。它通过可变的字符序列来避免频繁创建新的字符串对象，从而提高性能。不过，<code>StringBuilder</code>的代码结构也比较复杂。还是上面的例子，用<code>StringBuilder</code>来实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看看，使用<code>StringBuilder</code>时，得先创建对象，再调用多次<code>append</code>方法，最后还得调用<code>toString</code>方法转换为<code>String</code>类型。对于简单的字符串拼接场景，这操作是不是太“繁琐”了？简直就是“小题大做”。</p>
<h3> （三）格式化方法的痛点</h3>
<p>除了上述两种方式，我们还会用<code>String.format</code>和<code>MessageFormat</code>来进行字符串格式化拼接。但它们也有问题，比如将格式字符串与参数分离，这导致代码理解和维护起来超级困难。以<code>String.format</code>为例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然代码看起来简洁一些，但格式字符串里的占位符和后面的参数对应关系不够直观。当参数多或者格式字符串复杂时，很容易出错，也不利于代码维护。这就好比是“盲人摸象”，一不小心就容易“摸错地方”。</p>
<h2> JDK 21字符串模板闪亮登场</h2>
<p>好啦，传统方式的问题咱们都清楚了，那JDK 21中的字符串模板到底能给我们带来哪些惊喜呢？别急，这就来揭开它的神秘面纱。</p>
<h3> （一）特性简介</h3>
<p>字符串模板是JDK 21引入的一个预览特性，它允许我们在字符串中直接嵌入变量和表达式，从而简化字符串的拼接过程，提高代码的可读性和可维护性。这有点类似于<code>Python中</code>的<code>f-string</code>和<code>JavaScript</code>中的模板字符串，熟悉这两种语言的小伙伴肯定能轻松上手。</p>
<h3> （二）基本语法展示</h3>
<p>在JDK 21中，字符串模板用STR处理器和反引号“`”来定义。基本语法如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，<code>STR</code>是模板处理器，<code>\{name}</code>是嵌入的表达式，<code>name</code>的值会在运行时被替换到字符串中。运行这段代码，输出结果就是<code>Hello, 张三!</code>。是不是感觉比传统的字符串拼接方式简洁多了？简直就是“清爽版”的代码。</p>
<h3> （三）多行字符串的优雅处理</h3>
<p>在处理多行字符串时，字符串模板的优势就更明显了。比如，我们要拼接一个<code>HTML</code>字符串：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用字符串模板，我们可以像写普通的<code>HTML</code>代码一样来拼接字符串，再也不用担心繁琐的<code>+</code>号和转义字符了。这就好比是从“手写时代”直接跨越到了“打印时代”，清晰又方便。</p>
<p>同样，在拼接<code>JSON</code>字符串时，字符串模板也能让代码更加简洁明了：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出的<code>json</code>字符串就是：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> （四）表达式嵌入的强大功能</h3>
<p>字符串模板不仅支持嵌入变量，还支持嵌入各种表达式，比如算术运算、方法调用等。这可真是太厉害了！比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果就是两数之和为：<code>30</code>。再比如，我们有一个获取当前时间的方法<code>getCurrentTime()</code>，可以这样在字符串模板中调用：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果类似于当前时间是：<code>2024-10-22T15:30:00.123</code>，具体时间根据实际运行情况而定。</p>
<p>通过这种方式，我们可以轻松地将方法的返回值嵌入到字符串中，让代码更加简洁高效。这就好比是给代码“插上了翅膀”，让它能更灵活地“飞翔”。</p>
<h2> 深入探索字符串模板的用法</h2>
<h3> （一）自定义处理器的实现</h3>
<p>除了<code>JDK 21</code>自带的<code>STR</code>、<code>FMT</code>等模板处理器，我们还可以通过实现<code>StringTemplate.Processor</code>接口来自定义模板处理器，以满足特定的业务需求。比如，我们想实现一个自定义处理器，把字符串里的所有字母都变成大写。实现步骤如下：</p>
<ol>
<li>实现<code>StringTemplate.Processor</code>接口，并重写<code>process</code>方法。</li>
<li>在<code>process</code>方法中，获取模板中的片段和值，进行自定义处理。</li>
<li>返回处理后的结果。</li>
</ol>
<p>示例代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用自定义处理器的示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行上述代码，输出结果就是学习 <code>JAVA 很有趣</code>。</p>
<p>通过自定义处理器，我们可以根据具体的业务需求对字符串模板进行灵活处理，大大提高了字符串处理的灵活性和扩展性。</p>
<p>这就好比是给代码“量身定制”了一套“外衣”，让它能更好地适应各种场景。</p>
<h3> （二）与其他Java特性的融合</h3>
<p>字符串模板还可以和<code>Java</code>的其他特性，比如<code>lambda</code>表达式、流操作等，结合使用，发挥出更强大的功能。</p>
<p><strong>1.与lambda表达式结合</strong></p>
<p>我们可以在字符串模板的表达式中使用<code>lambda</code>表达式，实现一些复杂的逻辑处理。比如，我们有一个列表，需要把列表里的元素拼接成一个字符串，而且每个元素之间用逗号隔开，同时对每个元素进行一些处理（比如首字母大写）：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们使用了流操作对列表里的每个元素进行首字母大写处理，然后用<code>Collectors.joining</code>方法把处理后的元素拼接成一个字符串，最后把结果嵌入到字符串模板中。运行结果就是水果列表：<code>Apple, Banana, Cherry</code>。通过这种方式，我们可以把<code>字符串模板</code>和<code>lambda表达式</code>、<code>流操作</code>结合起来，实现复杂的数据处理和字符串生成。这就好比是把不同的“食材”放在一起“烹饪”，做出了一道“美味大餐”。</p>
<p><strong>2.与流操作结合</strong></p>
<p>字符串模板和流操作的结合还体现在对字符串的分割和处理上。比如，我们有一个多行字符串，想把它按行分割，然后对每一行进行一些操作（比如去除行首空格），最后再拼接成一个新的字符串：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们使用<code>lines</code>方法把多行字符串转换为流，然后用<code>map</code>方法对每一行进行去除行首空格的操作，最后用<code>Collectors.joining</code>方法把处理后的行重新拼接成一个字符串，并嵌入到字符串模板中。</p>
<p>运行结果就是处理后的字符串：<code>line1\nline2\nline3</code>。</p>
<p>通过把字符串模板和流操作结合，我们可以更加高效地处理字符串数据，提高代码的可读性和可维护性。这就好比是给字符串做了一次“美容”，让它变得更加“整洁”。</p>
<h2> 使用字符串模板的注意事项</h2>
<h3> （一）预览特性的局限性</h3>
<p>需要注意的是，字符串模板在JDK 21中还是一个预览特性。</p>
<p>这意味着它可能会在未来的 Java 版本中发生变化，甚至有可能被移除。</p>
<p>在生产环境中使用时，一定要谨慎考虑兼容性问题。</p>
<p>如果你的项目需要长期稳定运行，并且对 JDK 版本的升级比较敏感，那么在使用字符串模板之前，要充分评估其潜在风险。</p>
<p>比如，某些依赖库可能不支持 JDK 21 的预览特性，这可能会导致项目在编译或运行时出现问题。</p>
<p>在编译和运行包含字符串模板的代码时，需要添加<code>--enable-preview</code>参数来启用预览特性。</p>
<p>例如，使用命令行编译时，要这样写：<code>javac --enable-preview --source 21 YourClass.java</code>；运行时则使用<code>java --enable-preview YourClass</code>。</p>
<h3> （二）性能与资源考量</h3>
<p>虽然字符串模板让代码看起来清爽多了，但在某些情况下，咱们也得注意它的“小脾气”。比如，在循环里频繁创建模板字符串，那可就有点“得不偿失”了。为啥呢？每次创建模板字符串，都要进行解析和求值操作，这可是要消耗<code>CPU</code>和内存资源的。要是循环次数太多，那性能可就“一落千丈”了。</p>
<p>举个例子，想象一下你在厨房里，每次做饭都要重新洗菜、切菜，那效率得多低啊！所以，如果在循环中用到字符串模板，建议把不变的部分提前准备好，放在循环外面。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>prefix</code>是不变的部分，放在循环外面，这样就避免了每次循环都重复解析和求值<code>prefix</code>，效率一下子就上来了。</p>
<p>另外，如果处理的字符串特别大，或者模板里嵌入的表达式特别复杂，那内存可就“吃不消”了。想象一下，你在一个小房间里堆满了杂物，很快就没地方站了。所以，处理大数据量的字符串时，一定要合理设计表达式，避免不必要的内存开销。</p>
<h3> （三）错误处理策略</h3>
<p>用字符串模板的时候，难免会遇到一些“小插曲”，比如表达式求值失败。这就像是你在做一道复杂的菜，突然发现某个调料用完了，那可就麻烦了。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>divide(10, 0)</code>会抛出<code>ArithmeticException</code>异常，因为除数不能为0。不过别担心，我们用<code>try-catch</code>块把它“抓住”，然后进行相应的错误处理，这样程序就不会因为异常而“崩溃”了。</p>
<p>要是模板字符串的语法不对，比如反引号不匹配、表达式格式错误，编译器会像“警察叔叔”一样，及时提醒你。所以在写代码的时候，一定要仔细检查模板字符串的语法，确保它“规规矩矩”的。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些错误在编译的时候就会被发现，所以一定要根据编译器的提示及时修改代码，不然程序可就“跑不起来”了。</p>
<p>通过这些注意事项，咱们就能更好地驾驭字符串模板这个“新伙伴”，让它在项目中发挥最大的作用，同时避免一些常见的“坑”。</p>
]]></content:encoded>
    </item>
    <item>
      <title>11.JDK 21虚拟线程：Java并发编程的革新利器</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/11.Java21%EF%BC%9A%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/11.Java21%EF%BC%9A%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">11.JDK 21虚拟线程：Java并发编程的革新利器</source>
      <description>一、引言：并发编程的新曙光 嘿，各位Java开发者！是不是每次面对高并发场景，都感觉像是在打一场硬仗？传统线程就像是一群“老炮儿”，虽然经验丰富，但在高并发的战场上，它们的“腿脚”越来越不灵便了。想象一下，你的服务器被成千上万的请求“围攻”，每个请求都要派一个线程去处理。传统线程的创建和销毁成本高得吓人，而且占用的内存资源比“吃货”还多！这就像是在战场上派出了大量装备沉重、行动迟缓的士兵，不仅耗费巨大，还容易陷入混乱。 别担心，JDK 21带着虚拟线程来“救场”啦！虚拟线程就像是从天而降的“超级英雄”，专门来解决传统线程在高并发场景下的“疲软”问题。接下来，咱们就一起揭开虚拟线程的神秘面纱，看看它是怎么在高并发的战场上大显身手的！</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 18:11:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 一、引言：并发编程的新曙光</h2>
<p>嘿，各位Java开发者！是不是每次面对高并发场景，都感觉像是在打一场硬仗？传统线程就像是一群“老炮儿”，虽然经验丰富，但在高并发的战场上，它们的“腿脚”越来越不灵便了。想象一下，你的服务器被成千上万的请求“围攻”，每个请求都要派一个线程去处理。传统线程的创建和销毁成本高得吓人，而且占用的内存资源比“吃货”还多！这就像是在战场上派出了大量装备沉重、行动迟缓的士兵，不仅耗费巨大，还容易陷入混乱。</p>
<p>别担心，JDK 21带着虚拟线程来“救场”啦！虚拟线程就像是从天而降的“超级英雄”，专门来解决传统线程在高并发场景下的“疲软”问题。接下来，咱们就一起揭开虚拟线程的神秘面纱，看看它是怎么在高并发的战场上大显身手的！</p>
<h2> 二、虚拟线程是什么</h2>
<p>虚拟线程的调度主要包含三个核心部分：虚拟线程（Virtual Threads）、平台线程（Platform Threads）和调度器（Scheduler）。</p>
<ol>
<li><strong>虚拟线程池：</strong></li>
</ol>
<ul>
<li>这是一个包含大量虚拟线程的集合。每个虚拟线程代表一个轻量级的执行单元，它们可以由用户代码创建并提交到执行器中等待执行。虚拟线程之间是平等的，它们的栈空间较小，创建和销毁的开销也很低。</li>
</ul>
<ol start="2">
<li><strong>平台线程池：</strong></li>
</ol>
<ul>
<li>平台线程是与操作系统内核线程一一对应的线程，数量相对较少。平台线程负责执行虚拟线程中的实际任务，它们是系统资源的实际使用者。</li>
</ul>
<ol start="3">
<li><strong>调度器：</strong></li>
</ol>
<ul>
<li>调度器是整个系统的核心，负责将虚拟线程分配到可用的平台线程上执行。</li>
<li>调度器会根据虚拟线程的状态（如就绪、阻塞等）和平台线程的负载情况进行智能调度。</li>
<li>当一个虚拟线程遇到阻塞操作（如 I/O 操作）时，调度器会将该虚拟线程暂停，并将平台线程分配给其他就绪的虚拟线程；当阻塞操作完成后，调度器会将该虚拟线程重新加入到就绪队列中，等待再次分配到平台线程执行。</li>
</ul>
<ol start="4">
<li><strong>阻塞与唤醒机制：</strong></li>
</ol>
<ul>
<li>当虚拟线程进行 I/O 等阻塞操作时，会触发阻塞信号，调度器将其标记为阻塞状态并让出平台线程；</li>
<li>当阻塞操作完成，会有唤醒信号，调度器将其重新标记为就绪状态等待调度。</li>
</ul>
<p><strong>虚拟线程调度的基本流程：</strong></p>
<p>虚拟线程进入调度器，调度器将其分配到平台线程执行，当平台线程上的虚拟线程遇到阻塞操作时通知调度器，调度器再去唤醒其他就绪的虚拟线程执行。</p>
<figure><img src="/imgs/column/java/jdk21_virtual_thread_00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>虚拟线程，简单来说，就是由JVM管理的轻量级线程。它就像是线程世界里的“小精灵”，和传统的平台线程（也就是我们平常用的普通线程，由操作系统管理）有着天壤之别。传统的平台线程和操作系统线程是一一对应的，就好比一个萝卜一个坑，每个平台线程都要占用操作系统的一套资源，包括内存空间、内核数据结构等。而虚拟线程则是一群“小精灵”共享少量的“坑位”（平台线程），它们的创建和销毁成本极低，几乎可以忽略不计，就像在游戏里创建和删除一个虚拟角色一样轻松。</p>
<p>在调度方面，平台线程由操作系统内核负责调度，每次上下文切换都要陷入内核态，这个过程复杂又耗时。而虚拟线程则由JVM在用户态进行调度，JVM就像一个聪明的“小管家”，能够高效地安排这些“小精灵”的工作，大大减少了上下文切换的开销。打个比方，平台线程的调度就像是大公司里层层汇报的工作流程，效率低下；而虚拟线程的调度则像是创业团队里的扁平化管理，沟通高效，决策迅速。</p>
<p>在资源占用上，一个平台线程通常需要占用1MB左右的栈空间，这在高并发场景下是一笔巨大的开销。而虚拟线程的栈空间非常小，只有几十KB甚至更小，这使得我们可以在一个JVM中轻松创建数百万个虚拟线程，极大地提升了系统的并发处理能力。可以想象，平台线程是豪华的独栋别墅，占用大量空间资源；而虚拟线程则是精致的公寓，小巧玲珑，能够在有限的空间里容纳更多的“住户”。</p>
<h2> 三、虚拟线程的优势</h2>
<h3> （一）资源高效利用</h3>
<p>虚拟线程在资源利用方面，就像是一个精打细算的“小管家”，有着独特的优势。传统线程创建时，需要向操作系统申请一系列资源，包括内存空间用于线程栈，这就好比为每个“大管家”分配一个豪华大别墅，开销巨大。而且，操作系统对线程数量的管理能力有限，当创建的传统线程数量过多时，系统资源会被迅速耗尽，就像一个城市里突然涌入过多需要豪华别墅的人，城市资源根本无法承受，最终导致系统崩溃。</p>
<p>而虚拟线程则截然不同，它的创建和管理开销极低，几乎可以忽略不计。因为虚拟线程并不直接对应操作系统线程，它们共享少量的操作系统线程（也就是前面提到的“坑位”），就像多个“小管家”合住在一个经济实惠的公寓里，大大节省了资源。这使得在Java应用中可以轻松创建数百万个虚拟线程，而不会对系统资源造成过大压力。例如，在一个高并发的电商系统中，每一个商品查询请求都可以分配一个虚拟线程来处理，即使在促销活动期间，大量请求涌入，系统也能轻松应对，不会因为线程资源不足而出现卡顿或崩溃的情况。</p>
<h3> （二）高并发性能提升</h3>
<p>当面对高并发场景时，虚拟线程的表现堪称惊艳，就像一位超级英雄，能够轻松应对各种挑战。我们以Web服务器处理大量并发请求为例，在传统线程模型下，每一个请求都需要创建一个传统线程来处理。随着并发请求数量的增加，线程数量也会急剧上升，线程之间的上下文切换变得频繁，这就好比一个繁忙的十字路口，车辆过多导致交通堵塞，每个线程真正用于处理任务的时间被大大压缩，系统的响应速度变慢，吞吐量也随之降低。</p>
<p>而虚拟线程采用的是用户态调度，由JVM高效管理。当一个虚拟线程执行I/O操作（比如读取数据库数据、接收网络请求数据等）时，它会暂时让出执行权，JVM调度器会立即安排其他可运行的虚拟线程执行任务，就像一个高效的交通调度员，能够合理安排车辆通行，避免交通堵塞。这样一来，在高并发场景下，虚拟线程能够充分利用CPU资源，大大提高了系统的并发处理能力和吞吐量。有研究表明，在处理大量I/O密集型任务时，使用虚拟线程的系统吞吐量相比传统线程可以提升数倍甚至数十倍。例如，在一个处理大量并发网络请求的Web服务器中，使用虚拟线程后，每秒能够处理的请求数量从原来的数千个提升到了数万个，响应时间也从几百毫秒缩短到了几十毫秒，极大地提升了用户体验。</p>
<h3> （三）简化编程模型</h3>
<p>虚拟线程的出现，还为开发者带来了一个巨大的福音——简化编程模型，就像为复杂的编程世界带来了一张简洁明了的地图。在传统的并发编程中，为了实现高效的并发处理，开发者常常需要使用复杂的异步编程模型，如回调机制、Future模式等。这些模型虽然能够实现并发功能，但代码结构复杂，可读性差，就像一个迷宫，让人容易迷失方向。而且，在异步编程中，处理多个任务之间的依赖关系和错误处理也非常棘手，需要开发者花费大量的时间和精力去调试和维护。</p>
<p>而虚拟线程支持同步编程模型，开发者可以像编写普通单线程代码一样编写并发代码，不需要过多地关注线程的创建、销毁和调度等细节，就像在熟悉的道路上行驶，轻松自在。例如，在使用虚拟线程处理多个数据库查询任务时，开发者可以依次编写每个查询操作，就像在单线程环境下一样，而不需要像传统异步编程那样，将每个查询操作封装成回调函数，然后处理回调之间的嵌套关系。这样不仅降低了编程的难度，还提高了代码的可读性和可维护性，让开发者能够更加专注于业务逻辑的实现，提高开发效率。</p>
<h3> (四) 对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>平台线程</th>
<th>虚拟线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建数量</td>
<td>数千级</td>
<td><strong>百万级</strong></td>
</tr>
<tr>
<td>内存消耗</td>
<td>默认1MB/线程</td>
<td><strong>~200字节/线程</strong></td>
</tr>
<tr>
<td>上下文切换</td>
<td>内核参与</td>
<td><strong>JVM优化</strong></td>
</tr>
<tr>
<td>编程模型</td>
<td>回调地狱风险</td>
<td><strong>同步代码风格</strong></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>高吞吐</strong>：轻松支撑10万+并发连接</li>
<li><strong>低资源消耗</strong>：创建百万虚拟线程仅需几百MB内存</li>
<li><strong>代码简化</strong>：用同步代码实现异步性能，避免回调地狱</li>
<li><strong>兼容性</strong>：与现有Thread API、调试工具（如jstack）完全兼容</li>
</ol>
<h2> 四、应用场景与示例</h2>
<h3> （零）基本使用示例</h3>
<p>基本使用姿势有下面两种</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如使用虚拟线程实现归并排序</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明：</strong></p>
<ul>
<li>使用虚拟线程并行化归并排序的递归任务。</li>
<li>每个子任务（<code>mergeSort</code>）都在独立的虚拟线程中执行。</li>
<li>通过<code>Future</code>获取子任务结果，并合并（<code>merge</code>）排序后的数组。</li>
</ul>
<h3> （一）高并发网络服务</h3>
<p>在高并发网络服务场景中，Web服务器是一个典型的例子。想象一下，你的Web服务器就像一个繁忙的接待大厅，每天要接待成千上万的访客（并发请求）。传统的做法是为每个访客安排一个专门的接待人员（传统线程），但随着访客数量的增加，接待人员的数量也需要不断增加，这不仅成本高昂，而且管理起来非常困难。而虚拟线程就像是一群训练有素的兼职接待员，他们可以迅速响应访客的需求，并且占用的资源极少。</p>
<p>下面是一个简单的Web服务器使用虚拟线程处理并发请求的代码示例，我们使用Java的HttpServer类来创建一个简单的Web服务器，并对比传统线程池的处理方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们创建了两个Web服务器，一个使用虚拟线程处理请求，另一个使用固定大小为10的传统线程池处理请求。通过模拟处理请求的耗时操作（<code>Thread.sleep(100)</code>），可以直观地感受到虚拟线程在高并发场景下的优势。</p>
<p>在实际测试中，如果使用工具（如Apache JMeter）模拟大量并发请求，可以发现使用虚拟线程的Web服务器能够处理更多的并发请求，响应速度更快，吞吐量更高。因为虚拟线程的创建和切换开销极低，能够迅速响应新的请求，而传统线程池由于线程数量有限，在高并发情况下容易出现线程阻塞，导致请求处理速度变慢。</p>
<h3> （二）I/O密集型任务</h3>
<p>在I/O密集型任务中，文件读取和数据库查询是常见的场景。以文件读取为例，假设你需要从一个大型文件中读取数据并进行处理，每个读取操作都可能需要等待磁盘I/O完成，这期间线程会被阻塞。</p>
<p>传统线程在这种情况下，会占用大量的系统资源，并且由于线程阻塞，CPU资源无法得到充分利用。而虚拟线程就像是一群聪明的小助手，它们在等待I/O操作完成的过程中，会主动让出CPU资源，让其他任务得以执行。</p>
<p>下面是一个文件读取的示例代码，展示虚拟线程在I/O密集型任务中的应用：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们分别使用虚拟线程和传统线程来读取一个大型文件，并模拟对每一行数据的处理（<code>Thread.sleep(10)</code>）。可以看到，使用虚拟线程时，由于它在I/O阻塞时能够迅速挂起并释放资源，使得系统能够同时处理多个文件读取任务，大大提高了资源利用率和处理效率。而传统线程在读取文件时，如果遇到I/O阻塞，整个线程就会被阻塞，无法进行其他操作，导致CPU资源浪费。</p>
<p>再以数据库查询为例，假设我们有一个电商系统，需要查询商品信息。在高并发情况下，传统线程池可能会因为线程阻塞而导致查询效率低下。而使用虚拟线程，每个查询请求都可以分配一个虚拟线程，在等待数据库响应的过程中，虚拟线程可以被挂起，JVM可以调度其他虚拟线程执行任务，从而提高系统的并发处理能力和响应速度。例如，使用JDBC进行数据库查询时，代码可以这样写：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们分别使用虚拟线程和传统线程进行数据库查询，并模拟对查询结果的处理（<code>Thread.sleep(10)</code>）。可以看出，虚拟线程在处理I/O密集型的数据库查询任务时，能够有效减少线程阻塞时间，提高系统的并发处理能力和资源利用率。</p>
<h2> 五、使用方法与注意事项</h2>
<h3> （一）创建和启动虚拟线程</h3>
<p>在Java中，创建和启动虚拟线程非常简单，就像搭建一个简易的积木模型。我们可以使用<code>Thread</code>和<code>Thread.Builder APIs</code>来创建虚拟线程，就像挑选合适的积木块。例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们通过<code>Thread.ofVirtual().start()</code>方法创建并启动了一个虚拟线程，该线程执行一个简单的打印任务，输出当前线程的信息。这里的<code>Thread.ofVirtual()</code>就像是一个特殊的积木挑选器，专门用于挑选虚拟线程这块“积木”，而<code>start()</code>方法则是将这块“积木”搭建起来，让它开始工作。</p>
<p>我们还可以使用Thread.Builder来设置虚拟线程的一些属性，比如线程名称，就像给积木涂上不同的颜色进行标记：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们创建了一个名为MyVirtualThread的虚拟线程，通过Thread.Builder设置了线程名称，使我们在调试和管理线程时更容易识别。</p>
<p>除了上述方法，我们还可以使用Executors来创建虚拟线程。Executors就像是一个专业的积木搭建工具，它提供了<code>newVirtualThreadPerTaskExecutor</code>方法，为每个任务启动一个新的虚拟线程：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们使用<code>Executors.newVirtualThreadPerTaskExecutor</code>创建了一个ExecutorService，然后通过<code>submit</code>方法提交了10个任务，每个任务都会在一个新的虚拟线程中执行。这里的<code>Executors.newVirtualThreadPerTaskExecutor</code>就像是一个自动化的积木搭建助手，它会自动为每个任务搭建一个虚拟线程“积木”，并让它们开始工作。</p>
<h3> （二）使用建议</h3>
<p>在使用虚拟线程时，我们有一些实用的建议，就像驾驶汽车时需要遵循的规则。</p>
<p>首先，<strong>无需池化虚拟线程。</strong></p>
<ul>
<li>因为虚拟线程的创建和销毁开销极低，就像使用一次性餐具一样，用完即弃也不会造成太大的浪费。如果对虚拟线程进行池化，反而会增加不必要的管理复杂度，就像在一个小房间里摆放过多的家具，显得杂乱无章。</li>
</ul>
<p>其次，<strong>要尽量避免阻塞虚拟线程。</strong></p>
<ul>
<li>虽然虚拟线程对阻塞操作进行了优化，但长时间阻塞虚拟线程仍然会影响系统的并发处理能力。这就像是在一条繁忙的道路上，如果有一辆车长时间停在路中间，就会导致交通堵塞。例如，在进行I/O操作时，应该尽量使用非阻塞的I/O API，或者将阻塞操作放在单独的线程池中处理，避免阻塞虚拟线程。</li>
</ul>
<p>另外，<strong>虽然虚拟线程很轻量级，但也不能无节制地创建。</strong></p>
<ul>
<li>大量创建虚拟线程仍然会消耗一定的系统资源，就像在一个仓库里堆放过多的货物，会占用大量的空间。因此，在使用虚拟线程时，应根据系统的实际情况，合理控制其数量，避免资源浪费。例如，在一个Web服务器中，根据服务器的硬件配置和预计的并发请求数量，设置一个合适的虚拟线程上限，既能充分利用虚拟线程的优势，又能保证系统的稳定运行。</li>
</ul>
<h3> （三）注意事项</h3>
<p>在享受虚拟线程带来的便利时，我们也不能忽视一些注意事项，就像在享受美食时要注意食物的卫生。虚拟线程虽然强大，但它并不适用于所有场景。</p>
<p>对于计算密集型任务，由于这类任务主要依赖CPU进行大量的计算，而虚拟线程的优势在于减少线程上下文切换开销，对于CPU计算能力的提升并没有帮助，所以传统线程池可能更适合。例如，在进行复杂的数学计算、图像渲染等任务时，使用传统线程池可以更好地利用CPU资源，提高计算效率。</p>
<p>同时，我们还需要关注第三方库的兼容性问题。有些第三方库可能没有对虚拟线程进行优化，或者直接依赖于操作系统线程的特性，在虚拟线程中使用时可能会出现意想不到的问题。这就像是在一辆改装过的汽车上安装不匹配的零件，可能会影响汽车的正常行驶。因此，在使用第三方库时，要查看其文档，确认是否支持虚拟线程，或者进行充分的测试，确保在虚拟线程环境下能够正常工作。</p>
<p>此外，由于虚拟线程数量庞大，传统的线程监控和调试工具可能难以管理大量的虚拟线程。在调试和监控时，我们需要更好的支持工具。这就像是在一个大城市里，传统的交通指挥方式可能无法应对大量的车辆，需要更先进的交通管理系统。例如，使用一些专门针对虚拟线程的监控工具，能够实时监控虚拟线程的运行状态、资源消耗等信息，帮助我们及时发现和解决问题。</p>
<h2> 六、展望与总结</h2>
<p>虚拟线程的出现，无疑是Java并发编程领域的一次重大飞跃，它为我们打开了一扇通往高效、便捷编程世界的大门。就像在黑暗中点亮了一盏明灯，为高并发场景下的Java开发指明了新的方向。</p>
<p>它以极低的资源消耗和出色的并发处理能力，让我们能够轻松应对海量并发请求，大大提升了系统的性能和稳定性。在Web服务、I/O密集型任务等众多场景中，虚拟线程都展现出了巨大的优势，为开发者提供了更强大的工具和更高效的解决方案。</p>
<p>随着Java 21的发布，虚拟线程将逐渐走进更多开发者的视野，成为Java开发中的重要利器。它不仅会改变我们编写并发代码的方式，还将推动Java生态系统的进一步发展和创新。无论是大型企业级应用，还是小型创业项目，都能从虚拟线程中受益。</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/java/jdk21_virtual_thread_00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>12.Java 21 结构化并发：开启并发编程新篇章</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/12.Java21%EF%BC%9A%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/12.Java21%EF%BC%9A%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">12.Java 21 结构化并发：开启并发编程新篇章</source>
      <description>Java 21结构化并发：开启并发编程新篇章 Java并发编程演进之路 嘿，Java开发者们！还记得刚学Java时写并发代码的痛苦吗？那时，我们得继承Thread类或实现Runnable接口，手动管理线程的创建与销毁。代码繁琐不说，一旦涉及大量线程，管理起来更是让人崩溃！比如，你可能写过这样的代码： class MyThread extends Thread { @Override public void run() { System.out.println(&amp;quot;MyThread is running&amp;quot;); } } class MyRunnable implements Runnable { @Override public void run() { System.out.println(&amp;quot;MyRunnable is running&amp;quot;); } } public class Main { public static void main(String[] args) { MyThread thread = new MyThread(); Thread runnableThread = new Thread(new MyRunnable()); thread.start(); runnableThread.start(); } }</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 18:21:09 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 21结构化并发：开启并发编程新篇章</h1>
<h2> Java并发编程演进之路</h2>
<p>嘿，Java开发者们！还记得刚学Java时写并发代码的痛苦吗？那时，我们得继承<code>Thread</code>类或实现<code>Runnable</code>接口，手动管理线程的创建与销毁。代码繁琐不说，一旦涉及大量线程，管理起来更是让人崩溃！比如，你可能写过这样的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别复杂？每次写线程都得小心翼翼，生怕出错。</p>
<p>后来，Java引入了线程池，这无疑是一大进步！线程池可复用线程，降低了线程创建和销毁的开销，代码也简洁了许多。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>线程池虽解决了不少问题，但在复杂并发场景下仍显不足。例如，线程的生命周期管理不够直观，错误处理繁琐。当同时发起多个网络请求时，手动管理每个线程的执行结果会让代码瞬间变得混乱。</p>
<p><strong>小贴士</strong>：传统并发编程中，线程管理如同“走钢丝”，稍有不慎就会出错。</p>
<h2> 结构化并发：概念与核心原理</h2>
<h3> 结构化并发是什么</h3>
<p>想象一下，你正在开发一个电商系统，需要同时处理多个任务，如查询商品信息、计算订单总价、验证用户支付信息等。这些任务相互独立，却又同属处理订单这个大任务。要是能有一种方式，将这些任务有序组织起来，那该多好？</p>
<p>Java 21的结构化并发正是为此而生！它把并发任务组织成清晰的层次结构，类似一棵树，每个任务都可有自己的子任务。如此一来，任务间的关系一目了然，管理也变得轻松便捷。</p>
<p>举个例子，假设开发一个电商订单处理系统，处理订单的任务可拆分为以下子任务：</p>
<ol>
<li>查询商品信息。</li>
<li>计算订单总价。</li>
<li>验证用户支付信息。</li>
</ol>
<p>这些子任务都隶属于处理订单这个父任务，形成清晰的任务层次结构，任务关系清晰，管理方便。</p>
<h3> 核心原理剖析</h3>
<h4> 任务层次结构</h4>
<p>结构化并发将任务构建成层次分明的结构，如同树状，每个任务可包含多个子任务，子任务又能有自己的子任务。这种结构让任务间的关系清晰明了，便于管理和调度。</p>
<h4> 结果处理规则</h4>
<p>在结构化并发里，子任务的结果只会返回给直接启动它们的父任务，不会随意传递给其他无关任务。这确保了任务间的数据流动有序且可预测。</p>
<h4> 生命周期绑定</h4>
<p>子任务的生命周期不能超过其父任务。一旦父任务结束，所有未完成的子任务会被自动取消，有效避免了线程泄漏和资源浪费。</p>
<h4> 任务的协作与控制</h4>
<p>父任务能依据子任务的执行情况，灵活决定是否继续执行其他子任务，或提前结束整个任务。这种协作与控制机制使并发任务的执行更高效、更智能。</p>
<p><strong>小贴士</strong>：结构化并发就像给并发任务戴上了“紧箍咒”，让它们的执行更可控、更可预测。</p>
<h2> Java 21结构化并发特性深度解析</h2>
<h3> 上下文关联的任务创建</h3>
<p>在Java 21的结构化并发中，上下文关联的任务创建是一项关键特性。它允许我们在特定代码块或作用域内创建并发任务，这些任务会自动与创建它们的上下文关联。当上下文结束时，相关任务会被自动清理，比如取消未完成的任务、收集任务执行结果等，极大地简化了任务管理的复杂性。</p>
<p>举个例子，假设开发一个Web应用程序，处理用户请求时需并发获取多个数据源的数据。使用Java 21的结构化并发，可这样实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此例中，我们在<code>try - with - resources</code>语句块中创建了<code>StructuredTaskScope.ShutdownOnFailure</code>对象<code>scope</code>，它定义了任务执行的上下文。在该上下文中，通过<code>scope.fork()</code>方法创建了<code>userTask</code>和<code>orderTask</code>两个并发任务，分别用于获取用户信息和订单信息。当<code>try - with - resources</code>语句块结束时，<code>scope</code>会自动清理所有相关任务，确保无任务遗漏或泄漏。</p>
<p><strong>小贴士</strong>：<code>StructuredTaskScope</code>是结构化并发的核心API之一，如同任务的“大管家”，帮你管理任务的生命周期和结果。</p>
<h3> 更好的异常传播机制</h3>
<p>在并发编程中，异常处理一直是个难题。传统并发编程里，当一个并发任务抛出异常时，异常的传播和处理较为复杂，尤其是任务在不同线程中执行时，很难确保异常能被正确捕获和处理。</p>
<p>Java 21的结构化并发提供了更优的异常传播机制，使并发任务中的异常能得到更有效的管理。若一个子任务抛出异常，该异常会自动传播到其父任务，且整个任务结构会根据异常情况进行相应处理。</p>
<p>举个例子：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此例中，<code>task1</code>有可能抛出<code>RuntimeException</code>。当<code>task1</code>抛出异常时，<code>task2</code>会被自动取消，异常会传播到<code>scope.join()</code>处，通过<code>throwIfFailed()</code>方法抛出，最终被<code>catch</code>块捕获并处理。这样，我们就能在统一的地方处理并发任务中的异常，大幅提升了代码的健壮性和可维护性。</p>
<p><strong>小贴士</strong>：结构化并发的异常处理机制就像给并发任务装上了“安全气囊”，让异常处理更简单、更可靠。</p>
<h3> 简化并发控制的API</h3>
<p>Java 21的结构化并发提供了一系列更高级别的API，这些API极大地简化了并发控制的复杂性，让我们能更便捷地协调并发任务，减少手动同步和锁的使用，使并发逻辑更简洁清晰。</p>
<p>举个例子：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此例中，我们使用<code>StructuredTaskScope</code>创建了5个并发任务。通过<code>scope.fork()</code>方法可轻松启动每个任务，无需手动管理线程的创建和启动。<code>scope.join()</code>方法会等待所有任务完成，<code>throwIfFailed()</code>方法会检查是否有任务失败并抛出异常。最后，通过<code>scope.subtasks()</code>方法可获取每个任务的执行结果。这种方式让并发任务的控制和管理变得简单直观，大大减少了手动编写同步和锁代码的工作量。</p>
<p><strong>小贴士</strong>：<code>StructuredTaskScope</code>的API就像并发任务的“瑞士军刀”，让并发控制更简单、更高效。</p>
<h3> 与虚拟线程的完美融合</h3>
<p>Java 21引入的虚拟线程是一种轻量级线程实现，其创建和销毁开销极小，能在一个操作系统线程上运行大量虚拟线程，显著提升系统的并发处理能力。结构化并发与虚拟线程的结合，充分发挥了两者的优势，为高效并发编程提供了强大支持。</p>
<p>举个例子，假设开发一个高并发的网络爬虫应用，需要并发访问大量网页。使用虚拟线程和结构化并发，可这样实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此例中，我们使用虚拟线程并发访问多个URL。每个URL的访问任务通过<code>scope.fork()</code>方法创建，这些任务在虚拟线程中执行。由于虚拟线程的轻量级特性，我们可轻松创建大量任务，而不会对系统资源造成过大压力。同时，借助结构化并发的<code>StructuredTaskScope</code>，我们能方便地管理这些任务的生命周期和结果，确保所有任务正确执行并返回结果。这种结合方式使我们能高效处理高并发网络请求，提升应用程序的性能和响应速度。</p>
<p><strong>小贴士</strong>：虚拟线程和结构化并发的结合，就像给并发编程装上了“超级加速器”，让高并发任务处理变得轻松自如。</p>
<h2> 代码示例：实战Java 21结构化并发</h2>
<h3> 简单任务并发执行</h3>
<p>下面通过一个简单示例展示如何使用Java 21的结构化并发实现多个任务的并发执行。假设我们有三个独立任务，每个任务模拟一个耗时操作并返回结果。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此示例中，我们创建了<code>StructuredTaskScope.ShutdownOnFailure</code>对象<code>scope</code>，定义了任务执行范围。在该范围内，使用<code>scope.fork()</code>方法创建了<code>task1</code>、<code>task2</code>和<code>task3</code>三个并发任务。每个任务在独立线程中执行，并模拟了不同的耗时操作。</p>
<p><code>scope.join()</code>方法会阻塞当前线程，直至所有子任务完成。<code>throwIfFailed()</code>方法会检查是否有任务执行失败，若有则抛出异常。最后，通过<code>task1.resultNow()</code>、<code>task2.resultNow()</code>和<code>task3.resultNow()</code>方法获取并打印每个任务的执行结果。</p>
<p><strong>小贴士</strong>：结构化并发让并发任务管理如同“搭积木”，任务间关系一目了然。</p>
<h3> 复杂任务场景应用</h3>
<p>在实际开发中，常遇到复杂任务场景，如多任务依赖、任务优先级控制等。下面通过一个示例展示如何在这些场景下使用Java 21的结构化并发。</p>
<p>假设开发一个电商数据分析系统，需要从多个数据源获取数据，然后进行汇总和分析。其中，获取用户数据和订单数据的任务相互独立，可并发执行，但生成报表的任务依赖于用户数据和订单数据的获取结果。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此示例中，我们先创建了<code>userDataTask</code>和<code>orderDataTask</code>两个并发任务，分别用于获取用户数据和订单数据。通过<code>scope.join().throwIfFailed()</code>等待这两个任务完成，并获取结果。</p>
<p>接着，创建<code>reportTask</code>任务，它依赖于<code>userDataTask</code>和<code>orderDataTask</code>的结果，用于生成报表。最后，再次通过<code>scope.join().throwIfFailed()</code>等待报表生成任务完成，并获取报表结果进行打印。</p>
<p>通过这种方式，我们能清晰管理任务间的依赖关系，使复杂的并发任务逻辑更易于理解和维护。</p>
<p><strong>小贴士</strong>：结构化并发就像并发任务的“指挥官”，让任务协作有条不紊。</p>
<h2> 结构化并发应用场景与优势</h2>
<h3> 常见应用场景</h3>
<ul>
<li><strong>Web开发</strong>：在处理用户请求时，经常需要并发地获取多个数据源的数据，然后进行整合和处理。结构化并发可以轻松地并发执行这些任务，提高页面的加载速度和用户体验。</li>
<li><strong>大数据处理</strong>：在大数据处理中，常常需要对大量的数据进行并行计算和分析。结构化并发可以将数据处理任务拆分成多个子任务，每个子任务在独立的线程中执行，然后将结果合并，从而实现高效的数据处理。</li>
<li><strong>分布式系统</strong>：在分布式系统中，各个节点之间的通信和协作往往是并发进行的。结构化并发可以更好地管理这些并发操作，确保数据的一致性和系统的稳定性。</li>
</ul>
<h3> 相比传统并发的显著优势</h3>
<ul>
<li><strong>避免线程泄漏</strong>：结构化并发中，子任务的生命周期与父任务紧密绑定，当父任务结束时，所有未完成的子任务都会被自动取消，从而有效地避免了线程泄漏的发生。</li>
<li><strong>降低死锁风险</strong>：结构化并发通过明确的任务层次结构和执行顺序，减少了死锁发生的可能性。</li>
<li><strong>提高代码可读性和可维护性</strong>：结构化并发将并发任务组织成一个清晰的结构，使得代码的逻辑更加直观，易于理解和维护。</li>
<li><strong>提升性能</strong>：通过与虚拟线程的结合，结构化并发能够充分利用虚拟线程的轻量级特性，在处理大量并发任务时，减少线程创建和上下文切换的开销，从而显著提升系统的性能和响应速度。</li>
</ul>
<p><strong>小贴士</strong>：结构化并发就像是并发编程的“升级版”，让代码不仅更简洁，还更安全、更高效。</p>
<h2> 总结与展望</h2>
<p>Java 21的结构化并发为并发编程带来了重大的变革，它通过清晰的任务层次结构、更好的异常传播机制、简化的并发控制API以及与虚拟线程的完美融合，使得并发编程变得更加简单、可靠和高效。</p>
<p>在Web开发、大数据处理、分布式系统等众多领域，结构化并发都展现出了巨大的优势，能够帮助开发者更轻松地应对复杂的并发场景。</p>
<p>随着Java的不断发展，结构化并发有望成为并发编程的主流范式，为Java应用的性能和可靠性提供更强大的支持。我鼓励各位开发者积极尝试Java 21的结构化并发，将其应用到实际项目中，体验它带来的便利和优势。</p>
<p>如果你在使用Java 21结构化并发的过程中有任何问题、心得或体会，欢迎在留言区分享交流，让我们一起学习，共同进步！</p>
]]></content:encoded>
    </item>
    <item>
      <title>00.jdk8+迭代记录</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">00.jdk8+迭代记录</source>
      <description>这里记录JDK8+之后的新的特性 Java 8（2014年发布）到 Java 21（2023年发布）经历了多次迭代，新增了大量特性和改进。以下是主要版本（Java 9 到 Java 21）中值得关注的新特性分类整理： 一、语言特性改进 模块化系统（Java 9） Jigsaw 项目：引入模块化（module-info.java），解决 JAR 依赖和封装问题，提升安全性和可维护性。 局部变量类型推断（Java 10） var 关键字：允许在局部变量声明时省略显式类型（如 var list = new ArrayList&amp;lt;String&amp;gt;();）。 文本块（Java 15 正式支持） 多行字符串：使用 &amp;quot;&amp;quot;&amp;quot; ... &amp;quot;&amp;quot;&amp;quot; 简化 HTML、JSON 等多行文本的编写。 模式匹配（逐步引入） instanceof 模式匹配（Java 16）：直接提取对象属性，如 if (obj instanceof String s) { ... }。 switch 表达式（Java 14）：支持箭头语法和返回值，避免 break 的繁琐。 模式匹配 switch（Java 21 正式）：支持类型匹配和复杂条件，例如：switch (obj) { case Integer i -&amp;gt; System.out.println(&amp;quot;Integer: &amp;quot; + i); case String s when s.length() &amp;gt; 5 -&amp;gt; System.out.println(&amp;quot;Long string&amp;quot;); default -&amp;gt; {} } 记录类（Record，Java 16 正式） 简化不可变数据类的定义，自动生成 equals()、hashCode() 等方法：record Point(int x, int y) {} 密封类（Sealed Classes，Java 17 正式） 限制类的继承关系，明确子类范围：public sealed class Shape permits Circle, Square {} 字符串模板（Java 21 预览） 类似其他语言的模板插值功能，例如：String name = &amp;quot;John&amp;quot;; String message = STR.&amp;quot;Hello \{name}!&amp;quot;;</description>
      <pubDate>Fri, 14 Feb 2025 10:52:18 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里记录JDK8+之后的新的特性</p>
</blockquote>
<p>Java 8（2014年发布）到 Java 21（2023年发布）经历了多次迭代，新增了大量特性和改进。以下是主要版本（Java 9 到 Java 21）中值得关注的新特性分类整理：</p>
<hr>
<h3> <strong>一、语言特性改进</strong></h3>
<ol>
<li>
<p><strong>模块化系统（Java 9）</strong></p>
<ul>
<li><strong>Jigsaw 项目</strong>：引入模块化（<code>module-info.java</code>），解决 JAR 依赖和封装问题，提升安全性和可维护性。</li>
</ul>
</li>
<li>
<p><strong>局部变量类型推断（Java 10）</strong></p>
<ul>
<li><strong><code>var</code> 关键字</strong>：允许在局部变量声明时省略显式类型（如 <code>var list = new ArrayList&lt;String&gt;();</code>）。</li>
</ul>
</li>
<li>
<p><strong>文本块（Java 15 正式支持）</strong></p>
<ul>
<li><strong>多行字符串</strong>：使用 <code>""" ... """</code> 简化 HTML、JSON 等多行文本的编写。</li>
</ul>
</li>
<li>
<p><strong>模式匹配（逐步引入）</strong></p>
<ul>
<li><strong><code>instanceof</code> 模式匹配（Java 16）</strong>：直接提取对象属性，如 <code>if (obj instanceof String s) { ... }</code>。</li>
<li><strong><code>switch</code> 表达式（Java 14）</strong>：支持箭头语法和返回值，避免 <code>break</code> 的繁琐。</li>
<li><strong>模式匹配 <code>switch</code>（Java 21 正式）</strong>：支持类型匹配和复杂条件，例如：<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p><strong>记录类（Record，Java 16 正式）</strong></p>
<ul>
<li>简化不可变数据类的定义，自动生成 <code>equals()</code>、<code>hashCode()</code> 等方法：<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p><strong>密封类（Sealed Classes，Java 17 正式）</strong></p>
<ul>
<li>限制类的继承关系，明确子类范围：<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p><strong>字符串模板（Java 21 预览）</strong></p>
<ul>
<li>类似其他语言的模板插值功能，例如：<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
</ol>
<hr>
<h3> <strong>二、API 增强</strong></h3>
<ol>
<li>
<p><strong>新的集合工厂方法（Java 9）</strong></p>
<ul>
<li>快速创建不可变集合：<code>List.of("a", "b")</code>、<code>Set.of(1, 2)</code>、<code>Map.of("k", "v")</code>。</li>
</ul>
</li>
<li>
<p><strong>Stream API 增强</strong></p>
<ul>
<li><strong><code>takeWhile</code>/<code>dropWhile</code>（Java 9）</strong>：根据条件截取流。</li>
<li><strong><code>Collectors.toUnmodifiableList()</code>（Java 10）</strong>：生成不可变集合。</li>
</ul>
</li>
<li>
<p><strong>HTTP/2 客户端（Java 11 正式）</strong></p>
<ul>
<li>支持异步请求的现代 HTTP 客户端（<code>java.net.http.HttpClient</code>）。</li>
</ul>
</li>
<li>
<p><strong>进程 API 改进（Java 9+）</strong></p>
<ul>
<li>管理操作系统进程（如获取 PID、直接执行命令）。</li>
</ul>
</li>
<li>
<p><strong>新的日期时间 API（Java 8 已有，后续优化）</strong></p>
<ul>
<li><code>java.time</code> 包优化，例如 <code>LocalDate</code>、<code>ZonedDateTime</code> 等。</li>
</ul>
</li>
</ol>
<hr>
<h3> <strong>三、并发与性能</strong></h3>
<ol>
<li>
<p><strong>虚拟线程（Virtual Threads，Java 21 正式）</strong></p>
<ul>
<li>轻量级线程（协程），显著提升高并发吞吐量，简化异步编程：<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p><strong>结构化并发（Java 21 预览）</strong></p>
<ul>
<li>通过 <code>StructuredTaskScope</code> 管理多个子任务的生命周期，避免资源泄漏。</li>
</ul>
</li>
<li>
<p><strong>分代 ZGC（Java 21）</strong></p>
<ul>
<li>低延迟垃圾收集器 ZGC 支持分代回收，减少内存占用。</li>
</ul>
</li>
<li>
<p><strong>Shenandoah GC（Java 12+）</strong></p>
<ul>
<li>另一种低停顿时间的垃圾收集器。</li>
</ul>
</li>
</ol>
<hr>
<h3> <strong>四、工具与 JVM 改进</strong></h3>
<ol>
<li>
<p><strong>JShell（Java 9）</strong></p>
<ul>
<li>交互式 REPL 工具，快速测试代码片段。</li>
</ul>
</li>
<li>
<p><strong>单文件源码运行（Java 11）</strong></p>
<ul>
<li>直接运行 <code>.java</code> 文件（无需手动编译）：<code>java HelloWorld.java</code>。</li>
</ul>
</li>
<li>
<p><strong>动态 CDS 存档（Java 13+）</strong></p>
<ul>
<li>提升启动速度，通过共享类数据减少内存占用。</li>
</ul>
</li>
<li>
<p><strong>Flight Recorder（JFR）开源（Java 11）</strong></p>
<ul>
<li>生产环境性能监控工具，低开销收集 JVM 数据。</li>
</ul>
</li>
</ol>
<hr>
<h3> <strong>五、其他重要特性</strong></h3>
<ol>
<li>
<p><strong><code>var</code> 支持 Lambda 参数（Java 11）</strong></p>
<ul>
<li>允许在 Lambda 表达式中使用 <code>var</code> 声明参数。</li>
</ul>
</li>
<li>
<p><strong><code>@Deprecated</code> 增强（Java 9）</strong></p>
<ul>
<li>标记 API 废弃状态和替代方案。</li>
</ul>
</li>
<li>
<p><strong>接口私有方法（Java 9）</strong></p>
<ul>
<li>在接口中定义私有方法，提升代码复用性。</li>
</ul>
</li>
<li>
<p><strong>移除过时功能</strong></p>
<ul>
<li>移除 Applet、Java Web Start、永久代（PermGen）等。</li>
</ul>
</li>
</ol>
<hr>
<h3> <strong>六、Java 21 核心特性总结</strong></h3>
<p>Java 21 作为 LTS（长期支持版本），整合了此前多个预览特性，并重点优化了并发和内存管理：</p>
<ul>
<li><strong>虚拟线程</strong>：彻底改变高并发编程模型。</li>
<li><strong>分代 ZGC</strong>：提升垃圾回收效率。</li>
<li><strong>模式匹配</strong>：简化条件分支代码。</li>
<li><strong>字符串模板</strong>：增强字符串处理能力。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>06.JDK21增强的模式匹配：更简洁、更强大的条件逻辑</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/06.%E5%A2%9E%E5%BC%BA%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/06.%E5%A2%9E%E5%BC%BA%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">06.JDK21增强的模式匹配：更简洁、更强大的条件逻辑</source>
      <description>1. 背景：为什么需要增强的模式匹配？ 在Java中，条件逻辑通常通过if-else或switch语句实现，但这些方式存在以下问题： 冗长：需要显式类型检查和类型转换 易错：手动类型转换可能导致ClassCastException 局限性：switch语句仅支持有限的数据类型 增强的模式匹配（Enhanced Pattern Matching）是Java模式匹配的进一步扩展，旨在简化条件逻辑的编写。它结合了类型检查、类型转换和模式匹配的特性，使开发者能够以声明式的方式处理复杂条件逻辑。</description>
      <category>Java</category>
      <category>JDK21</category>
      <pubDate>Thu, 13 Feb 2025 17:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. 背景：为什么需要增强的模式匹配？</h2>
<p>在Java中，条件逻辑通常通过<code>if-else</code>或<code>switch</code>语句实现，但这些方式存在以下问题：</p>
<ol>
<li><strong>冗长</strong>：需要显式类型检查和类型转换</li>
<li><strong>易错</strong>：手动类型转换可能导致<code>ClassCastException</code></li>
<li><strong>局限性</strong>：<code>switch</code>语句仅支持有限的数据类型</li>
</ol>
<p><strong>增强的模式匹配</strong>（Enhanced Pattern Matching）是Java模式匹配的进一步扩展，旨在简化条件逻辑的编写。它结合了<strong>类型检查</strong>、<strong>类型转换</strong>和<strong>模式匹配</strong>的特性，使开发者能够以声明式的方式处理复杂条件逻辑。</p>
<p>JDK16首次引入模式匹配<code>instanceof</code>，JDK17扩展了<code>switch</code>的模式匹配能力，JDK21进一步优化并正式发布。</p>
<h2> 2. 原理：增强的模式匹配如何工作？</h2>
<h3> 2.1 传统条件逻辑 vs 增强的模式匹配</h3>
<h4> 传统方式</h4>
<ul>
<li><strong>显式类型检查</strong>：使用<code>instanceof</code>检查类型</li>
<li><strong>显式类型转换</strong>：手动进行类型转换</li>
<li><strong>冗长代码</strong>：需要多行代码完成简单操作</li>
</ul>
<h4> 增强的模式匹配</h4>
<ul>
<li><strong>声明式匹配</strong>：直接匹配类型并绑定变量</li>
<li><strong>自动类型转换</strong>：编译器自动推断类型，无需显式类型转换</li>
<li><strong>简洁代码</strong>：减少样板代码，提升开发效率</li>
</ul>
<h3> 2.2 核心机制</h3>
<ol>
<li>
<p><strong>模式匹配<code>instanceof</code></strong><br>
在<code>instanceof</code>中直接绑定变量，例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>模式匹配<code>switch</code></strong><br>
在<code>switch</code>中支持类型匹配和模式解构，例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>嵌套模式匹配</strong><br>
支持嵌套模式匹配，简化复杂数据结构的处理。</p>
</li>
<li>
<p><strong>类型推断</strong><br>
编译器自动推断匹配类型，减少显式类型转换。</p>
</li>
</ol>
<h3> 2.3 优势：为什么选择增强的模式匹配？</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>传统方式</th>
<th>增强的模式匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td>代码简洁性</td>
<td>冗长</td>
<td><strong>简洁</strong></td>
</tr>
<tr>
<td>类型安全性</td>
<td>需显式类型转换</td>
<td><strong>自动推断</strong></td>
</tr>
<tr>
<td>嵌套支持</td>
<td>手动逐层匹配</td>
<td><strong>自动解构</strong></td>
</tr>
<tr>
<td>可读性</td>
<td>低</td>
<td><strong>高</strong></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>代码简洁</strong>：减少样板代码，提升开发效率</li>
<li><strong>类型安全</strong>：编译器自动检查类型，减少运行时错误</li>
<li><strong>嵌套支持</strong>：轻松处理复杂数据结构</li>
<li><strong>可读性高</strong>：声明式语法更符合直觉</li>
</ol>
<h2> 3. 使用示例</h2>
<h3> 示例1：模式匹配<code>instanceof</code></h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例2：模式匹配<code>switch</code></h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例3：嵌套模式匹配</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例4：结合<code>switch</code>表达式</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3.小结</h2>
<h3> 3.1 注意事项</h3>
<ol>
<li>
<p><strong>类型检查顺序</strong><br>
在<code>switch</code>中，更具体的模式应放在前面：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>空值处理</strong><br>
模式匹配不支持<code>null</code>值匹配，需额外检查：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p><strong>性能影响</strong><br>
模式匹配在运行时可能引入额外开销，需在性能敏感场景中测试。</p>
</li>
<li>
<p><strong>兼容性</strong><br>
增强的模式匹配需要JDK16及以上版本。</p>
</li>
</ol>
<h3> 3.2 总结</h3>
<p>JDK21增强的模式匹配通过以下革新提升Java条件逻辑的效率：</p>
<ul>
<li>✅ 简化条件逻辑代码</li>
<li>✅ 提升类型安全性和可读性</li>
<li>✅ 支持嵌套模式匹配</li>
<li>✅ 与<code>switch</code>表达式无缝集成</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>处理复杂条件逻辑</li>
<li>实现类型安全的模式匹配</li>
<li>简化数据验证和提取</li>
</ul>
<p>增强的模式匹配是Java模式匹配的重要扩展，有兴趣的小伙伴可以参考<a href="https://openjdk.org/jeps/406" target="_blank" rel="noopener noreferrer">官方文档</a>以掌握最佳实践。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>01.JDK21新特性及示例说明</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/01.JDK21%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/01.JDK21%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.JDK21新特性及示例说明</source>
      <description>JDK 21 在 JDK 8 的基础上引入了许多新特性，下面详细介绍一些主要特性并给出相应的示例代码： 1. 虚拟线程（Virtual Threads） 虚拟线程是 JDK 21 引入的轻量级线程，能够以较低的开销处理大量并发任务。与传统的平台线程相比，虚拟线程由 Java 运行时管理，不需要操作系统内核线程的支持，从而可以创建数百万个虚拟线程而不会耗尽系统资源。 示例代码： import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class VirtualThreadsExample { public static void main(String[] args) { // 创建一个虚拟线程执行器 try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) { for (int i = 0; i &amp;lt; 1000; i++) { final int taskId = i; // 提交任务到执行器 executor.submit(() -&amp;gt; { System.out.println(&amp;quot;Task &amp;quot; + taskId + &amp;quot; is running on thread: &amp;quot; + Thread.currentThread()); try { // 模拟任务执行 Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } System.out.println(&amp;quot;Task &amp;quot; + taskId + &amp;quot; is completed.&amp;quot;); }); } } } }</description>
      <category>Java</category>
      <category>JDK21</category>
      <pubDate>Thu, 13 Feb 2025 09:48:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>JDK 21 在 JDK 8 的基础上引入了许多新特性，下面详细介绍一些主要特性并给出相应的示例代码：</p>
<h3> 1. 虚拟线程（Virtual Threads）</h3>
<p>虚拟线程是 JDK 21 引入的轻量级线程，能够以较低的开销处理大量并发任务。与传统的平台线程相比，虚拟线程由 Java 运行时管理，不需要操作系统内核线程的支持，从而可以创建数百万个虚拟线程而不会耗尽系统资源。</p>
<p><strong>示例代码</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 结构化并发（Structured Concurrency）</h3>
<p>结构化并发是一种新的并发编程模型，它将一组相关的任务视为一个单一的工作单元，使得任务的管理和错误处理更加简单和直观。通过使用 <code>StructuredTaskScope</code>，可以方便地启动和等待多个并发任务的完成。</p>
<p><strong>示例代码</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 记录模式（Record Patterns）</h3>
<p>记录模式允许在模式匹配中解构记录类型，使得代码更加简洁和易读。结合 <code>instanceof</code> 和 <code>switch</code> 表达式，可以更方便地处理记录类型的数据。</p>
<p><strong>示例代码</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 字符串模板（String Templates）</h3>
<p>字符串模板是一种新的字符串构建机制，它允许在字符串中嵌入表达式，使得字符串的拼接更加直观和方便。</p>
<p><strong>示例代码</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 增强的模式匹配（Enhanced Pattern Matching）</h3>
<p>JDK 21 进一步增强了模式匹配的功能，支持更复杂的模式匹配，如嵌套模式匹配和类型测试模式。</p>
<p><strong>示例代码</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>02.JDK21虚拟线程：重新定义Java高并发编程</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/02.%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/02.%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">02.JDK21虚拟线程：重新定义Java高并发编程</source>
      <description>1. 背景：为什么需要虚拟线程？ 在传统Java并发模型中，每个java.lang.Thread都直接对应一个操作系统线程（称为平台线程）。虽然这种1:1的模型保证了可靠的并发执行，但存在两个关键瓶颈： 资源限制：操作系统线程创建成本高（默认1MB栈空间），难以支持百万级并发 上下文切换开销：线程数量激增时，CPU时间大量消耗在切换线程上下文上 开发者通常通过线程池和异步编程（如CompletableFuture）缓解这些问题，但这导致了代码复杂度上升。Project Loom应运而生，其核心成果虚拟线程在JDK19中首次预览，最终在JDK21正式发布。</description>
      <category>Java</category>
      <category>JDK21</category>
      <pubDate>Thu, 13 Feb 2025 11:48:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. 背景：为什么需要虚拟线程？</h2>
<p>在传统Java并发模型中，每个<code>java.lang.Thread</code>都直接对应一个操作系统线程（称为<strong>平台线程</strong>）。虽然这种1:1的模型保证了可靠的并发执行，但存在两个关键瓶颈：</p>
<ol>
<li><strong>资源限制</strong>：操作系统线程创建成本高（默认1MB栈空间），难以支持百万级并发</li>
<li><strong>上下文切换开销</strong>：线程数量激增时，CPU时间大量消耗在切换线程上下文上</li>
</ol>
<p>开发者通常通过线程池和异步编程（如CompletableFuture）缓解这些问题，但这导致了代码复杂度上升。<strong>Project Loom</strong>应运而生，其核心成果<strong>虚拟线程</strong>在JDK19中首次预览，最终在JDK21正式发布。</p>
<h2> 2. 原理：虚拟线程如何工作？</h2>
<h3> 2.1 传统线程模型 vs 虚拟线程模型</h3>
<h4> 传统线程模型（平台线程）</h4>
<ul>
<li><strong>1:1 模型</strong>：每个Java线程直接映射到一个操作系统线程。</li>
<li><strong>资源开销大</strong>：每个线程默认占用1MB栈空间，创建和销毁成本高。</li>
<li><strong>上下文切换依赖内核</strong>：线程切换需要内核介入，开销较大。</li>
<li><strong>并发限制</strong>：受限于操作系统线程数（通常数千个）。</li>
</ul>
<h4> 虚拟线程模型</h4>
<ul>
<li><strong>M:N 模型</strong>：大量虚拟线程（M）复用在少量平台线程（N）上运行。</li>
<li><strong>轻量级</strong>：虚拟线程的栈空间按需分配，初始内存占用仅几百字节。</li>
<li><strong>协作式调度</strong>：虚拟线程在阻塞操作（如I/O）时自动让出执行权，由JVM调度器管理。</li>
<li><strong>高并发支持</strong>：可轻松创建数百万个虚拟线程。</li>
</ul>
<h3> 虚拟线程的核心机制</h3>
<ol>
<li>
<p><strong>Continuation（延续体）</strong></p>
<ul>
<li>虚拟线程的核心是一个可暂停和恢复的任务单元（Continuation）。</li>
<li>当虚拟线程执行阻塞操作时，JVM会保存当前状态并挂起任务，切换到其他虚拟线程。</li>
<li>阻塞操作完成后，JVM恢复任务状态并继续执行。</li>
</ul>
</li>
<li>
<p><strong>调度器</strong></p>
<ul>
<li>默认使用<code>ForkJoinPool</code>作为调度器，将虚拟线程分配到平台线程上执行。</li>
<li>调度器负责在虚拟线程阻塞时将其从平台线程上卸载，并在就绪时重新调度。</li>
</ul>
</li>
<li>
<p><strong>栈管理</strong></p>
<ul>
<li>虚拟线程的栈空间是动态分配的，按需增长和收缩。</li>
<li>通过<strong>Stack Chunk</strong>技术，JVM可以高效地管理虚拟线程的栈内存。</li>
</ul>
</li>
<li>
<p><strong>阻塞操作优化</strong></p>
<ul>
<li>虚拟线程在执行I/O、锁等待等阻塞操作时，会自动让出平台线程。</li>
<li>这种机制避免了平台线程的浪费，提高了资源利用率。</li>
</ul>
</li>
</ol>
<h4> 对比总结</h4>
<table>
<thead>
<tr>
<th>特性</th>
<th>平台线程</th>
<th>虚拟线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>线程模型</td>
<td>1:1（Java线程:OS线程）</td>
<td>M:N（虚拟线程:平台线程）</td>
</tr>
<tr>
<td>内存开销</td>
<td>默认1MB/线程</td>
<td><strong>~200字节/线程</strong></td>
</tr>
<tr>
<td>上下文切换</td>
<td>内核参与，开销大</td>
<td><strong>JVM管理，开销小</strong></td>
</tr>
<tr>
<td>阻塞操作</td>
<td>占用平台线程</td>
<td><strong>自动让出平台线程</strong></td>
</tr>
<tr>
<td>并发能力</td>
<td>数千级</td>
<td><strong>百万级</strong></td>
</tr>
</tbody>
</table>
<h3> 2.2 虚拟线程调度</h3>
<p>虚拟线程的调度主要包含三个核心部分：虚拟线程（Virtual Threads）、平台线程（Platform Threads）和调度器（Scheduler）。</p>
<ol>
<li><strong>虚拟线程池：</strong></li>
</ol>
<ul>
<li>这是一个包含大量虚拟线程的集合。每个虚拟线程代表一个轻量级的执行单元，它们可以由用户代码创建并提交到执行器中等待执行。虚拟线程之间是平等的，它们的栈空间较小，创建和销毁的开销也很低。</li>
</ul>
<ol start="2">
<li><strong>平台线程池：</strong></li>
</ol>
<ul>
<li>平台线程是与操作系统内核线程一一对应的线程，数量相对较少。平台线程负责执行虚拟线程中的实际任务，它们是系统资源的实际使用者。</li>
</ul>
<ol start="3">
<li><strong>调度器：</strong></li>
</ol>
<ul>
<li>调度器是整个系统的核心，负责将虚拟线程分配到可用的平台线程上执行。</li>
<li>调度器会根据虚拟线程的状态（如就绪、阻塞等）和平台线程的负载情况进行智能调度。</li>
<li>当一个虚拟线程遇到阻塞操作（如 I/O 操作）时，调度器会将该虚拟线程暂停，并将平台线程分配给其他就绪的虚拟线程；当阻塞操作完成后，调度器会将该虚拟线程重新加入到就绪队列中，等待再次分配到平台线程执行。</li>
</ul>
<ol start="4">
<li><strong>阻塞与唤醒机制：</strong></li>
</ol>
<ul>
<li>当虚拟线程进行 I/O 等阻塞操作时，会触发阻塞信号，调度器将其标记为阻塞状态并让出平台线程；</li>
<li>当阻塞操作完成，会有唤醒信号，调度器将其重新标记为就绪状态等待调度。</li>
</ul>
<p>虚拟线程调度的基本流程：</p>
<p>虚拟线程进入调度器，调度器将其分配到平台线程执行，当平台线程上的虚拟线程遇到阻塞操作时通知调度器，调度器再去唤醒其他就绪的虚拟线程执行。</p>
<figure><img src="/imgs/column/java/jdk21_virtual_thread_00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2.3 优势：为什么选择虚拟线程？</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>平台线程</th>
<th>虚拟线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建数量</td>
<td>数千级</td>
<td><strong>百万级</strong></td>
</tr>
<tr>
<td>内存消耗</td>
<td>默认1MB/线程</td>
<td><strong>~200字节/线程</strong></td>
</tr>
<tr>
<td>上下文切换</td>
<td>内核参与</td>
<td><strong>JVM优化</strong></td>
</tr>
<tr>
<td>编程模型</td>
<td>回调地狱风险</td>
<td><strong>同步代码风格</strong></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>高吞吐</strong>：轻松支撑10万+并发连接</li>
<li><strong>低资源消耗</strong>：创建百万虚拟线程仅需几百MB内存</li>
<li><strong>代码简化</strong>：用同步代码实现异步性能，避免回调地狱</li>
<li><strong>兼容性</strong>：与现有Thread API、调试工具（如jstack）完全兼容</li>
</ol>
<h2> 3. 使用示例</h2>
<h3> 示例1：创建虚拟线程</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例2：HTTP服务器对比</h3>
<p><strong>传统线程池（20线程）：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>虚拟线程版：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例3：使用虚拟线程实现归并排序</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明：</strong></p>
<ul>
<li>使用虚拟线程并行化归并排序的递归任务。</li>
<li>每个子任务（<code>mergeSort</code>）都在独立的虚拟线程中执行。</li>
<li>通过<code>Future</code>获取子任务结果，并合并（<code>merge</code>）排序后的数组。</li>
</ul>
<h2> 4.小结</h2>
<h3> 4.1 注意事项</h3>
<ol>
<li><strong>阻塞操作仍影响平台线程</strong></li>
</ol>
<p>在<code>synchronized</code>块或native方法中阻塞会占用平台线程</p>
<ol start="2">
<li><strong>避免在虚拟线程中：</strong></li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li><strong>正确关闭ExecutorService</strong></li>
</ol>
<p>使用try-with-resources确保自动关闭</p>
<ol start="4">
<li><strong>不要池化虚拟线程</strong></li>
</ol>
<p>每个任务应新建虚拟线程（JVM已优化创建成本）</p>
<ol start="5">
<li><strong>性能考虑</strong></li>
</ol>
<p>虚拟线程适合处理 I/O 密集型任务，而传统线程更适合处理 CPU 密集型任务。在设计系统时，需要根据任务的特点合理分配线程类型，以充分发挥各自的优势。</p>
<ol start="6">
<li><strong>资源管理：</strong></li>
</ol>
<p>无论是虚拟线程还是传统线程，都需要注意资源的合理使用和释放，避免出现资源泄漏的问题。</p>
<h3> 4.2 小结</h3>
<p>JDK21虚拟线程通过以下革新重塑Java并发：</p>
<ul>
<li>✅ 使高并发应用的代码复杂度降低50%+</li>
<li>✅ 吞吐量提升10倍（Tomcat基准测试数据）</li>
<li>✅ 完全兼容现有代码和监控工具</li>
</ul>
<p><strong>适用场景</strong>：高并发服务、微服务架构、异步IO处理等</p>
<p>尽管虚拟线程并非万能（CPU密集型任务仍需平台线程），但它无疑是Java在云原生时代的重要进化。 有兴趣的小伙伴快尝试下吧，<a href="https://docs.oracle.com/en/java/javase/21/core/virtual-threads.html" target="_blank" rel="noopener noreferrer">更多使用相关推荐参考官方指导</a></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/java/jdk21_virtual_thread_00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>03.JDK21结构化并发：重新定义并发任务的生命周期管理</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/03.%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/03.%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">03.JDK21结构化并发：重新定义并发任务的生命周期管理</source>
      <description>1. 背景：为什么需要结构化并发？ 在传统Java并发编程中，开发者通过ExecutorService、Future或CompletableFuture管理多线程任务。然而，这些方式存在显著问题： 生命周期管理困难：子任务可能脱离父任务独立运行，导致“线程泄漏” 错误处理复杂：异常可能被静默吞噬，难以追踪问题根源 资源浪费：未及时关闭的线程池可能持续占用系统资源</description>
      <category>Java</category>
      <category>JDK21</category>
      <pubDate>Thu, 13 Feb 2025 15:48:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. 背景：为什么需要结构化并发？</h2>
<p>在传统Java并发编程中，开发者通过<code>ExecutorService</code>、<code>Future</code>或<code>CompletableFuture</code>管理多线程任务。然而，这些方式存在显著问题：</p>
<ol>
<li><strong>生命周期管理困难</strong>：子任务可能脱离父任务独立运行，导致“线程泄漏”</li>
<li><strong>错误处理复杂</strong>：异常可能被静默吞噬，难以追踪问题根源</li>
<li><strong>资源浪费</strong>：未及时关闭的线程池可能持续占用系统资源</li>
</ol>
<p><strong>结构化并发</strong>（Structured Concurrency）的概念源自结构化编程，核心思想是<strong>任务的生命周期应与其创建者的作用域严格绑定</strong>。JDK21通过JEP 453引入结构化并发API（第二次预览），旨在以同步代码风格实现可靠的异步任务管理。</p>
<hr>
<h2> 2. 原理：结构化并发如何工作？</h2>
<h3> 2.1 传统并发 vs 结构化并发</h3>
<h4> 传统并发模型</h4>
<ul>
<li><strong>松散的任务关系</strong>：父任务与子任务之间无强制绑定</li>
<li><strong>手动管理关闭</strong>：需显式调用<code>shutdown()</code>或<code>cancel()</code></li>
<li><strong>错误传播困难</strong>：子任务异常无法自动传递到父任务</li>
</ul>
<h4> 结构化并发模型</h4>
<ul>
<li><strong>任务作用域</strong>：所有子任务必须在父任务的作用域内执行</li>
<li><strong>自动关闭保证</strong>：作用域退出时自动取消未完成子任务</li>
<li><strong>异常冒泡机制</strong>：子任务异常会直接中断父任务执行</li>
</ul>
<h3> 核心机制</h3>
<ol>
<li>
<p><strong>作用域（Scope）</strong><br>
通过<code>StructuredTaskScope</code>定义一个任务作用域，所有子任务必须在此作用域内创建和执行。作用域关闭时，自动清理所有子任务。</p>
</li>
<li>
<p><strong>关闭顺序控制</strong></p>
<ul>
<li>父任务作用域关闭时，首先取消所有未完成的子任务</li>
<li>等待所有子任务终止后才继续执行后续代码</li>
</ul>
</li>
<li>
<p><strong>错误传播</strong><br>
任一子任务抛出异常时，自动终止作用域内所有任务，并将异常传递给父任务。</p>
</li>
<li>
<p><strong>结果聚合</strong><br>
支持通过<code>ShutdownOnSuccess</code>（任一成功即返回）或<code>ShutdownOnFailure</code>（任一失败即终止）策略聚合结果。</p>
</li>
</ol>
<h3> 2.2 架构示意图</h3>
<div class="language-plaintext line-numbers-mode" data-ext="plaintext"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em>所有子任务的生命周期严格限定在父作用域内</em></p>
<hr>
<h2> 3. 优势：为什么选择结构化并发？</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>传统并发</th>
<th>结构化并发</th>
</tr>
</thead>
<tbody>
<tr>
<td>任务关系</td>
<td>松散</td>
<td><strong>严格层级化</strong></td>
</tr>
<tr>
<td>生命周期管理</td>
<td>手动</td>
<td><strong>自动管理</strong></td>
</tr>
<tr>
<td>异常传播</td>
<td>需显式处理</td>
<td><strong>自动冒泡</strong></td>
</tr>
<tr>
<td>代码可读性</td>
<td>回调嵌套复杂</td>
<td><strong>线性流程</strong></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>可靠性提升</strong>：避免线程泄漏，确保资源及时释放</li>
<li><strong>调试简化</strong>：通过线程转储（jstack）可清晰查看任务关系树</li>
<li><strong>错误处理统一</strong>：集中处理所有子任务的异常</li>
<li><strong>资源利用率优化</strong>：自动回收未完成任务占用的资源</li>
</ol>
<hr>
<h2> 4. 使用示例</h2>
<p>结构化并发的核心思想是将一组相关的并发任务视为一个单一的工作单元，这个工作单元有明确的开始和结束。在这个工作单元中，所有的子任务都在一个统一的作用域内执行，当工作单元完成或其中一个子任务失败时，整个工作单元会被正确地关闭，所有未完成的子任务也会被取消。这种方式使得并发代码的结构更加清晰，错误处理更加统一，从而提高了代码的可维护性和可靠性。</p>
<p>结构化并发通过 <code>StructuredTaskScope</code> 类来实现。<code>StructuredTaskScope</code> 提供了两种主要的模式：<code>ShutdownOnFailure</code> 和 <code>ShutdownOnSuccess</code></p>
<ul>
<li><code>ShutdownOnFailure：</code>当任何一个子任务失败时，会立即取消所有其他未完成的子任务，并抛出失败任务的异常。</li>
<li><code>ShutdownOnSuccess：</code>当任何一个子任务成功完成时，会立即取消所有其他未完成的子任务，并返回成功任务的结果。</li>
</ul>
<h3> 示例1：基本使用</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例2：订单处理（超时控制+异常处理）</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例3：并行聚合数据</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> 5. 小结</h2>
<h3> 5.1 注意事项</h3>
<ol>
<li>
<p><strong>作用域必须关闭</strong><br>
始终使用try-with-resources确保作用域关闭：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>避免跨作用域传递结果</strong><br>
子任务的结果应在同一作用域内消费：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>合理选择关闭策略</strong></p>
<ul>
<li><code>ShutdownOnSuccess</code>：适合快速获取首个成功结果（如多CDN择优）</li>
<li><code>ShutdownOnFailure</code>：适合所有子任务必须成功的场景（如支付验证）</li>
</ul>
</li>
<li>
<p><strong>与虚拟线程协同</strong><br>
结构化并发通常与虚拟线程配合使用：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h3> 5.2 小结</h3>
<p>JDK21结构化并发通过以下革新提升Java并发可靠性：</p>
<ul>
<li>✅ 将并发任务组织为可维护的树形结构</li>
<li>✅ 自动生命周期管理减少资源泄漏风险</li>
<li>✅ 异常传播机制提升调试效率</li>
<li>✅ 与虚拟线程协同实现高并发+高可靠</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>微服务中的并行API调用</li>
<li>批量数据处理任务</li>
<li>需要严格资源管理的长期运行任务</li>
</ul>
<p>目前结构化并发API仍处于预览阶段，可通过<code>--enable-preview</code>启用。 建议结合<a href="https://openjdk.org/jeps/453" target="_blank" rel="noopener noreferrer">官方指南</a>进行实践，这将为Java并发编程带来前所未有的代码清晰度与可靠性。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>04.JDK21记录模式：简化数据解构与模式匹配</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/04.%E8%AE%B0%E5%BD%95%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/04.%E8%AE%B0%E5%BD%95%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">04.JDK21记录模式：简化数据解构与模式匹配</source>
      <description>1. 背景：为什么需要记录模式？ 在Java中，处理复杂数据结构（如嵌套对象或记录类）时，通常需要编写大量样板代码来提取和验证数据。例如： 手动解构嵌套对象 使用instanceof和类型转换 编写冗长的条件分支 记录模式（Record Patterns）是Java模式匹配的进一步扩展，旨在简化数据解构和模式匹配的代码。它结合了记录类（Record）和模式匹配的特性，使开发者能够以声明式的方式提取和处理数据。</description>
      <category>Java</category>
      <category>JDK21</category>
      <pubDate>Thu, 13 Feb 2025 16:48:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. 背景：为什么需要记录模式？</h2>
<p>在Java中，处理复杂数据结构（如嵌套对象或记录类）时，通常需要编写大量样板代码来提取和验证数据。例如：</p>
<ul>
<li>手动解构嵌套对象</li>
<li>使用<code>instanceof</code>和类型转换</li>
<li>编写冗长的条件分支</li>
</ul>
<p><strong>记录模式</strong>（Record Patterns）是Java模式匹配的进一步扩展，旨在简化数据解构和模式匹配的代码。它结合了<strong>记录类</strong>（Record）和<strong>模式匹配</strong>的特性，使开发者能够以声明式的方式提取和处理数据。</p>
<p>JDK19首次引入记录模式作为预览特性，JDK21进一步优化并正式发布。</p>
<h2> 2. 原理：记录模式如何工作？</h2>
<p>记录类是一种特殊的类，它主要用于封装不可变的数据，自动生成构造函数、equals()、hashCode() 和 toString() 等方法。</p>
<p>记录模式利用记录类的这种特性，使得在进行类型检查和数据提取时可以一步完成，避免了传统方式下繁琐的属性访问操作</p>
<h3> 2.1 传统数据解构 vs 记录模式</h3>
<h4> 传统方式</h4>
<ul>
<li><strong>手动解构</strong>：通过getter方法或字段访问提取数据</li>
<li><strong>类型检查</strong>：使用<code>instanceof</code>和类型转换</li>
<li><strong>冗长代码</strong>：需要多行代码完成简单操作</li>
</ul>
<h4> 记录模式</h4>
<ul>
<li><strong>声明式解构</strong>：直接匹配记录类的结构并提取字段</li>
<li><strong>类型推断</strong>：自动推断字段类型，无需显式类型转换</li>
<li><strong>模式嵌套</strong>：支持嵌套记录类的解构</li>
</ul>
<h3> 核心机制</h3>
<ol>
<li>
<p><strong>模式匹配</strong><br>
记录模式扩展了<code>instanceof</code>和<code>switch</code>的模式匹配能力，允许直接匹配记录类的结构。</p>
</li>
<li>
<p><strong>解构绑定</strong><br>
在匹配成功后，自动将记录类的字段绑定到变量中。</p>
</li>
<li>
<p><strong>嵌套支持</strong><br>
支持嵌套记录类的解构，简化复杂数据结构的处理。</p>
</li>
<li>
<p><strong>类型推断</strong><br>
编译器自动推断字段类型，减少显式类型转换。</p>
</li>
</ol>
<h3> 2.2 架构示意图</h3>
<div class="language-plaintext line-numbers-mode" data-ext="plaintext"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 优势：为什么选择记录模式？</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>传统方式</th>
<th>记录模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>代码简洁性</td>
<td>冗长</td>
<td><strong>简洁</strong></td>
</tr>
<tr>
<td>类型安全性</td>
<td>需显式类型转换</td>
<td><strong>自动推断</strong></td>
</tr>
<tr>
<td>嵌套支持</td>
<td>手动逐层解构</td>
<td><strong>自动解构</strong></td>
</tr>
<tr>
<td>可读性</td>
<td>低</td>
<td><strong>高</strong></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>代码简洁</strong>：减少样板代码，提升开发效率</li>
<li><strong>类型安全</strong>：编译器自动检查类型，减少运行时错误</li>
<li><strong>嵌套解构</strong>：轻松处理复杂数据结构</li>
<li><strong>可读性高</strong>：声明式语法更符合直觉</li>
</ol>
<h2> 4. 使用示例</h2>
<p>记录模式的基本语法是在 instanceof 或 switch 表达式中使用记录类的名称，并在括号内指定要解构的组件变量。例如：</p>
<h3> 示例1：基本使用</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例2：嵌套记录类</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例3：在<code>switch</code>中使用记录模式</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例4：结合泛型使用</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5. 小结</h2>
<h3> 5.1 注意事项</h3>
<ol>
<li>
<p><strong>记录类要求</strong><br>
记录模式仅适用于记录类（Record），普通类需转换为记录类才能使用。</p>
</li>
<li>
<p><strong>模式顺序</strong><br>
在<code>switch</code>中，更具体的模式应放在前面：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>空值处理</strong><br>
记录模式不支持<code>null</code>值匹配，需额外检查：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p><strong>性能影响</strong><br>
记录模式在运行时可能引入额外开销，需在性能敏感场景中测试。</p>
</li>
</ol>
<h2> 5.2 总结</h2>
<p>JDK21记录模式通过以下革新提升Java数据处理的效率：</p>
<ul>
<li>✅ 简化数据解构代码</li>
<li>✅ 提升类型安全性和可读性</li>
<li>✅ 支持嵌套记录类的解构</li>
<li>✅ 与模式匹配无缝集成</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>处理复杂数据结构</li>
<li>实现模式匹配逻辑</li>
<li>简化数据验证和提取</li>
</ul>
<p>记录模式是Java模式匹配的重要扩展，建议有兴趣的小伙伴可以参考<a href="https://openjdk.org/jeps/440" target="_blank" rel="noopener noreferrer">官方文档</a>来实际体验一下它的魅力</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>05.JDK21字符串模板：更安全、更强大的字符串拼接</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/05.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/05.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">05.JDK21字符串模板：更安全、更强大的字符串拼接</source>
      <description>1. 背景：为什么需要字符串模板？ 在Java中，字符串拼接是常见的操作，但传统方式存在诸多问题： 可读性差：使用+或StringBuilder拼接字符串时，代码冗长且难以维护 安全性低：直接拼接用户输入可能导致SQL注入或XSS攻击 性能开销：频繁拼接字符串可能产生大量临时对象，影响性能 字符串模板（String Templates）是JDK21引入的一项新特性（预览），旨在提供一种更安全、更直观的字符串构建方式。它结合了模板引擎的灵活性和Java类型系统的安全性。</description>
      <category>Java</category>
      <category>JDK21</category>
      <pubDate>Thu, 13 Feb 2025 17:48:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. 背景：为什么需要字符串模板？</h2>
<p>在Java中，字符串拼接是常见的操作，但传统方式存在诸多问题：</p>
<ol>
<li><strong>可读性差</strong>：使用<code>+</code>或<code>StringBuilder</code>拼接字符串时，代码冗长且难以维护</li>
<li><strong>安全性低</strong>：直接拼接用户输入可能导致SQL注入或XSS攻击</li>
<li><strong>性能开销</strong>：频繁拼接字符串可能产生大量临时对象，影响性能</li>
</ol>
<p><strong>字符串模板</strong>（String Templates）是JDK21引入的一项新特性（预览），旨在提供一种更安全、更直观的字符串构建方式。它结合了<strong>模板引擎</strong>的灵活性和<strong>Java类型系统</strong>的安全性。</p>
<p><strong>基本概念</strong></p>
<p>字符串模板是一种允许在字符串字面量中嵌入表达式的机制。传统的 Java 字符串拼接通常使用 + 运算符或 String.format 方法，这在处理复杂的字符串拼接时会使代码变得冗长且不易阅读。而字符串模板通过将表达式直接嵌入到字符串中，使代码更加简洁和直观。</p>
<h2> 2. 原理：字符串模板如何工作？</h2>
<h3> 2.1 传统字符串拼接 vs 字符串模板</h3>
<h4> 传统方式</h4>
<ul>
<li><strong><code>+</code>操作符</strong>：简单但性能较差，可读性低</li>
<li><strong><code>StringBuilder</code></strong>：性能较好，但代码冗长</li>
<li><strong><code>String.format</code></strong>：可读性较高，但类型安全性差</li>
</ul>
<h4> 字符串模板</h4>
<ul>
<li><strong>嵌入式表达式</strong>：在字符串中直接嵌入变量或表达式</li>
<li><strong>类型安全</strong>：编译器检查表达式类型，避免运行时错误</li>
<li><strong>自定义处理器</strong>：支持通过处理器（Processor）自定义字符串生成逻辑</li>
</ul>
<h3> 核心机制</h3>
<ol>
<li>
<p><strong>模板语法</strong><br>
使用<code>\{...}</code>嵌入表达式，例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>模板处理器</strong><br>
字符串模板支持自定义处理器，例如：</p>
<ul>
<li><code>STR</code>：标准处理器，直接拼接字符串</li>
<li><code>FMT</code>：格式化处理器，支持格式化字符串</li>
<li>自定义处理器：实现<code>StringTemplate.Processor</code>接口</li>
</ul>
</li>
<li>
<p><strong>类型安全</strong><br>
编译器会检查嵌入表达式的类型，确保其与模板兼容。</p>
</li>
<li>
<p><strong>性能优化</strong><br>
字符串模板在编译时生成高效的字节码，减少运行时开销。</p>
</li>
</ol>
<h3> 2.2 优势：为什么选择字符串模板？</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>传统方式</th>
<th>字符串模板</th>
</tr>
</thead>
<tbody>
<tr>
<td>可读性</td>
<td>低</td>
<td><strong>高</strong></td>
</tr>
<tr>
<td>类型安全性</td>
<td>无</td>
<td><strong>有</strong></td>
</tr>
<tr>
<td>性能</td>
<td>较差</td>
<td><strong>优化</strong></td>
</tr>
<tr>
<td>灵活性</td>
<td>有限</td>
<td><strong>高</strong></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>代码简洁</strong>：减少样板代码，提升开发效率</li>
<li><strong>类型安全</strong>：编译器检查表达式类型，减少运行时错误</li>
<li><strong>性能优化</strong>：编译时生成高效字节码，减少运行时开销</li>
<li><strong>灵活扩展</strong>：支持自定义处理器，满足多样化需求</li>
</ol>
<h2> 3. 使用示例</h2>
<h3> 语法</h3>
<p>字符串模板主要有两种形式：简单字符串模板和带标签的字符串模板。</p>
<p><strong>简单字符串模板</strong></p>
<p>使用 STR 标签来标识字符串模板，在字符串中使用 <code>\{}</code> 语法嵌入表达式。</p>
<p><strong>带标签的字符串模板</strong></p>
<p>除了 STR 标签，我们还可以自定义标签来处理字符串模板。</p>
<ul>
<li>自定义标签是一个方法，它接收一个 TemplateContext 对象和一个 Object[] 数组作为参数。</li>
</ul>
<p>如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例1：基本使用</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例2：多行字符串</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例3：格式化字符串</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例4：自定义处理器</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4. 应用场景探索</h2>
<p>字符串模板的特性可以有效的应用在我们实际的业务场景中，如</p>
<h3> 4.1 构建动态消息</h3>
<p>在生成包含动态数据的消息时，字符串模板非常有用。比如生成用户欢迎消息、日志记录信息等。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.2 SQL拼接</h3>
<p>在构建 SQL 查询语句时，经常需要将变量值插入到 SQL 字符串中。使用字符串模板可以使代码更加清晰。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5. 小结</h2>
<h3> 4.1 注意事项</h3>
<ol>
<li>
<p><strong>语法兼容性</strong><br>
字符串模板使用<code>\{...}</code>语法，需确保与现有代码无冲突。</p>
</li>
<li>
<p><strong>处理器选择</strong><br>
根据需求选择合适的处理器，例如：</p>
<ul>
<li><code>STR</code>：普通字符串拼接</li>
<li><code>FMT</code>：格式化字符串</li>
<li>自定义处理器：复杂逻辑处理</li>
</ul>
</li>
<li>
<p><strong>性能测试</strong><br>
在性能敏感场景中，需测试字符串模板的性能表现。对于性能要求较高的场景，建议使用<code>StringBuilder</code>进行手动拼接</p>
</li>
<li>
<p><strong>安全性</strong><br>
使用自定义处理器时，确保对用户输入进行验证和转义，避免安全漏洞。</p>
</li>
<li>
<p><strong>表达式复杂度</strong>
嵌入的表达式应尽量保持简单，避免使用过于复杂的表达式，以免影响代码的可读性。</p>
</li>
<li>
<p><strong>转义字符</strong>
在字符串模板中，需要注意转义字符的使用。如果需要在字符串中包含 <code>\{</code> 或 <code>}</code>，需要进行适当的转义。</p>
</li>
</ol>
<h3> 4.2 总结</h3>
<p>JDK21字符串模板通过以下革新提升Java字符串处理的效率：</p>
<ul>
<li>✅ 简化字符串拼接代码</li>
<li>✅ 提升类型安全性和可读性</li>
<li>✅ 支持多行字符串和格式化</li>
<li>✅ 灵活扩展自定义处理器</li>
</ul>
<p>字符串模板是Java字符串处理的重要扩展，有兴趣的小伙伴可参考<a href="https://openjdk.org/jeps/430" target="_blank" rel="noopener noreferrer">官方文档</a>以掌握最佳实践。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>jdk21</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">jdk21</source>
      <pubDate>Thu, 13 Feb 2025 08:59:24 GMT</pubDate>
    </item>
    <item>
      <title>1.图片合成原理</title>
      <link>https://liuyueyi.github.io/tutorial/git/quick-media/image/01.%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90.html</link>
      <guid>https://liuyueyi.github.io/tutorial/git/quick-media/image/01.%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.图片合成原理</source>
      <description>图片合成 利用Java的绘图方法，实现图片合成 在开始之前，先定一个小目标，我们希望通过图片合成的方式，创建一个类似下面样式的图片 I. 设计思路 首先解析一下我们的目标实现图片合成，那么这些合成的基本组成单元有些什么？</description>
      <pubDate>Fri, 13 Jul 2018 20:37:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 图片合成</h1>
<blockquote>
<p>利用Java的绘图方法，实现图片合成</p>
</blockquote>
<p>在开始之前，先定一个小目标，我们希望通过图片合成的方式，创建一个类似下面样式的图片</p>
<figure><img src="/imgs/column/quick-media/image/13203703_6IVg.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> I. 设计思路</h3>
<blockquote>
<p>首先解析一下我们的目标实现图片合成，那么这些合成的基本组成单元有些什么？</p>
</blockquote>
<p><strong>组成基本单元</strong></p>
<ul>
<li>图片</li>
<li>文字</li>
<li>几何图形</li>
</ul>
<p>也就是说，我们可以将任意个图片，文字，几何图形，按照自己的意愿进行拼接，那么问题就转变成两个</p>
<ul>
<li>基本单元如何在画布上渲染</li>
<li>基本单元之间如何配合使用</li>
</ul>
<h3> II. 基本单元绘制</h3>
<p>首先定义一个基本单元的接口，之后所有组合的元素都继承自这个接口</p>
<p>接口<code>IMergeCell</code>只定义一个绘制的方法，用于实现该基本单元的绘制方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1. 图片绘制</h4>
<p>绘制图片，一般来讲需要知道：</p>
<ul>
<li>绘制的坐标(x,y)</li>
<li>绘制图片的宽高(w,h)，当目标是绘制原图时，宽高一般为图片本身的宽高</li>
</ul>
<p>结合上面两点，图片组成单元的定义如下: <code>ImgCell</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2. 文本绘制</h4>
<blockquote>
<p>图片绘制比较简单，相比而言，文字绘制就麻烦一点，主要是文本绘制的对齐方式，竖排还是横排布局</p>
</blockquote>
<p><strong>首先分析我们需要的基本信息</strong></p>
<ul>
<li>
<p>考虑对齐方式（居中对齐，靠左，靠上，靠右，靠下）</p>
<ul>
<li>因此需要确定文本绘制的区域，所以需要两个坐标 (startX, startY), (endX, endY)</li>
</ul>
</li>
<li>
<p>文本绘制参数</p>
<ul>
<li>可以指定字体<code>Font</code>，文本颜色 <code>Color</code>，行间距 <code>lineSpace</code></li>
</ul>
</li>
<li>
<p>绘制的文本信息</p>
<ul>
<li>文本内容 <code>List&lt;String&gt;</code></li>
</ul>
</li>
</ul>
<p><strong>绘制实现</strong></p>
<ul>
<li>
<p>若单行的文本超过长度上限，则需要自动换行，所以有 <code>batchSplitText</code> 方法，对原文本内容进行分割，确保不会超过边界</p>
</li>
<li>
<p>不同的对齐方式，绘制的起始坐标需要计算, 所以在水平布局文字时，需要通过 <code>calculateX</code>方法获取新的x坐标；竖直布局文字时，需要通过 <code>calculateY</code>获取新的y坐标</p>
</li>
</ul>
<p>实际代码如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em>说明:</em></p>
<ul>
<li>单行文本的分割，使用了博文系列中的工具方法 <code>GraphicUtil.splitStr</code>，有兴趣的关注源码进行查看</li>
<li>水平布局时，期望 <code>startX &lt; endX</code>, 从习惯来讲，基本上我们都是从左到右进行阅读</li>
<li>水平or垂直布局，都希望是 <code>startY &lt; endY</code></li>
<li>垂直布局时，以字符为单位进行绘制；标点符号的绘制时，x坐标有一个偏移量</li>
</ul>
<h4> 3. Line直线绘制</h4>
<p>几何图形之直线绘制，给出起点和结束点坐标，绘制一条直线，比较简单；这里给出了虚线的支持</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4. 矩形框绘制</h4>
<p>矩形框绘制，同直线绘制，支持圆角矩形，支持虚线框</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5. 矩形区域填充</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> III. 封装</h3>
<p>上面实现了几个常见的基本单元绘制，接下来则是封装绘制, 这块的逻辑就比较简单了如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> IV. 测试</h3>
<p>写了一个模板<code>QrCodeCardTemplateBuilder</code>，用于拼装上图的样式，代码较长，不贴了，有兴趣的查看原图</p>
<p>测试代码如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>演示图如下:</p>
<figure><img src="/imgs/column/quick-media/image/13203703_6IVg.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> V. 其他</h3>
<p><strong>项目地址：</strong></p>
<ul>
<li><a href="https://github.com/liuyueyi/quick-media" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/quick-media</a></li>
<li><code>QuickMedia</code> 目标是创建一个专注图文，音视频，二维码处理的开源项目</li>
</ul>
<p><strong>系列博文</strong></p>
<ul>
<li><a href="https://my.oschina.net/u/566591/blog/1359432" target="_blank" rel="noopener noreferrer">spring-boot &amp; ffmpeg 搭建一个音频转码服务</a></li>
<li><a href="https://my.oschina.net/u/566591/blog/1457164" target="_blank" rel="noopener noreferrer">spring-boot &amp; zxingy 搭建二维码服务</a></li>
<li><a href="https://my.oschina.net/u/566591/blog/1491697" target="_blank" rel="noopener noreferrer">二维码服务拓展(支持logo，圆角logo，背景图，颜色配置)</a></li>
<li><a href="https://my.oschina.net/u/566591/blog/1507162" target="_blank" rel="noopener noreferrer">zxing二维码生成服务之深度定制</a></li>
<li><a href="https://my.oschina.net/u/566591/blog/1514644" target="_blank" rel="noopener noreferrer">Java实现长图文生成</a></li>
<li><a href="https://my.oschina.net/u/566591/blog/1529564" target="_blank" rel="noopener noreferrer">Java竖排长图文生成</a></li>
<li><a href="https://my.oschina.net/u/566591/blog/1535380" target="_blank" rel="noopener noreferrer">Java实现markdown 转 html</a></li>
<li><a href="https://my.oschina.net/u/566591/blog/1536078" target="_blank" rel="noopener noreferrer">Java实现html 转 image</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/quick-media/image/13203703_6IVg.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>2.Java实现长图文生成</title>
      <link>https://liuyueyi.github.io/tutorial/git/quick-media/image/02.Java%E5%AE%9E%E7%8E%B0%E9%95%BF%E5%9B%BE%E6%96%87%E5%90%88%E6%88%90.html</link>
      <guid>https://liuyueyi.github.io/tutorial/git/quick-media/image/02.Java%E5%AE%9E%E7%8E%B0%E9%95%BF%E5%9B%BE%E6%96%87%E5%90%88%E6%88%90.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2.Java实现长图文生成</source>
      <description>Java实现长图文生成 很久很久以前，就觉得微博的长图文实现得非常有意思，将排版直接以最终的图片输出，收藏查看分享都很方便，现在则自己动手实现一个简单版本的 目标 首先定义下我们预期达到的目标：根据文字 + 图片生成长图文 目标拆解 支持大段文字生成图片 支持插入图片 支持上下左右边距设置 支持字体选择 支持字体颜色 支持左对齐，居中，右对齐</description>
      <pubDate>Fri, 18 Aug 2017 18:06:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java实现长图文生成</h1>
<blockquote>
<p>很久很久以前，就觉得微博的长图文实现得非常有意思，将排版直接以最终的图片输出，收藏查看分享都很方便，现在则自己动手实现一个简单版本的</p>
</blockquote>
<h2> 目标</h2>
<p>首先定义下我们预期达到的目标：根据文字 + 图片生成长图文</p>
<h3> 目标拆解</h3>
<ul>
<li>支持大段文字生成图片</li>
<li>支持插入图片</li>
<li>支持上下左右边距设置</li>
<li>支持字体选择</li>
<li>支持字体颜色</li>
<li>支持左对齐，居中，右对齐</li>
</ul>
<h3> 预期结果</h3>
<p>我们将通过spring-boot搭建一个生成长图文的http接口，通过传入参数来指定各种配置信息，下面是一个最终调用的示意图</p>
<figure><img src="/imgs/column/quick-media/image/18180654_y9iv.gif" alt="演示图" tabindex="0" loading="lazy"><figcaption>演示图</figcaption></figure>
<h2> 设计&amp;实现</h2>
<blockquote>
<p>长图文的生成，采用awt进行文字绘制和图片绘制</p>
</blockquote>
<h3> 1. 参数选项 <code>ImgCreateOptions</code></h3>
<p>根据我们的预期目标，设定配置参数，基本上会包含以下参数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 封装类 <code>ImageCreateWrapper</code></h3>
<p>封装配置参数的设置，绘制文本，绘制图片的操作方式，输出样式等接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面具体的文本和图片绘制实现没有，后面详细讲解，这里主要关注的是一个参数 <code>contentH</code>， 表示实际绘制的内容高度（包括上边距），因此最终生成图片的高度应该是</p>
<p><code>int realH = contentH + options.getBottomPadding();</code></p>
<p>其次简单说一下上面的图片输出方法：<code>com.hust.hui.quickmedia.common.image.ImgCreateWrapper.Builder#asImage</code></p>
<ul>
<li>计算最终生成图片的高度（宽度由输入参数指定）</li>
<li>绘制背景（如果没有背景图片，则用纯色填充）</li>
<li>绘制实体内容（即绘制的文本，图片）</li>
</ul>
<h3> 3. 内容填充 <code>GraphicUtil</code></h3>
<blockquote>
<p>具体的内容填充，区分为文本绘制和图片绘制</p>
</blockquote>
<h4> 设计</h4>
<ol>
<li>
<p>考虑到在填充的过程中，可以自由设置字体，颜色等，所以在我们的绘制方法中，直接实现掉内容的绘制填充，即 <code>drawXXX</code> 方法真正的实现了内容填充，执行完之后，内容已经填充到画布上了</p>
</li>
<li>
<p>图片绘制，考虑到图片本身大小和最终结果的大小可能有冲突，采用下面的规则</p>
</li>
</ol>
<ul>
<li>绘制图片宽度 &lt;=（指定生成图片宽 - 边距），全部填充</li>
<li>绘制图片宽度 &gt;（指定生成图片宽 - 边距），等比例缩放绘制图片</li>
</ul>
<ol start="3">
<li>文本绘制，换行的问题</li>
</ol>
<ul>
<li>每一行允许的文本长度有限，超过时，需要自动换行处理</li>
</ul>
<h4> 文本绘制</h4>
<p>考虑基本的文本绘制，流程如下</p>
<ul>
<li>创建<code>BufferImage</code>对象</li>
<li>获取<code>Graphic2d</code>对象，操作绘制</li>
<li>设置基本配置信息</li>
<li>文本按换行进行拆分为字符串数组, 循环绘制单行内容
<ul>
<li>计算当行字符串，实际绘制的行数，然后进行拆分</li>
<li>依次绘制文本（需要注意y坐标的变化）</li>
</ul>
</li>
</ul>
<p>下面是具体的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现比较清晰了，图片的绘制则更加简单</p>
<h4> 图片绘制</h4>
<p>只需要重新计算下待绘制图片的宽高即可，具体实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 内容渲染</h3>
<p>前面只是给出了单块内容（如一段文字，一张图片）的渲染，存在一些问题</p>
<ul>
<li>绘制的内容超过画布的高度如何处理</li>
<li>文本绘制要求传入的文本没有换行符，否则换行不生效</li>
<li>交叉绘制的场景，如何重新计算y坐标</li>
</ul>
<hr>
<p>解决这些问题则是在 <code>ImgCreateWrapper</code> 的具体绘制中进行了实现，先看文本的绘制</p>
<ul>
<li>根据换行符对字符串进行拆分</li>
<li>计算绘制内容最终转换为图片时，所占用的高度</li>
<li>重新生成画布 <code>BufferedImage result</code>
<ul>
<li>如果result为空，则直接生成</li>
<li>如果最终生成的高度，超过已有画布的高度，则生成一个更高的画布，并将原来的内容绘制上去</li>
</ul>
</li>
<li>迭代绘制单行内容</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面需要注意的是画布的生成规则，特别是高度超过上限之后，重新计算图片高度时，需要额外注意新增的高度，应该为基本的增量与（绘制内容高度+下边距）的较大值</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>重新生成画布实现 <code>com.hust.hui.quickmedia.common.util.GraphicUtil#createImg</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面理解之后，绘制图片就比较简单了，基本上行没什么差别</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. http接口</h3>
<p>上面实现的生成图片的公共方法，在 <code>quick-media</code> 工程中，利用spring-boot搭建了一个web服务，提供了一个http接口，用于生成长图文，最终的成果就是我们开头的那个gif图的效果，相关代码就没啥好说的，有兴趣的可以直接查看工程源码，链接看最后</p>
<h2> 测试验证</h2>
<p>上面基本上完成了我们预期的目标，接下来则是进行验证，测试代码比较简单，先准备一段文本，这里拉了一首诗</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出图片</p>
<figure><img src="/imgs/column/quick-media/image/18180717_MrRM.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 其他</h2>
<p>项目地址: <a href="https://github.com/liuyueyi/quick-media" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/quick-media</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/quick-media/image/18180654_y9iv.gif" type="image/gif"/>
    </item>
    <item>
      <title>3.Java实现竖排长图文生成</title>
      <link>https://liuyueyi.github.io/tutorial/git/quick-media/image/03.Java%E5%AE%9E%E7%8E%B0%E7%AB%96%E6%8E%92%E9%95%BF%E5%9B%BE%E6%96%87%E7%94%9F%E6%88%90.html</link>
      <guid>https://liuyueyi.github.io/tutorial/git/quick-media/image/03.Java%E5%AE%9E%E7%8E%B0%E7%AB%96%E6%8E%92%E9%95%BF%E5%9B%BE%E6%96%87%E7%94%9F%E6%88%90.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3.Java实现竖排长图文生成</source>
      <description>背景 前面2.Java实现长图文生成 中实现了一个基本的长图文生成工具，但遗留了一些问题 文字中包含英文字符时，分行计算问题 暂不支持竖排文字展示 其中英文字符的计算已经修复，主要是通过FontMetric来计算字符串实际占用绘制的长度，这一块不做多讲，本篇主要集中在竖排文字的支持</description>
      <pubDate>Tue, 05 Sep 2017 18:19:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 背景</h2>
<p>前面<a href="/tutorial/git/quick-media/image/02.Java%E5%AE%9E%E7%8E%B0%E9%95%BF%E5%9B%BE%E6%96%87%E5%90%88%E6%88%90.html" target="blank">2.Java实现长图文生成</a> 中实现了一个基本的长图文生成工具，但遗留了一些问题</p>
<ul>
<li>文字中包含英文字符时，分行计算问题</li>
<li>暂不支持竖排文字展示</li>
</ul>
<p>其中英文字符的计算已经修复，主要是通过<code>FontMetric</code>来计算字符串实际占用绘制的长度，这一块不做多讲，本篇主要集中在竖排文字的支持</p>
<h2> 设计</h2>
<blockquote>
<p>有前面的基础，在做竖排文字支持上，本以为是比较简单就能接入的，而实际的实现过程中，颇为坎坷</p>
</blockquote>
<h3> 1. 竖排文字绘制</h3>
<p>首先需要支持竖排文字的绘制，使用<code>Graphics2d</code>进行绘制时，暂不支持竖排绘制方式，因此我们需要自己来实现</p>
<p>而设计思路也比较简单，一个字一个字的绘制，x坐标不变，y坐标依次增加</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 自动换行</h3>
<p>竖排的自动换行相比较与水平有点麻烦的是间隔问题，首先看下<code>FontMertric</code>的几个参数 <code>ascent</code>, <code>descent</code>, <code>height</code></p>
<figure><img src="/imgs/column/quick-media/image/05181941_gJBV.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>举一个例子来看如何进行自动换行</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先我们是需要获取内容的总长度，中文还比较好说，都是方块的，可以直接用 <code>fontMetrics.stringWidth(content)</code> 获取内容长度（实际为宽度），然后需要加空格(即<code>descent</code>)</p>
<p>所以计算最终的行数可以如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据上面的计算， <code>l=72, lineNum=5;</code></p>
<p>然后就是一个字符一个字符的进行绘制，每次需要重新计算y坐标</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其次就是需要判断是否要换行</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 从右到左支持</h3>
<p>从左到右还比较好说，y坐标一直增加，当绘制的内容超过当前的图片时，直接在扩展后的图片上(0,0)位置进行绘制即可；</p>
<p>而从右到左则需要计算偏移量，如下图</p>
<figure><img src="/imgs/column/quick-media/image/05182209_f6NC.jpg" alt="offset" tabindex="0" loading="lazy"><figcaption>offset</figcaption></figure>
<h2> 实现</h2>
<h3> 1. 文本自动换行</h3>
<p>实现一个公共方法，根据上面的思路用于文本的自动换行</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，唯一需要注意的是，换行时，y坐标自增的场景下，需要计算 <code>fontMetric.descent</code> 的值，否则换行偏移会有问题</p>
<h3> 2. 垂直文本的绘制</h3>
<h4> 1. 起始y坐标计算</h4>
<p>因为我们支持集中不同的对齐方式，所以在计算起始的y坐标时，会有出入, 实现如下</p>
<ul>
<li>上对齐，则 y = 上边距</li>
<li>下对其， 则 y = 总高度 - 内容高度 - 下边距</li>
<li>居中， 则 y = (总高度 - 内容高度) / 2</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2. 实际绘制y坐标计算</h4>
<p>实际绘制中，y坐标还不能直接使用上面返回值，因为这个返回是字体的最上边对应的坐标，因此需要将实际绘制y坐标，向下偏移一个字</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3. 换行时，x坐标计算</h4>
<p>绘制方式的不同，从左到右与从右到左两种场景下，自动换行后，新行的x坐标的增量计算方式也是不同的</p>
<ul>
<li>从左到右：<code>int fontWidth = 字体宽度 + 行间距</code></li>
<li>从右到左：<code>int fontWidth = - (字体宽度 + 行间距）</code></li>
</ul>
<h4> 完整的实现逻辑如下</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 垂直图片绘制</h3>
<p>文本绘制实现之后，再来看图片，就简单很多了，因为没有换行的问题，所以只需要计算y坐标的值即可</p>
<p>此外当图片大于参数指定的高度时，对图片进行按照高度进行缩放处理；当小于高度时，就原图绘制即可</p>
<p>实现逻辑如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 封装类的实现</h3>
<p>正如前面一篇博文中实现的水平图文生成的逻辑一样，垂直图文生成也采用之前的思路：</p>
<ul>
<li>每次在文本绘制时，直接进行渲染；</li>
<li>记录实际内容绘制的宽度（这个宽度包括左or右边距）</li>
<li>每次绘制时，判断当前的画布是否容纳得下所有的内容
<ul>
<li>容的下，直接绘制即可</li>
<li>容不下，则需要扩充画布，生成一个更宽的画布，将原来的内容重新渲染在新画布上，然后在新画布上进行内容的填充</li>
</ul>
</li>
</ul>
<p>因为从左到右和从右到左的绘制在计算x坐标的增量时，扩充画布的重新绘制时，有些明显的区别，所以为了逻辑清晰，将两种场景分开，提供了两个方法</p>
<p>实现步骤:</p>
<ol>
<li>计算实际绘制内容占用的宽度</li>
<li>判断是否需要扩充画布（需要则扩充）</li>
<li>绘制文本</li>
<li>更新内容的宽度</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对比从左到右与从右到左，区别主要是两点</p>
<ul>
<li>扩充时，在新画布上绘制原画布内容的x坐标计算，一个为0，一个为 <code>新宽度-旧宽度</code></li>
<li>offsetX 的计算</li>
</ul>
<p>上面是文本绘制，图片绘制比较简单，基本上和水平绘制时，没什么区别，只不过是扩充时的w，h计算不同罢了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 输出</h3>
<p>上面是绘制的过程，绘制完毕之后，需要输出为图片的，因此对于这个输出需要再适配一把</p>
<p>再前一篇的基础上，输出新增了签名+背景的支持，这里一并说了</p>
<ul>
<li>计算生成图片的宽高</li>
<li>有签名时，绘制签名背景，在最下方绘制签名文本</li>
<li>背景图片</li>
<li>绘制填充内容</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 测试</h2>
<p>测试case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出图片</p>
<figure><img src="/imgs/column/quick-media/image/05182105_2smp.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://static.oschina.net/uploads/img/201709/05182105_2smp.jpg" alt="https://static.oschina.net/uploads/img/201709/05182105_2smp.jpg" tabindex="0" loading="lazy"><figcaption><a href="https://static.oschina.net/uploads/img/201709/05182105_2smp.jpg" target="_blank" rel="noopener noreferrer">https://static.oschina.net/uploads/img/201709/05182105_2smp.jpg</a></figcaption></figure>
<p>再输出一个从右到左的，居中显示样式</p>
<figure><img src="/imgs/column/quick-media/image/05182138_My1E.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 其他</h2>
<p>相关博文：<a href="https://my.oschina.net/u/566591/blog/1514644" target="_blank" rel="noopener noreferrer">《Java 实现长图文生成》</a></p>
<p>项目地址：<a href="https://github.com/liuyueyi/quick-media" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/quick-media</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/quick-media/image/05181941_gJBV.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>4.图片合成使用示例</title>
      <link>https://liuyueyi.github.io/tutorial/git/quick-media/image/04.%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/git/quick-media/image/04.%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4.图片合成使用示例</source>
      <description>本文为 image-plugin 图片合成的使用参考示例 1. 项目依赖 直接从中央仓库，导入最新依赖 &amp;lt;!-- https://mvnrepository.com/artifact/com.github.liuyueyi.media/image-plugin --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.github.liuyueyi.media&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;image-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;!-- 请使用最新版本号替换下面的版本 --&amp;gt; &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;</description>
      <pubDate>Wed, 05 Feb 2025 18:19:49 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文为 <a href="https://github.com/liuyueyi/quick-media/tree/master/plugins/image-plugin" target="_blank" rel="noopener noreferrer">image-plugin</a> 图片合成的使用参考示例</p>
</blockquote>
<h2> 1. 项目依赖</h2>
<p>直接从中央仓库，导入最新依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 参数说明</h2>
<p>相关参数配置由<code>com.github.hui.quick.plugin.image.wrapper.create.ImgCreateOptions</code>实体类进行装载，对应的参数说明如下</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>bgImg</td>
<td>BufferedImage</td>
<td>绘制的背景图</td>
</tr>
<tr>
<td>imgW</td>
<td>Integer</td>
<td>生成图片的宽</td>
</tr>
<tr>
<td>imgH</td>
<td>Integer</td>
<td>生成图片的高</td>
</tr>
<tr>
<td>font</td>
<td>Font</td>
<td>字体，默认值为 DEFAULT_FONT</td>
</tr>
<tr>
<td>fontColor</td>
<td>Color</td>
<td>字体色，默认值为黑色</td>
</tr>
<tr>
<td>leftPadding</td>
<td>int</td>
<td>左边距</td>
</tr>
<tr>
<td>rightPadding</td>
<td>int</td>
<td>右边距</td>
</tr>
<tr>
<td>topPadding</td>
<td>int</td>
<td>上边距</td>
</tr>
<tr>
<td>bottomPadding</td>
<td>int</td>
<td>底边距</td>
</tr>
<tr>
<td>linePadding</td>
<td>int</td>
<td>行距</td>
</tr>
<tr>
<td>alignStyle</td>
<td>AlignStyle</td>
<td>对齐方式，水平绘制时为左对齐、居中、右对齐；垂直绘制时为上对齐、居中、下对齐</td>
</tr>
<tr>
<td>drawStyle</td>
<td>DrawStyle</td>
<td>文本绘制方式，水平或垂直</td>
</tr>
</tbody>
</table>
<h2> 3. 使用示例</h2>
<blockquote>
<p>所有的使用姿势，可以在源码对应的test工程中获取</p>
<p>下文对应的示例，详情查看: <a href="https://github.com/liuyueyi/quick-media/blob/master/plugins/image-plugin/src/test/java/com/github/hui/quick/plugin/test/ImgCreateWrapperTest.java" target="_blank" rel="noopener noreferrer">ImgCreateWrapperTest.java</a></p>
</blockquote>
<h3> 3.1 基本使用示例</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/quick-media/image/2out.png" alt="输出图" tabindex="0" loading="lazy"><figcaption>输出图</figcaption></figure>
<p>如我们希望生成竖排输出的图文，可以在上面的基础上做一个微调即可快速实现，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/quick-media/image/v2out.png" alt="输出图" tabindex="0" loading="lazy"><figcaption>输出图</figcaption></figure>
<p>若我们希望在文字中间穿插图片，并设置对文字设置不同的颜色、字体、样式时，可以参照下面的实现方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/quick-media/image/more2out.png" alt="输出图" tabindex="0" loading="lazy"><figcaption>输出图</figcaption></figure>
<h3> 3.2 逐行打印文本，生成gif动画</h3>
<p>主要参数同上，使用姿势可以参考: <a href="https://github.com/liuyueyi/quick-media/blob/master/plugins/image-plugin/src/test/java/com/github/hui/quick/plugin/test/LineCreateWrapperTest.java" target="_blank" rel="noopener noreferrer">LineCreateWrapperTest</a></p>
<p>具体的使用示例与上面基本没有什么区别，无非是输出的图是gif动图</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/quick-media/image/line.gif" alt="输出图" tabindex="0" loading="lazy"><figcaption>输出图</figcaption></figure>
<h3> 3.3 逐字输出，生成gif动画</h3>
<p>主要参数同上，使用姿势可以参考: <a href="https://github.com/liuyueyi/quick-media/blob/master/plugins/image-plugin/src/test/java/com/github/hui/quick/plugin/test/LineCreateWrapperTest.java" target="_blank" rel="noopener noreferrer">LineCreateWrapperTest</a></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/quick-media/image/word.gif" alt="输出图" tabindex="0" loading="lazy"><figcaption>输出图</figcaption></figure>
<h2> 4. 进阶使用</h2>
<p>上面介绍的使用姿势适用于简单的图文合成，当我们有一些相对复杂的图片需要合成时，可以考虑一下基于模板的图文合成方式</p>
<p>这里主要使用的是 <code>ImgMergeWrapper</code> 提供的能力，其内部提供了五个基本单元（也支持扩展自己的基本绘制单元）</p>
<h3> 4.1 基础绘制单元</h3>
<p>如需要实现自定义的绘制单元，则可以通过实现下面的接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>image-plugin原生提供的几个实现如下</p>
<ul>
<li>TextCell: 文字绘制，支持超出最终输出图片的宽高时，自动换行</li>
<li>LineCell: 线条绘制，原生提供实线和虚线两种样式，也可以自定义线条样式</li>
<li>RectCell: 矩形框绘制</li>
<li>RectFillCell: 矩形区域绘制</li>
<li>ImgCell: 图片绘制</li>
</ul>
<h3> 4.2 基本使用</h3>
<blockquote>
<p>源码： <a href="https://github.com/liuyueyi/quick-media/blob/master/plugins/image-plugin/src/test/java/com/github/hui/quick/plugin/test/ImgMergeWrapperTest.java" target="_blank" rel="noopener noreferrer">ImgMergeWrapperTest</a></p>
</blockquote>
<p>下面是一个简单的示例，生成书籍封面图，一张底图，一个矩形框，一个矩形区域，然后再矩形区域内填充书名</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>输出1</th>
<th>输出2</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/imgs/column/quick-media/image/cover.png" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/cover2.png" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h3> 4.3 模板复用</h3>
<p>我们可以定义自己的合成模板，然后通过传入不同的参数来生成不同的图片；比如原生提供了一个二维码签名的模板</p>
<p>关键点在于 <code>QrCodeCardTemplateBuilder</code> 的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后对应的使用姿势就非常简单了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的输出图，实际上就是我的个人推介名片</p>
<figure><img src="/imgs/column/quick-media/image/qrcode.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/quick-media/image/2out.png" type="image/png"/>
    </item>
    <item>
      <title>5.图片转SVG使用示例</title>
      <link>https://liuyueyi.github.io/tutorial/git/quick-media/image/05.%E5%9B%BE%E7%89%87%E8%BD%ACSVG%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/git/quick-media/image/05.%E5%9B%BE%E7%89%87%E8%BD%ACSVG%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5.图片转SVG使用示例</source>
      <description>本文为 image-plugin 中图转SVG的使用参考示例 1. 基本原理 我们知道图片是由一个一个的像素点组成的，将图片转换为svg的一个思路就是将图片中的每个像素点直接转换为svg中的矩形颜色块，这样就可以直接生成一个对应的svg文本了</description>
      <pubDate>Thu, 06 Feb 2025 10:19:49 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文为 <a href="https://github.com/liuyueyi/quick-media/tree/master/plugins/image-plugin" target="_blank" rel="noopener noreferrer">image-plugin</a> 中图转SVG的使用参考示例</p>
</blockquote>
<h2> 1. 基本原理</h2>
<p>我们知道图片是由一个一个的像素点组成的，将图片转换为svg的一个思路就是将图片中的每个像素点直接转换为svg中的矩形颜色块，这样就可以直接生成一个对应的svg文本了</p>
<p>一个基本的转换实现可以参见 <a href="https://github.com/liuyueyi/quick-media/blob/master/plugins/image-plugin/src/test/java/com/github/hui/quick/plugin/test/feat/svg/SvgParseTest.java" target="_blank" rel="noopener noreferrer">SvgParseTest.java</a></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/quick-media/image/parseSvg-out1.svg" alt="输出图" tabindex="0" loading="lazy"><figcaption>输出图</figcaption></figure>
<p>上面实现就是基本的像素块的替换了，可以看到输出的svg文本较大；接下来我们可以再优化一下，首先利用<code>ImgPixelWrapper</code>将图片转换为像素块（降低精度），然后再将像素块的图片转换为svg</p>
<p>因此可以对上面的实现进行一个微调</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如上面设置<code>size = 8</code>，相当于将原图精度损失8倍，对应生成的svg如下</p>
<figure><img src="/imgs/column/quick-media/image/parseSvg-out2.svg" alt="输出图" tabindex="0" loading="lazy"><figcaption>输出图</figcaption></figure>
<h2> 2. 使用示例</h2>
<h3> 2.1 参数说明</h3>
<p>核心参数四个，其中source传图为必填</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>说明</th>
<th>是否必填</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>source</code></td>
<td><code>BufferedImage</code></td>
<td>原始图</td>
<td>是</td>
</tr>
<tr>
<td><code>blockSize</code></td>
<td><code>int</code></td>
<td>对于转字符图时，它控制字符大小；对于灰度/像素处理时，这个表示像素化的处理操作</td>
<td>非必填，默认 <code>4</code></td>
</tr>
<tr>
<td><code>scaleRate</code></td>
<td><code>Double</code></td>
<td>缩放比例，1 表示输出的图不缩放； &gt; 1，表示生成的图，按倍数扩大</td>
<td>非必填，默认 <code>1</code></td>
</tr>
<tr>
<td><code>bgPredicate</code></td>
<td><code>Predicate&lt;Color&gt;</code></td>
<td>背景色判断方式，传参为 <code>intColor</code>，如果返回<code>true</code>，表示认定为背景色；否则不是</td>
<td>非必填，默认纯白色为背景</td>
</tr>
</tbody>
</table>
<h3> 2.2 使用示例</h3>
<p>使用姿势形如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一个简单的使用示例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>原图</th>
<th>svg图</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/imgs/column/quick-media/image/d5137769-1836-cc20-c1eb-20af1109dc7a.jpg" height="500px"></td>
<td><img src="/imgs/column/quick-media/image/dlam.svg" height="500px"></td>
</tr>
</tbody>
</table>
<p>接下来再看一个真实人像的转换过程，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>说明：原图来自网上 <a href="https://fc.sinaimg.cn/large/ea98bce0gy1h6u8ge7y66j22q55wi4qs.jpg" target="_blank" rel="noopener noreferrer">https://www.5youqu.com/bizhi/124906.html</a>，做了背景剔除</p>
</blockquote>
<p>对比结果如下</p>
<table>
<thead>
<tr>
<th>原图</th>
<th>svg图</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/imgs/column/quick-media/image/lyf.png" height="500px"></td>
<td><img src="/imgs/column/quick-media/image/lyf.svg" height="500px"></td>
</tr>
<tr>
<td><img src="/imgs/column/quick-media/image/lyf.png" height="500px"></td>
<td><img src="/imgs/column/quick-media/image/lyf2.svg" height="500px"></td>
</tr>
</tbody>
</table>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/quick-media/image/parseSvg-out1.svg" type="image/svg+xml"/>
    </item>
    <item>
      <title>6.像素图片-图片灰度化</title>
      <link>https://liuyueyi.github.io/tutorial/git/quick-media/image/06.%E5%9B%BE%E7%89%87%E7%81%B0%E5%BA%A6%E5%8C%96.html</link>
      <guid>https://liuyueyi.github.io/tutorial/git/quick-media/image/06.%E5%9B%BE%E7%89%87%E7%81%B0%E5%BA%A6%E5%8C%96.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6.像素图片-图片灰度化</source>
      <description>本文通过一个简单的实例，演示如何使用java来实现图片灰度化处理，主要借助下面两种策略来处理颜色 灰度化公式 avgColor = red * 0.299f + green * 0.587f + blue * 0.114f</description>
      <pubDate>Fri, 12 Nov 2021 10:19:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文通过一个简单的实例，演示如何使用java来实现图片灰度化处理，主要借助下面两种策略来处理颜色</p>
<p><strong>灰度化公式</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>均值方式</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>基于上面两种方式，我们要实现一个图片灰度化的处理，无非就是获取图片的每个像素点的颜色，然后计算avgColor，再用新的颜色填充即可</p>
<p>一个基础的实现演示如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>生成原图与灰度图的对比如下</p>
<figure><img src="/imgs/211112/00.jpg" alt="输出图" tabindex="0" loading="lazy"><figcaption>输出图</figcaption></figure>
<p>注意上面的实现，其中加载网络图片的具体实现，之前的博文有介绍，有兴趣的小伙伴可以参考: 封装一个根据路径获取文件资源的工具类</p>
<p>此外介绍一个更好用的姿势，直接使用开源项目 <a href="https://github.com/liuyueyi/quick-media" target="_blank" rel="noopener noreferrer">quick-media/image-plugins</a> 来实现灰度处理</p>
<p>使用这个项目的 image-plugins 之后，生成一个灰度图就很简单了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>原图</th>
<th>svg图</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/imgs/column/quick-media/image/20180916175034_Gr2hk.jpeg" target="_blank" rel="noopener noreferrer">20180916175034_Gr2hk.jpeg</a></td>
<td><a href="/imgs/column/quick-media/image/gray.png" target="_blank" rel="noopener noreferrer"></a></td>
</tr>
</tbody>
</table>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/211112/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>7.像素图片-图片转字符图</title>
      <link>https://liuyueyi.github.io/tutorial/git/quick-media/image/07.%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E5%9B%BE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/git/quick-media/image/07.%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E5%9B%BE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7.像素图片-图片转字符图</source>
      <description>前面介绍了一篇java实现图片灰度化处理的小demo，接下来再介绍一个有意思的东西，将一个图片转换成字符图片 借助前面图片灰度化处理的知识点，若我们希望将一张图片转成字符图片，同样可以遍历每个像素点，然后将像素点由具体的字符来替换，从而实现字符化处理 基于上面这个思路，具体的实现就很清晰了 @Test public void testRender() throws IOException { String file = &amp;quot;http://i0.download.fd.52shubiao.com/t_960x600/g1/M00/10/17/oYYBAFWvR5-IeXHuAAd5kPb8eSgAACm0QF50xIAB3mo414.jpg&amp;quot;; // 从网络上下载图片 BufferedImage img = ImageIO.read(FileReadUtil.getStreamByFileName(file)); int w = img.getWidth(), h = img.getHeight(); // 创建新的字符图片画板 BufferedImage gray = new BufferedImage(w, h, img.getType()); Graphics2D g2d = gray.createGraphics(); g2d.setColor(null); g2d.fillRect(0, 0, w, h); Font font = new Font(&amp;quot;宋体&amp;quot;, Font.BOLD, 1); g2d.setFont(font); for (int x = 0; x &amp;lt; w; x ++) { for (int y = 0; y &amp;lt; h; y ++) { g2d.setColor(ColorUtil.int2color(img.getRGB(x, y))); g2d.drawString(&amp;quot;灰&amp;quot;, x, y); } } g2d.dispose(); System.out.printf(&amp;quot;渲染完成&amp;quot;); }</description>
      <pubDate>Tue, 16 Nov 2021 11:19:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍了一篇java实现图片灰度化处理的小demo，接下来再介绍一个有意思的东西，将一个图片转换成字符图片</p>
<p>借助前面图片灰度化处理的知识点，若我们希望将一张图片转成字符图片，同样可以遍历每个像素点，然后将像素点由具体的字符来替换，从而实现字符化处理</p>
<p>基于上面这个思路，具体的实现就很清晰了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，在会字符的时候，先取出源像素点的色彩，然后重新设置给g2d，这个int转color也比较简单，实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就实现了一个基础版的转字符图了，实际跑一下看看效果</p>
<figure><img src="/imgs/211116/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这下尴尬了，输出的并不是我们预期的字符图，那么问题出在哪呢？</p>
<p>仔细看上面的文字大小为1，文字太小，导致即使是有字符组件的图，最终肉眼看起来和原图也没啥区别</p>
<p>那么我们就试一下将这个文字搞大点，将<code>n*n</code>个像素点作为一个文字渲染区域，这样我们需要调整一下遍历的步长；其次就是这个区域的颜色怎么定
直接取均值</p>
<ul>
<li>直接取均值</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外的就是改一下遍历的步长</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次执行之后结果如下，实现了我们的预期效果</p>
<figure><img src="/imgs/211116/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>最后再介绍一个更好用的姿势，直接使用开源项目 <a href="https://github.com/liuyueyi/quick-media" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/quick-media/image-plugins</a> 来实现图片字符画</p>
<p>使用这个项目的 image-plugins 之后，生成一个字符图就很简单了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/211116/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>8.像素图片-GIF图片转字符动图</title>
      <link>https://liuyueyi.github.io/tutorial/git/quick-media/image/08.GIF%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E5%8A%A8%E5%9B%BE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/git/quick-media/image/08.GIF%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E5%8A%A8%E5%9B%BE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">8.像素图片-GIF图片转字符动图</source>
      <description>前面介绍了两篇基于jdk实现图片灰度处理、转字符图片的操作，接下来我们在将之前的能力扩展一下，支持将一个gif图灰度化或者转gif字符图 本文的实现主要在前面两篇文章的基础上来实现，推荐没有看过的小伙伴也可以瞅一眼 像素图片-图片灰度化 像素图片-图片转字符图</description>
      <pubDate>Sat, 20 Nov 2021 11:19:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面介绍了两篇基于jdk实现图片灰度处理、转字符图片的操作，接下来我们在将之前的能力扩展一下，支持将一个gif图灰度化或者转gif字符图</p>
<p>本文的实现主要在前面两篇文章的基础上来实现，推荐没有看过的小伙伴也可以瞅一眼</p>
<ul>
<li><a href="/tutorial/git/quick-media/image/06.%E5%9B%BE%E7%89%87%E7%81%B0%E5%BA%A6%E5%8C%96.html" target="blank">像素图片-图片灰度化</a></li>
<li><a href="/tutorial/git/quick-media/image/07.%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E5%9B%BE.html" target="blank">像素图片-图片转字符图</a></li>
</ul>
<p>单张图的灰度化与转字符实现之后，gif图的实现就简单多了；gif图无非是多张图组合而成，将每一张图转换之后，再重新组装成gif图就完事了</p>
<p>这里我们使用的gif工具类来自于 <a href="https://github.com/liuyueyi/quick-media/tree/master/plugins/base-plugin/src/main/java/com/github/hui/quick/plugin/base/gif" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/quick-media/tree/master/plugins/base-plugin/src/main/java/com/github/hui/quick/plugin/base/gif</a></p>
<p>核心关键类为GifEncode与GifDecode；借助它来实现gif图的加载与保存</p>
<p>首先我们将上篇博文中的转字符图的方法抽取一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着就是Gif的操作了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上图转换成功之后，输出如下</p>
<figure><img src="/imgs/211120/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如果希望输出图片更像原图，可以修改上面的fontSize，比如上面用的是12，可以调整成8，6等值，根据实际情况进行选择</p>
<p>有的小伙伴可能会说了，动漫的gif图转换之后相似度还可以，那么真实人物图转换之后呢？</p>
<p>接下来我们借助开源项目 <a href="https://github.com/liuyueyi/quick-media" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/quick-media</a> 来迅速的实现一个gif图转换</p>
<blockquote>
<p>下图来自网络，有兴趣的自己打开查看，就不贴上了😏）
<a href="http://n.sinaimg.cn/sinacn/w390h219/20171231/0ac1-fyqefvw5238474.gif" target="_blank" rel="noopener noreferrer">http://n.sinaimg.cn/sinacn/w390h219/20171231/0ac1-fyqefvw5238474.gif</a></p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/211120/01.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>最后提个小问题，gif图都能生成字符图了，那么视频也可以生成字符视频么？</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/211120/00.gif" type="image/gif"/>
    </item>
    <item>
      <title>9.像素图片-位图转矢量图</title>
      <link>https://liuyueyi.github.io/tutorial/git/quick-media/image/09.%E4%BD%8D%E5%9B%BE%E8%BD%AC%E7%9F%A2%E9%87%8F%E5%9B%BE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/git/quick-media/image/09.%E4%BD%8D%E5%9B%BE%E8%BD%AC%E7%9F%A2%E9%87%8F%E5%9B%BE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">9.像素图片-位图转矢量图</source>
      <description>通过前面几篇图片转字符、灰度图的文章介绍之后，接下来我们再来看一个有意思的东西，基于前文的基础，实现位图转矢量图的功能 关于位图与矢量图的简单理解如下： 位图：如Jpg/png，放大之后会失真，看到像素块 矢量图：如svg，放大图片也不会失真 1. 实现策略 要实现位图转矢量图，可不是一个简单的活；当然我们这里也不追求完美实现，在前文的基础上，可以想到一个实现策略 首先根据位图输出字符画 然后通过字符画，来生成矢量图</description>
      <pubDate>Fri, 26 Nov 2021 21:44:26 GMT</pubDate>
      <content:encoded><![CDATA[<p>通过前面几篇图片转字符、灰度图的文章介绍之后，接下来我们再来看一个有意思的东西，基于前文的基础，实现位图转矢量图的功能</p>
<p>关于位图与矢量图的简单理解如下：</p>
<ul>
<li>位图：如Jpg/png，放大之后会失真，看到像素块</li>
<li>矢量图：如svg，放大图片也不会失真</li>
</ul>
<h3> 1. 实现策略</h3>
<p>要实现位图转矢量图，可不是一个简单的活；当然我们这里也不追求完美实现，在前文的基础上，可以想到一个实现策略</p>
<ul>
<li>首先根据位图输出字符画</li>
<li>然后通过字符画，来生成矢量图</li>
</ul>
<p>基于上面这个策略，第一步生成字符前一篇博文已经介绍过了；接下来重点就是如何根据输出的字符数组，来生成svg呢？</p>
<h3> 2. 实现方法</h3>
<p>第一步位图输出字符画的代码就不贴了，有兴趣的小伙伴可以参考前文</p>
<ul>
<li><a href="/tutorial/git/quick-media/image/07.%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E5%9B%BE.html" target="blank">像素图片-图片转字符图</a></li>
</ul>
<p>接下来我们重点看一下如何根据生成的<code>List&lt;String&gt;</code>来生成svg图</p>
<p>首先我们定义一个svg模板，用于来表示基于字符输出的矢量图，如下</p>
<div class="language-svg line-numbers-mode" data-ext="svg"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于上面的模板中，有几个关键值需要替换</p>
<ul>
<li>svg 标签中
<ul>
<li><code>{width}</code>: 生成矢量图的宽度</li>
<li><code>{height}</code>: 生成矢量图的高度</li>
<li><code>{BG_COLOR}</code>: 背景颜色</li>
</ul>
</li>
<li>style 样式设置
<ul>
<li><code>{FONT_COLOR}</code>: 字符渲染颜色</li>
</ul>
</li>
</ul>
<p>其次<code>tspan</code>标签内容就是我们需要输出的字符，一行字符对应一个<code>tspan</code>标签</p>
<p>因此我们的实现逻辑就是上面这个模板的关键字替换输出了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现逻辑中的几个变量就是上面模板的关键值，就不重复输出了；详情看文末的源码查看</p>
<ul>
<li>SVG_START</li>
<li>SVG_END</li>
</ul>
<h3> 3. 实测演示</h3>
<p>上面已经贴出了核心的实现代码，接下来我们根据成品来看一下输出效果如何；下面是直接使用封装好的方法来调用测试</p>
<p>项目源码：<a href="https://github.com/liuyueyi/quick-media/tree/master/plugins/image-plugin" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/quick-media/tree/master/plugins/image-plugin</a></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出的svg文件如下</p>
<ul>
<li><a href="/imgs/211126/pkq.svg" target="_blank" rel="noopener noreferrer">皮卡丘.svg</a></li>
<li><a href="/imgs/211126/queen.svg" target="_blank" rel="noopener noreferrer">冰雪女王.svg</a></li>
</ul>
<p>实例图:</p>
<figure><img src="/imgs/211126/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/211126/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>10.图片像素化使用示例</title>
      <link>https://liuyueyi.github.io/tutorial/git/quick-media/image/10.%E5%9B%BE%E7%89%87%E5%83%8F%E7%B4%A0%E5%8C%96%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/git/quick-media/image/10.%E5%9B%BE%E7%89%87%E5%83%8F%E7%B4%A0%E5%8C%96%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">10.图片像素化使用示例</source>
      <description>本文为 image-plugin 中土拍你像素化相关操作的使用参考示例 1. 项目依赖 直接从中央仓库，导入最新依赖 &amp;lt;!-- https://mvnrepository.com/artifact/com.github.liuyueyi.media/image-plugin --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.github.liuyueyi.media&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;image-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;!-- 请使用最新版本号替换下面的版本 --&amp;gt; &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;</description>
      <pubDate>Tue, 11 Feb 2025 11:44:26 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文为 <a href="https://github.com/liuyueyi/quick-media/tree/master/plugins/image-plugin" target="_blank" rel="noopener noreferrer">image-plugin</a> 中土拍你像素化相关操作的使用参考示例</p>
</blockquote>
<h2> 1. 项目依赖</h2>
<p>直接从中央仓库，导入最新依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 参数说明</h2>
<p>相关参数配置由<code>com.github.hui.quick.plugin.image.wrapper.pixel.ImgPixelOptions</code>实体类进行装载，对应的参数说明如下</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>说明</th>
<th>是否必要</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>source</code></td>
<td><code>BufferedImage</code></td>
<td>原图</td>
<td>与下面的gifSource必须有一个存在</td>
</tr>
<tr>
<td><code>gifSource</code></td>
<td><code>GifDecoder</code></td>
<td>gif 图</td>
<td>于上的source必须有一个存在</td>
</tr>
<tr>
<td><code>pixelType</code></td>
<td><code>IPixelStyle</code></td>
<td>转换类型</td>
<td>否，默认为<code>CHAR_COLOR</code></td>
</tr>
<tr>
<td><code>blockSize</code></td>
<td><code>int</code></td>
<td>对于转字符图时，它控制字符大小；对于灰度/像素处理时，这个表示像素化的处理操作</td>
<td>否 1</td>
</tr>
<tr>
<td><code>fontSize</code></td>
<td><code>int</code></td>
<td>字体大小</td>
<td>否</td>
</tr>
<tr>
<td><code>chars</code></td>
<td><code>String</code></td>
<td>字符图时，用于渲染的字符集</td>
<td><code>$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/|()1{}[]?-_+~&lt;&gt;i!lI;:,\"^'. </code></td>
</tr>
<tr>
<td><code>font</code></td>
<td><code>Font</code></td>
<td>字符字体</td>
<td>否，默认黑色字体</td>
</tr>
<tr>
<td><code>rate</code></td>
<td><code>Double</code></td>
<td>缩放比例，1 表示输出的图不缩放； &gt; 1，表示生成的图，按倍数扩大</td>
<td>否，默认1</td>
</tr>
<tr>
<td><code>picType</code></td>
<td><code>String</code></td>
<td>输出图片类型</td>
<td>否，默认<code>png</code></td>
</tr>
<tr>
<td><code>bgChar</code></td>
<td><code>Character</code></td>
<td>背景字符，默认值为空格</td>
<td>否，默认为空格</td>
</tr>
<tr>
<td><code>bgColor</code></td>
<td><code>Color</code></td>
<td>字符图/svg 图的背景色</td>
<td>否，默认白色</td>
</tr>
<tr>
<td><code>fontColor</code></td>
<td><code>Color</code></td>
<td>字符图/svg 图的字体色</td>
<td>否，默认黑色</td>
</tr>
<tr>
<td><code>bgPredicate</code></td>
<td><code>Predicate&lt;Integer&gt;</code></td>
<td>背景色判断方式，传参为 intColor，如果返回 true，表示认定为背景色；否则不是</td>
<td>否，默认颜色rbga == 0时为背景</td>
</tr>
</tbody>
</table>
<p>上面的配置参数中，重点关注一下 <code>PixelType</code>，它表明了具体的转换策略</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>示例图</th>
</tr>
</thead>
<tbody>
<tr>
<td>GRAY_ALG</td>
<td>基于灰度公式将图片灰度化</td>
<td><img src="/imgs/column/quick-media/image/gray_alg.png" alt="" loading="lazy"></td>
</tr>
<tr>
<td>GRAY_AVG</td>
<td>基于灰度均值将图片灰度化</td>
<td><img src="/imgs/column/quick-media/image/gray_avg.png" alt="" loading="lazy"></td>
</tr>
<tr>
<td>PIXEL_COLOR_AVG</td>
<td>图片像素化时，采用颜色均值</td>
<td><img src="/imgs/column/quick-media/image/pixelColorAvg.png" alt="" loading="lazy"></td>
</tr>
<tr>
<td>CHAR_COLOR</td>
<td>图片转字符图</td>
<td><img src="/imgs/column/quick-media/image/charColor.png" alt="" loading="lazy"></td>
</tr>
<tr>
<td>CHAR_GRAY</td>
<td>图片转灰度字符图</td>
<td><img src="/imgs/column/quick-media/image/charGray.png" alt="" loading="lazy"></td>
</tr>
<tr>
<td>CHAR_BLACK</td>
<td>图片转纯黑白字符，常用于svg输出</td>
<td><img src="/imgs/column/quick-media/image/charGray.svg" alt="" loading="lazy"></td>
</tr>
<tr>
<td>CHAR_SEQ_SCALE_UP</td>
<td>图片转文字图，根据字符顺序绘画，且支持按比例放大</td>
<td><img src="/imgs/column/quick-media/image/charSeq.png" alt="" loading="lazy"></td>
</tr>
<tr>
<td>BLACK_CHAR_BORDER</td>
<td>只针对有颜色的边框进行渲染，常用于文本输出</td>
<td><img src="/imgs/column/quick-media/image/charBorder.jpg" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h2> 3. 使用示例</h2>
<blockquote>
<p>所有的使用姿势，可以在源码对应的test工程中获取 <a href="https://github.com/liuyueyi/quick-media/blob/master/plugins/image-plugin/src/test/java/com/github/hui/quick/plugin/test/pixel/BasicPixelTest.java" target="_blank" rel="noopener noreferrer">BasicPixelTest.java</a></p>
</blockquote>
<p>根据实际需要，选择不同的处理枚举，如</p>
<h3> case1: 希望对图片进行灰度处理时：</h3>
<ul>
<li><code>PixelStyleEnum.GRAY_ALG</code></li>
<li><code>PixelStyleEnum.GRAY_AVG</code></li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下:</p>
<table>
<thead>
<tr>
<th>样式</th>
<th>原图</th>
<th>转换图</th>
</tr>
</thead>
<tbody>
<tr>
<td>GRAY_ALG</td>
<td><img src="/imgs/column/quick-media/image/nezha.jpeg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/gray_alg.png" alt="" loading="lazy"></td>
</tr>
<tr>
<td>GRAY_AVG</td>
<td><img src="/imgs/column/quick-media/image/nezha.jpeg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/gray_avg.png" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h3> case2: 希望将图片转换像素块图时</h3>
<p>主要需要设置 <code>blockSize</code> 参数，将其设置&gt;1，此时可使用的转换类型方式为</p>
<ul>
<li><code>PixelStyleEnum.GRAY_ALG</code></li>
<li><code>PixelStyleEnum.GRAY_AVG</code></li>
<li><code>PixelStyleEnum.PIXEL_COLOR_AVG</code></li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下:</p>
<table>
<thead>
<tr>
<th>样式</th>
<th>原图</th>
<th>转换图</th>
</tr>
</thead>
<tbody>
<tr>
<td>PIXEL_COLOR_AVG</td>
<td><img src="/imgs/column/quick-media/image/nezha.jpeg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/pixelColorAvg.png" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h3> case3: 将图转换为字符图时</h3>
<p>可以输出图片也可以输出svg，常用的转换类型方式为</p>
<ul>
<li><code>PixelStyleEnum.CHAR_COLOR</code></li>
<li><code>PixelStyleEnum.CHAR_GRAY</code></li>
<li><code>PixelStyleEnum.CHAR_BLACK</code>：常用于输出svg字符图、二维字符数组</li>
<li><code>PixelStyleEnum.CHAR_SEQ_SCALE_UP</code>: 它于上面三个的区别在于根据传入的文字进行顺序渲染，且对输出图片会按照文字的大小进行等比例放大、以确保文字可见</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>样式</th>
<th>原图</th>
<th>转换图</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR_COLOR</td>
<td><img src="/imgs/column/quick-media/image/nezha.jpeg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/charColor.png" alt="" loading="lazy"></td>
</tr>
<tr>
<td>CHAR_GRAY</td>
<td><img src="/imgs/column/quick-media/image/nezha.jpeg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/charGray.png" alt="" loading="lazy"></td>
</tr>
<tr>
<td>CHAR_BLACK</td>
<td><img src="/imgs/column/quick-media/image/nezha.jpeg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/charGray.svg" alt="" loading="lazy"></td>
</tr>
<tr>
<td>CHAR_SEQ_SCALE_UP</td>
<td><img src="/imgs/column/quick-media/image/nezha.png" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/charSeq.png" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h3> case4: 输出字符画</h3>
<p>将图片转换为ascii或者特定的字符画，可用</p>
<ul>
<li><code>PixelStyleEnum.CHAR_BLACK</code></li>
<li><code>PixelStyleEnum.BLACK_CHAR_BORDER</code>: 与上面的区别在于它希望输入的是线图</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>样式</th>
<th>原图</th>
<th>转换图</th>
</tr>
</thead>
<tbody>
<tr>
<td>BLACK_CHAR_BORDER</td>
<td><img src="/imgs/column/quick-media/image/slake.jpeg" width="600px"></td>
<td><img src="/imgs/column/quick-media/image/charBorder.jpg" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h3> case5: GIF图转换</h3>
<p>上面除了给出对静态图的处理之外，我们还额外支持gif图的转换，需要注意的是gif图时，只支持输出为gif，不支持输出svg格式</p>
<p>基本使用姿势与前面一致，区别在于传入的图片为gif格式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>原图</th>
<th>v1</th>
<th>v2</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/imgs/column/quick-media/image/xhr.gif" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/outV1.gif" alt="" loading="lazy"></td>
<td><img src="/imgs/column/quick-media/image/outV2.gif" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/quick-media/image/gray_alg.png" type="image/png"/>
    </item>
    <item>
      <title>9.耗时输出重定向</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/09.%E8%80%97%E6%97%B6%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/09.%E8%80%97%E6%97%B6%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">9.耗时输出重定向</source>
      <description>前面实现的耗时分布输出直接以日志的方式进行打印，在实际的业务场景中，可能希望以其他的方式（比如Prometheus）来收集耗时，基于这种场景，我们的组件又可以怎么进行演进呢？ 1. 控制日志是否输出 首先我们来看一下，若我不希望输出日志，最简单的实现方式就是直接在TraceRecoder中添加变量，用于控制是否进行输出日志 首先改造一下DefaultTraceRecoder，新增logEnable变量 /** * 控制是否打印日志的条件 */ private boolean logEnable; public DefaultTraceRecoder() { this(AsyncUtil.executorService, &amp;quot;TraceDog&amp;quot;, true); } public DefaultTraceRecoder(ExecutorService executorService, String task, boolean logEnable) { this.traceName = task; list = new CopyOnWriteArrayList&amp;lt;&amp;gt;(); // 支持排序的耗时记录 cost = new ConcurrentSkipListMap&amp;lt;&amp;gt;(); this.executorService = TtlExecutors.getTtlExecutorService(executorService); this.markExecuteOver = false; this.logEnable = logEnable; start(task); MdcUtil.setGlobalTraceId(MdcUtil.fetchGlobalMsgIdForTraceRecoder()); }</description>
      <category>技术组件</category>
      <pubDate>Sun, 01 Sep 2024 18:19:48 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面实现的耗时分布输出直接以日志的方式进行打印，在实际的业务场景中，可能希望以其他的方式（比如Prometheus）来收集耗时，基于这种场景，我们的组件又可以怎么进行演进呢？</p>
<h3> 1. 控制日志是否输出</h3>
<p>首先我们来看一下，若我不希望输出日志，最简单的实现方式就是直接在<code>TraceRecoder</code>中添加变量，用于控制是否进行输出日志</p>
<p>首先改造一下<code>DefaultTraceRecoder</code>，新增<code>logEnable</code>变量</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着是输出日志的时候，加一个判断</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除此之外，我们还需要改造一下 <code>trace-watch-dog-spring</code> 工程中的 <code>@TraceDog</code> 注解，需要新增一个是否输入日志的逻辑</p>
<p>考虑到适用的场景，我们新增两个属性来判定是否输出日志</p>
<ul>
<li><code>boolean logEnable() default true</code>: 简单版，控制是否输出日志</li>
<li><code>String logSpEL() default "";</code> SpEL版，根据动态参数来判断是否输出日志</li>
</ul>
<p>上面两个属性搭配使用；当不存在 <code>logSpEL</code> 时，我们直接以 <code>logEnable</code> 来判断是否要打印日志；若存在 <code>logSpEL</code>，那么我们就要要求上面两个同时为<code>true</code>才能输出日志;</p>
<p>核心的实现就是<code>logSpEL</code>的执行</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的实际实现来看，控制是否打印日志比较简单，那么这个真的有用么？</p>
<p>下面给出几个应用场景：</p>
<ul>
<li>某个执行链路，我们希望测试环境打印日志，生产环境不打印日志（根据运行环境判断是否需要打印日志）</li>
<li>某个执行链路，我们通过一个动态的配置来控制是否需要打印日志，当需要进行排查耗时情况分析时，打开配置输出日志；其他情况则进行关闭</li>
</ul>
<h3> 2. 日志输出重定向</h3>
<p>到目前为止，我们所有的耗时输出都是基于控制台/日志文件，当我们的项目集成了类似Prometheus监控系统时，我们可能更希望将耗时上报到Prometheus，因此就有了输出重定向的诉求</p>
<p>为了支持输出重定向，我们新增一个扩展，在<code>prettyPrint</code>方法中，根据用户自定义的实现来处理</p>
<p>先定义一个函数方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接入两个参数，其中 <code>cost</code> 记录总耗时 + 各子任务的耗时，traceName 表示入口任务名，主要用于获取总耗时</p>
<p>然后调整一下 <code>DefaultTraceRecoder</code></p>
<ol>
<li>新增<code>private List&lt;CostOutput&gt; output;</code> 保存输出重定向的规则</li>
<li>添加默认的<code>log.info</code>输出规则</li>
<li>支持传入自定义的输出重定向规则</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调整下 <code>prettyPrint</code> 方法的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后就是默认的日志输出</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 <code>TraceWatch</code> 中维持全局的重定向规则</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在输出重定向的实现中，主要是借助函数方法来提供能力增强，由于<code>TraceRecoder</code>都是以实例的方式来运行的，如果一个自定义的重定向，需要在每个使用地方都手动注册，显然对使用者极不友好，因此我们提供了全局的注册逻辑，这样就可以实现一次注册，全局生效；同时单个实例也可以有自己的个性化逻辑</p>
<h3> 3. 测试</h3>
<p>接下来我们写个测试用例，使用自定义的输出代替默认的日志输出规则</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点关注上面的<code>testWithAsyncTrace</code>的逻辑，首先是注册全局的自定义耗时输出规则； 然后就是在创建<code>TraceRecoder</code>时，通过传入false，表示不使用原来的日志输出</p>
<p>执行成功之后，我们将得到如下输出:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>8.借助AOP提供非侵入的使用姿势</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/08.%E5%80%9F%E5%8A%A9AOP%E6%8F%90%E4%BE%9B%E9%9D%9E%E4%BE%B5%E5%85%A5%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/08.%E5%80%9F%E5%8A%A9AOP%E6%8F%90%E4%BE%9B%E9%9D%9E%E4%BE%B5%E5%85%A5%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">8.借助AOP提供非侵入的使用姿势</source>
      <description>再前面完成封装的TraceWatch，进一步简化了使用体验，但是依然存在一个明显的缺陷，对业务代码的侵入性较强，需要再业务代码中，进行主动的埋点 对应常年和Spring打交道的java开发者来说，一个很容易想到的优化方案就是借助AOP来简化业务代码的侵入，接下来我们就看一下，如何借助Spring的AOP能力，对我们之前提供的TraceWatch做一个能力增强 1. 方案设计 对于某个链路的耗时统计，首先确定有一个方法作为耗时记录的入口，表示开始记录耗时，然后就是再执行的过程中，发现有需要统计耗时的方法，则通过Around环绕切面来计算耗时，最后再入口方法执行完毕之后，输出耗时情况即可</description>
      <category>技术组件</category>
      <pubDate>Wed, 28 Aug 2024 18:19:48 GMT</pubDate>
      <content:encoded><![CDATA[<p>再前面完成封装的<code>TraceWatch</code>，进一步简化了使用体验，但是依然存在一个明显的缺陷，对业务代码的侵入性较强，需要再业务代码中，进行主动的埋点</p>
<p>对应常年和Spring打交道的java开发者来说，一个很容易想到的优化方案就是借助AOP来简化业务代码的侵入，接下来我们就看一下，如何借助Spring的AOP能力，对我们之前提供的<code>TraceWatch</code>做一个能力增强</p>
<h2> 1. 方案设计</h2>
<p>对于某个链路的耗时统计，首先确定有一个方法作为耗时记录的入口，表示开始记录耗时，然后就是再执行的过程中，发现有需要统计耗时的方法，则通过<code>Around</code>环绕切面来计算耗时，最后再入口方法执行完毕之后，输出耗时情况即可</p>
<h3> 1.1 整体实现流程</h3>
<figure><img src="/imgs/column/trace/12-aop.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面是一个简单的AOP集成说明：</p>
<ol>
<li>首先自定义一个注解，用来表示哪些方法需要进行耗时记录</li>
<li>执行链路中的，首个被自定义注解标注的方法，作为耗时记录的入口
<ul>
<li>即调用 <code>TraceWatch.start</code> 来创建 <code>TraceRecoder</code></li>
</ul>
</li>
<li>在入口方法内部执行的调用链路中，执行到需要记录耗时的方法时，通过<code>traceRecoder.sync/async</code>来加入耗时统计</li>
<li>在入口方法执行完毕时，输出耗时分布</li>
</ol>
<h3> 1.2 方案细节确认</h3>
<p><strong>如何确定入口</strong></p>
<p>上面的流程中，说的是第一个被切面拦截的方法，作为入口，那么这种方式是否合适呢？</p>
<p>如有一个通用的请求校验方法，在支付的链路中，需要记录耗时分布；但是这个方法又会被其他的如提交订单、查看订单等场景使用，又不希望记录耗时，显然这种场景下，使用上面的姿势就不太合适</p>
<p>因此我们自定义注解中，新增一个<code>传播属性 Progation</code>，设置下面三种类型</p>
<ul>
<li>REQUIRED: 支持当前trace记录，如果当前上下文中不存在DefaultTraceRecoder存在，则新创建一个TraceRecoder作为入口开始记录</li>
<li>SUPPORTS: 支持当前trace记录，如果当前上下文中不存在DefaultTraceRecoder存在，则以同步的SyncTraceRecoder方式执行，不参与耗时统计</li>
<li>NEVER: 不支持记录，不管当前存不存在，都以同步的方式执行，且不参与记录</li>
</ul>
<p><strong>耗时记录任务名规则</strong></p>
<p>当不指定具体的任务名时，使用<code>类名#方法名</code>来作为这个耗时的任务名</p>
<p><strong>同步异步选择</strong></p>
<p>默认方法都是同步调用，那么需要异步并行调用时，我们可以通过一个参数来控制</p>
<p><strong>异步方法返回值如何获取</strong></p>
<p>如果某一个方法是异步去执行，那这个方法的返回值怎么获取呢？</p>
<p>如果是直接返回结果，那对于调用者而言，这个异步执行就是个伪并行了（因为需要等待它执行完毕获取结果），因此对于异步调用的方法，返回结果应该由<code>CompletableFuture</code>来包裹</p>
<h2> 2. AOP实现</h2>
<h3> 2.0 前置依赖</h3>
<p>我们接下来借助Spring的AOP来实现，首先需要集成相关依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了避免对使用者项目带来影响，因此我们的实现对引入的依赖是scope是<code>provided</code></p>
<h3> 2.1 注解定义</h3>
<p>首先我们来定义一下关键注解</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.2 传播属性定义</h3>
<p>内置传播属性的枚举<code>Propagation</code>，入口处使用<code>REQUIRED</code>来标识，过程中则使用<code>SUPPORTS</code>来标识</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.3 切面实现</h3>
<p>切面的实现逻辑中，直接根据注解来切连接点，然后基于传播属性，判断是否为入口；对于过程执行中，则需要重点确认下同步还是异步调用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的实现中，我们通过 <code>genTraceName</code> 获取任务名，其规则就是优先从注解中取，拿不到时用<code>类名#方法名</code>作为任务名</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们在来包装一下，目标方法的同步/异步执行，对于异步调用的方法，因为方法本身返回的是<code>CompletableFuture</code>类型，<code>TraceRecoder.async()</code> 返回的也是<code>CompletableFuture</code>，因此我们需要执行下 <code>join()</code> 来获取真实的返回</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同步异步执行的实现逻辑补全，其中复杂一些的在于异步的实现，需要区分有没有返回结果</p>
<ul>
<li>如果有返回结果，且是 <code>CompletableFuture</code> 封装，则需要调用上面的<code>executeWithFuture</code>走异步执行</li>
<li>如果有返回结果，但是直接返回了对象，这种场景对于调用者而言等同于同步调用直接拿到返回结果，因此我们依然走同步执行</li>
<li>如果没有返回结果，则使用<code>async</code>异步执行</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.4 自动注册</h3>
<p>上面就完成了AOP的核心功能实现，接下来就是针对SpringBoot/Spring场景下，做些自动装配的工作</p>
<p>bean声明配置类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SpringBoot的自动装配，在<code>resource/META-INF</code>目录下，新增<code>spring.factories</code>文件</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于不是SpringBoot的场景，则可以通过<code>@EnableTraceWatchDog</code>来开启</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 使用示例与小结</h2>
<h3> 3.1 使用示例</h3>
<p>接下来我们演示一下基于AOP的使用姿势</p>
<p>下两个demoBean</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>已<code>Index#buildIndexVo()</code>作为统计入口，<code>DemoService</code>中提供了五个方法，但是只有四个上有<code>@TraceDog</code>注解，因此方法耗时统计也只会有这四个; 由于<code>ignoreCost</code>内部添加了一个代码块的执行耗时，因此最终的耗时分布输出会额外加上这个代码块的耗时，共5个</p>
<p>接下来实际访问测试一下，添加测试依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试入口如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行之后的输出如</p>
<figure><img src="/imgs/column/trace/13-aopUse.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3.2 小结</h3>
<p>本文我们主要借助AOP对耗时分布统计的工具类做了使用侧的能力增强，从上面的使用示例也可以看出，不需要再业务代码中进行埋点，再需要的方法上，添加上注解就行了，当然若我们对某一段代码块的耗时需要进行统计时，也可以再具体的方法内，通过<code>raceWatch.getRecoderOrElseSync().sync(() -&gt; {}, "任务名");</code> 方式来实现</p>
<p>对于AOP的使用方式，我们需要重点注意：</p>
<ol>
<li>对于希望使用异步的方法，首先注解的<code>async</code>设置为true，其次如果存在返回结果，则必须是<code>CompletableFuture</code>类型</li>
<li>注意AOP切面不生效的场景，同样会导致无法记录耗时（如服务内部调用，注解装饰private方法等）</li>
</ol>
<blockquote>
<p>本文中的测试用例，可以到这里查看 <a href="https://github.com/liuyueyi/hhui-components/blob/master/trace-watch-dog-spring/src/test/java/com/github/liuyueyi/hhui/trace/test/step/BasicDemo.java" target="_blank" rel="noopener noreferrer">trace-watch-dog-spring</a></p>
<p>本文中的实现对应的是 <a href="https://github.com/liuyueyi/hhui-components/blob/master/trace-watch-dog-spring" target="_blank" rel="noopener noreferrer">trace-watch-dog-spring</a> 核心实现</p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/trace/12-aop.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>7. 便捷的使用封装</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/07.%E4%BE%BF%E6%8D%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B0%81%E8%A3%85.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/07.%E4%BE%BF%E6%8D%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B0%81%E8%A3%85.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7. 便捷的使用封装</source>
      <description>接上文，我们现在实现的耗时分布记录工具路TraceRecoder已基本成型，接下来我们将重点放在使用层面的优化上，看一下如何给调用者提供简洁、舒适的使用体验 1. 使用侧的问题分析 现来看一下前面测试用例中的使用case @Test public void testCost2() { try (TraceRecorder recorder = new TraceRecorder()) { randSleep(&amp;quot;前置&amp;quot;, 20); recorder.sync(() -&amp;gt; randSleep(&amp;quot;task1&amp;quot;, 200), &amp;quot;task1&amp;quot;); recorder.async(() -&amp;gt; randSleep(&amp;quot;task2&amp;quot;, 100), &amp;quot;task2&amp;quot;); } }</description>
      <category>技术组件</category>
      <pubDate>Tue, 27 Aug 2024 18:19:48 GMT</pubDate>
      <content:encoded><![CDATA[<p>接上文，我们现在实现的耗时分布记录工具路<code>TraceRecoder</code>已基本成型，接下来我们将重点放在使用层面的优化上，看一下如何给调用者提供简洁、舒适的使用体验</p>
<h2> 1. 使用侧的问题分析</h2>
<p>现来看一下前面测试用例中的使用case</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么上面这种使用姿势，有什么问题呢？</p>
<p>对于单一方法的代码块而言，并没有什么问题，假设再<code>randSleep</code>方法中，我也希望统计某些代码块的执行耗时，那应该怎么做呢？</p>
<h3> 1.1 嵌套的耗时记录方式</h3>
<p>再需要的地方再创建一个 <code>TraceRecoder</code>，实现链路内的代码块耗时记录</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/trace/09-trace-use1.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的输出也可以看出，外层<code>testCost3</code>的 <code>TraceRecoder</code> 与内部方法<code>subRun</code>的 <code>TraceRecoder</code> 各打印了自己的输出</p>
<p>而我更希望的是将所有的耗时都集成在一个输出中</p>
<h3> 1.2 传参方式</h3>
<p>既然我们希望所有的耗时都放在一个<code>TraceRecoder</code>中，那么可以考虑将这个对象透传给需要的地方，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/trace/10-trace-use2.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>使用同一个<code>TraceRecoder</code>作为参数传递给需要记录耗时的方法之后，我们可以看到所有的耗时都集成再一起了</p>
<p>虽然这种方式可以满足诉求，但是对业务代码的改动就有点大了，需要修改调用方法的传参，那么有其他的解决方法么？</p>
<h3> 1.3 上下文维护TraceRecoder</h3>
<p>借助上下文来保存<code>TraceRecoder</code>，然后再需要的地方直接从上下文中获取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是一个基于上下文的简单使用示例，再整个执行链路中，需要记录耗时的地方，直接从上下文中获取<code>TraceRecoder</code>即可</p>
<p>但是这里依然存在一个问题，如果上面的这个 <code>subRun</code> 方法，被另外一个入口调用，但是这个入口的调用链路中，没有开启耗时记录，即上下文中没有<code>TraceRecoder</code>，那岂不是就会导致<code>NPE</code>?</p>
<p>因此我们需要再上下文获取<code>TraceRecoder</code>时，做一个保护</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 使用优化</h2>
<p>基于上面的几个分析步骤，我们对使用侧的优化就有了一个基本的方向：</p>
<ol>
<li>借助ThreadLocal来持有<code>TraceRecoder</code></li>
<li>再开始记录的入口，初始化<code>TraceRecoder</code>，并保存到上下文</li>
<li>再链路的过程中，需要记录耗时的，可以直接从上下文中获取</li>
</ol>
<h3> 2.1 抽象TraceRecoder</h3>
<p>基于上面提到的几点实现思路，面临一个现实的问题就是从上下文获取<code>TraceRecoder</code>记录耗时时，若返回null，需要再使用侧做一个兼容，为了不让业务代码变得恶心，我们就需要考虑再使用侧做一个保护</p>
<p>我们抽象一个<code>ITraceRecoder</code>的接口类，将前面的工具类作为一个具体实现<code>DefaultTraceRecoder</code>，然后再提供一个同步的实现类<code>SyncTraceRecoder</code>，用于从上下文中获取不到<code>DefaultTraceRecoder</code>时，就返回<code>SyncTraceRecoder</code>，这样对于使用侧而言就不需要做<code>if/else</code>的<code>null</code>保护了</p>
<p>接口定义:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>兜底的同步实现<code>SyncTraceRecoder</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前面封装的耗时统计实现<code>DefaultTraceRecoder</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.2 使用门面</h3>
<p>接下来我们就需要对上面的实现做一个使用的门面封装<code>TraceWatch</code>，对外提供统一的访问姿势</p>
<p>我们可以考虑在<code>TraceWatch</code>中，持有上下文信息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.3 使用示例</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/trace/11-trace-use3.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p>本文中的过程代码，可以到这里查看 <a href="https://github.com/liuyueyi/hhui-components/blob/master/trace-watch-dog/src/test/java/com/github/liuyueyi/hhui/trace/test/step/Step7.java" target="_blank" rel="noopener noreferrer">trace-watch-dog</a></p>
<p>本文中的实现对应的是 <a href="https://github.com/liuyueyi/hhui-components/blob/master/trace-watch-dog" target="_blank" rel="noopener noreferrer">trace-watch-dog</a> 核心实现</p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/trace/09-trace-use1.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>6. 日志输出与全链路traceId透传</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/06.%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E4%B8%8E%E5%85%A8%E9%93%BE%E8%B7%AFtraceId%E9%80%8F%E4%BC%A0.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/06.%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E4%B8%8E%E5%85%A8%E9%93%BE%E8%B7%AFtraceId%E9%80%8F%E4%BC%A0.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6. 日志输出与全链路traceId透传</source>
      <description>前面封装耗时任务分布工具类的输出，主要是通过System.out.println进行控制台输出，这显然不符合实际的生产使用，接下来我们使用Slf4j进行输出的替换，额外需要注意的就是异步场景下，避免出现全链路的traceId的丢失 1. 日志集成 1.1 slf4j日志输出 在项目中使用日志比较简单，先添加依赖 &amp;lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.16&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;</description>
      <category>技术组件</category>
      <pubDate>Mon, 26 Aug 2024 18:19:48 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面封装耗时任务分布工具类的输出，主要是通过<code>System.out.println</code>进行控制台输出，这显然不符合实际的生产使用，接下来我们使用<code>Slf4j</code>进行输出的替换，额外需要注意的就是异步场景下，避免出现全链路的traceId的丢失</p>
<h2> 1. 日志集成</h2>
<h3> 1.1 slf4j日志输出</h3>
<p>在项目中使用日志比较简单，先添加依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后就是更新下<code>prettyPrint</code>的日志输出</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点关注下上面的实现，<code>LoggerFactory.getILoggerFactory() instanceof NOPLoggerFactory</code> 通过这一行来判断当前使用的项目中，是否已经集成了日志打印，如果是就利用 <code>log.info()</code> 打印日志，若没有集成类似<code>logback/log4j</code>之类的日志框架，那就依然使用<code>System.out.println</code>来输出耗时情况</p>
<h3> 1.2 全链路的日志集成</h3>
<p>对全链路有过了解的小伙伴应该知晓，在整个执行链路中，即便是出现了异步（线程池调度）、跨进程（RPC)、跨服务等场景，仍然需要一个traceId从头到尾一直携带到最后</p>
<p>那么我们的工具类中的异步代码块执行，如何将这个<code>traceId</code>携带进去呢？</p>
<ul>
<li>借助<code>MDC</code>来实现</li>
</ul>
<p>作为一个工具提供方，我们需要知晓如何从MDC中获取全链路的<code>traceId</code>，如果没有自定义的全链路traceId生成携带策略，我们也可以提供一个默认的实现进行支持</p>
<p>因此我们先封装一个<code>MdcUtil</code>工具类，来读写上下文中的traceId</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，这里主要提供了一个全局的配置<code>traceIdAutoGen</code>来控制，当上下文中拿不到<code>traceId</code>时，我们应该是重新生成一个还是压根就不管它</p>
<p>然后我们就需要在之前的实现层<code>TraceRecoder</code>，做一些改造，以实现异步执行时的traceId透传</p>
<ul>
<li>在执行代码块的封装层，在业务代码执行前初始化<code>traceId</code> （需要注意，不要将获取traceId的逻辑放在代码块中了）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3 全链路traceId测试</h3>
<p>接下来就需要我们来验证一下集成情况了，首先再看一下完整修改后的<code>TraceRecoder</code>工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面将本次新增的逻辑标记了出来，对原有的改造较小，接下来，再写个测试用例，基本使用姿势与之前无异，唯一的区别在于我们再异步代码块中，使用日志输出看看<code>traceId</code>是否能打印出来</p>
<p>要使用slf4j，先添加一个具体的日志实现，比如logback</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再资源目录下，添加配置文件 <code>resources/logback.xml</code></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后就是测试用例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>先看下，直接借助已有的<code>traceId</code>场景</p>
<figure><img src="/imgs/column/trace/07-traceId1.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>再看下，上下文中没有<code>traceId</code>，使用默认的的<code>traceId</code>生成策略</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/trace/08-traceId2.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 1.4 小结</h3>
<p>到这里我们就已经实现了<code>trace-watch-dog</code>的日志集成了，并且为全链路的<code>traceId</code>透传也提供了相应的解决方案</p>
<p>从上面的实现来看，我们还有有个更推荐的写法，再任务的执行前后各添加一个钩子，然后再钩子中进行任务执行前后的执行单元注册，将全链路的<code>traceId</code>透传放在钩子中执行，这样也可以提供更强的扩展能力</p>
<p>至于这个如何设计后续再来介绍</p>
<blockquote>
<p>本文中的相关代码，可以到这里查看 <a href="https://github.com/liuyueyi/hhui-components/blob/master/trace-watch-dog/src/test/java/com/github/liuyueyi/hhui/trace/test/step/Step6.java" target="_blank" rel="noopener noreferrer">trace-watch-dog</a></p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/trace/07-traceId1.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>5. 上下文信息传递</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/05.%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/05.%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5. 上下文信息传递</source>
      <description>前面完成的TraceRecoder支持了异步代码块的调度，接下来我们就需要重点解决一下多线程下的数据传递问题，确保异步代码块的执行过程中，不会出现各种难以理解的并发问题 1. 并发问题复现 首先我们先来看一下，TraceRecoder 会在什么场景出现问题 1.1 上下文再线程池场景下的共享异常 既然我们的工具类是支持异步代码块封装，考虑到上下文的共享，我们第一想到就是使用InheritableThreadLocal 来替代 ThreadLocal 来存储上下文信息</description>
      <category>技术组件</category>
      <pubDate>Fri, 23 Aug 2024 09:19:48 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面完成的<code>TraceRecoder</code>支持了异步代码块的调度，接下来我们就需要重点解决一下多线程下的数据传递问题，确保异步代码块的执行过程中，不会出现各种难以理解的并发问题</p>
<h2> 1. 并发问题复现</h2>
<p>首先我们先来看一下，<code>TraceRecoder</code> 会在什么场景出现问题</p>
<h3> 1.1 上下文再线程池场景下的共享异常</h3>
<p>既然我们的工具类是支持异步代码块封装，考虑到上下文的共享，我们第一想到就是使用<code>InheritableThreadLocal</code> 来替代 <code>ThreadLocal</code> 来存储上下文信息</p>
<p>但是有过了解的小伙伴会知道这个东西，在线程池的场景是可能出现共享异常的</p>
<p>我们可以构造一个简单的demo来验证一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实现，主要是模拟<code>TraceRecoder</code>的线程池中的线程复用场景，从而诱导线程池复用、导致引用其他任务的上下文出现的概率</p>
<p>当我们执行上面的测试用例，将会可能得到下面的输出</p>
<figure><img src="/imgs/column/trace/06-并发问题.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的输出，也可以直观的看到 <code>t2</code> 执行链路中 获取到了<code>t1</code>执行链路的上下文；</p>
<p>那么怎么解决这种问题呢?</p>
<h3> 1.2 解决方案</h3>
<p>借助阿里开源的<code>transmittable-thread-local</code>来替换默认的上下文，从而解决并发的上下文共享问题</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 并发问题改造</h2>
<h3> 2.1 异步工具类适配</h3>
<p>首先我们对线程池进行改造，使用<code>TtlExecutors</code>进行包裹，先调整默认的线程池</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着对用户传递线程池进行保护</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.2 要求使用TransmittableThreadLocal上下文</h3>
<p>接下来就是对使用侧进行约束，对于有异步使用的场景，请使用<code>TransmittableThreadLocal</code>替换jdk的<code>ThreadLocal</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再调整之后，可以继续执行前面的测试用例，我们稍微调整一下，用于多次执行判断是否有异常情况</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.3 小结</h3>
<p>本文主要介绍了 <code>TraceRecoder</code> 在异步执行场景执行下可能出现的上下文共享问题，为了解决并发问题，在使用层，我们需要注意使用<code>TransmittableThreadLocal</code> 来存储上下文信息</p>
<blockquote>
<p>本文中的相关代码，可以到这里查看 <a href="https://github.com/liuyueyi/hhui-components/blob/master/trace-watch-dog/src/test/java/com/github/liuyueyi/hhui/trace/test/step/Step5.java" target="_blank" rel="noopener noreferrer">trace-watch-dog</a></p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/trace/06-并发问题.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3. 从0到1封装一个通用的耗时统计工具类</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/03.%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E8%80%97%E6%97%B6%E5%88%86%E5%B8%83%E5%B7%A5%E5%85%B7%E7%B1%BB.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/03.%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E8%80%97%E6%97%B6%E5%88%86%E5%B8%83%E5%B7%A5%E5%85%B7%E7%B1%BB.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3. 从0到1封装一个通用的耗时统计工具类</source>
      <description>接下来本文将再前面的基础耗时工具类的基础之上，从0到1写一个支持多线程场景下的耗时统计工具类 1. 设计思路 1.1 明确思路 首先明确目标： 实现一个并发安全的StopWatch工具类 主要挑战： 并发安全 实现思路： 参照StopWatch的实现，解决并发问题 1.2 设计思路 到这里，假定大家已经看过了StopWatch的实现源码（实际上没看过也没啥影响）</description>
      <category>技术组件</category>
      <pubDate>Thu, 22 Aug 2024 09:19:48 GMT</pubDate>
      <content:encoded><![CDATA[<p>接下来本文将再前面的基础耗时工具类的基础之上，从0到1写一个支持多线程场景下的耗时统计工具类</p>
<h2> 1. 设计思路</h2>
<h3> 1.1 明确思路</h3>
<p>首先明确目标：</p>
<ul>
<li>实现一个并发安全的<code>StopWatch</code>工具类</li>
</ul>
<p>主要挑战：</p>
<ul>
<li>并发安全</li>
</ul>
<p>实现思路：</p>
<ul>
<li>参照<code>StopWatch</code>的实现，解决并发问题</li>
</ul>
<h3> 1.2 设计思路</h3>
<p>到这里，假定大家已经看过了<code>StopWatch</code>的实现源码（实际上没看过也没啥影响）</p>
<ul>
<li>在<code>StopWatch</code>中，通过<code>List&lt;TaskInfo&gt; taskList</code>来记录每个任务的耗时情况</li>
<li>因为它主要应用于单线程场景，所以不存在任务的并行耗时记录的场景，通常是要给任务执行完毕，然后开始记录下一个任务，所以在全局使用<code>startTimeNanos</code>表示当前任务的开始时间，当结束记录时，将任务耗时情况写入<code>taskList</code>列表</li>
</ul>
<p>基本工作原理如下</p>
<figure><img src="/imgs/column/trace/02-stopwatch原理.jpg" alt="StopWatch工作原理" tabindex="0" loading="lazy"><figcaption>StopWatch工作原理</figcaption></figure>
<p>从StopWatch的工作原理上，想实现一个并发安全的貌似也不难，我们将List换成Map，支持同时记录多个任务的耗时情况</p>
<figure><img src="/imgs/column/trace/03-traceDog原理.jpg" alt="trace-watch-dog工作原理" tabindex="0" loading="lazy"><figcaption>trace-watch-dog工作原理</figcaption></figure>
<p>我们的设计上也相对清晰</p>
<ol>
<li>使用一个并发安全的Map容器（如ConcurrentHashMap)来记录任务的耗时情况</li>
<li>开始记录一个任务时，向Map中写入<code>任务名</code> + <code>当前时间戳</code> 的键值对</li>
<li>结束一个任务时，从Map中获取对应任务的时间戳，与当前时间戳取差值，得到任务的执行耗时，并写回到Map中，这样Map中记录的就是这个任务的耗时时间了</li>
<li>耗时分布输出：遍历map，打印结果</li>
</ol>
<h2> 2. 实现</h2>
<h3> 2.1 基础实现</h3>
<blockquote>
<p>下面的源码，可在<code>com.github.liuyueyi.hhui.trace.test.step.Step3</code>进行查看</p>
</blockquote>
<p>接下来我们按照上面的设计思路，现来实现一个Map版本的<code>StopWatch</code></p>
<p>定义一个工具类 <code>TraceWatch</code>，申明两个核心变量 <code>taskName:总任务名</code> + <code>taskCost:子任务耗时map</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后就是实现记录某个任务执行耗时的开始、结束方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后再实现一个各任务的耗时输出分布 （日志打印基本上验用StopWatch的格式化打印，区别在于这里使用的是毫秒输出）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到这里，一个支持多任务耗时并行记录的工具类就实现了，接下来写一个测试用例来验证下效果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一个示例的输出结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的使用demo以及输出，会发现存在一些问题</p>
<ol>
<li>代码的冗余度高</li>
<li>总耗时与实际不符（总耗时是每个任务的耗时加和，但是有些任务是并行执行的）</li>
<li>最终的结果输出时，得等到所有任务执行完毕，但是上面的实现无法保证这一点</li>
<li>耗时统计的代码块抛出异常时，会导致无法正确记录耗时情况（即stop方法要求业务方确保和start一起出现，一定会被调用到）</li>
</ol>
<h3> 2.2 使用姿势优化</h3>
<p>接下来我们尝试解决提出的问题，首先是使用姿势的优化，提供一个耗时的封装</p>
<p>在前面的基础上，新增一个无返回/有返回的方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，我们再借助<code>try</code>语句来实现自动的耗时输出, 再结果打印时，我们遍历一下所有的任务，看一下是否已经执行完毕(通过判断taskCost中存的是时间戳还是耗时来判断任务是否执行完毕，当然也是可以新增一个状态来判断任务是否已执行完)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来再看一下新的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>整体来说，相比较于前面的版本，使用侧还是要简单明了不少的。 但是请注意，再实际使用的过程中，可能会出现最后一个 task4 耗时统计异常的情况，如下</p>
<figure><img src="/imgs/column/trace/04-traceWatch输出.jpg" alt="异常输出" tabindex="0" loading="lazy"><figcaption>异常输出</figcaption></figure>
<p>为什么会出现这种情况呢？ 我们在耗时输出时，不是已经做了一个自旋等待所有任务执行完毕么，为啥还会出现任务没有执行完毕的情况呢？</p>
<p>这里主要的原因在于并行的场景下，<code>TraceWatch</code> 的 <code>close</code> 方法执行过程中，<code>allExecuted</code> 这个方法执行完了之后，而在 <code>prettyPrint</code> 打印前，上面的task4这个任务执行了<code>start()</code>方法开始了耗时记录，从而导致出现上面的问题</p>
<h3> 2.3 并发优化</h3>
<p>接下来我们再优化一下上面的工具类，除了解决上面的问题之外，我们再调整一下整体耗时的规则，记录从<code>TraceWatch</code>初始化，到最终耗时输出这个时间段的耗时，作为整体的耗时记录（取代之前的所有的单个任务耗时加和作为总耗时）</p>
<ul>
<li>新增 <code>markExecuteOver</code> 标记是否所有的任务执行完毕</li>
<li>若所有任务执行完毕，则不再支持新的任务耗时记录</li>
<li>对象创建时，作为整体任务的开始时间； 日志打印/close方法触发时，作为整体任务执行结束时间</li>
</ul>
<p>添加上面三个逻辑之后，新的工具类如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的使用姿势基本上与前面没什么差别，我们新增一个没有被<code>traceWatch.cost</code>包裹的代码块，验证下新的工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>多执行几次，将会看到下面这类的输出</p>
<figure><img src="/imgs/column/trace/05-traceWatch输出2.jpg" alt="输出结果" tabindex="0" loading="lazy"><figcaption>输出结果</figcaption></figure>
<p>重点注意几个关键输出：</p>
<ol>
<li>task4 耗时记录被忽略了，即出现了先执行<code>allExecuted()</code>，后统计 <code>task4</code> 耗时的场景</li>
<li><code>整体耗时(147ms)</code> 约等于 <code>前置(12ms)</code> + <code>task1(106ms)</code> + <code>task3(27ms)</code></li>
</ol>
<p>因为task2是异步执行的，它可以与task1/3并行执行，所以对整体的耗时基本没有影响，这里的整体耗时输出和我们外层直接统计的耗时输出基本一致，表明这个整体的耗时输出结果是符合真实预期的</p>
<h3> 2.4 小结</h3>
<p>本文通过一步一步的实现 + 复盘，得出了一个简单的、适用于并发场景下的耗时分布统计工具类。再实现的过程中，给出了为什么最终的成品长这样，因为什么原因，引入了xx成员变量，解决了什么问题，通过将这个工具类的实现步骤拆分，给大家演示了一下一个相对成熟的工具类的迭代过程</p>
<p><strong>知识点</strong></p>
<p>接下来我们对整体的实现，从技术侧做一个小结，相关的知识点有：</p>
<ul>
<li>并发任务耗时支持： 借助<code>ConcurrentHashMap</code>来记录每个任务的耗时情况</li>
<li>通过函数方法，封装代码块的耗时统计使用姿势，确保 <code>start</code> 与 <code>stop</code> 一定会配套出现</li>
<li>自旋等待的方式，等待所有的任务执行完毕之后，再输出耗时分布</li>
<li>全局结束标记，当标记结束之后，不再支持新的任务耗时统计（注意<code>markExecuteOver</code>前面的修饰<code>volatile</code>）</li>
</ul>
<p><strong>缺陷点</strong></p>
<p>然后我们再看一下这个工具类的缺陷：</p>
<ul>
<li>代码侵入性问题（依然时需要再业务代码侧进行埋点）</li>
<li>任务名相同时，会出现耗时覆盖</li>
<li>任务耗时百分比加和不是100%(因为异步任务以及任务之外的代码块执行耗时的影响，导致占比一般不是100%了)</li>
</ul>
<p><strong>待优化点</strong></p>
<p>在上面这个工具类的基础上，我们还有什么可以优化的地方么?</p>
<ul>
<li>简化异步代码块的耗时统计，看是否可以直接将异步的能力集成在工具类中，减小业务侧异步支持的成本</li>
</ul>
<blockquote>
<p>本文所有代码均可以在 <a href="https://github.com/liuyueyi/hhui-components/blob/master/trace-watch-dog/src/test/java/com/github/liuyueyi/hhui/trace/test/step/Step4.java" target="_blank" rel="noopener noreferrer">trace-watch-dog</a> 获取</p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/trace/02-stopwatch原理.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>4. 异步使用能力增强</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/04.%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81%E7%AD%96%E7%95%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/04.%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81%E7%AD%96%E7%95%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4. 异步使用能力增强</source>
      <description>接上文的耗时统计工具类，对于TraceWatch工具类的基本使用，都是基于同步的策略来的，如 // 无返回结果 traceWatch.cost(() -&amp;gt; xxx, &amp;quot;task1&amp;quot;); // 有返回结果 ans = traceWatch.cost(() -&amp;gt; { xxx; return xxx; }, &amp;quot;task1&amp;quot;);</description>
      <category>技术组件</category>
      <pubDate>Thu, 22 Aug 2024 18:19:48 GMT</pubDate>
      <content:encoded><![CDATA[<p>接上文的耗时统计工具类，对于<code>TraceWatch</code>工具类的基本使用，都是基于同步的策略来的，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们考虑对它的能力进行增强，我们希望可以简单的指定需要统计的代码块是同步执行还是异步执行</p>
<p>比如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 1. 异步增强</h2>
<h3> 1.1 通用的线程池工具类</h3>
<p>既然是异步能力增强，支持代码块的异步调度，那么我们可以封装一个简单的线程池工具类，主要用于异步执行的线程池的创建</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2 异步能力增强</h3>
<p>当我们希望包装的代码块可以同步/异步执行时，首先是在创建对象的时候，指定一下线程池</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们封装一下上面的<code>start</code>, <code>end</code>方法的使用姿势，与前面的工具类的实现，重要的区别在于返回</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么返回的是 <code>Runnable/Supplier</code>？</p>
<blockquote>
<p>这个就需要从同步/异步的调用方法来看为什么这么设计了</p>
</blockquote>
<p>对于同步执行的场景，我们可以分别为有返回/无返回提供两个方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于异步执行的场景，我们需要将<code>xxWithTime</code>的返回丢到线程池中执行</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看到上面的实现之后，我们很容易想到，在输出耗时分布时，判断是否所有任务执行完毕，实际上不需要用之前的自旋等待的方式判断是否都执行完毕了，我们可以持有异步的返回的<code>CompletableFuture</code>，通过join的方式来等待所有任务执行完毕</p>
<p>因此我们可以声明一个全局的异步结果缓存容器，在实例化对象的时候进行初始化</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来就是在异步调度时，保存一下结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>等待所有任务执行完毕就可以直接借助<code>CompletableFuture.allOf().join</code>来实现了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此，我们的异步能力增强已基本实现完毕, 接下来进入实测体验</p>
<h2> 2. 使用体验</h2>
<h3> 2.1 完整工具类</h3>
<p>下面是完整的工具实现类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.2 使用体验</h3>
<p>接下来看一下具体的使用实例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出示例</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.3 小结</h3>
<p>从上面的使用来看，现在的工具类相对来说就完整很多了，使用上也比较简单(至少代码阅读起来，还算优雅)，但是依然没能解决<code>业务代码侵入</code>问题</p>
<p>此外，在异步的场景下，我们需要注意多线程/线程池场景下的上下文传递问题，若上面的<code>async</code>代码块中，希望获取主线程中的上下文参数，可以正常拿到么？</p>
<blockquote>
<p>本文中的相关代码，可以到这里查看 <a href="https://github.com/liuyueyi/hhui-components/blob/master/trace-watch-dog/src/test/java/com/github/liuyueyi/hhui/trace/test/step/Step5.java" target="_blank" rel="noopener noreferrer">trace-watch-dog</a></p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>2. 封装一个基础的耗时统计工具类</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/02.%E5%9F%BA%E7%A1%80%E8%80%97%E6%97%B6%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/02.%E5%9F%BA%E7%A1%80%E8%80%97%E6%97%B6%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2. 封装一个基础的耗时统计工具类</source>
      <description>在日常的工作中，对某一段代码的执行耗时进行记录，属于相对常见的诉求，实现起来也很简单，不就是开始前记录一下当前时间戳，执行结束之后再记录一下当前时间戳，两者相减就可以得到我们想要的结果了 1. 时间戳差值法 这里主要借助的就是 System.currentTimeMillis() 来获取当前的时间戳（毫秒） 1.1 基本实现 先来看一下基本的使用姿势 // com.github.liuyueyi.hhui.trace.test.step.Step1#testCost long start = System.currentTimeMillis(); // ... 这里省略掉需要计算耗时的业务逻辑 long end = System.currentTimeMillis(); System.out.println(&amp;quot;cost: &amp;quot; + (end - start) + &amp;quot;ms&amp;quot;);</description>
      <category>技术组件</category>
      <pubDate>Wed, 21 Aug 2024 19:19:48 GMT</pubDate>
      <content:encoded><![CDATA[<p>在日常的工作中，对某一段代码的执行耗时进行记录，属于相对常见的诉求，实现起来也很简单，不就是开始前记录一下当前时间戳，执行结束之后再记录一下当前时间戳，两者相减就可以得到我们想要的结果了</p>
<h2> 1. 时间戳差值法</h2>
<p>这里主要借助的就是 <code>System.currentTimeMillis()</code> 来获取当前的时间戳（毫秒）</p>
<h3> 1.1 基本实现</h3>
<p>先来看一下基本的使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这种写法比较简单直接，唯一的问题就是会有较多的重复冗余代码，特别是再一个执行链路中，存在较多的地方需要输出耗时时，就会发现代码块中，会出现大量的上面的代码块</p>
<p>有没有什么办法可以提炼一下呢？</p>
<ul>
<li>通过函数方法来实现</li>
</ul>
<h3> 1.2 公用方法</h3>
<p>针对上面的写法，我们抽出一个耗时统计的公用方法，如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当执行一个代码块不需要关注返回结果时，就可以通过下面这种方式进行耗时输出</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行以下上面的 testCost2 ，会得到如下的执行耗时输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的公用方法适用于没有返回结果的耗时打印，但是现实中，当然还存在需要获取返回的场景，这个时候我们可以再封装一个公共方法，适用于有返回结果的场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>给出一个具体的使用demo</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是执行的返回结果示例</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3 实现小结</h3>
<p>上面基于时间戳封装了一个简单的耗时打印公共方法，我们整合一下关键的实现，提炼一个通用工具类如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的使用姿势也比较简单，根据是否有返回结果，可以区分为下面两种</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从结果来看，这个工具类已经能满足基本诉求了，那么到此为止么？再看一下这个工具类，会有什么问题么？</p>
<p>从使用侧的角度来看，这个工具类还有两个不便</p>
<ol>
<li>代码侵入性强，需要主动再业务代码中进行集成</li>
<li>输出结果分散，对于链路较长的业务，具体是哪一块业务逻辑耗时较久不太直观</li>
</ol>
<h2> 2. StopWatch工具类</h2>
<p>Spring本身提供了一个耗时统计的工具类<code>StopWatch</code>，当然也有很多的组件库(如Hutool)提供了类似的工具类，那么它主要是为了解决什么问题呢？</p>
<h3> 2.1 使用体验</h3>
<p>接下来我们通过实际的使用，来体验一下<code>StopWatch</code>的效果表现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的输出结果，可以直观看到每个任务的耗时，对整体耗时的占用百分比，基于此可以更容易找到性能瓶颈点，这里也可以回答上一节的疑问，主要解决的就是上面提到的第二个缺陷：输出比较分散的问题</p>
<h3> 2.2 使用封装</h3>
<p>同样的，我们也希望将上面的使用姿势做一个封装，尽量减少冗余代码对业务代码的侵入</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的工具类中，我们借助<code>Closeable</code> + <code>try</code> 来实现自动的耗时输出</p>
<p>接下来再看一下使用姿势</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出示例</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用工具类，整体上对业务代码的可阅读性上，相比较于之前会更优雅一点； 那么这个StopWatchWrapper的工具类是否就已经可以满足我们的诉求了呢？</p>
<h3> 2.3 StopWatch特性小结</h3>
<p>仔细看一下上面的耗时打印，StopWatch 输出的耗时，实际上是从首次调用 <code>stopWatch.start</code> 开始计算耗时，到最后一个 <code>stopWatch.stop</code> 调用作为结束</p>
<p>即上面的测试代码中，try语句中的第一个<code>randSleep(300);</code> 和最后一个 <code>randSleep(300);</code> 的耗时，实际上是不包含在最终的耗时输出结果中的，这里就有一点反直觉了</p>
<p>此外，有看过<code>StopWatch</code>源码的小伙伴可以知道，它是线程不安全的，即在多线程场景下，即容易出错</p>
<figure><img src="/imgs/column/trace/01-stopwatch.jpg" alt="异常提示" tabindex="0" loading="lazy"><figcaption>异常提示</figcaption></figure>
<h2> 3. 小结</h2>
<p>我们这里主要封装了两个工具类，主要解决的是使用层面的问题</p>
<ol>
<li>CostUtil</li>
</ol>
<p>适用于单一代码块的耗时输出，借助 <code>System.currentTimeMillis</code> 获取当前时间戳，通过代码块执行前后的时间差来输出耗时情况</p>
<p>封装的工具类主要借助函数方法来简化使用方式，它本身的缺点有下面几点</p>
<ul>
<li>侵入性强，需要主动埋点记录耗时</li>
<li>对于复杂的业务链路下，存在多个任务耗时统计时，输出结果离散不直观</li>
</ul>
<ol start="2">
<li>StopWatchWrapper</li>
</ol>
<p>适用于某一业务链路，多个任务耗时打印输出场景，借助<code>StopWatch</code>来实现耗时分布统计</p>
<p>这里主要借助函数方法 + try/closeable来简化使用方式, 它解决了CostUtil的输出离散问题，单依然存在下面几个缺点</p>
<ul>
<li>侵入性强，需要主动埋点记录耗时</li>
<li>并发场景下容易出现异常</li>
</ul>
<p>既然现有的工具方法不够完美，那就自己撸一个，目标是</p>
<ul>
<li>侵入性小</li>
<li>支持并发场景的耗时记录</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/trace/01-stopwatch.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>1. 诞生的契机</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/01.%E8%AF%9E%E7%94%9F%E7%9A%84%E5%A5%91%E6%9C%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/01.%E8%AF%9E%E7%94%9F%E7%9A%84%E5%A5%91%E6%9C%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1. 诞生的契机</source>
      <description>为什么会萌发写一个记录链路耗时的组件的念头呢？ 来源于一个不太美妙的线上问题。 自从开始做toB的业务之后，对系统的性能要求阈值不断下降，当一个接口响应超过3s时，发现适应适应还可接受，然后逐渐的，你会发现接口的响应会滑向5s、10s... (底线一段突破，那就将没有底线可言) 在经历某一次重大的迭代之后，整体的数据量翻了两翻，部分接口的响应直接突破10s，然后业主方终于是不能忍了，明确提出要求做性能优化 那么怎么做呢？ 按照一般的做事惯例，先定目标，然后基于现状拆解任务，接着就是任务的研发推进，最终的交付测试上线 当明确提出要优化某个接口时，至少我们现在的目标是明确，要缩减接口的耗时</description>
      <category>技术组件</category>
      <pubDate>Wed, 14 Aug 2024 19:19:48 GMT</pubDate>
      <content:encoded><![CDATA[<p>为什么会萌发写一个记录链路耗时的组件的念头呢？ 来源于一个不太美妙的线上问题。 自从开始做toB的业务之后，对系统的性能要求阈值不断下降，当一个接口响应超过3s时，发现适应适应还可接受，然后逐渐的，你会发现接口的响应会滑向5s、10s... (底线一段突破，那就将没有底线可言)</p>
<p>在经历某一次重大的迭代之后，整体的数据量翻了两翻，部分接口的响应直接突破10s，然后业主方终于是不能忍了，明确提出要求做性能优化</p>
<p>那么怎么做呢？</p>
<p>按照一般的做事惯例，先定目标，然后基于现状拆解任务，接着就是任务的研发推进，最终的交付测试上线</p>
<p>当明确提出要优化某个接口时，至少我们现在的目标是明确，要缩减接口的耗时</p>
<p>现在也是明确的，接口响应很慢。 那么我们的任务也相对明确，即是解决接口响应慢的问题。 接下来就自然有一个疑问，到底是哪里慢了？ 对应的策略有两种</p>
<ol>
<li>老老实实啃代码，根据个人经验来判断慢的点</li>
<li>借助一些工具，输出各关键节点的耗时分布情况，直观上找到性能瓶颈点</li>
</ol>
<p>对于第一点，没有什么好说的；重点看一下第二个，我现在迫切需要一个工具，能帮我分析整个接口的执行链路中，是哪些环节会比较慢</p>
<p>现在我有什么？</p>
<ul>
<li>skywalking</li>
<li>loki + grafana</li>
</ul>
<p>既然有全链路监控神器Skywalking，当然想着就是充分利用起来，先直接观察一下链路的执行情况</p>
<figure><img src="/imgs/column/trace/00-skywalking.jpg" alt="来自网图" tabindex="0" loading="lazy"><figcaption>来自网图</figcaption></figure>
<p>默认的Skywalking的链路追踪中，主要显示的是一些io相关的耗时操作，对于我们实际的业务场景有帮助，但不大（链路长、网络io非常多，很难精确定位到具体是哪里耗时久）</p>
<p>此时就需要我们主动在代码的方法上埋点，通过<code>@Trace</code>注解来手动插入<code>LocalSpan</code>，从而增加关键方法的执行情况输出；接下来我遇到另外一个稍显现实的问题，特么的代码写得有点拉跨，大部分逻辑放在一个方法里，咋搞....</p>
<blockquote>
<p>关于skywalking的基础知识点：（<a href="https://www.jianshu.com/p/541eb76c6edc" target="_blank" rel="noopener noreferrer">Skywalking的埋点-Trace的基本概念 - 简书</a>）</p>
</blockquote>
<p>接下来只能老老实实的在代码中通过 <code>StopWatch</code> 来统计代码块的执行耗时情况了，耗时打印输出日志，借助<code>loki+grafana</code>来统一收集查看，也能满足诉求，但是，这种方式写出来的代码，会导致本就岌岌可危的业务代码，又添加了一堆无甚鸟用的逻辑，实在是有点难以忍受； 还有另外一个严重的问题，则是<code>StopWatch</code>对并发的支持不行，对于链路中存在异步调用的场景下，会出现统计偏差或异常</p>
<p>既然现存的工具栈不合心意，那就自己搞一个，先指定几个基本要求：</p>
<ul>
<li>不会引入新的问题</li>
<li>使用简单方便，输出直观的耗时统计</li>
<li>对现有的业务代码块侵入较小</li>
<li>支持链路中存在并行任务执行场景的耗时统计</li>
<li>可以方便的将某些方法/代码块，由同步的调度改成异步的调度，从而提高接口性能</li>
</ul>
<p>接下来我们将正式进入实现篇，如何从0到1手撸一个耗时分布统计的工具组件</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/trace/00-skywalking.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>trace-watch-dog</title>
      <link>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/app/trace-watch-dog/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">trace-watch-dog</source>
      <description>trace-watch-dog 源码地址： trace-watch-dog 用于记录项目中，某一个链路的执行耗时情况，同时也支持将链路中的某些同步调用，改成异步执行，从而提高整体的性能表现 迭代记录 v1.0.1 支持在上下文中，随时获取 TraceBridge 进行手动埋点, 支持传入自定义的logSpEL，控制是否输出日志 v1.0.0 实现一个基础的 TraceWatch 工具类，通过手动埋点的方式记录整体的耗时分布情况</description>
      <pubDate>Wed, 14 Aug 2024 14:17:36 GMT</pubDate>
      <content:encoded><![CDATA[<h2> trace-watch-dog</h2>
<blockquote>
<p>源码地址： <a href="https://github.com/liuyueyi/hhui-components/blob/master/trace-watch-dog" target="_blank" rel="noopener noreferrer">trace-watch-dog</a></p>
</blockquote>
<p>用于记录项目中，某一个链路的执行耗时情况，同时也支持将链路中的某些同步调用，改成异步执行，从而提高整体的性能表现</p>
<h3> 迭代记录</h3>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> v1.0.1 支持在上下文中，随时获取 <code>TraceBridge</code> 进行手动埋点, 支持传入自定义的logSpEL，控制是否输出日志</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> v1.0.0 实现一个基础的 <code>TraceWatch</code> 工具类，通过手动埋点的方式记录整体的耗时分布情况</label></li>
</ul>
<h3> 系列教程</h3>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> trace-watch-dog 诞生的契机</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> 如何实现一个基础版本的耗时监控工具类</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-4" disabled="disabled"><label class="task-list-item-label" for="task-item-4"> 便捷的同步转异步的实现策略</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-5" disabled="disabled"><label class="task-list-item-label" for="task-item-5"> 解决异步的上下文信息丢失问题（如traceId）</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-6" disabled="disabled"><label class="task-list-item-label" for="task-item-6"> 借助上下文，支持随时使用</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-7" disabled="disabled"><label class="task-list-item-label" for="task-item-7"> 借助AOP，实现非侵入式的埋点</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-8" disabled="disabled"><label class="task-list-item-label" for="task-item-8"> AOP的使用缺陷</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-9" disabled="disabled"><label class="task-list-item-label" for="task-item-9"> 基于Agent的实现方式</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-10" disabled="disabled"><label class="task-list-item-label" for="task-item-10"> 耗时输出重定向(标准输出，slf4j输出，日志上报三方平台)</label></li>
</ul>
<h3> 使用姿势</h3>
<p>引入依赖，基于jitpack的如下</p>
<blockquote>
<p>版本根据实际需要进行选择，当前最新版本 0.0.1</p>
</blockquote>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基础核心使用，可应用非Spring应用场景</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于SpringBoot的应用场景下，可以引入下面的依赖，支持基于AOP的埋点方式</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>1. Centos 安装ElasticSearch</title>
      <link>https://liuyueyi.github.io/tutorial/db/es/200605-Centos-%E5%AE%89%E8%A3%85ElasticSearch.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/es/200605-Centos-%E5%AE%89%E8%A3%85ElasticSearch.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1. Centos 安装ElasticSearch</source>
      <description>本文记录Centos 7.5 安装 ElasticSearch 6.8.5 版本的全过程</description>
      <category>开源</category>
      <category>ElasticSearch</category>
      <pubDate>Fri, 05 Jun 2020 17:24:44 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文记录<code>Centos 7.5</code> 安装 <code>ElasticSearch 6.8.5</code> 版本的全过程</p>
<!-- more -->
<h3> 1. ES安装流程</h3>
<blockquote>
<p>es的运行依赖jdk，所以需要先安装好java环境，我们这里用的jdk1.8，这里不额外说明jdk环境的安装流程</p>
</blockquote>
<h4> a. 下载</h4>
<p>首先到目标网站，查询需要下载的版本 : <a href="https://www.elastic.co/cn/downloads/past-releases#elasticsearch" target="_blank" rel="noopener noreferrer">https://www.elastic.co/cn/downloads/past-releases#elasticsearch</a></p>
<p>本文选择<code>6.8.5</code>（主要是为了和<code>SpringBoot 2.2.0-RELEASE</code>对上）</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> b. 解压启动</h4>
<p>下载完之后，直接解压，并进入目录，</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>修改配置，指定数据存储和日志路径，支持外部访问</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> c. 启动测试</h4>
<p>直接运行bin目录下的<code>elasticsearch</code>即可启动es，当然也可以以后台方式启动</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本机访问:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>2. Elastic &amp; Kibana安装与基本使用</title>
      <link>https://liuyueyi.github.io/tutorial/db/es/210329-Elastic-Kibana%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/es/210329-Elastic-Kibana%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2. Elastic &amp; Kibana安装与基本使用</source>
      <description>本文主要介绍es &amp;amp; kibana的安装和基本使用，更多es的相关用法后面逐一补上</description>
      <category>开源</category>
      <category>ElasticSearch</category>
      <pubDate>Mon, 29 Mar 2021 18:49:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文主要介绍es &amp; kibana的安装和基本使用，更多es的相关用法后面逐一补上</p>
<!-- more -->
<h3> 1. elasticsearch安装</h3>
<p>linux环境下，直接下载安装包</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>jvm参数配置</p>
<p>默认es启动，占用的内存太大了，本机测试有必要限制一下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>启动完毕之后，会看到控制台有一些输出，日志不打印时，可以输入下面的查询，验证是否ok</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2. kibana安装</h3>
<p>同样linux环境下，直接下载tar包解压使用</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>访问</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 3. Dev Tools 实现es基本操作</h3>
<p>借助kibana来做一些es的基本操作，如添加文档，查询等</p>
<p>打开url: <a href="http://localhost:5601/app/dev_tools#/console" target="_blank" rel="noopener noreferrer">http://localhost:5601/app/dev_tools#/console</a></p>
<p><strong>添加文档</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210329/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>查询所有</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210329/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>精确查询</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210329/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>删除索引</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210329/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/hexblog/imgs/210329/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>3. 基本使用姿势</title>
      <link>https://liuyueyi.github.io/tutorial/db/es/210331-ElasticSearch-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/es/210331-ElasticSearch-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3. 基本使用姿势</source>
      <description>ElasticSearch 基本使用姿势，如常见的 添加文档 常见的查询姿势 修改/删除文档</description>
      <category>开源</category>
      <category>ElasticSearch</category>
      <pubDate>Wed, 31 Mar 2021 17:39:55 GMT</pubDate>
      <content:encoded><![CDATA[<p>ElasticSearch 基本使用姿势，如常见的</p>
<ul>
<li>添加文档</li>
<li>常见的查询姿势</li>
<li>修改/删除文档</li>
</ul>
<!-- more -->
<h3> 1. 添加文档</h3>
<p>首次添加文档时，若索引不存在会自动创建； 借助kibana的<code>dev-tools</code>来实现es的交互</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然也可以直接使用http进行交互，下面的方式和上面等价（后面都使用kibanan进行交互，更直观一点）</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 查询文档</h3>
<h4> 2.0 kibana配置并查询</h4>
<p>除了基础的查询语法之外，直接使用kibana进行查询，对于使用方而言，门槛最低；首先配置上面的es索引</p>
<ul>
<li>Management -&gt; Stack Management -&gt; Kiabana Index Patterns</li>
<li>index pattern name</li>
<li>时间字段，选择 <code>@timestamp</code> 这个与实际的文档中的field有关</li>
</ul>
<figure><img src="/hexblog/imgs/210331/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/hexblog/imgs/210331/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/hexblog/imgs/210331/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/hexblog/imgs/210331/04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来进入<code>Discover</code> 进行查询</p>
<figure><img src="/hexblog/imgs/210331/05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>比如字段查询</p>
<figure><img src="/hexblog/imgs/210331/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 2.1 查询所有</h4>
<p>不加任何匹配，捞出文档(当数据量很多时，当然也不会真的全部返回，也是会做分页的)</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/07.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 2.2 term精确匹配</h4>
<p>根据field进行value匹配，忽略大小写;</p>
<p>查询语法，形如:   <code>{"query": {"term": {"成员名": {"value": "查询值"}}}}</code></p>
<ul>
<li><code>query</code>, <code>term</code>, <code>value</code> 三个key为固定值</li>
<li><code>成员名</code>: 为待查询的成员</li>
<li><code>查询值</code>: 需要匹配的值</li>
</ul>
<p>(说明：后面语法中，中文的都是需要替换的，英文的为固定值)</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/08.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>当value不匹配，或者查询的field不存在，则查不到的对应的信息，如</p>
<figure><img src="/hexblog/imgs/210331/09.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 2.3 terms 多值匹配</h4>
<p>term表示value的精确匹配，如果我希望类似<code>value in (xxx)</code>的查询，则可以使用terms</p>
<p>语法:</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实例如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/10.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 2.4 range 范围匹配</h4>
<p>适用于数值、日期的比较查询，如常见的 &gt;, &gt;=, &lt;, &lt;=</p>
<p>查询语法</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>范围操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>gt</code></td>
<td>大于 &gt;</td>
</tr>
<tr>
<td><code>gte</code></td>
<td>大于等于 &gt;=</td>
</tr>
<tr>
<td><code>lt</code></td>
<td>小于 &lt;</td>
</tr>
<tr>
<td><code>lte</code></td>
<td>小于等于 &lt;=</td>
</tr>
</tbody>
</table>
<p>实例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/11.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 2.5 字段过滤</h4>
<p>根据是否包含某个字段来查询， 主要有两个 <code>exists</code> 表示要求存在， <code>missing</code>表示要求不存在</p>
<p>查询语法</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/12.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 2.6 组合查询</h4>
<p>上面都是单个查询条件，单我们需要多个查询条件组合使用时，可以使用<code>bool + must/must_not/should</code>来实现</p>
<p>查询语法</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面截图以 must_not 输出示意</p>
<figure><img src="/hexblog/imgs/210331/13.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>说明</strong></p>
<ul>
<li>前面根据字段查询 <code>existing</code> 只能单个匹配，可以借助这里的组合来实现多个的判断</li>
</ul>
<h4> 2.7 match查询</h4>
<p>最大的特点是它更适用于模糊查询，比如查询某个field中的字段匹配</p>
<p>语法</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举例说明</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/14.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>说明，如果有精确查询的需求，使用前面的term，可以缓存结果</strong></p>
<h4> 2.8 multi_match查询</h4>
<blockquote>
<p>更多相关信息，可以查看: <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/multi-match-query.html" target="_blank" rel="noopener noreferrer">官网-multi_match查询</a></p>
</blockquote>
<p>多个字段中进行查询</p>
<p>语法</p>
<ul>
<li>type: <code>best_fields</code> 、 <code>most_fields</code> 和 <code>cross_fields</code> （最佳字段、多数字段、跨字段）</li>
<li><strong>最佳字段</strong> ：当搜索词语具体概念的时候，比如 “brown fox” ，词组比各自独立的单词更有意义</li>
<li><strong>多数字段</strong>：为了对相关度进行微调，常用的一个技术就是将相同的数据索引到不同的字段，它们各自具有独立的分析链。</li>
<li><strong>混合字段</strong>：对于某些实体，我们需要在多个字段中确定其信息，单个字段都只能作为整体的一部分</li>
</ul>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实例演示</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/15.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面除了写上精确的字段之外，还支持模糊匹配，比如所有字段中进行匹配</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.9 wildcard查询</h4>
<p>shell统配符</p>
<ul>
<li><code>?</code>: 0/1个字符</li>
<li><code>*</code>: 0/n个字符</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明，对中文可能有问题</strong></p>
<h4> 2.10 regexp查询</h4>
<p>正则匹配</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.11 prefix查询</h4>
<p>前缀匹配</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.12 排序</h4>
<p>查询结果排序，根据sort来指定</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.13 更多</h4>
<p>更多操作姿势，可以在官方文档上获取</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html" target="_blank" rel="noopener noreferrer">官方教程</a></p>
<h3> 3. 删除文档</h3>
<p>需要根据文档id进行指定删除</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/16.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>删除成功</p>
<figure><img src="/hexblog/imgs/210331/17.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4.更新文档</h3>
<h4> 4.1 覆盖更新</h4>
<p>使用PUT来实现更新，同样通过id进行</p>
<ul>
<li>覆盖更新</li>
<li>version版本会+1</li>
<li>如果id对应的文档不存在，则新增</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/18.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 4.2 增量更新</h4>
<p>采用POST来实现增量更新</p>
<ul>
<li>field 存在，则更新</li>
<li>field不存在，则新增</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/210331/19.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>此外还可以采用script脚本更新</p>
<ul>
<li>在原来的age基础上 + 5</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/hexblog/imgs/210331/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>6. 全文搜索支持配置</title>
      <link>https://liuyueyi.github.io/tutorial/db/es/211018-ElasticSearch%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E6%94%AF%E6%8C%81%E9%85%8D%E7%BD%AE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/es/211018-ElasticSearch%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E6%94%AF%E6%8C%81%E9%85%8D%E7%BD%AE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6. 全文搜索支持配置</source>
      <description>在es的使用过程中，全文搜索属于一个常见的场景，特别是当我们将es作为日志存储检索来使用时，根据关键字查询对应的日志信息，可以怎么处理呢?</description>
      <category>开源</category>
      <category>ElasticSearch</category>
      <pubDate>Mon, 18 Oct 2021 18:47:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>在es的使用过程中，全文搜索属于一个常见的场景，特别是当我们将es作为日志存储检索来使用时，根据关键字查询对应的日志信息，可以怎么处理呢?</p>
<!-- more -->
<h3> 1. 动态模板结合copy_to方式</h3>
<p>在创建索引的时候，我们新增一个allColumnValue的字段，将所有其他的column值都拷贝过去，然后针对这个字段进行检索，即可以实现全文的搜索方式了</p>
<p>这里借助<code>dynamic_templtes</code>来实现上面的自动拷贝逻辑，因此我们可以如下创建一个索引</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建上面的映射表时，两个点</p>
<ul>
<li>allColumnValue：字段</li>
<li>dynamic_templates: 实现字段拷贝</li>
</ul>
<p>接下来写入一个数据进行测试</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后检索一下是否可以查询到希望的结果</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个查询之后，正常会命中我们的数据，并返回</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p>
<p>使用上面这种配置时，对于Field有要求，当我们制定一个Map类型时，会失败</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的<code>ddd</code>会提示异常</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 部分字段组合搜索</h3>
<p>上面介绍的是全量的数据凭借到allColumnValue，从而实现全文检索；可能在实际的场景中，我只是希望对部分的field进行联合检索，基于此可以如下设置</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>新增两个数据</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们检索<code>一灰</code>时，可以查到第二条数据</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 小结</h3>
<p>本文主要介绍借助copy_to，来实现es的联合/全文搜索的功能；通过简单的设置，来支撑更友好的查询场景</p>
<h2> II. 其他</h2>
<h3> 1. <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">一灰灰Blog</a>： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener noreferrer">https://liuyueyi.github.io/hexblog</a></h3>
<p>一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3> 2. 声明</h3>
<p>尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
</ul>
<h3> 3. 扫描关注</h3>
<p><strong>一灰灰blog</strong></p>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://spring.hhui.top/spring-blog/imgs/info/info.png" type="image/png"/>
    </item>
    <item>
      <title>8. 分组查询抛异常解决方案</title>
      <link>https://liuyueyi.github.io/tutorial/db/es/211123-ElasticSearch%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2%E6%8A%9B%E5%BC%82%E5%B8%B8%EF%BC%9F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/es/211123-ElasticSearch%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2%E6%8A%9B%E5%BC%82%E5%B8%B8%EF%BC%9F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">8. 分组查询抛异常解决方案</source>
      <description>在使用es进行组合查询的时候，遇到一个非常有意思的场景，特此记录一下 某些场景下，直接针对某个Field进行分组查询，居然无法返回结果，会给出类似Text fields are not optimised for operations that require per-document field data like aggregations and sorting, so these operations are disabled by default的提示信息，接下来看一下这个问题是个什么情况，以及如何解决</description>
      <category>开源</category>
      <category>ElasticSearch</category>
      <pubDate>Tue, 23 Nov 2021 18:11:36 GMT</pubDate>
      <content:encoded><![CDATA[<p>在使用es进行组合查询的时候，遇到一个非常有意思的场景，特此记录一下</p>
<p>某些场景下，直接针对某个Field进行分组查询，居然无法返回结果，会给出类似<code>Text fields are not optimised for operations that require per-document field data like aggregations and sorting, so these operations are disabled by default</code>的提示信息，接下来看一下这个问题是个什么情况，以及如何解决</p>
<!-- more -->
<h3> 1. 数据准备</h3>
<p>初始化一个索引，写入一些测试数据</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 分组查询基本知识点</h3>
<p>相当于sql中的<code>group by</code>，常用于聚合操作中的统计计数的场景</p>
<p>在es中，使用<code>aggs</code>来实现，语法如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如我们希望根据url统计访问计数，对应的查询可以是</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接执行上面的分组查询，结果问题来了</p>
<figure><img src="/hexblog/imgs/211123/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>右边返回的提示信息为<code>Text fields are not optimised for operations that require per-document field data like aggregations and sorting, so these operations are disabled by default. Please use a keyword field instead. Alternatively, set fielddata=true on [url] in order to load field data by uninverting the inverted index. Note that this can use significant memory</code>这个异常</p>
<h3> 3. 解决方案</h3>
<p>简单来说，上面这个问题，就是因为url这个字段为text类型，默认情况下这种类型的不走索引，不支持聚合排序，如果需要则需要设置<code>fielddata=true</code>，或者使用url的分词<code>url.keyword</code></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/211123/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>注意</strong></p>
<ul>
<li>
<p>虽然我们更注重的是分组后的结果，但是<code>hits</code>中依然会返回命中的文档，若是只想要分组后的统计结果，可以在查询条件中添加 <code>size:0</code></p>
</li>
<li>
<p>聚合操作和查询条件是可以组合的，如只查询某个url对应的计数</p>
</li>
</ul>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/hexblog/imgs/211123/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面介绍了TEXT类型的field，根据分词进行聚合操作；还有一种方式就是设置<code>fielddata=true</code>，操作姿势如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改完毕之后，再根据url进行分组查询，就不会抛异常了</p>
<figure><img src="/hexblog/imgs/211123/03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 小结</h3>
<p>最后小结一下，当我们使用es的某个field进行分组操作时，此时需要注意</p>
<p>当这个field类型为text，默认的场景下是不支持分组操作的，如果非要用它进行分组查询，有两个办法</p>
<ul>
<li>使用它的索引字段，如 <code>url.keyword</code></li>
<li>在索引的filed上添加<code>fileddata: true</code> 配置</li>
</ul>
<h2> 一灰灰的联系方式</h2>
<p>尽信书则不如无书，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>个人站点：<a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
<li>微信公众号：<strong>一灰灰blog</strong></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/hexblog/imgs/211123/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>5. Grafana使用语法之ES/Luence篇</title>
      <link>https://liuyueyi.github.io/tutorial/db/es/220302-Grafana%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95%E4%B9%8BES-Luence%E7%AF%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/es/220302-Grafana%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95%E4%B9%8BES-Luence%E7%AF%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5. Grafana使用语法之ES/Luence篇</source>
      <description>Grafnan结合ElasticSearch，实现数据统计，大盘配置</description>
      <category>开源</category>
      <category>运维</category>
      <pubDate>Wed, 02 Mar 2022 14:48:19 GMT</pubDate>
      <content:encoded><![CDATA[<p>Grafnan结合ElasticSearch，实现数据统计，大盘配置</p>
<!-- more -->
<h3> 1. 查询成员字段</h3>
<p>语法：<code>{"find": "fields", "type": "keyword"}</code></p>
<ul>
<li>find： 表示查什么东西</li>
<li>type：表示检索条件</li>
</ul>
<p>如查询<code>long</code>类型的字段，可以如下处理</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>什么时候用这个呢？</p>
<ul>
<li>比如我想知道这个es中定义了哪些字段</li>
<li>比如在配置Grafana的变量时，可以使用它来做一些限定</li>
</ul>
<h3> 2. 查询成员值</h3>
<p>语法： <code>{"find": "terms", "field": "成员名", "size": 100}</code></p>
<ul>
<li>find：后面跟上的是 terms， 表示查询具体的值</li>
<li>field: 用于限定需要查的成员</li>
<li>size：数量限制，可以不填</li>
</ul>
<p>举例如下，查询所有的服务器ip</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用范围：</p>
<ul>
<li>常见于配置Grafana变量，配置一个服务器ip选择的变量，用于查看不同服务器的表现情况</li>
</ul>
<h3> 3. 条件查询成员值</h3>
<p>在前面的基础上加一下限定，比如一个es为多个应用使用，此时我只关注其中app1的大盘，此时配置服务器时，想加一个条件限定</p>
<p>语法: <code>{"find": "terms", "field": "成员名", "query": "k:v"}</code></p>
<ul>
<li>query： lucence查询语法，要求成员k的值为v</li>
</ul>
<p>举例，查询server_name = app的服务器ip</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. Lucene 查询语法</h3>
<p>配置大盘的查询条件，主要就是借助lucene语法来处理，接下来看一下常见的使用姿势</p>
<h4> 4.1  条件等于查询</h4>
<p>语法： <code>field_name: filed_value</code></p>
<ul>
<li>filed_name: 字段名</li>
<li>field_value: 需要检索的值</li>
</ul>
<p><strong>注意：</strong> 中间使用英文冒号分隔，表示条件命中</p>
<h4> 4.2 不等于查询</h4>
<p>如果希望不等于查询，主要使用下面这种方式</p>
<ul>
<li><code>!(field_name:field_value)</code></li>
</ul>
<h4> 4.3 字段本身存在与否</h4>
<ul>
<li><code>_exists_:field_name</code>:  查询包含field成员的记录</li>
<li><code>_missing_:field_name</code>:  查询不包含field成员的记录</li>
</ul>
<h4> 4.4 通配符查询</h4>
<p>在查询条件中，包含下面两个的表示使用通配查询</p>
<ul>
<li><code>?</code>匹配打个字符</li>
<li><code>*</code> 匹配0或多个字符</li>
</ul>
<p>比如我有个应用，部署多个环境，分别名为 app-cn, app-usa，现在想统计整个应用的情况，就可以使用下面这种正则方式</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>除了上面的示例，在实际的工作中，更常见的是url的统计，比如统计 <code>/get/</code> 这个域名开头的请求</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.5 模糊搜索</h4>
<p>在单次后面添加剂上 <code>~</code>来实现模糊搜索，这种更适用于搜索业务场景，通常对于grafana的大盘配置，个人感觉不太实用</p>
<p>实用方式</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.6 范围搜索</h4>
<p>除了前面的精确搜索，我们还可以进行范围搜索</p>
<p>语法： <code>[ a TO b ]</code>,  <code>{a TO B}</code></p>
<ul>
<li><code>[]</code>： 闭包区间，包含左边的值</li>
<li><code>{}</code>： 开区间，不包含两边值</li>
<li><code>a/b</code> 如果为 <code>*</code> 表示某一侧不限制范围</li>
</ul>
<p>实例演示，查询http状态码为 4xx 的case</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>除了上面这种写法，也可以使用 <code>&gt; &lt; </code>的方式，比如上面的写法等价</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.7 逻辑操作</h4>
<p>多条件组合，使用AND/OR来处理，这里的组合即可以表明多个field，也可以是一个field的多个value组合</p>
<p>如多字段匹配：找出app-cn应用中状态码为500的记录</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如多value匹配：找出状态码为500, 503的记录</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 4.8 转移字符</h4>
<p>当查询条件中，包含下面字符中的一个时，需要使用注意</p>
<ul>
<li>特殊字符: <code>+ - = &amp;&amp; || &gt; &lt; ! ( ) { } [ ] ^ " ~ * ? : \ /</code></li>
<li>转义修饰: <code>\/</code></li>
</ul>
<p>如url的查询时，通常会用到转义</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 5. 小结</h3>
<p>本文主要介绍Grafana中使用es数据源时，常见的语法操作，当然其中Lucence的部分，在kibana中也同样适用；</p>
<p>通常来讲，在Grafana中，有下面几个地方会使用到上面的知识点</p>
<p>变量配置时，使用第1，2，3节中的方式，过滤出下拉选项</p>
<figure><img src="/hexblog/imgs/220302/00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在大盘配置的Query输入框中，使用 Lucene 语法</p>
<figure><img src="/hexblog/imgs/220302/01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在Explore中使用Lucene语法</p>
<figure><img src="/hexblog/imgs/220302/02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>参考博文：</p>
<ul>
<li><a href="https://www.cnblogs.com/xing901022/p/4974977.html" target="_blank" rel="noopener noreferrer">Lucene查询语法详解</a></li>
</ul>
<h2> 一灰灰的联系方式</h2>
<p>尽信书则不如无书，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>个人站点：<a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
<li>微信公众号：<strong>一灰灰blog</strong></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/hexblog/imgs/220302/00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>7. 开启权限验证</title>
      <link>https://liuyueyi.github.io/tutorial/db/es/220321-ElasticSearch%E5%BC%80%E5%90%AF%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81.html</link>
      <guid>https://liuyueyi.github.io/tutorial/db/es/220321-ElasticSearch%E5%BC%80%E5%90%AF%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7. 开启权限验证</source>
      <description>为了保证es的安全性，一般来讲我们会对es集群开启权限验证，下面将简单记录一下如何开启Basic Auth验证</description>
      <category>开源</category>
      <category>ElasticSearch</category>
      <pubDate>Mon, 21 Mar 2022 20:04:31 GMT</pubDate>
      <content:encoded><![CDATA[<p>为了保证es的安全性，一般来讲我们会对es集群开启权限验证，下面将简单记录一下如何开启Basic Auth验证</p>
<!-- more -->
<p>修改配置文件 <code>config/elasticsearch.yml</code>，添加下面的配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>启动es服务</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>生成密码</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>es的交互，主要使用 <code>Basic Auth</code> 方式进行身份校验，简单来讲，就是在请求头中，添加</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 一灰灰的联系方式</h2>
<p>尽信书则不如无书，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激</p>
<ul>
<li>个人站点：<a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a></li>
<li>微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener noreferrer">小灰灰Blog</a></li>
<li>QQ： 一灰灰/3302797840</li>
<li>微信公众号：<strong>一灰灰blog</strong></li>
</ul>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="QrCode" tabindex="0" loading="lazy"><figcaption>QrCode</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://spring.hhui.top/spring-blog/imgs/info/info.png" type="image/png"/>
    </item>
  </channel>
</rss>