<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://liuyueyi.github.io/tutorial/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://liuyueyi.github.io/tutorial/rss.xml" rel="self" type="application/rss+xml"/>
    <title>一灰灰的站点</title>
    <link>https://liuyueyi.github.io/tutorial/</link>
    <description>一灰灰的全网知识站点</description>
    <language>zh-CN</language>
    <pubDate>Mon, 09 Feb 2026 05:11:50 GMT</pubDate>
    <lastBuildDate>Mon, 09 Feb 2026 05:11:50 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>Copyright by 一灰灰blog</copyright>
    <image>
      <title>一灰灰的站点</title>
      <url>https://liuyueyi.github.io/tutorial/logo.svg</url>
      <link>https://liuyueyi.github.io/tutorial/</link>
    </image>
    <category>工具</category>
    <category>Chrome</category>
    <category>SpringAI</category>
    <category>LLM</category>
    <category>Agent</category>
    <category>AI</category>
    <category>Kotlin</category>
    <category>SpringBoot</category>
    <category>迭代</category>
    <category>QuickMCP</category>
    <category>Java</category>
    <category>JDK21</category>
    <item>
      <title>8. Chrome插件TableHelper-解决在线表格选择困难症</title>
      <link>https://liuyueyi.github.io/tutorial/tool/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/08.TableHelper%E8%A1%A8%E6%A0%BC%E5%8A%A9%E6%89%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/tool/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/08.TableHelper%E8%A1%A8%E6%A0%BC%E5%8A%A9%E6%89%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">8. Chrome插件TableHelper-解决在线表格选择困难症</source>
      <description>像Excel一样选择网页表格 &amp;amp; 支持选中表单生成sql的神器：TableHelper 一、开篇 作为一个与archery(一款开源的 SQL 审核与数据库管理平台、网页版)交互时间大于实际写代码的非标程序员，总是被网页表格数据的选择所折磨，如何只选某一(几)行列数据、或者选择某些单元格的数据，再将这些选中内容作为sql查询条件时、需要主动补齐分割符，可谓是极为麻烦了 那么有没有什么工具可以方便我们便捷、快速的处理网页上的表格数据呢？ 下面这个插件完全可以解决上面的问题，让我们可以像excel一样，自由的选择任何网页上的表格内容</description>
      <category>工具</category>
      <category>Chrome</category>
      <pubDate>Fri, 16 Jan 2026 17:22:29 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 像Excel一样选择网页表格 &amp; 支持选中表单生成sql的神器：TableHelper</h1>
<h2> 一、开篇</h2>
<p>作为一个与archery(一款开源的 SQL 审核与数据库管理平台、网页版)交互时间大于实际写代码的非标程序员，总是被网页表格数据的选择所折磨，如何只选某一(几)行列数据、或者选择某些单元格的数据，再将这些选中内容作为sql查询条件时、需要主动补齐分割符，可谓是极为麻烦了</p>
<p>那么有没有什么工具可以方便我们便捷、快速的处理网页上的表格数据呢？</p>
<p>下面这个插件完全可以解决上面的问题，让我们可以像excel一样，自由的选择任何网页上的表格内容</p>
<ul>
<li><a href="https://chromewebstore.google.com/detail/tablehelper/dklaelceomicpnakfmdonmghianjoiag" target="_blank" rel="noopener noreferrer">TableHelper: 提供精准的选择工具与智能SQL生成器，你的网页表格瑞士军刀</a></li>
</ul>
<h2> 二、适用场景</h2>
<h3> 1. 手动复制粘贴，效率太低</h3>
<p>每次处理表格数据都要一点点复制粘贴，不仅耗时，还容易出错。特别是遇到大表格，几个小时就这么没了...</p>
<h3> 2. 无法精确选择数据</h3>
<p>想选某几行或某几列的数据，结果只能整个表格复制，然后再去Excel里筛选，来回切换太麻烦。</p>
<h3> 3. 没有实时统计功能</h3>
<p>想要看看数据的总和、平均值，还得把数据复制到Excel里计算，步骤繁琐，浪费时间。</p>
<h3> 4. 数据格式转换困难</h3>
<p>从网页表格提取的数据经常需要转换格式才能使用，手动处理既费时又容易出错。</p>
<h3> 5. 担心数据安全</h3>
<p>用在线工具处理敏感数据时，总是担心数据泄露的问题。</p>
<h2> 二、Table Helper如何解决这些问题？</h2>
<h3> 1. 精确选择功能</h3>
<p>就像在Excel里一样，你可以精确选择单元格、行、列或任意区域。支持多种选择方式：</p>
<ul>
<li>单击选择单个单元格</li>
<li>按住Ctrl多选</li>
<li>Shift+点击选择连续区域</li>
<li>Alt+点击选择整列</li>
</ul>
<h3> 2. 智能表格识别</h3>
<p>自动识别网页中表格结构，智能高亮显示选中区域，让你清楚知道自己选择了哪些数据。</p>
<h3> 3. 实时统计面板</h3>
<p>选中数据后，右侧会自动显示统计信息：计数、求和、平均值、最大值、最小值等，一目了然。</p>
<h3> 4. 一键SQL生成</h3>
<p>选中数据后，可以直接生成标准SQL语句（SELECT、INSERT、UPDATE等），方便导入数据库。</p>
<h3> 5. 集合操作功能</h3>
<p>支持多表数据的交集、并集、差集运算，处理复杂数据关系更便捷。</p>
<h3> 6. 表格数据编辑功能</h3>
<p>支持针对选中的表格数据，以单元格、行、列粒度进行自定义编辑、去重等操作</p>
<h3> 7. 本地处理，数据安全</h3>
<p>所有操作都在本地浏览器完成，无需上传数据，完全不用担心隐私泄露。</p>
<h2> 三、如何使用Table Helper？</h2>
<h3> 1. 安装步骤</h3>
<ol>
<li>打开Chrome浏览器，进入扩展商店，或者直接进入插件详情 <a href="https://chromewebstore.google.com/detail/tablehelper/dklaelceomicpnakfmdonmghianjoiag" target="_blank" rel="noopener noreferrer">TableHelper: https://chromewebstore.google.com/detail/tablehelper/dklaelceomicpnakfmdonmghianjoiag</a></li>
<li>搜索"Table Helper"</li>
<li>点击"添加至Chrome"安装</li>
<li>安装完成后，工具栏会出现插件图标</li>
</ol>
<figure><img src="/imgs/260116/01.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 基础操作</h3>
<ul>
<li><strong>按住Ctrl+双击</strong>：选择整个表格</li>
<li><strong>按住Ctrl+点击</strong>：多选单元格</li>
<li><strong>Ctrl&amp;Shift+点击</strong>：选择连续区域</li>
<li><strong>Alt+点击</strong>：选择整列</li>
<li><strong>Ctrl+Alt+点击</strong>：选择整行</li>
<li><strong>Ctrl+C</strong>：复制选中数据</li>
</ul>
<p>注：上面的是默认的快捷键操作，支持进行修改哦~</p>
<figure><img src="/imgs/260116/02.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 高级功能</h3>
<ul>
<li><strong>统计面板</strong>：选中数据后自动显示统计信息</li>
<li><strong>SQL生成器</strong>：一键生成SQL语句</li>
<li><strong>集合运算</strong>：处理多个表格数据</li>
<li><strong>主题切换</strong>：支持多种视觉主题</li>
</ul>
<h2> 四、典型场景介绍分析</h2>
<h3> 痛点1：手动复制粘贴表格数据，耗时易错</h3>
<ul>
<li>需要逐行逐列选择数据，操作繁琐</li>
<li>容易选错数据或遗漏信息</li>
<li>大型表格处理时间更是让人抓头</li>
</ul>
<p>接下来我们实际演示一下，如何使用TableHelper来说实现表格的精确选择，像Excel一样，自由的选择你想要的区域</p>
<ul>
<li>单元格选择、多个单元格选择：按住ctrl + 点击单元格，支持多选</li>
<li>选中行：ctrl + alt + 单元格，选中这一列</li>
<li>选中列：alt + 单元格，选中这一列</li>
<li>区域选择： 选中一个单元格作为开始点位，然后按住 ctrl+shift，滑动鼠标就会看到你将选中的区域范围，当点击一个新的单元格之后，表示选中以这两个单元格位对角的区域范围</li>
<li>全标选择： ctrl + 单元格上双击</li>
</ul>
<figure><img src="/imgs/260116/03.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 痛点2：无法精确选择特定行列或区域数据</h3>
<ul>
<li>传统浏览器只支持简单的文本选择</li>
<li>无法进行复杂的表格数据筛选</li>
<li>不同列之间的数据难以关联</li>
</ul>
<p>使用TableHelper之后，自由选中行列就非常方便了（默认的设置中，选中列时，是不携带表头的，如果有需要可以在设置中打开哦~）</p>
<ul>
<li>自动识别表格结构和边界</li>
<li>支持跨行跨列的复杂选择</li>
<li>智能高亮显示选中区域</li>
</ul>
<figure><img src="/imgs/260116/04.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 痛点3：缺乏实时统计分析功能</h3>
<ul>
<li>需要将数据导出到Excel才能进行分析</li>
<li>无法快速查看数据概览</li>
<li>统计计算需要额外工具</li>
</ul>
<p>TableHelper 内置统计面板，支持</p>
<ul>
<li>实时显示选中数据的统计信息（计数、求和、平均值、最值等）</li>
<li>一键查看数据摘要</li>
<li>支持数值和文本两种统计模式</li>
</ul>
<figure><img src="/imgs/260116/05.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 痛点4：难以将网页表格数据快速转化为可用格式</h3>
<ul>
<li>数据格式转换复杂</li>
<li>需要手动整理和清洗</li>
<li>不同系统间数据兼容性问题</li>
</ul>
<p>选中单元格，通过侧边抽屉的基础操作，实现单元格的转换、列去重、列合并、行合并等基础变化</p>
<figure><img src="/imgs/260116/06.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>若我们需要针对选中的两列进行集合运算，比如交集、合集、差集时，同样可以通过侧边抽屉的操作来完成</p>
<figure><img src="/imgs/260116/07.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>对于常年和sql打交道后端研发，TableHelper还提供了一个非常有趣的sql能力生成，比如 select 查询语句生成</p>
<figure><img src="/imgs/260116/08.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>除了sql查询之外，自动生成insert语句也是很可以的</p>
<figure><img src="/imgs/260116/09.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>当然，update语句也不能缺少，我们可以直接根据表格内容，生成批量的update语句，支持自定义设置查询语句、更新语句</p>
<figure><img src="/imgs/260116/10.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如果发现侧边抽屉操作空间太小，限制了你的发挥，当然我们也内置了一个独立的工具页，用于支持上面的所有能力哦，通过进行换出</p>
<figure><img src="/imgs/260116/11.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 痛点5：数据安全与隐私担忧</h3>
<ul>
<li>担心数据被上传到第三方服务器</li>
<li>企业敏感信息泄露风险</li>
<li>需要离线处理能力</li>
</ul>
<p><strong>解决方案：本地处理与隐私保护</strong></p>
<ul>
<li>所有处理均在本地浏览器完成</li>
<li>无需上传任何数据</li>
<li>完全离线操作支持</li>
</ul>
<h2> 五、立即体验</h2>
<p>如果你也经常处理网页表格数据，强烈推荐试试Table Helper。安装简单，操作方便，关键是能大大提升工作效率。</p>
<p>想要提升表格处理效率的朋友们，赶紧下载试试吧！</p>
<ul>
<li>在线工具页：<a href="https://ai.hhui.top/tablehelper/index.html" target="_blank" rel="noopener noreferrer">TableHelper: 提供精准的选择工具与智能SQL生成器，你的网页表格瑞士军刀</a></li>
<li>谷歌插件商店：<a href="https://chromewebstore.google.com/detail/tablehelper/dklaelceomicpnakfmdonmghianjoiag" target="_blank" rel="noopener noreferrer">TableHelper: 提供精准的选择工具与智能SQL生成器，你的网页表格瑞士军刀</a></li>
<li>项目源码： <a href="https://github.com/liuyueyi/TableHelper#" target="_blank" rel="noopener noreferrer">TableHelper</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/260116/01.webp" type="image/webp"/>
    </item>
    <item>
      <title>D02.从0到1实现一个自然语言提取地址信息的智能体</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%BA%94%E7%94%A8%E7%AF%87/D02.%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E6%8F%90%E5%8F%96%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%BA%94%E7%94%A8%E7%AF%87/D02.%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E6%8F%90%E5%8F%96%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">D02.从0到1实现一个自然语言提取地址信息的智能体</source>
      <description>点击阅读全文 D02.从0到1实现一个自然语言提取地址信息的智能体 | Helllo LLM Guides</description>
      <category>SpringAI</category>
      <pubDate>Wed, 14 Jan 2026 10:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>点击阅读全文 <a href="https://www.ppai.top/ai-guides/ai-dev/%E5%BA%94%E7%94%A8%E7%AF%87/D02.%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E6%8F%90%E5%8F%96%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93.html" target="_blank" rel="noopener noreferrer">D02.从0到1实现一个自然语言提取地址信息的智能体 | Helllo LLM Guides</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>D03.从0到1实现一个发票信息提取智能体</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%BA%94%E7%94%A8%E7%AF%87/D03.%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%91%E7%A5%A8%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%E6%99%BA%E8%83%BD%E4%BD%93.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%BA%94%E7%94%A8%E7%AF%87/D03.%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%91%E7%A5%A8%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%E6%99%BA%E8%83%BD%E4%BD%93.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">D03.从0到1实现一个发票信息提取智能体</source>
      <description>点击阅读全文 D03.从0到1实现一个发票信息提取智能体 | Helllo LLM Guides</description>
      <category>SpringAI</category>
      <pubDate>Thu, 15 Jan 2026 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>点击阅读全文 <a href="https://www.ppai.top/ai-guides/ai-dev/%E5%BA%94%E7%94%A8%E7%AF%87/D03.%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%91%E7%A5%A8%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%E6%99%BA%E8%83%BD%E4%BD%93.html" target="_blank" rel="noopener noreferrer">D03.从0到1实现一个发票信息提取智能体 | Helllo LLM Guides</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>LLM 应用开发是什么：零基础也可以读懂的科普文(极简版)</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/01.llm%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%95%99%E5%AD%A6%E7%89%88%E6%95%99%E7%A8%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/01.llm%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%95%99%E5%AD%A6%E7%89%88%E6%95%99%E7%A8%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">LLM 应用开发是什么：零基础也可以读懂的科普文(极简版)</source>
      <description>LLM 应用开发教学版教程 面向对象：初级程序员 / 对 LLM 有基础认知、希望真正做出 LLM 应用的人 本教程不追求“模型原理深度”，而是帮助你一步步理解：为什么要这样做、如果不这样会出现什么问题。 LLM 应用开发是什么：零基础也可以读懂的科普文(极简版)</description>
      <category>LLM</category>
      <pubDate>Mon, 29 Dec 2025 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> LLM 应用开发教学版教程</h1>
<blockquote>
<p>面向对象：初级程序员 / 对 LLM 有基础认知、希望真正做出 LLM 应用的人</p>
<p>本教程不追求“模型原理深度”，而是帮助你<strong>一步步理解：为什么要这样做、如果不这样会出现什么问题</strong>。</p>
<p><a href="https://mp.weixin.qq.com/s/qCn8x2XO2shA8MheYbHq0w" target="_blank" rel="noopener noreferrer">LLM 应用开发是什么：零基础也可以读懂的科普文(极简版)</a></p>
</blockquote>
<hr>
<h2> 第 0 章：为什么现在的程序员，绕不开 LLM？</h2>
<p>在正式开始写代码之前，我们先停下来思考一个问题：</p>
<blockquote>
<p><strong>如果你已经会写后端、前端、脚本、接口，那 LLM 对你来说到底意味着什么？</strong></p>
</blockquote>
<p>很多初学者一开始接触 LLM，会有两种极端反应：</p>
<ul>
<li>一种是：<em>“这不就是个更聪明的聊天机器人吗？”</em></li>
<li>另一种是：<em>“以后是不是不用写代码了？”</em></li>
</ul>
<p>这两种理解，其实都不太准确。</p>
<p>这一章，我们只做一件事：</p>
<blockquote>
<p><strong>帮你建立一个“正确的位置感”：LLM 在软件系统中，究竟扮演什么角色。</strong></p>
</blockquote>
<hr>
<h3> 0.1 传统程序解决问题的方式，有什么局限？</h3>
<p>先回到你熟悉的世界。</p>
<p>在没有 LLM 之前，一个程序通常是这样工作的：</p>
<ul>
<li>输入是<strong>结构化的</strong>（表单、参数、JSON）</li>
<li>逻辑是<strong>确定的</strong>（if / else、规则、流程）</li>
<li>输出是<strong>可预期的</strong></li>
</ul>
<p>这套模式非常稳定，也非常可靠。</p>
<p>但它有一个明显前提：</p>
<blockquote>
<p><strong>问题本身，必须是“可以被提前描述清楚的”。</strong></p>
</blockquote>
<p>举几个你可能遇到过的真实场景：</p>
<ul>
<li>用户输入一段“很随意”的自然语言描述</li>
<li>文档是 PDF / Word / Markdown，结构混乱</li>
<li>用户的问题，每次问法都不一样</li>
</ul>
<p>这时你会发现：</p>
<blockquote>
<p>👉 规则开始爆炸
👉 if / else 越来越多
👉 覆盖不全、维护困难</p>
</blockquote>
<p>不是你写得不好，而是<strong>问题本身已经不适合用纯规则解决了</strong>。</p>
<hr>
<h3> 0.2 LLM 带来的真正变化是什么？</h3>
<p>LLM 并没有取代程序员，它真正改变的是这一点：</p>
<blockquote>
<p><strong>程序第一次拥有了“理解非结构化输入”的能力。</strong></p>
</blockquote>
<p>注意这里的关键词：</p>
<ul>
<li>不是“理解世界”</li>
<li>而是“理解语言形式上的意图”</li>
</ul>
<p>这意味着什么？</p>
<p>以前你需要做的事情是：</p>
<blockquote>
<p>把用户输入 → 强行变成结构化数据 → 再处理</p>
</blockquote>
<p>而现在你可以：</p>
<blockquote>
<p>把“理解这件事”本身，交给模型</p>
</blockquote>
<p>程序员的角色开始发生变化：</p>
<ul>
<li>从“写规则的人”</li>
<li>变成“设计约束和流程的人”</li>
</ul>
<p>这也是为什么我们说：</p>
<blockquote>
<p><strong>LLM 应用开发，本质是工程问题，而不是模型问题。</strong></p>
</blockquote>
<hr>
<h3> 0.3 什么叫“LLM 应用开发”？</h3>
<p>很多人一开始会把 LLM 应用理解为：</p>
<blockquote>
<p>“写几个 Prompt，调个 API，就完了”</p>
</blockquote>
<p>但在真实项目中，很快你就会遇到这些问题：</p>
<ul>
<li>模型有时会胡说八道</li>
<li>对话一长，它就开始“失忆”</li>
<li>不同用户，需要不同风格的回答</li>
<li>数据是私有的，模型根本没见过</li>
</ul>
<p>于是你会发现：</p>
<blockquote>
<p><strong>真正的 LLM 应用 = 模型 + 工程系统</strong></p>
</blockquote>
<p>一个完整的 LLM 应用，通常至少包含：</p>
<ul>
<li>模型调用（API）</li>
<li>提示词设计（Prompt）</li>
<li>上下文与记忆管理</li>
<li>外部知识接入（RAG）</li>
<li>工具 / 接口调用（Function Calling）</li>
</ul>
<p>本教程接下来所有内容，都会围绕这些组件展开。</p>
<hr>
<h3> 0.4 在开始之前，你需要一个心理预期</h3>
<p>在正式进入技术细节前，有三点非常重要的心理预期：</p>
<ol>
<li>
<p><strong>LLM 不是银弹</strong><br>
它能解决一类问题，但不是所有问题。</p>
</li>
<li>
<p><strong>LLM 会犯错，而且看起来很自信</strong><br>
你必须为它设计“兜底机制”。</p>
</li>
<li>
<p><strong>写好 LLM 应用，比写 Demo 难得多</strong><br>
真正的难点在工程设计，而不是 API 调用。</p>
</li>
</ol>
<p>如果你带着这个预期继续往下读，后面的内容会顺很多。</p>
<hr>
<h3> 本章小结</h3>
<p>这一章你只需要记住三件事：</p>
<ul>
<li>LLM 的价值，在于处理非结构化语言</li>
<li>LLM 应用开发，是一门工程能力</li>
<li>后面的每一章，都是为了解决一个“你一定会遇到的问题”</li>
</ul>
<p>下一章，我们不会立刻写代码，而是先回答一个更基础的问题：</p>
<blockquote>
<p><strong>LLM 到底能做什么？又有哪些事情，是它天然做不好的？</strong></p>
</blockquote>
<hr>
<h2> 第 1 章：LLM 能做什么？不能做什么？</h2>
<p>在真正开始调用模型之前，我们必须先回答一个非常现实的问题：</p>
<blockquote>
<p><strong>哪些问题适合交给 LLM？哪些问题一开始就不该用它？</strong></p>
</blockquote>
<p>如果这个判断一开始就错了，后面 Prompt 写得再好、RAG 再复杂，效果也很难理想。</p>
<p>这一章的目标只有一个：</p>
<blockquote>
<p><strong>帮你建立对 LLM 能力边界的直觉判断。</strong></p>
</blockquote>
<hr>
<h3> 1.1 LLM 最擅长做的事情是什么？</h3>
<p>先说结论：</p>
<blockquote>
<p><strong>LLM 最擅长的，是“处理语言本身”。</strong></p>
</blockquote>
<p>这里的“处理”，并不是指“懂世界”，而是指：</p>
<ul>
<li>理解语言里的意图</li>
<li>生成符合上下文的自然语言</li>
<li>在已有信息基础上进行组织、改写、总结</li>
</ul>
<p>你可以把 LLM 想象成一个：</p>
<blockquote>
<p><strong>极其擅长阅读、写作和模仿语言风格的系统</strong></p>
</blockquote>
<p>基于这一点，它在下面这些场景中，往往表现得很好。</p>
<hr>
<h4> 场景一：信息整理与改写</h4>
<p>例如：</p>
<ul>
<li>把一段很长的文字总结成要点</li>
<li>把技术文档改写成用户能看懂的说明</li>
<li>把零散的会议记录整理成结构化结论</li>
</ul>
<p>这些任务的共同点是：</p>
<ul>
<li>输入是自然语言</li>
<li>输出仍然是自然语言</li>
<li>不要求“绝对精确”，而是“整体合理”</li>
</ul>
<p>LLM 在这类任务上，往往比纯规则系统简单得多、效果也更好。</p>
<hr>
<h4> 场景二：基于上下文的问答</h4>
<p>例如：</p>
<ul>
<li>“帮我解释一下这段代码在干什么”</li>
<li>“根据这份文档，回答用户的问题”</li>
<li>“用更通俗的方式解释这个概念”</li>
</ul>
<p>只要你能把<strong>必要的信息</strong>提供给模型，它就能基于上下文进行回答。</p>
<p>这也是后面 RAG 技术存在的根本原因。</p>
<hr>
<h4> 场景三：语言风格与角色模拟</h4>
<p>你可能已经体验过：</p>
<ul>
<li>让模型用“老师的口吻”解释问题</li>
<li>用“客服风格”回复用户</li>
<li>模拟某种固定的写作风格</li>
</ul>
<p>这并不是模型“在演戏”，而是因为：</p>
<blockquote>
<p><strong>语言风格本身，就是一种可以被学习的模式。</strong></p>
</blockquote>
<hr>
<h3> 1.2 那它不擅长什么？</h3>
<p>理解 LLM 的能力边界，比理解它的能力本身更重要。</p>
<p>下面这些事情，是 LLM <strong>天然就不擅长</strong>，甚至是“危险的”。</p>
<hr>
<h4> 不擅长一：精确计算和绝对正确性</h4>
<p>LLM 并不是计算器。</p>
<p>当你问它：</p>
<ul>
<li>精确的数学结果</li>
<li>严格的逻辑证明</li>
<li>每一步都不能出错的推导</li>
</ul>
<p>它<strong>有可能给你一个“看起来合理，但实际上错误”的答案</strong>。</p>
<p>原因很简单：</p>
<blockquote>
<p><strong>它追求的是“语言上的合理性”，而不是“结果上的正确性”。</strong></p>
</blockquote>
<hr>
<h4> 不擅长二：最新、私有或未提供的信息</h4>
<p>模型的训练数据是有限的。</p>
<p>如果你问它：</p>
<ul>
<li>最新发生的事情</li>
<li>公司内部的数据</li>
<li>你电脑里的某个文件内容</li>
</ul>
<p>在没有额外手段的情况下，它只能：</p>
<blockquote>
<p><strong>猜一个最像真的答案</strong></p>
</blockquote>
<p>这正是“幻觉”问题的来源之一。</p>
<hr>
<h4> 不擅长三：替你做判断和承担责任</h4>
<p>LLM 可以给你建议，但它：</p>
<ul>
<li>不对结果负责</li>
<li>不知道真实世界的后果</li>
<li>无法替你做价值判断</li>
</ul>
<p>所以在：</p>
<ul>
<li>法律</li>
<li>医疗</li>
<li>金融决策</li>
</ul>
<p>等高风险场景中，<strong>它只能作为辅助，而不能作为最终决策者</strong>。</p>
<hr>
<h3> 1.3 一个非常重要的结论</h3>
<p>到这里，我们可以得出一个对后续所有章节都非常重要的结论：</p>
<blockquote>
<p><strong>LLM 适合做“语言层面的智能”，而不是“事实层面的权威”。</strong></p>
</blockquote>
<p>这句话你可以多读几遍。</p>
<p>它几乎解释了后面所有技术为什么存在：</p>
<ul>
<li>Prompt：为了让模型“更好地理解你想要什么”</li>
<li>上下文管理：为了让模型“别忘了已经说过什么”</li>
<li>RAG：为了让模型“基于真实资料说话”</li>
<li>Function Calling：为了让模型“不要自己瞎编，而是去调用系统”</li>
</ul>
<hr>
<h3> 本章小结</h3>
<p>这一章，你只需要记住三点：</p>
<ol>
<li>LLM 擅长处理自然语言</li>
<li>LLM 不保证事实绝对正确</li>
<li>用不用 LLM，首先是一个<strong>工程判断</strong></li>
</ol>
<p>下一章，我们终于要开始真正“用模型”了。</p>
<p>但在写任何复杂逻辑之前，我们会先做一件很基础、但非常关键的事情：</p>
<blockquote>
<p><strong>把 LLM 接进你的程序，搞清楚你到底在和什么交互。</strong></p>
</blockquote>
<hr>
<h2> 第 2 章：第一次把 LLM 接进你的程序</h2>
<p>在前两章，我们一直在讲“为什么”和“能不能”。</p>
<p>从这一章开始，我们终于要做一件非常具体的事情：</p>
<blockquote>
<p><strong>把大语言模型，当成一个真正的系统组件，接进你的程序里。</strong></p>
</blockquote>
<p>这一章不会追求复杂功能，它的目标只有一个：</p>
<blockquote>
<p><strong>让你清楚：你到底在和什么交互。</strong></p>
</blockquote>
<p>如果这一点没想清楚，后面所有 Prompt、RAG、Agent，都会变成“玄学调参”。</p>
<hr>
<h3> 2.1 调用 LLM，本质上是在做什么？</h3>
<p>先说一个非常容易被忽略的事实：</p>
<blockquote>
<p><strong>你调用 LLM，并不是在“和一个人聊天”。</strong></p>
</blockquote>
<p>从工程角度看，你在做的事情其实是：</p>
<ul>
<li>构造一次请求</li>
<li>把一段上下文发给模型</li>
<li>让模型基于这些上下文，生成下一段文本</li>
</ul>
<p>也就是说：</p>
<blockquote>
<p><strong>每一次调用，模型都是“一次性地”看完整个输入。</strong></p>
</blockquote>
<p>它不会自动记住你上一次说了什么，除非：</p>
<blockquote>
<p>👉 你把这些内容，再一次发给它</p>
</blockquote>
<p>这个认知，对理解后面的“上下文管理”非常重要。</p>
<hr>
<h3> 2.2 messages：你真正传给模型的是什么？</h3>
<p>在大多数 LLM API 中，你都会看到一个类似的结构：</p>
<ul>
<li>model</li>
<li>messages</li>
</ul>
<p>其中，<code>messages</code> 往往是一个列表，看起来像是“聊天记录”。</p>
<p>但从模型的视角来看：</p>
<blockquote>
<p><strong>它不是聊天记录，而是一段“完整的输入文本”。</strong></p>
</blockquote>
<p>模型并不知道哪一句是“刚刚发生的”，
它只看到：</p>
<blockquote>
<p>“现在，有这样一段内容，请继续往下写。”</p>
</blockquote>
<hr>
<h3> 2.3 system / user / assistant 角色，到底有什么用？</h3>
<p>在 <code>messages</code> 中，通常会看到三种角色：</p>
<ul>
<li>system</li>
<li>user</li>
<li>assistant</li>
</ul>
<p>很多初学者会以为：</p>
<blockquote>
<p>“这些角色是给模型‘分身份’用的。”</p>
</blockquote>
<p>但更准确的理解是：</p>
<blockquote>
<p><strong>它们是用来给模型不同“权重和语义提示”的。</strong></p>
</blockquote>
<hr>
<h4> system：全局约束和行为边界</h4>
<p><code>system</code> 的作用是：</p>
<blockquote>
<p><strong>告诉模型：你是谁，你应该如何整体地表现。</strong></p>
</blockquote>
<p>例如：</p>
<ul>
<li>你是一个严谨的技术助手</li>
<li>回答时不要编造不存在的内容</li>
<li>输出必须是 JSON 格式</li>
</ul>
<p>你可以把 <code>system</code> 理解为：</p>
<blockquote>
<p><strong>整次生成过程的“最高优先级说明书”</strong></p>
</blockquote>
<hr>
<h4> user：具体任务和问题</h4>
<p><code>user</code> 消息，通常代表：</p>
<ul>
<li>当前用户提出的问题</li>
<li>当前这一次调用想要完成的任务</li>
</ul>
<p>它关注的是：</p>
<blockquote>
<p><strong>这一次你希望模型做什么。</strong></p>
</blockquote>
<hr>
<h4> assistant：历史输出，用来“延续上下文”</h4>
<p><code>assistant</code> 并不是模型自己生成的“实时内容”，
而是：</p>
<blockquote>
<p><strong>你主动提供给模型的、它“之前说过的话”。</strong></p>
</blockquote>
<p>这样做的目的只有一个：</p>
<blockquote>
<p><strong>让模型在新的生成中，延续之前的对话风格和内容。</strong></p>
</blockquote>
<hr>
<h3> 2.4 一个重要但反直觉的结论</h3>
<p>到这里，我们可以得出一个非常关键的结论：</p>
<blockquote>
<p><strong>模型并不“记得”任何东西，除非你把它再发给它。</strong></p>
</blockquote>
<p>所谓的“多轮对话”，在工程上其实是：</p>
<blockquote>
<p><strong>你不断把历史对话，重新打包发给模型。</strong></p>
</blockquote>
<p>这也解释了两个常见现象：</p>
<ul>
<li>对话越长，成本越高</li>
<li>对话越长，模型越容易“跑偏”</li>
</ul>
<p>这不是模型变笨了，而是：</p>
<blockquote>
<p><strong>输入变得又长又杂了。</strong></p>
</blockquote>
<hr>
<h3> 2.5 为什么这一章不急着讲 Prompt 技巧？</h3>
<p>你可能已经注意到：</p>
<blockquote>
<p>这一章我们几乎没有讲“怎么写 Prompt”。</p>
</blockquote>
<p>这是刻意的。</p>
<p>因为在你没有理解：</p>
<ul>
<li>模型怎么看输入</li>
<li>角色是怎么影响生成的</li>
<li>上下文是如何被一次性消费的</li>
</ul>
<p>之前，所有 Prompt 技巧，都会变成：</p>
<blockquote>
<p>“试出来的经验，而不是可复用的方法。”</p>
</blockquote>
<hr>
<h3> 本章小结</h3>
<p>这一章你需要记住的，其实只有三点：</p>
<ol>
<li>LLM API 是一次性生成，不是持续对话</li>
<li>messages 是完整输入，而不是增量补丁</li>
<li>system / user / assistant 是语义提示工具</li>
</ol>
<p>下一章，我们终于要开始面对一个所有人都会遇到的问题：</p>
<blockquote>
<p><strong>为什么我明明说得很清楚，模型却总是答非所问？</strong></p>
</blockquote>
<p>这将引出 LLM 应用开发中，最基础、也是最容易被误解的一件事：</p>
<blockquote>
<p><strong>Prompt 的本质。</strong></p>
</blockquote>
<hr>
<h2> 第 3 章：为什么模型总是答非所问？——Prompt 的本质</h2>
<p>如果你已经实际调用过 LLM，大概率遇到过这样的情况：</p>
<blockquote>
<p>你觉得自己已经说得很清楚了，
但模型给你的回答却：</p>
<ul>
<li>跑题</li>
<li>太泛</li>
<li>或者完全不是你想要的形式</li>
</ul>
</blockquote>
<p>于是你开始不断修改 Prompt：</p>
<ul>
<li>多加几句话</li>
<li>换一种说法</li>
<li>反复“试到对”为止</li>
</ul>
<p>这一章，我们要解决的正是这个问题：</p>
<blockquote>
<p><strong>为什么 Prompt 会失效？以及，什么才是“有效 Prompt”的本质。</strong></p>
</blockquote>
<hr>
<h3> 3.1 一个常见误区：把 Prompt 当成“问题”</h3>
<p>很多初学者写 Prompt 时，脑子里想的是：</p>
<blockquote>
<p>“我该怎么把问题问清楚？”</p>
</blockquote>
<p>但模型接收到的，并不是一个“问题”，而是：</p>
<blockquote>
<p><strong>一段用来继续生成文本的上下文。</strong></p>
</blockquote>
<p>这意味着：</p>
<ul>
<li>模型不会自动帮你补全目标</li>
<li>也不会自动知道你“想用这个结果干嘛”</li>
</ul>
<p>如果上下文里没有清楚地体现任务，
模型只能按照“语言概率”自由发挥。</p>
<hr>
<h3> 3.2 Prompt 的真实角色：任务说明书</h3>
<p>一个更准确的理解是：</p>
<blockquote>
<p><strong>Prompt 不是提问，而是任务说明书。</strong></p>
</blockquote>
<p>想象你把一项工作交给一个新同事：</p>
<ul>
<li>你会只丢一句话给他吗？</li>
<li>还是会说明：
<ul>
<li>要做什么</li>
<li>用什么方式做</li>
<li>结果要长什么样</li>
</ul>
</li>
</ul>
<p>LLM 也是一样。</p>
<p>当你只给它一句模糊的问题时，
它只能给你一个“看起来像回答”的文本。</p>
<hr>
<h3> 3.3 一个有效 Prompt，至少要回答三个问题</h3>
<p>从工程角度看，一个可控的 Prompt，通常需要明确三件事：</p>
<hr>
<h4> 第一件事：你希望它“扮演什么角色”？</h4>
<p>这通常通过 <code>system</code> 或开头的角色描述完成。</p>
<p>例如：</p>
<ul>
<li>你是一个资深 Java 后端工程师</li>
<li>你是一个严谨的技术文档助手</li>
</ul>
<p>角色并不是装饰，而是在<strong>限制生成空间</strong>。</p>
<hr>
<h4> 第二件事：你希望它“完成什么任务”？</h4>
<p>这里要避免的，是只描述问题本身。</p>
<p>更好的方式是直接说明：</p>
<ul>
<li>请你做分析</li>
<li>请你给出步骤</li>
<li>请你输出结构化结果</li>
</ul>
<p>也就是说：</p>
<blockquote>
<p><strong>直接告诉模型你要的“动作”，而不是只给素材。</strong></p>
</blockquote>
<hr>
<h4> 第三件事：你希望“结果长什么样”？</h4>
<p>这是最容易被忽略的一点。</p>
<p>模型并不知道你：</p>
<ul>
<li>是要一段解释</li>
<li>还是一份列表</li>
<li>还是 JSON / Markdown</li>
</ul>
<p>如果你不说明，
它会选择“最通用、最安全”的输出方式。</p>
<hr>
<h3> 3.4 Zero-shot 和 Few-shot，是怎么被“逼出来的”？</h3>
<p>当你发现：</p>
<blockquote>
<p>“我已经写得很清楚了，它还是不稳定”</p>
</blockquote>
<p>通常不是模型不够聪明，而是：</p>
<blockquote>
<p><strong>它不知道你心里那个‘参考答案长什么样’。</strong></p>
</blockquote>
<p>这时，就会自然出现两种做法。</p>
<hr>
<h4> Zero-shot：只给说明，不给示例</h4>
<ul>
<li>适合规则简单、边界清晰的任务</li>
<li>成本低，但不稳定</li>
</ul>
<hr>
<h4> Few-shot：直接给几个示例</h4>
<ul>
<li>告诉模型：
<blockquote>
<p>“照着这个样子来”</p>
</blockquote>
</li>
</ul>
<p>示例的作用不是“教知识”，而是：</p>
<blockquote>
<p><strong>在输入中，明确什么是“好输出”。</strong></p>
</blockquote>
<hr>
<h3> 3.5 为什么 Prompt 永远不可能解决所有问题？</h3>
<p>到这里，你可能会产生一个错觉：</p>
<blockquote>
<p>“那我是不是只要把 Prompt 写得足够复杂就行了？”</p>
</blockquote>
<p>很遗憾，答案是否定的。</p>
<p>原因在于：</p>
<ul>
<li>Prompt 仍然只是文本</li>
<li>模型仍然只是在“生成下一个词”</li>
</ul>
<p>当任务涉及：</p>
<ul>
<li>真实世界的事实</li>
<li>私有或大量数据</li>
<li>严格的一致性要求</li>
</ul>
<p><strong>Prompt 的能力就会到达上限。</strong></p>
<p>这不是技巧问题，而是能力边界问题。</p>
<hr>
<h3> 本章小结</h3>
<p>这一章，你需要记住的不是“Prompt 模板”，而是三个核心认知：</p>
<ol>
<li>Prompt 是任务说明书，不是问题</li>
<li>角色、任务、输出格式同样重要</li>
<li>Prompt 有上限，不能解决所有问题</li>
</ol>
<p>下一章，我们将面对另一个所有人都会遇到的现实问题：</p>
<blockquote>
<p><strong>聊着聊着，模型为什么就开始“忘事”了？</strong></p>
</blockquote>
<p>这将引出 LLM 应用开发中，非常关键的一环：</p>
<blockquote>
<p><strong>上下文与记忆管理。</strong></p>
</blockquote>
<hr>
<h2> 第 4 章：聊着聊着它就忘了？——上下文与记忆管理</h2>
<p>当你把 Prompt 写得越来越清楚之后，通常会遇到下一个问题：</p>
<blockquote>
<p>对话刚开始时一切正常，
但聊着聊着，模型就开始：</p>
<ul>
<li>忘记前面说过的约束</li>
<li>前后回答自相矛盾</li>
<li>或者突然换了一种风格</li>
</ul>
</blockquote>
<p>很多初学者会直觉地认为：</p>
<blockquote>
<p>“是不是模型不稳定？”</p>
</blockquote>
<p>但实际上，问题几乎从来不在模型身上。</p>
<p>这一章，我们要彻底讲清楚：</p>
<blockquote>
<p><strong>LLM 为什么会‘忘事’，以及我们在工程上该如何应对。</strong></p>
</blockquote>
<hr>
<h3> 4.1 一个必须先打破的误解：模型并没有记忆</h3>
<p>先说结论：</p>
<blockquote>
<p><strong>LLM 本身并不具备持续记忆。</strong></p>
</blockquote>
<p>在第 2 章我们已经提到过：</p>
<ul>
<li>每一次调用</li>
<li>模型看到的都是<strong>一次性完整输入</strong></li>
</ul>
<p>这意味着：</p>
<blockquote>
<p><strong>所谓“记住”，只是你把历史内容再次发给了它。</strong></p>
</blockquote>
<p>如果你没有把某段信息放进当前请求中，
那对模型来说，这段信息就是不存在的。</p>
<hr>
<h3> 4.2 什么是上下文窗口？（直觉理解）</h3>
<p>模型并不是可以无限读取输入的。</p>
<p>它有一个限制，通常被称为：</p>
<blockquote>
<p><strong>上下文窗口（Context Window）</strong></p>
</blockquote>
<p>你可以把它想象成：</p>
<blockquote>
<p>模型在生成回答时，
能“同时看到”的最大文本长度。</p>
</blockquote>
<p>当输入内容超过这个长度时：</p>
<ul>
<li>早期的内容会被截断</li>
<li>或者根本无法被模型同时考虑</li>
</ul>
<p>于是就会出现一种现象：</p>
<blockquote>
<p><strong>模型并不是选择性遗忘，而是根本“看不到”。</strong></p>
</blockquote>
<hr>
<h3> 4.3 为什么对话越长，效果越容易变差？</h3>
<p>即使没有超过上下文窗口，
对话变长也会带来新的问题。</p>
<p>原因主要有三个：</p>
<hr>
<h4> 原因一：重要信息被淹没</h4>
<p>当你把大量历史对话一股脑塞给模型时：</p>
<ul>
<li>新的任务</li>
<li>旧的闲聊</li>
<li>无关的中间推理</li>
</ul>
<p>都会混在一起。</p>
<p>模型并不知道：</p>
<blockquote>
<p>哪些是“你现在最关心的”。</p>
</blockquote>
<hr>
<h4> 原因二：早期约束逐渐失效</h4>
<p>即使你在最开始的 <code>system</code> 中设定了规则，</p>
<p>随着输入变长：</p>
<ul>
<li>后续内容的影响会越来越大</li>
<li>早期指令的“权重”会被稀释</li>
</ul>
<p>于是你会感觉：</p>
<blockquote>
<p>模型开始“不听话了”。</p>
</blockquote>
<hr>
<h4> 原因三：成本和延迟直线上升</h4>
<p>上下文越长：</p>
<ul>
<li>每次调用消耗的 token 越多</li>
<li>响应时间越长</li>
<li>成本越不可控</li>
</ul>
<p>这在真实系统中，往往是不可接受的。</p>
<hr>
<h3> 4.4 工程上常见的三种记忆策略</h3>
<p>既然不能无限塞上下文，
那工程上通常会怎么做？</p>
<p>实际上，常见的策略只有三种。</p>
<hr>
<h4> 策略一：全量上下文（最简单，也最脆弱）</h4>
<p>做法：</p>
<ul>
<li>把所有历史对话原样保留</li>
<li>每次请求全部发送</li>
</ul>
<p>优点：</p>
<ul>
<li>实现最简单</li>
<li>短对话效果好</li>
</ul>
<p>缺点：</p>
<ul>
<li>极易超出上下文窗口</li>
<li>成本高</li>
<li>长对话必然失控</li>
</ul>
<p>适合：</p>
<ul>
<li>Demo</li>
<li>非常短的交互</li>
</ul>
<hr>
<h4> 策略二：摘要记忆（折中方案）</h4>
<p>做法：</p>
<ul>
<li>定期把历史对话压缩成摘要</li>
<li>只保留关键信息和结论</li>
</ul>
<p>这样做的本质是：</p>
<blockquote>
<p><strong>用“信息密度”，换“上下文长度”。</strong></p>
</blockquote>
<p>优点：</p>
<ul>
<li>成本可控</li>
<li>能保留整体语义</li>
</ul>
<p>缺点：</p>
<ul>
<li>细节不可逆丢失</li>
<li>摘要质量直接影响效果</li>
</ul>
<hr>
<h4> 策略三：向量记忆（为后面 RAG 做铺垫）</h4>
<p>做法：</p>
<ul>
<li>把历史信息向量化</li>
<li>在需要时进行检索</li>
<li>只把相关内容送入上下文</li>
</ul>
<p>这种方式的关键思想是：</p>
<blockquote>
<p><strong>不是“全记住”，而是“按需回忆”。</strong></p>
</blockquote>
<p>优点：</p>
<ul>
<li>可扩展</li>
<li>不受上下文长度限制</li>
</ul>
<p>缺点：</p>
<ul>
<li>实现复杂</li>
<li>需要额外系统支持</li>
</ul>
<hr>
<h3> 4.5 一个重要的工程认知</h3>
<p>到这里，你应该能意识到一件事：</p>
<blockquote>
<p><strong>上下文管理不是 Prompt 问题，而是系统设计问题。</strong></p>
</blockquote>
<p>很多“模型突然变差”的问题，
本质上都是：</p>
<ul>
<li>信息组织失败</li>
<li>重要内容没有被正确送达</li>
</ul>
<p>这也是为什么：</p>
<blockquote>
<p><strong>只靠 Prompt，永远做不好复杂对话系统。</strong></p>
</blockquote>
<hr>
<h3> 本章小结</h3>
<p>这一章你需要记住的核心点是：</p>
<ol>
<li>模型没有记忆，只有你提供的上下文</li>
<li>上下文窗口是硬限制</li>
<li>记忆策略是工程取舍</li>
</ol>
<p>下一章，我们将面对一个更棘手、也更危险的问题：</p>
<blockquote>
<p><strong>模型为什么会“一本正经地胡说八道”？</strong></p>
</blockquote>
<p>这将引出 LLM 应用开发中，绕不开的主题：</p>
<blockquote>
<p><strong>幻觉问题。</strong></p>
</blockquote>
<hr>
<h2> 第 5 章：它为什么会“一本正经地胡说八道”？——幻觉问题</h2>
<p>如果你已经按照前面的章节做过一些尝试，那么很可能遇到过下面这种情况：</p>
<blockquote>
<p>模型回答得非常完整，
语气也很自信，
逻辑看起来还挺通顺，
但你越核对，越发现哪里不对。</p>
</blockquote>
<p>很多人第一次遇到这种情况时，都会有点“崩溃”：</p>
<blockquote>
<p>“这也太不靠谱了吧？”</p>
</blockquote>
<p>这一章，我们要做的不是吐槽模型，
而是回答一个非常关键的问题：</p>
<blockquote>
<p><strong>模型为什么会胡说八道？而且还说得这么像真的？</strong></p>
</blockquote>
<hr>
<h3> 5.1 先说结论：幻觉不是 Bug</h3>
<p>先给出一个可能有点反直觉的结论：</p>
<blockquote>
<p><strong>幻觉不是模型的 Bug，而是它工作方式的自然结果。</strong></p>
</blockquote>
<p>回到最本质的一点：</p>
<ul>
<li>LLM 的目标是</li>
<li>在给定上下文下</li>
<li>生成“最可能出现的下一个词”</li>
</ul>
<p>注意这里的关键词是：</p>
<blockquote>
<p><strong>“最可能”，而不是“最正确”。</strong></p>
</blockquote>
<p>当模型面对一个它并不真正“知道答案”的问题时，
它并不会停下来告诉你“我不知道”。</p>
<p>相反，它会：</p>
<blockquote>
<p><strong>尽可能生成一个“看起来合理”的答案。</strong></p>
</blockquote>
<p>这就是幻觉的根源。</p>
<hr>
<h3> 5.2 幻觉通常在什么情况下出现？</h3>
<p>虽然幻觉不可避免，但它并不是随机发生的。</p>
<p>在工程实践中，幻觉往往集中出现在以下几类场景。</p>
<hr>
<h4> 场景一：信息不完整或上下文模糊</h4>
<p>当你给模型的信息不足时：</p>
<ul>
<li>问题范围很大</li>
<li>关键条件没有说明</li>
<li>或者上下文前后矛盾</li>
</ul>
<p>模型只能“自行补全”。</p>
<p>而补全的依据，只能是训练时学到的语言模式。</p>
<hr>
<h4> 场景二：询问模型并不具备的知识</h4>
<p>例如：</p>
<ul>
<li>最新发生的事件</li>
<li>公司内部的业务数据</li>
<li>你本地系统的状态</li>
</ul>
<p>在这些情况下，</p>
<blockquote>
<p><strong>模型既看不到真实数据，也无法访问外部系统。</strong></p>
</blockquote>
<p>于是它只能编一个。</p>
<hr>
<h4> 场景三：要求模型给出“权威结论”</h4>
<p>当你让模型：</p>
<ul>
<li>下判断</li>
<li>给结论</li>
<li>承担决策责任</li>
</ul>
<p>幻觉风险会显著升高。</p>
<p>因为模型并不知道：</p>
<blockquote>
<p>错了会有什么后果。</p>
</blockquote>
<hr>
<h3> 5.3 为什么幻觉在真实应用中很危险？</h3>
<p>在一些轻量场景中，幻觉可能只是“有点不准”。</p>
<p>例如：</p>
<ul>
<li>聊天</li>
<li>头脑风暴</li>
<li>文案草稿</li>
</ul>
<p>但在下面这些场景中，幻觉是不可接受的：</p>
<ul>
<li>企业知识问答</li>
<li>技术文档查询</li>
<li>法律、医疗、金融相关系统</li>
</ul>
<p>原因很简单：</p>
<blockquote>
<p><strong>用户无法分辨哪些内容是模型“编的”。</strong></p>
</blockquote>
<p>如果系统本身又没有做校验或限制，
那么：</p>
<blockquote>
<p>错误信息会被当成事实传播。</p>
</blockquote>
<hr>
<h3> 5.4 一个重要的工程判断：哪些幻觉可以容忍？</h3>
<p>在进入解决方案之前，我们先明确一件事：</p>
<blockquote>
<p><strong>不是所有幻觉，都必须被彻底消除。</strong></p>
</blockquote>
<p>在工程上，你通常需要做的是：</p>
<ul>
<li>区分“可容忍的幻觉”</li>
<li>和“必须消除的幻觉”</li>
</ul>
<p>例如：</p>
<ul>
<li>写创意文案时，少量编造是可以接受的</li>
<li>但在查询公司制度时，一句编造就是严重事故</li>
</ul>
<p>这一步判断，决定了你后续系统的复杂度。</p>
<hr>
<h3> 5.5 为什么 Prompt 解决不了幻觉？</h3>
<p>很多初学者会尝试在 Prompt 中加上类似：</p>
<blockquote>
<p>“如果不知道，请直接说不知道”</p>
</blockquote>
<p>有时有效，但你很快会发现：</p>
<ul>
<li>它并不稳定</li>
<li>在复杂场景下几乎必然失效</li>
</ul>
<p>原因在于：</p>
<blockquote>
<p><strong>Prompt 只能影响生成倾向，无法改变模型是否“知道”。</strong></p>
</blockquote>
<p>当模型缺乏事实基础时，
再严格的 Prompt，
也只能降低幻觉概率，而无法消除。</p>
<hr>
<h3> 5.6 解决幻觉的根本思路是什么？</h3>
<p>到这里，其实答案已经呼之欲出了。</p>
<p>如果幻觉的根源在于：</p>
<blockquote>
<p><strong>模型没有真实、可靠的信息来源</strong></p>
</blockquote>
<p>那么解决思路也就很明确：</p>
<blockquote>
<p><strong>不要让模型凭空回答，让它基于你提供的真实资料回答。</strong></p>
</blockquote>
<p>也就是说：</p>
<ul>
<li>把“事实”从模型训练中解耦出来</li>
<li>在推理阶段，把真实资料送给模型</li>
</ul>
<p>这正是下一章要介绍的核心技术：</p>
<blockquote>
<p><strong>RAG（Retrieval-Augmented Generation）。</strong></p>
</blockquote>
<hr>
<h3> 本章小结</h3>
<p>这一章你需要牢牢记住的几点是：</p>
<ol>
<li>幻觉不是 Bug，而是模型特性</li>
<li>幻觉在信息不足时几乎不可避免</li>
<li>Prompt 无法根治幻觉</li>
<li>解决幻觉需要外部真实信息</li>
</ol>
<p>下一章，我们将正式进入 LLM 应用开发中
<strong>最重要、也是最具工程价值的一项能力</strong>：</p>
<blockquote>
<p><strong>让模型基于你的数据回答问题。</strong></p>
</blockquote>
<h2> 第 6 章：RAG —— 让模型基于真实资料回答问题（系统设计视角）</h2>
<p>在上一章，我们已经得出了一个非常明确的结论：</p>
<blockquote>
<p><strong>只要模型缺乏可靠的事实来源，幻觉就一定会出现。</strong></p>
</blockquote>
<p>因此，真正严肃的 LLM 应用，必须回答一个问题：</p>
<blockquote>
<p><strong>系统如何为模型“提供事实”，而不是让它凭空猜？</strong></p>
</blockquote>
<p>RAG（Retrieval-Augmented Generation）并不是一个技巧，而是一种<strong>系统设计模式</strong>。</p>
<p>这一章，我们会站在工程和系统设计的角度，把 RAG 讲清楚。</p>
<hr>
<h3> 6.1 一个几乎所有人都会走过的弯路</h3>
<p>在第一次做“基于文档的问答”时，很多人都会自然想到：</p>
<blockquote>
<p>“那我是不是把文档内容直接塞进 Prompt 就行了？”</p>
</blockquote>
<p>在文档很短、用户很少的情况下，这种做法<strong>确实能跑起来</strong>。</p>
<p>但一旦进入真实系统，你很快就会遇到：</p>
<ul>
<li>文档内容远超上下文窗口</li>
<li>成本随着文档长度线性上涨</li>
<li>模型抓不住重点，回答质量反而下降</li>
</ul>
<p>这时你会意识到一个事实：</p>
<blockquote>
<p><strong>问题不在模型，而在信息投喂方式。</strong></p>
</blockquote>
<hr>
<h3> 6.2 RAG 的本质：把“找资料”和“生成回答”拆开</h3>
<p>RAG 的核心思想可以用一句话概括：</p>
<blockquote>
<p><strong>让系统负责“找事实”，让模型负责“说人话”。</strong></p>
</blockquote>
<p>这一步拆分，在系统设计上非常重要。</p>
<ul>
<li>
<p>检索阶段（Retrieval）：</p>
<ul>
<li>关注的是：
<ul>
<li>找得准不准</li>
<li>覆盖全不全</li>
</ul>
</li>
</ul>
</li>
<li>
<p>生成阶段（Generation）：</p>
<ul>
<li>关注的是：
<ul>
<li>表达是否清晰</li>
<li>是否遵循约束</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>通过这种拆分：</p>
<blockquote>
<p><strong>模型不再被当成“知识库”，而只是一个表达引擎。</strong></p>
</blockquote>
<hr>
<h3> 6.3 为什么要用向量检索？（系统角度的解释）</h3>
<p>在系统设计中，“检索”并不是新问题。</p>
<p>你可能会问：</p>
<blockquote>
<p>“我能不能直接用关键词搜索？”</p>
</blockquote>
<p>在很多场景下，答案是：<strong>不够好</strong>。</p>
<p>原因在于：</p>
<ul>
<li>用户的提问方式是多样的</li>
<li>文档里的表述方式也是多样的</li>
<li>关键词很难穷举所有同义表达</li>
</ul>
<p>向量检索的价值在于：</p>
<blockquote>
<p><strong>它检索的是“语义相似度”，而不是字面匹配。</strong></p>
</blockquote>
<p>从系统角度看，这意味着：</p>
<ul>
<li>检索层对用户输入更宽容</li>
<li>上层生成质量更稳定</li>
</ul>
<hr>
<h3> 6.4 RAG 的标准系统架构</h3>
<p>从工程角度看，一个典型的 RAG 系统，可以拆成下面几个明确的组件。</p>
<hr>
<h4> 组件一：文档接入与预处理</h4>
<p>这一层的目标只有一个：</p>
<blockquote>
<p><strong>把原始资料，变成“适合被检索”的形态。</strong></p>
</blockquote>
<p>常见职责包括：</p>
<ul>
<li>文档解析（PDF / Word / HTML 等）</li>
<li>文档清洗（去噪、去无关内容）</li>
<li>文档切分（Chunking）</li>
</ul>
<p>切分的设计原则是：</p>
<ul>
<li>单个 Chunk 语义相对完整</li>
<li>不要过长，也不要过短</li>
</ul>
<p>这是一个<strong>典型的工程取舍点</strong>。</p>
<hr>
<h4> 组件二：向量化与存储</h4>
<p>这一层的职责是：</p>
<ul>
<li>把每个 Chunk 转换成向量</li>
<li>存入向量数据库</li>
</ul>
<p>从系统设计角度看：</p>
<ul>
<li>这是一个<strong>离线为主</strong>的过程</li>
<li>更新频率取决于文档变化频率</li>
</ul>
<p>一个重要认知是：</p>
<blockquote>
<p><strong>Embedding 模型的选择，直接影响检索质量上限。</strong></p>
</blockquote>
<hr>
<h4> 组件三：查询理解与检索</h4>
<p>当用户发起请求时，系统并不会立刻调用 LLM。</p>
<p>而是先：</p>
<ul>
<li>对用户问题进行向量化</li>
<li>在向量库中检索 Top-K 相关 Chunk</li>
</ul>
<p>这里的关键设计点包括：</p>
<ul>
<li>K 取多少</li>
<li>是否做重排序（Re-ranking）</li>
<li>是否引入元数据过滤</li>
</ul>
<p>这些设计，决定了：</p>
<blockquote>
<p><strong>模型“能看到哪些事实”。</strong></p>
</blockquote>
<hr>
<h4> 组件四：上下文构建与生成</h4>
<p>只有在完成检索之后，系统才会：</p>
<ul>
<li>把检索到的内容</li>
<li>组织成上下文</li>
<li>交给模型生成最终回答</li>
</ul>
<p>这里的系统职责是：</p>
<ul>
<li>控制上下文长度</li>
<li>明确告诉模型：
<blockquote>
<p>“只能基于这些资料回答”</p>
</blockquote>
</li>
</ul>
<hr>
<h3> 6.5 RAG 系统中常见的设计误区</h3>
<p>在实际项目中，RAG 常见的失败，并不是算法问题，而是设计问题。</p>
<hr>
<h4> 误区一：把 RAG 当成一次性功能</h4>
<p>RAG 不是“接一次就完了”的功能。</p>
<p>随着：</p>
<ul>
<li>文档规模增长</li>
<li>用户问题变化</li>
</ul>
<p>你必须不断调整：</p>
<ul>
<li>切分策略</li>
<li>检索策略</li>
<li>上下文构建方式</li>
</ul>
<hr>
<h4> 误区二：过度依赖模型能力</h4>
<p>即使在 RAG 系统中：</p>
<blockquote>
<p><strong>模型仍然不会帮你纠错。</strong></p>
</blockquote>
<p>如果检索阶段拿错了资料，
模型只会：</p>
<blockquote>
<p>一本正经地基于错误资料回答。</p>
</blockquote>
<hr>
<h4> 误区三：忽视失败场景设计</h4>
<p>一个健壮的 RAG 系统，必须考虑：</p>
<ul>
<li>检索不到相关资料怎么办</li>
<li>检索结果冲突怎么办</li>
<li>是否要让模型明确说明“不知道”</li>
</ul>
<p>这些都属于系统层面的责任。</p>
<hr>
<h3> 6.6 一个重要的认知升级</h3>
<p>到这里，你应该已经意识到一件事：</p>
<blockquote>
<p><strong>RAG 的难点，不在模型，而在系统设计。</strong></p>
</blockquote>
<p>模型只是整个链路中的一环。</p>
<p>真正决定系统质量的，是：</p>
<ul>
<li>数据准备是否合理</li>
<li>检索是否稳定</li>
<li>上下文是否清晰</li>
</ul>
<hr>
<h3> 本章小结</h3>
<p>这一章你需要牢牢记住的，是下面几个系统级认知：</p>
<ol>
<li>RAG 是一种系统设计模式，而不是模型技巧</li>
<li>核心思想是“检索”和“生成”的职责分离</li>
<li>系统设计决定 RAG 的效果上限</li>
<li>模型只负责表达，不负责保证事实正确</li>
</ol>
<p>理解了这些内容之后，你就具备了：</p>
<blockquote>
<p><strong>设计“可信 LLM 应用”的核心能力之一。</strong></p>
</blockquote>
<p>下一章，我们将继续解决一个现实问题：</p>
<blockquote>
<p><strong>即使模型知道该做什么，它也“什么都做不了”。</strong></p>
</blockquote>
<p>这将引出另一个关键能力：</p>
<blockquote>
<p><strong>Function Calling —— 让模型参与真实系统的执行流程。</strong></p>
</blockquote>
<hr>
<h2> 第 7 章：Function Calling —— 让模型真正参与系统执行</h2>
<p>在上一章，我们已经解决了一个非常关键的问题：</p>
<blockquote>
<p><strong>如何让模型“基于真实资料说话”。</strong></p>
</blockquote>
<p>但当你真的把 RAG 系统接入业务后，很快又会遇到一个新的现实困境。</p>
<p>模型现在：</p>
<ul>
<li>能理解问题了</li>
<li>也能给出看起来很合理的回答</li>
</ul>
<p>但问题是：</p>
<blockquote>
<p><strong>它只能“说”，不能“做”。</strong></p>
</blockquote>
<p>这一章，我们要解决的，正是这个问题。</p>
<hr>
<h3> 7.1 一个非常常见、但很快会失败的做法</h3>
<p>很多人在第一次尝试“让模型帮我干活”时，会这样设计系统：</p>
<blockquote>
<p>“我让模型输出一段 JSON，
然后我在代码里解析这个 JSON，
再根据内容去调用对应逻辑。”</p>
</blockquote>
<p>在 Demo 阶段，这种方式通常可以跑起来。</p>
<p>但一旦进入真实系统，你会发现问题接踵而至：</p>
<ul>
<li>JSON 格式不稳定</li>
<li>字段名偶尔变化</li>
<li>缺字段、多字段</li>
<li>模型输出夹杂自然语言</li>
</ul>
<p>这时你会意识到：</p>
<blockquote>
<p><strong>模型并不知道哪些输出是“必须严格遵守的”。</strong></p>
</blockquote>
<hr>
<h3> 7.2 Function Calling 要解决的核心问题</h3>
<p>Function Calling 并不是为了“让模型会写代码”。</p>
<p>它真正解决的是一个系统层面的问题：</p>
<blockquote>
<p><strong>如何让模型在“自然语言理解”和“系统能力调用”之间，
建立一个稳定、可控的接口。</strong></p>
</blockquote>
<p>换句话说：</p>
<ul>
<li>
<p>模型负责：</p>
<ul>
<li>理解用户意图</li>
<li>决定“要做什么”</li>
</ul>
</li>
<li>
<p>系统负责：</p>
<ul>
<li>提供“能做什么”</li>
<li>执行具体逻辑</li>
</ul>
</li>
</ul>
<p>这是一次非常重要的职责划分。</p>
<hr>
<h3> 7.3 从系统角度看 Function Calling 的工作方式</h3>
<p>站在系统设计视角，Function Calling 可以被理解为：</p>
<blockquote>
<p><strong>模型参与决策，但不直接参与执行。</strong></p>
</blockquote>
<p>一个典型流程如下：</p>
<ol>
<li>
<p>系统向模型声明：</p>
<ul>
<li>当前有哪些函数（工具）可用</li>
<li>每个函数的用途和参数结构</li>
</ul>
</li>
<li>
<p>模型根据用户输入：</p>
<ul>
<li>判断是否需要调用函数</li>
<li>以及应该调用哪一个</li>
</ul>
</li>
<li>
<p>系统接管执行：</p>
<ul>
<li>校验参数</li>
<li>调用真实业务逻辑</li>
</ul>
</li>
<li>
<p>执行结果再回传给模型，用于后续回答</p>
</li>
</ol>
<p>在这个过程中：</p>
<blockquote>
<p><strong>模型从“输出文本”，升级为“输出结构化决策”。</strong></p>
</blockquote>
<hr>
<h3> 7.4 为什么说 Function Calling 是“工程能力”，不是模型能力</h3>
<p>一个非常容易被忽略的点是：</p>
<blockquote>
<p><strong>Function Calling 的可靠性，主要由系统保证，而不是模型保证。</strong></p>
</blockquote>
<p>即使模型判断错了：</p>
<ul>
<li>参数缺失</li>
<li>类型不对</li>
<li>调用了不该调用的函数</li>
</ul>
<p>系统仍然可以：</p>
<ul>
<li>拒绝执行</li>
<li>返回错误信息</li>
<li>要求模型重新决策</li>
</ul>
<p>这意味着：</p>
<blockquote>
<p><strong>风险被牢牢控制在系统边界内。</strong></p>
</blockquote>
<hr>
<h3> 7.5 Function Calling 在系统中的典型使用场景</h3>
<p>当你理解了它的系统定位，就会发现 Function Calling 非常适合下面这些场景。</p>
<hr>
<h4> 场景一：查询类操作</h4>
<p>例如：</p>
<ul>
<li>查询订单状态</li>
<li>查询库存信息</li>
<li>查询用户配置</li>
</ul>
<p>模型负责理解“查什么”，
系统负责返回真实数据。</p>
<hr>
<h4> 场景二：状态变更类操作</h4>
<p>例如：</p>
<ul>
<li>创建订单</li>
<li>修改配置</li>
<li>提交审批</li>
</ul>
<p>这里尤其重要的一点是：</p>
<blockquote>
<p><strong>模型永远不应该直接修改数据。</strong></p>
</blockquote>
<p>它只能“请求”，
是否执行，完全由系统决定。</p>
<hr>
<h4> 场景三：多步流程中的一步</h4>
<p>在更复杂的系统中：</p>
<ul>
<li>模型并不一次完成所有事情</li>
<li>而是参与多个步骤的决策</li>
</ul>
<p>这为后面引入 Agent 打下基础。</p>
<hr>
<h3> 7.6 Function Calling 的设计边界</h3>
<p>理解边界，比理解能力更重要。</p>
<p>在系统设计中，你需要明确：</p>
<ul>
<li>哪些能力可以暴露给模型</li>
<li>哪些能力必须完全禁止</li>
</ul>
<p>一个基本原则是：</p>
<blockquote>
<p><strong>模型只能调用“可逆、可校验、可回滚”的操作。</strong></p>
</blockquote>
<p>任何：</p>
<ul>
<li>高风险</li>
<li>不可恢复</li>
<li>责任重大的操作</li>
</ul>
<p>都不应该直接暴露给模型。</p>
<hr>
<h3> 7.7 一个重要的系统认知升级</h3>
<p>到这里，你应该已经意识到：</p>
<blockquote>
<p><strong>Function Calling 不是让模型更聪明，
而是让系统更安全。</strong></p>
</blockquote>
<p>它的价值不在于：</p>
<ul>
<li>模型能做更多事</li>
</ul>
<p>而在于：</p>
<ul>
<li>模型被限制在正确的位置上</li>
<li>系统始终掌握最终控制权</li>
</ul>
<hr>
<h3> 本章小结</h3>
<p>在这一章中，你需要记住下面几个关键点：</p>
<ol>
<li>模型只能理解意图，不能直接执行</li>
<li>Function Calling 是模型与系统之间的“安全接口”</li>
<li>决策与执行必须严格分离</li>
<li>风险控制是系统设计的首要目标</li>
</ol>
<p>理解了这些内容之后，你已经具备了：</p>
<blockquote>
<p><strong>设计“可控 LLM 系统”的关键能力。</strong></p>
</blockquote>
<p>下一章，我们将把前面所有能力组合起来，回答一个常被过度神话的问题：</p>
<blockquote>
<p><strong>什么时候，我们才真的需要 Agent？</strong></p>
</blockquote>
<hr>
<h2> 第 8 章：Agent 的工程化理解 —— 去神话版</h2>
<p>在前面的章节中，我们已经一步步为模型补齐了能力：</p>
<ul>
<li>第 5 章：认识到模型会幻觉，不能被直接信任</li>
<li>第 6 章：通过 RAG，让模型基于真实资料回答</li>
<li>第 7 章：通过 Function Calling，让模型参与系统决策</li>
</ul>
<p>到这里，很多人会自然地产生一个想法：</p>
<blockquote>
<p>“那是不是把这些东西一组合，我就有了一个 Agent？”</p>
</blockquote>
<p>答案是：</p>
<blockquote>
<p><strong>是的，但也正因为如此，Agent 并不神秘。</strong></p>
</blockquote>
<p>这一章，我们就从工程角度，把 Agent 这件事彻底讲清楚。</p>
<hr>
<h3> 8.1 先回答一个尖锐的问题：你真的需要 Agent 吗？</h3>
<p>在技术社区中，Agent 往往被描述成：</p>
<ul>
<li>能自主思考</li>
<li>能自动规划</li>
<li>能持续执行任务</li>
</ul>
<p>听起来非常强大。</p>
<p>但在真实工程中，你需要先冷静下来问一句：</p>
<blockquote>
<p><strong>我的系统，真的需要这种复杂度吗？</strong></p>
</blockquote>
<p>因为 Agent 带来的，不只是能力提升，还有：</p>
<ul>
<li>系统复杂度指数级上升</li>
<li>调试和测试难度显著增加</li>
<li>不确定性扩大</li>
</ul>
<p>一个非常务实的判断标准是：</p>
<blockquote>
<p><strong>如果一个请求，在一次 RAG + Function Calling 中就能解决，
那你根本不需要 Agent。</strong></p>
</blockquote>
<hr>
<h3> 8.2 Agent 并不是一个新能力</h3>
<p>一个常见误解是：</p>
<blockquote>
<p>“Agent 是模型的新能力。”</p>
</blockquote>
<p>但从工程角度看，这并不准确。</p>
<p>事实上，一个 Agent 通常只是下面这些能力的组合：</p>
<ul>
<li>Prompt（任务描述）</li>
<li>上下文管理（状态）</li>
<li>RAG（事实获取）</li>
<li>Function Calling（工具调用）</li>
<li>一个控制循环（Loop）</li>
</ul>
<p>也就是说：</p>
<blockquote>
<p><strong>Agent 的核心，不在模型，而在“控制逻辑”。</strong></p>
</blockquote>
<hr>
<h3> 8.3 控制循环：Agent 真正的核心</h3>
<p>如果一定要用一句话来定义 Agent：</p>
<blockquote>
<p><strong>Agent = 一个带状态的、可重复执行的决策循环。</strong></p>
</blockquote>
<p>一个最简化的 Agent 循环，可以抽象为：</p>
<ol>
<li>读取当前状态</li>
<li>决定下一步要做什么</li>
<li>调用工具或获取信息</li>
<li>更新状态</li>
<li>判断是否结束，否则继续</li>
</ol>
<p>注意这里的关键点：</p>
<blockquote>
<p><strong>循环是由系统控制的，而不是模型。</strong></p>
</blockquote>
<p>模型只是参与每一轮的“决策建议”。</p>
<hr>
<h3> 8.4 为什么 Agent 必须由系统“牵着走”</h3>
<p>很多失败的 Agent 实验，问题都出在这里：</p>
<ul>
<li>把过多控制权交给模型</li>
<li>让模型自己决定是否继续</li>
</ul>
<p>这在工程上是非常危险的。</p>
<p>一个健壮的 Agent 系统，通常会明确限制：</p>
<ul>
<li>最大执行步数</li>
<li>每一步允许调用的工具</li>
<li>明确的终止条件</li>
</ul>
<p>这些限制的目的只有一个：</p>
<blockquote>
<p><strong>把不确定性关进笼子里。</strong></p>
</blockquote>
<hr>
<h3> 8.5 Agent 适合解决什么问题？</h3>
<p>在真实系统中，Agent 并不是“通用解法”。</p>
<p>它更适合下面这些场景：</p>
<ul>
<li>需要多步推理和多次信息获取</li>
<li>步骤之间存在依赖关系</li>
<li>中间结果会影响后续决策</li>
</ul>
<p>例如：</p>
<ul>
<li>复杂任务拆解与执行</li>
<li>多工具协作的问题解决</li>
<li>长时间运行的辅助流程</li>
</ul>
<p>而不适合：</p>
<ul>
<li>简单问答</li>
<li>单步决策</li>
<li>强一致性、高风险操作</li>
</ul>
<hr>
<h3> 8.6 一个现实的工程建议</h3>
<p>如果你是第一次在项目中引入 Agent，我给你一个非常保守但实用的建议：</p>
<blockquote>
<p><strong>先把 Agent 当成“可多次调用的流程编排器”，
而不是“自主智能体”。</strong></p>
</blockquote>
<p>从工程视角看，这会让你：</p>
<ul>
<li>更容易调试</li>
<li>更容易监控</li>
<li>更容易回滚</li>
</ul>
<hr>
<h3> 本章小结</h3>
<p>在这一章中，你需要牢牢记住下面几点：</p>
<ol>
<li>Agent 并不神秘，它是能力的组合</li>
<li>控制循环才是 Agent 的核心</li>
<li>系统必须始终掌握控制权</li>
<li>大多数场景下，你并不需要 Agent</li>
</ol>
<p>如果你能带着这些认知去使用 Agent，那么它会成为：</p>
<blockquote>
<p><strong>一个强大但可控的工程工具。</strong></p>
</blockquote>
<p>而不是一个不可预测的风险源。</p>
<hr>
<h2> 全文总结：从“用模型”到“设计系统”</h2>
<h3> 写给工程师的 LLM 使用宣言</h3>
<p>如果你完整读完了这套教程，我希望你至少记住一件事：</p>
<blockquote>
<p><strong>大语言模型不是一个可以被“信任”的系统组件。</strong></p>
</blockquote>
<p>它不保证正确性，
不理解后果，
也不会为错误负责。</p>
<p>真正可靠的，从来不是模型本身，而是你设计的系统。</p>
<hr>
<h3> 不要问“模型还能多聪明”</h3>
<p>在工程实践中，一个更有价值的问题是：</p>
<blockquote>
<p><strong>哪些不确定性，必须被系统兜住？</strong></p>
</blockquote>
<ul>
<li>用 Prompt 约束表达</li>
<li>用 RAG 约束事实</li>
<li>用 Function Calling 约束执行</li>
<li>用 Agent 的控制循环约束流程</li>
</ul>
<p>这不是限制模型，而是保护系统。</p>
<hr>
<h3> 大多数失败，都不是模型失败</h3>
<p>如果一个 LLM 应用：</p>
<ul>
<li>经常胡说八道</li>
<li>行为不可预测</li>
<li>出问题后无法追踪</li>
</ul>
<p>那么问题通常不在模型，而在于：</p>
<blockquote>
<p><strong>系统把不该交给模型的责任，交给了模型。</strong></p>
</blockquote>
<hr>
<h3> 成熟的 LLM 工程，是“去魔法化”的过程</h3>
<p>当你不再期待模型“自动搞定一切”，
而是：</p>
<ul>
<li>明确边界</li>
<li>明确职责</li>
<li>明确失败路径</li>
</ul>
<p>你会发现，LLM 反而变得可靠起来。</p>
<hr>
<h3> 最后一句话</h3>
<p>如果你想长期做 LLM 应用开发，请记住这句话：</p>
<blockquote>
<p><strong>不是让模型变强，而是让系统变稳。</strong></p>
</blockquote>
<p>只要你坚持这个原则，
无论技术如何变化，你都站在正确的一边。</p>
]]></content:encoded>
    </item>
    <item>
      <title>LLM应用开发进阶大纲</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/02.LLM%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%E5%A4%A7%E7%BA%B2.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/02.LLM%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%E5%A4%A7%E7%BA%B2.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">LLM应用开发进阶大纲</source>
      <description>前言 为什么你“会用 LLM”，但做不出复杂应用？ 为什么调得好 Prompt ≠ 系统就稳定？ 为什么多数 Demo 无法上线？ 本书解决什么问题、不解决什么问题 本书的学习路径说明 你需要什么基础？ 每一模块学完你“能做什么” 推荐的学习与实践方式 第一部分｜重新认识 LLM：不是模型问题，而是系统问题 目标：建立“工程师视角”的 LLM 认知模型</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 09:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<h3> 为什么你“会用 LLM”，但做不出复杂应用？</h3>
<ul>
<li>为什么调得好 Prompt ≠ 系统就稳定？</li>
<li>为什么多数 Demo 无法上线？</li>
<li>本书解决什么问题、不解决什么问题</li>
</ul>
<h3> 本书的学习路径说明</h3>
<ul>
<li>你需要什么基础？</li>
<li>每一模块学完你“能做什么”</li>
<li>推荐的学习与实践方式</li>
</ul>
<hr>
<h1> 第一部分｜重新认识 LLM：不是模型问题，而是系统问题</h1>
<blockquote>
<p><strong>目标：建立“工程师视角”的 LLM 认知模型</strong></p>
</blockquote>
<hr>
<h2> 第 1 章：LLM 到底在做什么？（程序员版认知重建）</h2>
<h3> 1.1 一个反直觉的问题：LLM 真的“理解”语言吗？</h3>
<ul>
<li>如果它不理解，为什么还能推理？</li>
<li>“下一个 token 预测”到底意味着什么？</li>
</ul>
<h3> 1.2 从函数视角理解 LLM</h3>
<ul>
<li>LLM ≈ <code>f(context) → token</code></li>
<li>为什么上下文就是一切？</li>
<li>为什么 prompt 是“代码”？</li>
</ul>
<p>📊 <strong>图：Token 预测与采样机制示意图（mermaid）</strong></p>
<hr>
<h3> 1.3 你必须接受的事实：LLM 天生不可靠</h3>
<ul>
<li>什么是幻觉？为什么无法彻底消除？</li>
<li>“不知道”为什么是最难的答案？</li>
</ul>
<p>📊 <strong>图：无约束生成 vs 受约束生成对比图</strong></p>
<hr>
<h3> 1.4 第一性原理总结</h3>
<ul>
<li>LLM 擅长什么？</li>
<li>LLM 永远不该做什么？</li>
<li>哪些问题必须交给系统解决？</li>
</ul>
<hr>
<h2> 第 2 章：模型不是重点，参数才是你真正的控制面板</h2>
<h3> 2.1 一个问题：为什么同一个 Prompt 效果忽好忽坏？</h3>
<ul>
<li>随机性从哪来？</li>
<li>temperature / top_p 在“干什么”？</li>
</ul>
<h3> 2.2 参数 ≠ 配置，而是策略</h3>
<ul>
<li>不同任务的参数决策逻辑</li>
<li>为什么大多数人“乱调参”？</li>
</ul>
<p>📊 <strong>图：任务类型 → 参数决策树</strong></p>
<hr>
<h3> 2.3 API 调用的本质结构</h3>
<ul>
<li>messages 是“状态机”</li>
<li>system role 真正的权力边界</li>
</ul>
<p>🧪 示例：最小多轮对话实现（伪代码）</p>
<hr>
<h1> 第二部分｜Prompt 工程：让模型“稳定干活”的第一道防线</h1>
<blockquote>
<p><strong>目标：从“写提示词”升级为“设计 Prompt 结构”</strong></p>
</blockquote>
<hr>
<h2> 第 3 章：Prompt 为什么会失败？</h2>
<h3> 3.1 一个常见误区：Prompt 写得越长越好？</h3>
<ul>
<li>模糊 ≠ 自由</li>
<li>细节 ≠ 噪声</li>
</ul>
<h3> 3.2 Prompt 的三条工程原则</h3>
<ul>
<li>清晰性</li>
<li>约束性</li>
<li>可复用性</li>
</ul>
<p>📊 <strong>图：坏 Prompt vs 好 Prompt 结构对比</strong></p>
<hr>
<h2> 第 4 章：从 Zero-shot 到 Few-shot 的设计思维</h2>
<h3> 4.1 什么时候你真的需要 Few-shot？</h3>
<ul>
<li>模型不会“猜你的规则”</li>
</ul>
<h3> 4.2 示例驱动 Prompt 的本质</h3>
<ul>
<li>示例是在教模型“判题规则”</li>
</ul>
<p>🧪 示例：文本分类 / 数据抽取 Prompt 演进过程</p>
<hr>
<h2> 第 5 章：Prompt 模板化与工程落地</h2>
<h3> 5.1 为什么 Prompt 必须版本化？</h3>
<ul>
<li>Prompt 就是代码</li>
</ul>
<h3> 5.2 通用 Prompt 模板结构</h3>
<ul>
<li>Role</li>
<li>Task</li>
<li>Constraints</li>
<li>Output Schema</li>
</ul>
<p>📊 <strong>图：Prompt 模板结构图</strong></p>
<hr>
<h1> 第三部分｜上下文与记忆：对话为什么会“失忆”？</h1>
<blockquote>
<p><strong>目标：掌握对话系统设计，而不是堆 messages</strong></p>
</blockquote>
<hr>
<h2> 第 6 章：上下文窗口的真实边界</h2>
<h3> 6.1 上下文不是“无限内存”</h3>
<ul>
<li>Token 成本、性能与遗忘</li>
</ul>
<h3> 6.2 为什么长对话一定会崩？</h3>
<p>📊 <strong>图：上下文窗口滚动与信息丢失示意图</strong></p>
<hr>
<h2> 第 7 章：三种记忆策略的工程取舍</h2>
<h3> 7.1 短期记忆：直接塞上下文</h3>
<h3> 7.2 摘要记忆：用 LLM 管 LLM</h3>
<h3> 7.3 长期记忆：向量化存储历史</h3>
<p>📊 <strong>图：短 / 中 / 长期记忆系统架构对比</strong></p>
<p>🧪 示例：对话摘要生成伪代码</p>
<hr>
<h2> 第 8 章：上下文工程（Context Engineering）</h2>
<h3> 8.1 什么信息值得留下？</h3>
<h3> 8.2 信息如何“压缩但不失真”？</h3>
<h3> 8.3 结构化上下文设计模式</h3>
<p>📊 <strong>图：结构化上下文拼装流程图</strong></p>
<hr>
<h1> 第四部分｜能力扩展：让 LLM 走出“纯聊天”</h1>
<blockquote>
<p><strong>目标：让 LLM 接入真实世界，而不是只会说话</strong></p>
</blockquote>
<hr>
<h2> 第 9 章：为什么单靠 LLM 永远不够？</h2>
<h3> 9.1 知识截止的问题</h3>
<h3> 9.2 无状态的问题</h3>
<h3> 9.3 无执行能力的问题</h3>
<p>📊 <strong>图：LLM 核心缺陷总览</strong></p>
<hr>
<h2> 第 10 章：Function Calling —— LLM 的“决策大脑”</h2>
<h3> 10.1 模型是如何“选择工具”的？</h3>
<h3> 10.2 Schema 设计的关键原则</h3>
<ul>
<li>函数不是越多越好</li>
</ul>
<p>📊 <strong>图：Function Calling 全流程闭环</strong></p>
<p>🧪 示例：天气 / 数据库查询工具调用</p>
<hr>
<h2> 第 11 章：RAG —— 企业级 LLM 的地基</h2>
<h3> 11.1 为什么 RAG 不是“外挂知识库”？</h3>
<h3> 11.2 RAG 解决的是哪一类问题？</h3>
<p>📊 <strong>图：RAG 离线 + 在线全流程图</strong></p>
<hr>
<h3> 11.3 文档 → Chunk → Embedding 的关键设计点</h3>
<ul>
<li>切多大才合理？</li>
<li>为什么分割决定效果上限？</li>
</ul>
<h3> 11.4 检索失败的真实原因</h3>
<ul>
<li>不是模型问题，而是数据问题</li>
</ul>
<p>🧪 示例：最小 RAG 原型（伪代码）</p>
<hr>
<h1> 第五部分｜Agent 思维：从调用模型到构建系统</h1>
<blockquote>
<p><strong>目标：理解“智能体”不是框架，而是架构模式</strong></p>
</blockquote>
<hr>
<h2> 第 12 章：什么是 Agent？它和 Prompt 的本质区别</h2>
<h3> 12.1 为什么 CoT ≠ Agent？</h3>
<h3> 12.2 ReAct / Plan-Execute 的本质抽象</h3>
<p>📊 <strong>图：Agent 推理循环结构图</strong></p>
<hr>
<h2> 第 13 章：一个 Agent 的最小系统结构</h2>
<ul>
<li>输入解析</li>
<li>状态管理</li>
<li>工具调度</li>
<li>结果评估</li>
</ul>
<p>📊 <strong>图：Agent 系统架构全景图</strong></p>
<hr>
<h2> 第 14 章：失败的 Agent 都失败在哪？</h2>
<ul>
<li>无限循环</li>
<li>工具滥用</li>
<li>目标漂移</li>
</ul>
<p>🧪 示例：Agent 失败案例拆解</p>
<hr>
<h1> 第六部分｜实战：从 Demo 到“可上线系统”</h1>
<blockquote>
<p><strong>目标：真正跑起来，而不是只在 Notebook 里成功</strong></p>
</blockquote>
<hr>
<h2> 第 15 章：实战一：可控的多轮对话助手</h2>
<ul>
<li>Prompt + 记忆 + 参数策略</li>
</ul>
<h2> 第 16 章：实战二：企业知识库问答系统（RAG）</h2>
<ul>
<li>文档接入</li>
<li>检索优化</li>
<li>引用溯源</li>
</ul>
<h2> 第 17 章：实战三：工具驱动型 Agent</h2>
<ul>
<li>Function Calling</li>
<li>状态管理</li>
<li>错误恢复</li>
</ul>
<hr>
<h1> 终章｜下一步你该学什么？</h1>
<ul>
<li>什么时候该微调？</li>
<li>什么时候该换模型？</li>
<li>LLM 应用的长期演进方向</li>
</ul>
<hr>
<h2> 📌 附录</h2>
<ul>
<li>Prompt 模板速查表</li>
<li>RAG 参数调优清单</li>
<li>Agent 架构设计 Checklist</li>
<li>常见坑位与反模式总结</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>前言</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/03.%E5%89%8D%E8%A8%80.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/03.%E5%89%8D%E8%A8%80.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">前言</source>
      <description>下面是一份可以直接作为成稿使用的「前言」章节内容，风格与全书保持一致：不炫技、不晦涩，用问题牵引认知转变，并且明确告诉读者这本书“解决什么、不解决什么”。 前言 为什么你“会用 LLM”，但做不出复杂应用？ 如果你已经读到这里，大概率符合下面的画像之一： 你能写出效果不错的 Prompt 你做过一些 Demo，看起来“挺智能” 但一到真实场景，就开始不对劲： 回答时好时坏 对话一长就跑偏 数据一多就失控 Demo 很难上线，更谈不上长期维护</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 09:45:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>下面是一份<strong>可以直接作为成稿使用的「前言」章节内容</strong>，风格与全书保持一致：不炫技、不晦涩，用问题牵引认知转变，并且<strong>明确告诉读者这本书“解决什么、不解决什么”</strong>。</p>
<hr>
<h2> 前言</h2>
<h3> 为什么你“会用 LLM”，但做不出复杂应用？</h3>
<p>如果你已经读到这里，大概率符合下面的画像之一：</p>
<ul>
<li>
<p>你能写出效果不错的 Prompt</p>
</li>
<li>
<p>你做过一些 Demo，看起来“挺智能”</p>
</li>
<li>
<p>但一到真实场景，就开始不对劲：</p>
<ul>
<li>回答时好时坏</li>
<li>对话一长就跑偏</li>
<li>数据一多就失控</li>
<li>Demo 很难上线，更谈不上长期维护</li>
</ul>
</li>
</ul>
<p>你可能已经问过自己一些问题：</p>
<ul>
<li><strong>为什么 Prompt 调得很好，系统却依然不稳定？</strong></li>
<li><strong>为什么 Demo 阶段“看起来能用”，上线后问题不断？</strong></li>
<li><strong>为什么模型很强，但应用却很脆弱？</strong></li>
</ul>
<p>如果你有这些困惑，那问题<strong>并不在于你不会用 LLM</strong>。</p>
<p>真正的问题是：</p>
<blockquote>
<p><strong>你学到的大多数内容，都是“如何驱动模型”，
而不是“如何构建系统”。</strong></p>
</blockquote>
<hr>
<h4> 调得好 Prompt ≠ 系统就稳定</h4>
<p>这是很多开发者都会踩的第一个坑。</p>
<p>Prompt 确实重要，但它只解决一件事：</p>
<blockquote>
<p><strong>在一次生成中，如何约束模型行为。</strong></p>
</blockquote>
<p>而真实的 LLM 应用，必然涉及：</p>
<ul>
<li>多轮对话</li>
<li>状态变化</li>
<li>知识更新</li>
<li>错误处理</li>
<li>成本与安全边界</li>
</ul>
<p>这些问题，<strong>没有一个是靠多写几句 Prompt 能解决的</strong>。</p>
<hr>
<h4> 为什么多数 Demo 无法上线？</h4>
<p>因为 Demo 往往具备三个“天然优势”：</p>
<ul>
<li>用户少</li>
<li>数据小</li>
<li>时间短</li>
</ul>
<p>一旦进入真实环境：</p>
<ul>
<li>上下文开始膨胀</li>
<li>知识开始过期</li>
<li>用户开始“乱问”</li>
<li>错误开始积累</li>
</ul>
<p>你会发现：</p>
<blockquote>
<p><strong>Demo 是“一次生成的问题”，
而上线是“系统随时间演化的问题”。</strong></p>
</blockquote>
<p>这正是两者之间的本质鸿沟。</p>
<hr>
<h4> 这篇系列教程解决什么问题？不解决什么问题？</h4>
<p>这个系列教程<strong>不试图</strong>做以下事情：</p>
<ul>
<li>❌ 教你写“最强 Prompt 模板”</li>
<li>❌ 罗列各种框架 API 用法</li>
<li>❌ 追逐最新模型或参数技巧</li>
</ul>
<p>本书真正要解决的是：</p>
<blockquote>
<p><strong>如何把一个不可靠的大模型，
放进一个可控、可维护、可演进的系统中。</strong></p>
</blockquote>
<p>更具体地说：</p>
<ul>
<li>为什么 Prompt 必须是“约束”，而不是“知识”</li>
<li>为什么上下文会天然失控，以及如何设计记忆</li>
<li>为什么 RAG 不是外挂，而是工程必然</li>
<li>为什么 Agent 不是智能幻想，而是系统循环</li>
<li>为什么评估与监控决定了项目能不能活下来</li>
</ul>
<p>如果你期待的是“技巧合集”，这个系列教程可能不适合你。</p>
<p>如果你想的是<strong>真正把 LLM 应用做成产品</strong>，那你来对了。</p>
<hr>
<h3> 本书的学习路径说明</h3>
<p>这不是一本可以“跳着看也无所谓”的书。</p>
<p>因为它试图做一件事：</p>
<blockquote>
<p><strong>带你完成一次从“模型使用者”到“系统设计者”的转变。</strong></p>
</blockquote>
<hr>
<h4> 你需要什么基础？</h4>
<p>你不需要：</p>
<ul>
<li>深度学习理论</li>
<li>Transformer 数学推导</li>
<li>算法竞赛背景</li>
</ul>
<p>但你需要：</p>
<ul>
<li>基本的编程经验</li>
<li>对 Web / 后端 / 系统设计有基本认知</li>
<li>至少实现过一个简单的 LLM 应用或 Demo</li>
</ul>
<p>如果你已经写过几次 Prompt、接过模型 API、踩过一些坑，那正是<strong>最佳起点</strong>。</p>
<hr>
<h4> 每一模块学完，你“能做什么”？</h4>
<p>本书的每一部分，都对应一种<strong>能力跃迁</strong>：</p>
<ul>
<li>
<p><strong>理解模型本质</strong>
→ 不再迷信“模型会自己想明白”</p>
</li>
<li>
<p><strong>Prompt 与约束</strong>
→ 能设计行为边界，而不是碰运气</p>
</li>
<li>
<p><strong>Context 与 Memory</strong>
→ 能做稳定的多轮系统</p>
</li>
<li>
<p><strong>RAG 与知识注入</strong>
→ 能让系统基于真实事实回答</p>
</li>
<li>
<p><strong>Function Calling 与 Agent</strong>
→ 能让系统完成任务，而不只是聊天</p>
</li>
<li>
<p><strong>评估与工程化</strong>
→ 能让系统长期运行、持续演进</p>
</li>
</ul>
<p>你最终获得的不是某个技巧，而是：</p>
<blockquote>
<p><strong>一套判断“该不该这么设计”的工程直觉。</strong></p>
</blockquote>
<hr>
<h4> 推荐的学习与实践方式</h4>
<p>这本书<strong>强烈不推荐</strong>只读不做。</p>
<p>更好的方式是：</p>
<ol>
<li>
<p><strong>以“企业知识库助手”为主线对照阅读</strong></p>
<ul>
<li>每读一章，想一想：
<em>如果是我的系统，会在哪里出问题？</em></li>
</ul>
</li>
<li>
<p><strong>在你已有的 Demo 上逐步套用</strong></p>
<ul>
<li>不用一次重构</li>
<li>先从约束、再到上下文、再到检索</li>
</ul>
</li>
<li>
<p><strong>接受一个事实</strong></p>
<ul>
<li>LLM 应用不是“搭完就好”</li>
<li>而是一个会随时间退化的系统</li>
</ul>
</li>
</ol>
<p>如果你在阅读过程中不断产生这样的想法：</p>
<blockquote>
<p>“原来我之前的问题不是偶然的。”
“原来这一步是迟早要做的。”</p>
</blockquote>
<p>那么，这本书正在发挥它真正的价值。</p>
<hr>
<blockquote>
<p><strong>这不是一本教你“怎么用模型”的书，
而是一本教你“如何与模型共处”的工程指南。</strong></p>
</blockquote>
<p>欢迎开始。</p>
<hr>
<h3> 全书大纲</h3>
<figure><img src="/imgs/column/llm/03-1.png" alt="思维导图版大纲" tabindex="0" loading="lazy"><figcaption>思维导图版大纲</figcaption></figure>
<p>文字版大纲如下</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/llm/03-1.png" type="image/png"/>
    </item>
    <item>
      <title>第 1 章：LLM 到底在做什么？</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/04.LLM%E5%88%B0%E5%BA%95%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/04.LLM%E5%88%B0%E5%BA%95%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第 1 章：LLM 到底在做什么？</source>
      <description>在开始写任何复杂的 LLM 应用之前，我们必须先解决一个根本问题： LLM 到底在“干什么”？ 如果你对这个问题的理解是模糊的，那么后面所有工程决策——Prompt 怎么写、参数怎么调、是否要加 RAG、什么时候该用 Agent——都会变成“试出来的经验”，而不是可复用的能力。 本章我们不从“官方定义”开始，而是从你在真实开发中一定遇到过的困惑说起。 1.1 一个反直觉的问题：LLM 真的「理解」语言吗？</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 10:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在开始写任何复杂的 LLM 应用之前，我们必须先解决一个根本问题：</p>
<blockquote>
<p><strong>LLM 到底在“干什么”？</strong></p>
</blockquote>
<p>如果你对这个问题的理解是模糊的，那么后面所有工程决策——Prompt 怎么写、参数怎么调、是否要加 RAG、什么时候该用 Agent——都会变成“试出来的经验”，而不是可复用的能力。</p>
<p>本章我们不从“官方定义”开始，而是从<strong>你在真实开发中一定遇到过的困惑</strong>说起。</p>
<hr>
<h3> 1.1 一个反直觉的问题：LLM 真的「理解」语言吗？</h3>
<p>先看一个你大概率遇到过的现象：</p>
<ul>
<li>同一个 Prompt</li>
<li>同一个模型</li>
<li>有时回答像专家</li>
<li>有时却一本正经地胡说八道</li>
</ul>
<p>于是你可能会问：</p>
<blockquote>
<p><strong>它到底懂不懂我在说什么？</strong></p>
</blockquote>
<p>直觉上，我们很容易把 LLM 当成一个“理解语言的智能体”。但如果你站在工程视角，这种理解反而会误导你。</p>
<p>一个更接近事实、也更有用的结论是：</p>
<blockquote>
<p><strong>LLM 并不理解语言，它在做的是「基于上下文的概率预测」。</strong></p>
</blockquote>
<p>这句话非常重要，后面几乎所有设计原则都会从这里推导出来。</p>
<p>既然 LLM 的核心行为是 “基于上下文的概率预测”，那从计算逻辑的角度，我们该如何抽象这种行为？如果把它看作一个函数，这个函数的输入和输出又是什么？这正是我们接下来要拆解的核心 —— 用函数视角重新理解 LLM 的工作机制。</p>
<hr>
<h3> 1.2 用函数视角重新理解 LLM</h3>
<p>如果我们暂时抛开“智能”“理解”这些词，只从计算角度看，LLM 的核心行为可以抽象成一个函数：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>也就是说：</p>
<ul>
<li>输入：你给它的所有上下文（system / user / assistant）</li>
<li>输出：<strong>下一个最可能出现的 token</strong></li>
</ul>
<p>不断重复这个过程，就得到了完整的回答。</p>
<p>这里有三个关键点，请你特别留意：</p>
<ol>
<li><strong>LLM 永远只预测下一个 token</strong>，它并不知道“整段话是否正确”；</li>
<li>所谓的“推理过程”，只是多步 token 预测的自然结果；</li>
<li>模型对世界的全部认知，都来自你提供的上下文。</li>
</ol>
<p>但这个 “只预测下一个 token” 的函数，似乎与我们观察到的现象有矛盾：当我们让 LLM 解数学题或写代码时，它明明能展现出 “一步步推导” 的能力。这难道不算是 “推理” 吗？</p>
<hr>
<h3> 1.3 为什么它「看起来」会推理？</h3>
<p>你可能会反驳：</p>
<blockquote>
<p>可是 LLM 明明能一步步推导数学题、写出复杂代码？</p>
</blockquote>
<p>这并不矛盾。</p>
<p>原因在于：</p>
<ul>
<li>在训练阶段，模型看过**大量“推理过程长什么样”**的文本</li>
<li>它学会了：
<ul>
<li>在什么上下文下</li>
<li>下一步“看起来合理”的 token 是什么</li>
</ul>
</li>
</ul>
<p>当你要求它“逐步思考”“一步一步推导”时，</p>
<blockquote>
<p>它并不是在“思考”，而是在<strong>模仿一种常见的文本模式</strong>。</p>
</blockquote>
<p>这也是为什么 <strong>Chain-of-Thought 是一种提示策略，而不是模型能力本身</strong>。</p>
<hr>
<h3> 1.4 采样机制：随机性从哪里来？</h3>
<p>既然 LLM 是在“预测下一个 token”，那为什么同一个 Prompt 会有不同结果？</p>
<p>这种随机性并非偶然，而是模型生成过程中一个关键机制的直接体现，答案在于：采样机制</p>
<blockquote>
<p><strong>模型输出的不是一个确定值，而是一个概率分布。</strong></p>
</blockquote>
<p>简化后的过程如下：</p>
<figure><img src="/imgs/column/llm/04-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>temperature 越低：越偏向“最可能”的结果</li>
<li>temperature 越高：越容易探索“次优但合理”的结果</li>
</ul>
<p><strong>随机性不是噪声，而是模型能力的一部分。</strong></p>
<p>工程问题在于：</p>
<blockquote>
<p>你是否在合适的场景下，使用了合适的随机性？</p>
</blockquote>
<hr>
<h3> 1.5 第一性原理小结（非常重要）</h3>
<p>从 “不理解语言，只做概率预测”，到 “函数视角下的 token 生成”，再到 “推理是模仿文本模式” 和 “随机性来自采样机制”，我们已经拆解了 LLM 的核心行为逻辑。现在，我们可以基于这些观察，提炼出一组工程视角下的第一性原理 —— 这将成为后续所有系统设计的底层逻辑。</p>
<p>这一组<strong>工程级结论</strong>即：</p>
<ul>
<li>LLM 不是知识库</li>
<li>LLM 不是规则引擎</li>
<li>LLM 也不是“思考主体”</li>
</ul>
<p>而是：</p>
<blockquote>
<p><strong>一个基于上下文进行概率生成的语言函数</strong></p>
</blockquote>
<p>这意味着：</p>
<ul>
<li>它的所有能力，都依赖于输入</li>
<li>它的所有不可靠性，也来自输入</li>
</ul>
<p><strong>你能控制的，不是模型本身，而是系统如何使用它。</strong></p>
<p>既然 “系统如何使用 LLM” 是可控的核心，那么在系统设计中，除了输入的上下文（比如 Prompt），还有哪些因素会直接影响 LLM 的行为？</p>
<p>如果你曾困惑于 “为什么同样的模型和 Prompt，效果时好时坏”，答案很可能藏在那些被你当作 “微调参数” 的配置里 —— 它们其实是控制 LLM 行为的核心面板。接下来的第二章，我们就来拆解这些参数的真正作用。</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/llm/04-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>第 2 章：模型不是重点，参数才是你真正的控制面板</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/05.LLM%E5%8F%82%E6%95%B0%E5%86%B3%E7%AD%96.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/05.LLM%E5%8F%82%E6%95%B0%E5%86%B3%E7%AD%96.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第 2 章：模型不是重点，参数才是你真正的控制面板</source>
      <description>在了解 LLM 的基本工作方式之后，我们来看一个实际体验中很常见的问题： 为什么同一个模型、同样的 Prompt， 有时表现很好，有时却很糟糕？ 2.1 一个常见困惑：为什么效果忽好忽坏？ 在实际使用中，我们可能都遇到过，选择了更牛的模型、也按照要求反复调整了提示词，在demo中表现挺好，可是只要一上线，各种问题就来了，如 输出不稳定 有时啰嗦，有时过于简短 出现不符合现状或者自相矛盾的结果</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 11:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在了解 LLM 的基本工作方式之后，我们来看一个<strong>实际体验中很常见的问题</strong>：</p>
<blockquote>
<p><strong>为什么同一个模型、同样的 Prompt， 有时表现很好，有时却很糟糕？</strong></p>
</blockquote>
<hr>
<h3> 2.1 一个常见困惑：为什么效果忽好忽坏？</h3>
<p>在实际使用中，我们可能都遇到过，选择了更牛的模型、也按照要求反复调整了提示词，在demo中表现挺好，可是只要一上线，各种问题就来了，如</p>
<ul>
<li>输出不稳定</li>
<li>有时啰嗦，有时过于简短</li>
<li>出现不符合现状或者自相矛盾的结果</li>
</ul>
<p>然后我们能干啥呢？ 换个模型？ 调整下提示词？ 或者随机改一下传参？ 即便是某一次碰巧搞定了，也不知道为啥。 将确定的编程过程整成了玄学，一个雷放在那儿、随时可能爆炸，这可以说是一个码农的噩梦了。</p>
<p>但问题到底出在什么地方呢？LLM开发让人头疼的一点也在于此，不像我们的业务代码，还可以通过debug，单步到核心逻辑去研究一下；大模型对于开发者而言，更多的是一个黑盒，想调试也束手无策</p>
<p>一般这种场景下，问题有可能并不在模型本身，而在于：</p>
<blockquote>
<p><strong>你是否意识到：参数本身就是“行为策略”？</strong></p>
</blockquote>
<p>当我们说 “参数是行为策略”，并不是指那些随意调整的 “玄学数值”。 比如 <code>temperature</code> 和 <code>top_p</code> 这两个最常用的参数，很多地方将他们描述为 “控制创造性的调味料”，这种描述挺贴切的，但是在具体的编码活动中，我们可能更希望有一个确切的数值标准，如果有不同的应用场景的最佳参数设置实践，那就更完美了。</p>
<p>接下来，我们仔细盘一下这两个参数 —— 它们到底在控制 LLM 的什么行为？</p>
<hr>
<h3> 2.2 temperature / top_p 不是“调味料”</h3>
<p>网上很多教程中，将<code>temperature</code> 解释为 <strong>“控制创造性，越大越发散”</strong> 的核心控制参数</p>
<p>这句话<strong>挺贴切的，从工程化的角度改怎么理解呢？</strong>。</p>
<p>使用更专业或者不那么容易懂语言进行解释</p>
<blockquote>
<p><strong>temperature 决定：模型是否允许偏离当前最优预测路径。</strong></p>
</blockquote>
<ul>
<li>temperature 越低
→ 越倾向选择概率最高的 token</li>
<li>temperature 越高
→ 越允许探索次优甚至低概率路径的 token</li>
</ul>
<p>从上面的描述，也可以得出一个直观的感受，temperature的取值，可影响</p>
<ul>
<li>输出是否可复现</li>
<li>行为是否稳定</li>
<li>是否适合被系统消费（而不仅是人阅读）</li>
</ul>
<hr>
<h4> 那 top_p 又是什么？</h4>
<p>如果说 temperature 是“整体发散程度”，那 <code>top_p</code> 更像是：</p>
<blockquote>
<p><strong>你允许模型在“多大的候选范围”里做选择。</strong></p>
</blockquote>
<ul>
<li><code>top_p = 0.9</code>
→ 只从累计概率前 90% 的 token 中选</li>
<li><code>top_p = 1.0</code>
→ 几乎不做限制</li>
</ul>
<p>请注意，所有的参数都不是独立生效的，他们必然是相互影响的（感觉像是废话，参数都是一起传给大模型的，肯定是一起工作的啊🤣）</p>
<p>在实际的开发过程中，不妨借鉴一下 “控制变量法” 的思路来进行调参：</p>
<ul>
<li><strong>固定其中一个</strong></li>
<li><strong>调另一个作为主策略</strong></li>
</ul>
<p>显然这又是一个痛苦和煎熬的反复拉扯过程~</p>
<hr>
<h3> 2.3 model：不是“越强越好”，而是“是否匹配任务”</h3>
<p>有一个反直觉的事实表现：</p>
<blockquote>
<p><strong>模型越大、越新，系统并不一定表现就越好。</strong></p>
</blockquote>
<p>在真实的应用抉择上，模型选择其实是一个多方面的<strong>工程权衡问题</strong>：</p>
<ul>
<li>能力上限</li>
<li>成本</li>
<li>延迟</li>
<li>行为一致性</li>
</ul>
<p>比如几个经典的应用场景下对模型的要求：</p>
<ul>
<li>
<p><strong>规则解释 / 企业知识问答</strong></p>
<ul>
<li>更需要稳定、克制</li>
<li>不一定需要最“聪明”的模型</li>
</ul>
</li>
<li>
<p><strong>创意生成 / 头脑风暴</strong></p>
<ul>
<li>可以接受不确定性</li>
<li>模型探索能力更重要</li>
</ul>
</li>
</ul>
<p>因此，一个更健康的视角是：</p>
<blockquote>
<p><strong>model 是能力边界，参数决定你是否触碰这个边界。</strong></p>
</blockquote>
<hr>
<h3> 2.4 max_tokens：你允许系统“说到什么程度”</h3>
<p><code>max_tokens</code> 经常被当作一个简单的“长度限制”。</p>
<p>但在系统层面，它真正控制的是：</p>
<blockquote>
<p><strong>模型是否被允许“继续展开思路”。</strong></p>
</blockquote>
<p>这在以下场景尤为关键：</p>
<ul>
<li>多步推理</li>
<li>解释性回答</li>
<li>Agent 场景中的中间推理</li>
</ul>
<p>如果 <code>max_tokens</code> 过低，导致 <code>推理会被强行截断</code> + <code>输出容易“看似合理但不完整”</code></p>
<p>如果过高，也会导致 <code>成本上升</code> + <code>模型更容易开始“自由发挥”</code></p>
<p>所以它本质上是：</p>
<blockquote>
<p><strong>对“思考深度”的一种工程约束。</strong></p>
</blockquote>
<p>看到这里不知道你脑海里是否和我有相同的感觉，这种大模型调用的传参，感觉变成了一个<code>经验学科</code>了，只有实际体验得多了，才知道什么场景、选择什么样的传参🤣</p>
<hr>
<h3> 2.5 stream：不是体验优化，而是系统架构选择</h3>
<p><code>stream</code> 可以简单的理解为 <code>能不能一边生成一边显示结果</code></p>
<p>在复杂系统中，它还包含着一些潜在的含义：</p>
<ul>
<li>是否允许<strong>增量消费输出</strong></li>
<li>是否能在生成过程中：
<ul>
<li>中断</li>
<li>校验</li>
<li>触发后续逻辑</li>
</ul>
</li>
</ul>
<p>在 Agent / Tool / 长文本场景中：</p>
<ul>
<li>非流式 → 一次性黑箱结果</li>
<li>流式 → 可观测、可干预</li>
</ul>
<p>从上面的描述也可以看出，流式调用除了体验的优化之外，还有一些系统约束层面的能力</p>
<blockquote>
<p><strong>LLM可以是“一次性函数调用”之外，作为系统的一部分存在</strong></p>
</blockquote>
<h3> 2.6 用「任务类型」来决定参数，而不是凭感觉</h3>
<p>上面说了这些参数，那么在我的应用场景中，具体应该怎么设置呢， 全部用默认参数吗？</p>
<p>显然一个更合理的做法是：</p>
<blockquote>
<p><strong>先判断你在做什么任务，再决定参数策略。</strong></p>
</blockquote>
<p>比如根据实际场景，我是否需要一个发散性的回复，例如</p>
<ul>
<li>代码生成：
<ul>
<li>temperature 低</li>
<li>输出结构稳定</li>
</ul>
</li>
<li>创意写作：
<ul>
<li>temperature 高</li>
<li>接受一定不确定性</li>
</ul>
</li>
</ul>
<figure><img src="/imgs/column/llm/05-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>一组参数配合调参，应对不同的应用场景：</p>
<figure><img src="/imgs/column/llm/05-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 2.7 把参数当成策略的一部分（伪代码示例）</h3>
<p>明确了 “任务类型决定参数策略” 的逻辑后，接下来我们再来看一下，代码实现上，可以怎么进行表现（好像也是简单的if/else 😊）</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 2.8 本章小结</h3>
<p>这一篇的内容主要介绍了大模型访问的几个关键传参，并且声明了大模型表现与参数配置之间的关系</p>
<ul>
<li>模型决定能力上限</li>
<li>参数决定行为方式</li>
<li>行为决定系统是否可靠</li>
</ul>
<p>在后面的章节中我们也会逐渐发现</p>
<ul>
<li>Prompt 是<strong>约束</strong></li>
<li>参数是<strong>策略</strong></li>
<li>RAG / Tool / Memory 是<strong>补偿机制</strong></li>
</ul>
<p>所有的这一切，都是围绕着 <strong>如何让一个不可靠的模型，在系统中变得可控。</strong> 努力</p>
<p>既然参数这一块已经说明，接下来自然就是重头戏，如何与LLM进行对话交流，所以下一部分，我们将正式进入 <code>Prompt</code> 工程，但不从“怎么写”开始，而是先回答：</p>
<p><strong>Prompt 为什么会失败？</strong></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/llm/05-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>第二部分｜Prompt 工程：从“写提示词”到“设计约束系统”（以企业知识库助手为主线）</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/06.%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%20Prompt%E5%B7%A5%E7%A8%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/06.%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%20Prompt%E5%B7%A5%E7%A8%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第二部分｜Prompt 工程：从“写提示词”到“设计约束系统”（以企业知识库助手为主线）</source>
      <description>本部分目标： 让读者真正理解 Prompt 在系统中的地位，而不是学会几条写作技巧 通过「企业知识库助手」这一真实场景，引导读者像工程师一样思考 Prompt 为后续 RAG、Memory、Agent 建立统一的“约束设计”认知框架 在第一部分中，我们已经反复强调过一个结论： LLM 天生不可靠，可靠性来自系统，而不是模型本身。</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 11:55:07 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本部分目标：</p>
<ul>
<li>让读者真正<strong>理解 Prompt 在系统中的地位</strong>，而不是学会几条写作技巧</li>
<li>通过「企业知识库助手」这一真实场景，引导读者<strong>像工程师一样思考 Prompt</strong></li>
<li>为后续 RAG、Memory、Agent 建立统一的“约束设计”认知框架</li>
</ul>
</blockquote>
<p>在第一部分中，我们已经反复强调过一个结论：</p>
<blockquote>
<p><strong>LLM 天生不可靠，可靠性来自系统，而不是模型本身。</strong></p>
</blockquote>
<p>这一部分要回答的问题是：</p>
<blockquote>
<p><strong>在还没有 RAG、没有工具、没有 Agent 之前，
我们能做的第一件工程化的事情是什么？</strong></p>
</blockquote>
<p>答案是：<strong>Prompt 工程。</strong></p>
<p>但请注意：</p>
<blockquote>
<p>本书所说的 Prompt 工程，
并不是“写得更聪明”，
而是“约束得更清楚”。</p>
</blockquote>
<hr>
<h2> 示例应用贯穿说明：企业知识库助手</h2>
<p>在本书后续所有章节中，我们都会围绕同一个示例系统展开：</p>
<blockquote>
<p><strong>企业知识库助手（Enterprise Knowledge Assistant）</strong></p>
</blockquote>
<p>这是一个非常“现实世界”的系统：</p>
<ul>
<li>面向公司内部员工（用户群体明确，需求集中在业务流程、制度规范、产品信息等具体领域）</li>
<li>回答的问题往往<strong>有标准答案</strong>（例如 “报销流程需要哪些审批人”“产品 A 的质保期限是多久”）</li>
<li>回答错误的成本很高（可能导致员工操作违规、业务决策失误，甚至法律风险）</li>
<li>“听起来合理但其实是错的”，比“不知道”更糟糕（例如错误告知 “供应商付款无需 CEO 审批”，可能引发财务漏洞）</li>
</ul>
<p>这使它成为 Prompt 工程的<strong>理想试验场</strong>。—— 因为它对 “准确性” 和 “可控性” 的要求，恰好击中了 LLM 最需要被约束的痛点。</p>
<p>正是这样一个对可靠性要求极高的系统，在实际开发中却常常因为 “简单化的 Prompt 设计” 而翻车。很多团队认为只要给模型贴上 “知识库助手” 的标签，就能得到符合预期的结果，但现实往往事与愿违。为什么看似清晰的 Prompt 会失效？这背后藏着对 LLM 工作逻辑的认知偏差，也暴露了 Prompt 设计中未被重视的核心问题 —— 这正是我们接下来要深入拆解的内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title></title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/07.Prompt%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%A4%B1%E8%B4%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/07.Prompt%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%A4%B1%E8%B4%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml"></source>
      <description>order: 7 title: 第 3 章：Prompt 为什么会失败？ tag: - LLM category: - LLM date: 2025-12-30 12:15:07 keywords: LLM应用开发 在大模型应用开发之初，demo版、或者初版的设计一般大同小异，比如以企业知识库助手为例，第一版实现通常是这样的： “你是一个企业知识库助手，请根据公司文档回答用户的问题。”</description>
      <pubDate>Wed, 31 Dec 2025 02:21:16 GMT</pubDate>
      <content:encoded><![CDATA[<hr>
<h2> order: 7
title: 第 3 章：Prompt 为什么会失败？
tag:
- LLM
category:
- LLM
date: 2025-12-30 12:15:07
keywords: LLM应用开发</h2>
<p>在大模型应用开发之初，demo版、或者初版的设计一般大同小异，比如以企业知识库助手为例，第一版实现通常是这样的：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从实际的表现来看，demo还行，但是离生产使用，总是差点意思：</p>
<ul>
<li>回答流畅（大模型的输出一般还是很可以的，至少语言组织天赋应该胜过很多像我这样比较潦草的人了🤣）</li>
<li>语气专业（即使回答内容有误，也是一股正经、理直气壮，这就是让开发者感到为难的地方了~）</li>
<li>但事实经常对不上（例如把 “3 个工作日审批” 说成 “5 个工作日”，把 “部门经理审批” 漏掉）</li>
</ul>
<p>那么问题来了：</p>
<blockquote>
<p><strong>Prompt 已经写了，为什么系统还是不可靠？</strong></p>
</blockquote>
<hr>
<h3> 3.1 一个必须先纠正的认知误区</h3>
<p>很多小伙伴可能会有下面这个潜意识</p>
<blockquote>
<p>“Prompt 是给模型下指令的。”</p>
</blockquote>
<p>但如果你还记得第一部分的结论，就会意识到：</p>
<blockquote>
<p><strong>LLM 并不会‘执行指令’，它只是在延续文本。</strong></p>
</blockquote>
<p>这是啥意思呢，又表明什么呢？</p>
<ul>
<li><code>Prompt</code> 不是命令（模型没有 “理解指令并执行” 的能力，它只是根据上下文概率生成下一个词）</li>
<li><code>Prompt</code> 是上下文的一部分（模型会把 Prompt 当作 “对话历史” 的开头，然后 “接话”）</li>
<li><code>Prompt</code> 的作用，是改变生成空间的形状（通过调整上下文，让模型更可能生成符合预期的内容）</li>
</ul>
<p>如果你在上下文中留下了模糊空间，大模型“自由合理地填满这些空白”，就是必然会出现的结果了</p>
<p>举个例子来解释下上面的说法</p>
<p>当用户问 “公司的病假工资怎么算？”，如果 Prompt 只说 “根据公司文档回答”，模型会怎么做？</p>
<p>它会先从训练数据中回忆 “一般公司的病假工资规则”（比如 “按基本工资的 80% 发放”），再尝试把这个 “常识” 套进 “公司文档” 的语境里</p>
<p>即使文档中明确写的是 “按全额工资发放”，模型也可能因为 “常识更熟悉” 而优先输出错误内容。</p>
<hr>
<h3> 3.2 企业场景下，Prompt 最常见的三类失败模式</h3>
<h4> 失败模式一：角色边界缺失</h4>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个描述在自然语言中是清晰的，但对模型来说，信息几乎为零。</p>
<p>问题在于：</p>
<ul>
<li>这个角色是否可以使用常识？（比如用户问 “打印机坏了怎么办”，是否可以推荐 “重启试试” 这种通用经验？）</li>
<li>是否可以综合多份资料？（比如用户问 “跨部门协作流程”，是否允许整合《部门沟通规范》和《项目管理手册》的内容？）</li>
<li>是否允许推断 “合理但未写明” 的结论？（比如文档说 “员工入职满 1 年可休年假”，是否可以推断 “不满 1 年不可休”？）</li>
</ul>
<blockquote>
<p><strong>没有被否定的行为，都会被模型视为“允许”。</strong></p>
</blockquote>
<p>在企业场景中，这种 “默认允许” 往往是灾难的源头。</p>
<p>比如某公司文档只写了 “经理级以上可申请弹性工作”，模型可能会 “合理推断”“主管级以下不可申请”</p>
<p>但实际上，文档漏写了 “主管级满足条件也可申请”，导致员工权益受损。</p>
<hr>
<h4> 失败模式二：信息来源未被工程化</h4>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从模型视角看：</p>
<ul>
<li>“你所知道的内容” = 训练语料（互联网上的通用知识、其他公司的制度、甚至过时的信息） + 当前上下文（可能包含的部分文档片段）</li>
</ul>
<p>而在企业知识库助手中，我们真正想要的是：</p>
<blockquote>
<p><strong>一个“被严格限制的信息子集”（即 “仅当前提供的公司内部文档”）。</strong></p>
</blockquote>
<p>这也是为什么后续 RAG 的核心价值，并不只是“补充知识”，而是： <strong>缩小生成空间。</strong></p>
<p>举个具体案例：</p>
<p>某公司 2025 年更新了差旅费标准（住宿上限从 800 元调整为 1000 元），但模型训练数据截止到 2024 年。</p>
<p>如果 Prompt 没有严格限制 “仅用提供的 2024 年文档”，当用户问 “出差住宿能报多少” 时，模型会优先输出训练数据中的 800 元</p>
<p>因为对它来说，“旧知识” 比 “新文档片段” 更 “熟悉”。</p>
<hr>
<h4> 失败模式三：输出目标不可判定</h4>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这类 Prompt 最大的问题不是“不清楚”，而是：</p>
<blockquote>
<p><strong>你无法客观判断它有没有答对。</strong></p>
</blockquote>
<p>详细” 是多详细？“相关” 是哪些相关？当输出结果出现时，你只能凭感觉说 “好像对” 或 “好像不对”，但无法用明确的标准验证。</p>
<p>一旦输出目标不可判定：</p>
<ul>
<li>系统无法测试（无法写自动化用例验证 “是否符合详细说明的要求”）</li>
<li>系统无法评估（无法量化 “回答准确率”，只能靠人工主观打分）</li>
<li>系统也无法迭代（不知道改 Prompt 后是变好还是变坏）</li>
</ul>
<p>例如，当用户问 “报销流程有几步” 时，“详细说明” 可能输出 “先填单、再审批、最后报销”（3 步），也可能输出 “填单需附发票、审批分部门和财务、报销到账约 3 天”（包含额外信息）。</p>
<p>这两种输出都符合 “详细”，但前者漏了关键步骤（如 “发票校验”），却无法通过明确规则判定错误。</p>
<hr>
<h3> 3.3 本章小结</h3>
<p>到这里，我们可以给出一个工程层面的总结：</p>
<blockquote>
<p><strong>Prompt 失败的根本原因，不是表达能力不足，而是约束设计不足。</strong></p>
</blockquote>
<p>Prompt 的核心职责不是 “告诉模型该怎么说”（比如 “用专业语气”“分点回答”），而是：</p>
<blockquote>
<p><strong>明确告诉模型：哪些内容是被允许生成的，哪些不是。</strong></p>
</blockquote>
<p>既然我们已经找到了 Prompt 失败的根源是 “约束设计不足”，那么解决方案就不再是 “优化措辞”，而是构建一套系统化的约束框架。Prompt 不应该是零散的指令集合，而需要有稳定、可复用的结构来承载这些约束</p>
<p>—— 这正是第 4 章要探讨的核心：如何通过工程化的结构设计，让 Prompt 真正成为可靠的 “约束系统”。</p>
]]></content:encoded>
    </item>
    <item>
      <title>第 4 章：Prompt 的工程化结构设计</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/08.Prompt%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/08.Prompt%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第 4 章：Prompt 的工程化结构设计</source>
      <description>既然 Prompt 的本质是“约束生成空间”，那么它就不应该是随意拼接的字符串，而应该具备清晰、稳定、可复用的结构。 4.1 Prompt 为什么必须结构化？ 请思考一个问题： 如果 Prompt 改了一句话，系统行为发生了明显变化， 这是好事，还是坏事？ 在工程视角下，这通常是一个危险信号。 因为它意味着： 行为不可预测（改一个词就 “性情大变”，说明系统没有稳定的约束逻辑） 改动影响范围不可控（不知道改这句话会让哪些场景的输出出错）</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 12:45:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>既然 Prompt 的本质是“约束生成空间”，那么它就不应该是随意拼接的字符串，而应该具备清晰、稳定、可复用的结构。</p>
<hr>
<h3> 4.1 Prompt 为什么必须结构化？</h3>
<p>请思考一个问题：</p>
<blockquote>
<p>如果 Prompt 改了一句话，系统行为发生了明显变化， 这是好事，还是坏事？</p>
</blockquote>
<p>在工程视角下，这通常是一个<strong>危险信号</strong>。</p>
<p>因为它意味着：</p>
<ul>
<li>行为不可预测（改一个词就 “性情大变”，说明系统没有稳定的约束逻辑）</li>
<li>改动影响范围不可控（不知道改这句话会让哪些场景的输出出错）</li>
</ul>
<p>结构化 Prompt 的目标正是：</p>
<blockquote>
<p><strong>让系统行为的变化，来源于“有意识的设计”，
而不是偶然的文本差异。</strong></p>
</blockquote>
<p>例如，当你想调整 “是否允许模型使用外部知识” 时，只需要修改 “约束/Constraints” 部分的某一条规则，而不是在整个 Prompt 中 “凭感觉加一句话”—— 这样的改动可预期、可追溯。</p>
<hr>
<h3> 4.2 一个可解释、可扩展的 Prompt 结构</h3>
<p>在企业知识库助手中，我们采用如下四段式结构：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这四部分分别解决四个不同的问题：</p>
<ul>
<li>我是谁？（Role：明确模型的 “权限范围” 和 “责任边界”，避免越权行为）</li>
<li>我要做什么？（Task：锁定当前任务的核心目标，避免答非所问）</li>
<li>我不能做什么？（Constraints：划出 “红线”，禁止可能导致错误的行为）</li>
<li>我的结果如何被判断？（Output Schema：定义输出的格式和标准，让 “对 / 错” 可量化）</li>
</ul>
<p>这个结构的优势在于：</p>
<ul>
<li>可解释性：任何一个环节的设计都有明确目的，便于团队协作理解</li>
<li>可扩展性：需要新增约束时，直接在对应部分补充即可，无需重构整体</li>
<li>可测试性：每一部分都能单独验证（比如测试 Constraints 是否有效阻止了幻觉）</li>
</ul>
<hr>
<h3> 4.3 将结构落地到企业知识库助手（深入示例）</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意这里的几个关键设计细节：</p>
<ul>
<li><strong>Role 部分的权责绑定</strong>：不仅说了 “是什么”，还明确了 “不是什么”（没有权限访问未公开信息），从源头限制模型的 “越界冲动”。</li>
<li><strong>Task 部分的冲突处理</strong>：提前定义 “资料冲突时需全部列出”，避免模型 “主观选择” 一个更 “合理” 的答案（而忽略真实的资料矛盾）。</li>
<li><strong>Constraints 中的 “禁止推断”</strong>：在企业场景中，“资料没说 = 不能确定”，比如资料只写了 “销售部可享受 XX 福利”，模型不能推断 “其他部门不可享受”（可能只是资料漏写）。</li>
<li><strong>Output Schema 的可验证性</strong>：通过 “标注资料编号”，用户可以直接回溯原始资料验证答案；冲突处理的格式要求，让 “矛盾信息” 一目了然，避免误导。</li>
</ul>
<p>其中最核心的设计是：</p>
<blockquote>
<p><strong>“不知道”被明确列为一种合法输出。</strong></p>
</blockquote>
<p>这一步对于企业系统至关重要，因为它第一次从 Prompt 层面：</p>
<blockquote>
<p><strong>压缩了幻觉出现的空间。</strong></p>
</blockquote>
<p>模型会意识到：“说不知道” 是被允许的，甚至是更安全的选择，而不是必须 “强行给一个答案”。</p>
<hr>
<h3> 4.4 Prompt 结构如何影响生成空间（示意图）</h3>
<figure><img src="/imgs/column/llm/08-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这个示意图的核心逻辑是：</p>
<ul>
<li>Role 和 Task 先框定 “大致范围”（比如 “企业知识库助手”+“回答资料相关问题”）</li>
<li>Constraints 像 “过滤器” 一样压缩空间（去掉 “外部知识”“推断内容” 等无效区域）</li>
<li>Output Schema 最后筛选出 “符合格式标准” 的输出（确保结果可评估）</li>
</ul>
<p>最终的 “可生成空间” 越小、越明确，LLM 输出的可靠性就越高。</p>
<p>结构化 Prompt 解决了 “单次调用” 的约束问题，但在真实的企业系统中，Prompt 不会是 “一劳永逸” 的 —— 新业务场景会要求新增约束，多部门复用会需要灵活适配，版本迭代会需要追溯变更。这意味着 Prompt 不能只停留在 “设计” 层面，还需要进入工程化的治理体系，像代码一样被管理、被复用、被迭代 —— 这正是第 5 章要聚焦的 “从 Prompt 到 Prompt 模板与工程治理”。</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/llm/08-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>第 5 章：从 Prompt 到 Prompt 模板与工程治理</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/09.Prompt%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%B7%A5%E7%A8%8B%E6%B2%BB%E7%90%86.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/09.Prompt%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%B7%A5%E7%A8%8B%E6%B2%BB%E7%90%86.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第 5 章：从 Prompt 到 Prompt 模板与工程治理</source>
      <description>当我们开发的系统被真实用户使用时，很快就会发现： Prompt 不是一次性工作（初期设计总会有遗漏，比如没考虑 “资料重复” 的处理） Prompt 会不断演进（新的业务场景出现，需要新增约束；模型升级后，可能需要调整规则） 而且每一次修改，都可能悄悄改变系统行为 这意味着，单纯的硬编码提示词会存在很多的工程性问题 Prompt 必须进入工程治理体系。 5.1 Prompt 是“软代码”，而不是文案</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 13:45:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>当我们开发的系统被真实用户使用时，很快就会发现：</p>
<ul>
<li>Prompt 不是一次性工作（初期设计总会有遗漏，比如没考虑 “资料重复” 的处理）</li>
<li>Prompt 会不断演进（新的业务场景出现，需要新增约束；模型升级后，可能需要调整规则）</li>
<li>而且每一次修改，都可能悄悄改变系统行为</li>
</ul>
<p>这意味着，单纯的硬编码提示词会存在很多的工程性问题</p>
<blockquote>
<p><strong>Prompt 必须进入工程治理体系。</strong></p>
</blockquote>
<hr>
<h3> 5.1 Prompt 是“软代码”，而不是文案</h3>
<p>在很多早期项目中，Prompt 往往以这样的形式存在：</p>
<ul>
<li>写在代码里的一段字符串</li>
<li>存在 Notion / 文档中的一段描述</li>
<li>甚至只存在于某个同事的“经验里”</li>
</ul>
<p>这在 Demo 阶段或许还能接受，但在企业知识库助手这样的系统中，这是<strong>极其危险的</strong>。</p>
<p>如在企业知识库助手中：</p>
<ul>
<li>Prompt 的一次微调（比如删掉 “禁止推断”）</li>
<li>可能直接影响业务决策（员工根据错误推断的内容执行操作）</li>
</ul>
<p>这种不可控性，很容易产生不可预知的后果，而产生这些问题的原因也很简单：</p>
<ul>
<li>
<p>Prompt 决定模型的<strong>行为边界</strong></p>
</li>
<li>
<p>Prompt 的一次微调，可能直接影响：</p>
<ul>
<li>回答是否合规</li>
<li>是否产生幻觉</li>
<li>是否越权推断</li>
</ul>
</li>
</ul>
<p>从工程视角看，你必须接受一个事实：</p>
<blockquote>
<p><strong>Prompt 是一种“软代码（Soft Code）”。</strong></p>
</blockquote>
<p>它和代码的区别只在于：</p>
<ul>
<li>不是由编译器执行</li>
<li>而是由模型“解释执行”</li>
</ul>
<p>因此你需要像对待代码一样对待 Prompt：</p>
<ul>
<li>版本管理：记录每一次修改的时间、修改人、修改原因（例如 “v1.2 新增‘资料冲突处理规则’，解决财务制度矛盾问题”）</li>
<li>可回滚：当某次修改导致错误率上升时，能快速切回上一个稳定版本</li>
<li>可审计：在出现问题时，能追溯到某版 Prompt 的设计逻辑，分析漏洞来源</li>
</ul>
<hr>
<h3> 5.2 什么是 Prompt 模板？（不是字符串复用）</h3>
<p>很多人第一次听到“Prompt 模板”时，会误以为：</p>
<blockquote>
<p><em>不就是把 Prompt 抽成一个格式化字符串吗？</em></p>
</blockquote>
<p>这只是最表层的理解。</p>
<p>更准确地说：</p>
<blockquote>
<p><strong>Prompt 模板是一种“设计决策的结构化表达”。</strong></p>
</blockquote>
<p>它的核心目标不是复用文本，而是<strong>固定认知结构</strong>。</p>
<h4> 一个最小但正确的 Prompt 模板结构</h4>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意：
这里的每一块，并不是为了“好看”，而是为了<strong>工程可控性</strong>。</p>
<p>在工程实践中，这意味着：</p>
<ul>
<li>Prompt 可以被 review：团队成员能清晰看到 “Role/Task/Constraints” 等模块的设计，针对性提出意见（比如 “Constraints 漏了‘禁止修改数字’”）</li>
<li>Prompt 可以被测试：通过填充不同变量（如不同的 reference_materials），编写自动化用例验证 “是否符合约束”（例如用例 1：输入无相关资料的问题，检查是否输出 “不知道”）</li>
<li>Prompt 变化是可追踪的：当需要调整时，只需修改对应模块的变量（如更新 constraints 列表），而不是改写整个 Prompt，确保改动可预期</li>
</ul>
<p>例如，针对不同部门的知识库（如 “人力资源”“财务”），可以通过填充不同的 role 变量（“你是人力资源知识库助手，专注于考勤、福利等制度”），实现 “一套模板，多场景复用”，同时保持核心约束的一致性。</p>
<hr>
<h3> 5.3 Prompt 模板解决的，其实是“无意识漂移”</h3>
<p>Prompt 最危险的地方在于：<strong>它可以在不被察觉的情况下改变系统行为。</strong></p>
<p>例如：</p>
<ul>
<li>新增一句“请尽量详细说明”</li>
<li>删除一句“不确定时请说明不知道”</li>
<li>调整一下角色描述语气</li>
</ul>
<p>这些修改往往是：</p>
<ul>
<li>出于好意</li>
<li>为了解决一个局部问题</li>
</ul>
<p>但它们可能导致：</p>
<blockquote>
<p><strong>整个系统的行为分布发生变化。</strong></p>
</blockquote>
<p>Prompt 模板的真正价值就在于：</p>
<blockquote>
<p><strong>把“为什么要这么写”固化成结构，而不是留在人的记忆里。</strong></p>
</blockquote>
<hr>
<h3> 5.4 Prompt 模板在系统中的位置（结构图）</h3>
<p>下面这张图非常关键，它说明了 Prompt 在整个 LLM 系统中的真实位置：</p>
<figure><img src="/imgs/column/llm/09-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这意味着：</p>
<ul>
<li>Prompt <strong>不是直接对着模型写的</strong></li>
<li>而是：
<ul>
<li>介于「业务意图」与「模型行为」之间的<strong>中间层</strong></li>
</ul>
</li>
</ul>
<p>它是<strong>第一道、也是最脆弱的一道约束机制</strong>。</p>
<hr>
<h3> 5.5 Prompt 工程 ≠ Prompt 治理</h3>
<p>到这里，很多读者会产生一个误解：</p>
<blockquote>
<p><em>“那我只要设计一个好模板就行了？”</em></p>
</blockquote>
<p>答案是：<strong>远远不够。</strong></p>
<p>Prompt 工程解决的是：</p>
<ul>
<li><strong>如何设计一次合理的约束</strong></li>
</ul>
<p>而 Prompt 治理要解决的是：</p>
<ul>
<li><strong>这些约束如何在时间维度上不被破坏</strong></li>
</ul>
<hr>
<h4> 一个典型的 Prompt 失控路径</h4>
<figure><img src="/imgs/column/llm/09-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>注意：
这条路径中，<strong>没有任何一步是“错误操作”</strong>。</p>
<p>但最终结果却是：</p>
<ul>
<li>行为不可预测</li>
<li>无法解释为什么“最近变差了”</li>
</ul>
<hr>
<h3> 5.6 工程治理中的 Prompt 最佳实践</h3>
<p>在企业级 LLM 应用中，Prompt 至少应当具备以下治理能力：</p>
<h4> 1️. Prompt 必须版本化</h4>
<ul>
<li>
<p>每一次修改都有版本号</p>
</li>
<li>
<p>可以明确回答：</p>
<blockquote>
<p>“这个行为是从哪个版本开始变化的？”</p>
</blockquote>
</li>
</ul>
<h4> 2. Prompt 必须可审计</h4>
<ul>
<li>
<p>你要能回答：</p>
<ul>
<li>谁改的？</li>
<li>为什么改？</li>
<li>解决什么问题？</li>
</ul>
</li>
</ul>
<h4> 3️. Prompt 必须可测试</h4>
<ul>
<li>
<p>至少要能在一组固定输入上：</p>
<ul>
<li>对比修改前 / 后输出差异</li>
</ul>
</li>
</ul>
<h4> 4. Prompt 只负责“静态约束”</h4>
<ul>
<li>
<p>不要试图在 Prompt 中：</p>
<ul>
<li>记忆历史</li>
<li>管理状态</li>
<li>承载大量知识</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Prompt 的职责边界越清晰，系统就越稳定。</strong></p>
</blockquote>
<hr>
<h3> 5.7 Prompt 模板示例（工程化）</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个模板的价值不在于“写得好不好”，而在于：</p>
<ul>
<li>行为边界清晰</li>
<li>失败路径明确</li>
<li>可被团队理解与维护</li>
</ul>
<h3> 5.3 本部分总结：Prompt 是约束，不是智能来源</h3>
<p>通过这一部分，你应该已经建立起这样一种认知：</p>
<ul>
<li>Prompt 不是魔法</li>
<li>Prompt 也不是文案</li>
<li>Prompt 更不是“越复杂越好”</li>
</ul>
<p>而是：</p>
<blockquote>
<p><strong>LLM 系统中的第一层行为约束机制。</strong></p>
</blockquote>
<p>但你也应该已经隐约意识到一个事实：</p>
<blockquote>
<p>即使 Prompt 再稳定，
只要对话持续、信息累积，
系统仍然会开始失控。</p>
</blockquote>
<p>这并不是 Prompt 设计的问题，而是<strong>上下文与记忆无法靠 Prompt 解决</strong>的问题。</p>
<hr>
<blockquote>
<p><strong>下一部分，我们将进入 Context 与 Memory：
为什么“对话一变长，系统就一定会出问题”？</strong></p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/llm/09-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>第三部分｜上下文与记忆：让企业知识库助手在时间维度上可靠</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/10.%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%20%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E8%AE%B0%E5%BF%86.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/10.%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%20%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E8%AE%B0%E5%BF%86.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第三部分｜上下文与记忆：让企业知识库助手在时间维度上可靠</source>
      <description>本部分目标： 解释一个几乎所有真实 LLM 系统都会遇到的问题：为什么对话一变长，系统就开始失控？ 引入并系统化「Context Engineering（上下文工程）」这一核心思想 让企业知识库助手从“单轮可用”，升级为“多轮可信” 在第二部分中，我们通过 Prompt 工程为模型建立了单次生成层面的约束—— 比如明确系统角色、限定回答范围、规范输出格式等。这些方法在单轮对话中往往能取得不错的效果：用户问一个问题，系统基于设定的规则和知识库给出答案，看起来既准确又可靠。</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 13:55:07 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本部分目标：</p>
<ul>
<li>解释一个几乎所有真实 LLM 系统都会遇到的问题：<strong>为什么对话一变长，系统就开始失控？</strong></li>
<li>引入并系统化「Context Engineering（上下文工程）」这一核心思想</li>
<li>让企业知识库助手从“单轮可用”，升级为“多轮可信”</li>
</ul>
</blockquote>
<p>在第二部分中，我们通过 Prompt 工程为模型建立了单次生成层面的约束—— 比如明确系统角色、限定回答范围、规范输出格式等。这些方法在单轮对话中往往能取得不错的效果：用户问一个问题，系统基于设定的规则和知识库给出答案，<em>看起来</em>既准确又可靠。</p>
<p>但如果你真正将企业知识库助手投入实际使用，很快就会收到用户这样的反馈：“一开始回答得挺准的，多聊几句就越来越离谱了。”</p>
<p>这并非 Prompt 突然失效，也不是模型能力下降，而是当对话从 “单轮” 进入 “多轮”，系统面临了一个全新的<strong>挑战维度 —— 时间</strong>。</p>
<p>在持续交互中，历史信息的累积会逐渐改变模型的输入环境，进而打破最初设定的约束边界。</p>
<p>接下来，我们将从上下文窗口的本质出发，逐步拆解多轮对话失控的根源，最终落地一套可工程化的上下文管理方案。</p>
]]></content:encoded>
    </item>
    <item>
      <title>第 6 章：上下文窗口的真实边界</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/11.%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AA%97%E5%8F%A3%E7%9A%84%E7%9C%9F%E5%AE%9E%E8%BE%B9%E7%95%8C.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/11.%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AA%97%E5%8F%A3%E7%9A%84%E7%9C%9F%E5%AE%9E%E8%BE%B9%E7%95%8C.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第 6 章：上下文窗口的真实边界</source>
      <description>在讨论“记忆”之前，我们必须先回答一个技术决策层面的问题： 当用户开始连续提问时，我们是否应该“尽量多地保留历史对话”？ 很多团队在这个问题上的直觉答案是： 当然要保留，历史越完整，模型越能理解上下文，回答自然更准确 但这一章要做的事情，正是推翻这个直觉 —— 因为 “全量保留历史” 不仅无法解决问题，反而会埋下系统失控的隐患。</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 14:05:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在讨论“记忆”之前，我们必须先回答一个<strong>技术决策层面的问题</strong>：</p>
<blockquote>
<p><strong>当用户开始连续提问时，我们是否应该“尽量多地保留历史对话”？</strong></p>
</blockquote>
<p>很多团队在这个问题上的直觉答案是：</p>
<blockquote>
<p><em>当然要保留，历史越完整，模型越能理解上下文，回答自然更准确</em></p>
</blockquote>
<p>但这一章要做的事情，正是<strong>推翻这个直觉</strong> —— 因为 “全量保留历史” 不仅无法解决问题，反而会埋下系统失控的隐患。</p>
<hr>
<h3> 6.1 一个常被忽略的事实：上下文不是记忆</h3>
<p>在 LLM 的 API 交互中，我们通常通过 messages 参数传入对话历史，格式类似这样：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这很容易让人产生一个工程误判：</p>
<blockquote>
<p>“只要我把历史消息都塞进去，模型就能记住一切。”</p>
</blockquote>
<p>但如果回到第一部分对 LLM 本质 —— <strong><code>token</code>序列的概率预测模型</strong> —— 的分析，你会发现：</p>
<ul>
<li>模型接收的所有上下文（包括系统提示、用户提问、历史回答）会被<strong>一次性拼接成一个长 <code>token</code> 序列</strong>（比如上述示例会变成 “<code>&lt;system&gt;</code>你是企业知识库助手...<code>&lt;user&gt;</code>请问年假怎么申请？<code>&lt;assistant&gt;</code>需通过 OA 系统...”）</li>
<li>它并不知道哪些是“历史”，哪些是“当前”（即它只会基于整个序列的统计规律预测下一个 token）</li>
<li>更不知道哪些信息<strong>在工程上更重要</strong>（比如 “仅回答内部政策”），哪些是 “临时的无关信息”。</li>
</ul>
<p>因此，一个关键认知是：</p>
<blockquote>
<p><strong>上下文只是输入数据，而不是记忆机制。</strong></p>
</blockquote>
<p>人类的记忆会主动筛选、分层、关联信息，而上下文只是无序的信息堆砌。</p>
<hr>
<h3> 6.2 上下文窗口的三个硬限制（为什么“全塞进去”一定会失败）</h3>
<p>即使你愿意无条件保留所有历史，对话系统也会很快撞上三个不可绕过的限制：</p>
<ol>
<li><strong>长度上限</strong>：超过窗口，信息会被直接截断</li>
</ol>
<p>所有 LLM 都有明确的 token 长度限制（比如 GPT-3.5 为 4k token，GPT-4 基础版为 8k token，增强版为 128k token）。当历史对话累积的 token 数超过这个上限时，系统只能通过 “截断” 处理（通常是删除最早的内容），这会直接导致早期关键信息（比如系统约束）丢失。举例：如果系统提示包含</p>
<p><em>“禁止回答外部政策”，但随着对话变长，这条约束被挤出窗口，模型就可能开始回答无关内容。</em></p>
<ol start="2">
<li><strong>注意力衰减</strong>：越靠前的信息，影响力越弱</li>
</ol>
<p><em>举例：用户在第 1 轮提到 “我是市场部员工”，到第 10 轮询问报销政策时，模型可能已经 “忽略” 了这个身份信息，给出了不适用的规则。</em></p>
<ol start="3">
<li><strong>成本与延迟</strong>：token 越多，系统越慢、越贵</li>
</ol>
<p>LLM 的调用成本（按 token 计费）和响应延迟与上下文长度正相关。全量保留历史会导致每轮对话的 token 数持续增长，直接推高系统成本（可能是初始成本的 10 倍以上），同时延长用户等待时间（从几百毫秒增至几秒）。</p>
<p>这些限制最终会导致一个危险的后果：</p>
<blockquote>
<p><strong>最早写下的系统约束（比如 “仅用知识库内容回答”“不泄露隐私”），反而最先失效。</strong></p>
</blockquote>
<hr>
<h3> 6.3 技术决策的失败路径：对话为什么会“慢慢跑偏”？</h3>
<p>当我们坚持 “全量保留历史对话” 时，对话系统会沿着一条可预见的路径逐渐失控，我们可以用一个流程图来理解这个过程：</p>
<figure><img src="/imgs/column/llm/11-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这并不是模型突然变差，而是系统在时间维度上<strong>失去了对约束的控制权</strong>。每一轮对话都会让关键规则的影响力减弱一分，直到最后完全失效。</p>
<p><em>比如，一个初始设定为 “仅回答薪酬相关问题” 的助手，在多轮对话后可能会开始回应 “公司地址”“产品价格” 等无关内容 —— 不是它 “忘记” 了规则，而是规则在上下文序列中被稀释到几乎无法影响预测结果。</em></p>
<hr>
<h3> 6.4 本章小结：一个必须接受的结论</h3>
<p>通过本章的分析，我们可以得出一个明确的结论：</p>
<ul>
<li>“尽量保留所有上下文”是一个<strong>工程反模式(Anti-pattern)</strong>，它会导致约束失效、成本飙升、体验下降。</li>
<li>上下文窗口无法承担“长期记忆”的职责，其本质上是 “一次性输入缓冲区”</li>
</ul>
<p>既然全量保留不可行，那自然会引出下一个问题：</p>
<blockquote>
<p><strong>如果不能无脑堆上下文，那我们到底该保留什么？</strong></p>
</blockquote>
<p>这正是下一章要解决的核心问题 —— 从 “被动堆积上下文” 转向 “主动管理上下文”。</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/llm/11-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>第 7 章：从 “堆上下文” 到 “管理上下文”</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/12.%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/12.%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第 7 章：从 “堆上下文” 到 “管理上下文”</source>
      <description>在上一章中，我们已经明确否定了一种做法： 把上下文当作“无限可用的记忆容器”。 那么一个更难、也更重要的问题随之出现： 在有限的上下文窗口里，哪些信息值得被保留？ 这并不是一个模型问题，而是一个系统设计决策 —— 它直接决定了多轮对话中系统的稳定性。 7.1 技术决策的第一步：承认信息是有“等级”的</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 14:25:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在上一章中，我们已经明确否定了一种做法：</p>
<blockquote>
<p><strong>把上下文当作“无限可用的记忆容器”。</strong></p>
</blockquote>
<p>那么一个更难、也更重要的问题随之出现：</p>
<blockquote>
<p><strong>在有限的上下文窗口里，哪些信息值得被保留？</strong></p>
</blockquote>
<p>这并不是一个模型问题，而是一个<strong>系统设计决策</strong> —— 它直接决定了多轮对话中系统的稳定性。</p>
<hr>
<h3> 7.1 技术决策的第一步：承认信息是有“等级”的</h3>
<p>在企业知识库助手的真实对话中，并不是所有信息都同等重要。</p>
<p>如果你不主动区分，模型就会被迫“平均对待”。</p>
<p>从工程角度，我们至少需要区分三类信息，它们的优先级和保留策略完全不同：</p>
<h4> 1.不变约束（最高优先级）</h4>
<p>指系统必须始终遵守的核心规则，不随对话内容变化而改变。</p>
<p>例如：</p>
<ul>
<li><em>系统角色定义（“你是 XX 公司的内部知识库助手，不对外提供服务”）</em></li>
<li><em>行为边界（“仅回答员工手册、财务制度中的内容，超出范围需明确拒绝”）</em></li>
<li><em>安全规则（“禁止泄露员工个人信息、未公开的业务数据”）</em></li>
</ul>
<p>这类信息必须<strong>永远保留在上下文窗口中</strong>，且位置要尽可能靠前（减少注意力衰减影响）。</p>
<h4> 2.会话状态（中高优先级）</h4>
<p>指当前对话中形成的关键共识、未完成的任务或用户的核心意图，是维持对话连贯性的基础。</p>
<p>例如：</p>
<ul>
<li><em>当前讨论主题（“用户正在咨询 2024 年新版差旅报销政策”）</em></li>
<li><em>已确认事实（“用户是销售部员工，经常出差至华东地区”）</em></li>
<li><em>待解决问题（“需确认‘高铁一等座是否可报销’”）</em></li>
</ul>
<p>这类信息需要<strong>持续维护和更新</strong>，确保模型了解对话的 “当前阶段”。</p>
<h4> 3. 瞬时上下文（低优先级）</h4>
<p>指对话中的临时交互、举例说明或过渡性内容，对长期连贯性影响较小。例如：</p>
<ul>
<li>用户的临时追问（“那二等座呢？”）</li>
<li>辅助说明（“比如我上次去上海的高铁票是一等座”）</li>
<li>无关寒暄（“谢谢，我再看看”）</li>
</ul>
<p>这类信息可以<strong>按需保留最近几轮</strong>，超出范围后可直接丢弃。</p>
<blockquote>
<p><strong>上下文失控的本质，不是信息太多，而是信息没有被分层。</strong> —— 让低优先级的内容挤占了高优先级信息的 “生存空间”。</p>
</blockquote>
<hr>
<h3> 7.2 为什么“直接摘要历史”并不是银弹？</h3>
<p>在意识到上下文有限后，很多团队会做出第二个直觉决策：</p>
<blockquote>
<p><em>那就把历史对话总结一下，再塞回去。</em></p>
</blockquote>
<p>这个思路的方向是对的（减少冗余信息），但如果不区分信息等级，简单做 “全量摘要”，会引入新的系统风险：</p>
<ul>
<li>约束信息被压缩：比如原系统提示中的 “5 条核心规则” 可能被摘要简化为 “遵守公司规定”，丢失关键细节。</li>
<li>错误结论被固化：如果某轮回答存在错误（比如 “年假可累计 15 天” 实际应为 10 天），摘要可能会保留这个错误并持续传递。</li>
<li>决策过程被抹平：用户曾明确拒绝的方向（比如 “我不想了解北京的政策”）可能在摘要中被忽略，导致模型重复无效信息。</li>
</ul>
<p>这意味着：</p>
<blockquote>
<p><strong>我们需要的不是“一个摘要”，而是“结构化状态”。</strong> —— 即针对不同等级的信息，设计专门的保留和更新策略。</p>
</blockquote>
<hr>
<h3> 7.3 本章小结：上下文开始变成工程对象</h3>
<p>到这里，你应该已经意识到：</p>
<ul>
<li>上下文不再是自然增长的聊天记录，而是一个<strong>需要被主动设计、分层管理、动态维护的系统状态</strong></li>
<li>多轮对话的可靠性，取决于 “高优先级信息是否能稳定地影响模型决策”。</li>
</ul>
<p>这一步认知转变，会直接引出下一个问题：</p>
<blockquote>
<p><strong>既然信息需要被分层管理，那“记忆”是否也应该分层？</strong></p>
</blockquote>
<p>这正是下一章要探讨的核心问题 —— 记忆策略的工程化选择。</p>
]]></content:encoded>
    </item>
    <item>
      <title>第 8 章：记忆策略的工程化选择</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/13.%E8%AE%B0%E5%BF%86%E7%AD%96%E7%95%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/13.%E8%AE%B0%E5%BF%86%E7%AD%96%E7%95%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第 8 章：记忆策略的工程化选择</source>
      <description>在前两章中，我们已经完成了两个关键决策： 否定“无限上下文”的幻想 接受“信息必须被分层管理” 接下来，我们需要面对一个更系统级的问题： “记忆”是否应该只有一种实现方式？ 答案是否定的。 8.1 技术决策视角：记忆不是功能，而是策略组合 在很多产品讨论中，“给系统加记忆” 常被当作一个简单的功能点（比如 “让模型记住之前说过的话”）。但从工程角度看，记忆是一组需要根据场景动态调整的策略</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 14:55:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在前两章中，我们已经完成了两个关键决策：</p>
<ul>
<li>否定“无限上下文”的幻想</li>
<li>接受“信息必须被分层管理”</li>
</ul>
<p>接下来，我们需要面对一个更系统级的问题：</p>
<blockquote>
<p><strong>“记忆”是否应该只有一种实现方式？</strong></p>
</blockquote>
<p>答案是否定的。</p>
<hr>
<h3> 8.1 技术决策视角：记忆不是功能，而是策略组合</h3>
<p>在很多产品讨论中，“给系统加记忆” 常被当作一个简单的功能点（比如 “让模型记住之前说过的话”）。但从工程角度看，记忆是<strong>一组需要根据场景动态调整的策略</strong></p>
<p>—— 不同的信息生命周期（几秒、几小时、几天）、不同的重要性，需要匹配不同的记忆方式。</p>
<p>比如：</p>
<ul>
<li><em>用户当前的提问意图（“我在问报销流程”）需要 “即时记忆”，确保下一句回应不跑偏；</em></li>
<li><em>已确认的用户身份（“市场部员工”）需要 “会话级记忆”，在整个对话过程中保持一致；</em></li>
<li><em>三个月前用户咨询过的 “差旅政策” 需要 “长期记忆”，在用户再次提问时能快速关联。</em></li>
</ul>
<p>这些不同场景的需求，无法通过单一的 “记忆功能” 满足，必须设计分层的记忆策略。</p>
<hr>
<h3> 8.2 短期记忆：受控的上下文拼接（什么时候足够用）</h3>
<p>最基础、成本最低的记忆策略是 “短期记忆”，适用于单一会话内的近期交互（通常持续几分钟到 1 小时）。其核心设计是：</p>
<ul>
<li>只保留最近 N 轮对话（N 的值根据模型窗口大小确定，通常为 5-10 轮）；</li>
<li>明确区分 <code>system</code> / <code>state</code> / <code>recent messages</code> 三个层级，按优先级拼接上下文</li>
</ul>
<figure><img src="/imgs/column/llm/13-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这个策略的工程价值在于：</p>
<ul>
<li><strong>行为可预测</strong>：由于只保留有限内容，token 数量可控，不会突然触发截断；</li>
<li><strong>成本可控</strong>：避免了全量历史导致的 token 爆炸，调用成本稳定；</li>
<li><strong>实现简单</strong>：无需复杂的存储或摘要逻辑，仅需维护一个滑动窗口。</li>
</ul>
<p>但它很快会遇到边界：</p>
<blockquote>
<p><strong>当对话跨越更长时间或主题切换频繁时，仅靠短期记忆会导致状态丢失</strong></p>
</blockquote>
<p>例如，用户上午讨论 “年假政策”，下午继续对话时，系统可能已经忘记上午确认的 “用户入职满 3 年” 这一关键信息。</p>
<hr>
<h3> 8.3 中期记忆：由 LLM 维护的状态摘要（为什么要引入）</h3>
<p>为了避免重要状态被挤出窗口，企业知识库助手通常会引入 “中期记忆”—— 通过“会话状态摘要”来持久化关键信息，确保在对话持续数小时或主题切换时，核心状态不丢失。</p>
<p>会话状态摘要的核心不是 “总结对话内容”，而是<strong>记录 “已确认的决策信息”</strong>，格式通常是结构化的键值对或列表。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这类摘要的维护机制通常是：<strong>每轮对话结束后，调用 LLM 对比新内容与当前摘要，自动更新关键信息</strong>（新增确认项、移除已解决问题、修正错误）。</p>
<p>它的核心价值是：<strong>将分散在多轮对话中的关键信息 “浓缩固化”，避免被短期记忆的滑动窗口 “挤出”</strong>。</p>
<p>即使短期记忆只保留最近 5 轮，状态摘要也能确保 “用户身份”“已确认规则” 等信息持续影响模型决策。</p>
<blockquote>
<p>这不是对话摘要，而是<strong>决策状态的持久化</strong>。</p>
</blockquote>
<hr>
<h3> 8.4 长期记忆：为什么不能继续塞进上下文？</h3>
<p>当对话场景扩展到以下情况时，仅靠短期和中期记忆（依赖上下文窗口）就会变得不现实：</p>
<ul>
<li><strong>跨天对话</strong>：用户今天咨询一半，明天继续；</li>
<li><strong>多任务切换</strong>：用户同时处理 “报销”“年假”“绩效” 多个主题；</li>
<li><strong>多用户并发</strong>：同一个助手服务多个员工，需要区分每个人的历史。</li>
</ul>
<p>此时，继续将所有信息塞进上下文窗口会导致两个问题：</p>
<ol>
<li>窗口容量有限，无法容纳多天的状态摘要；</li>
<li>不同用户 / 任务的信息混杂，导致模型混淆。</li>
</ol>
<p>因此，我们需要一种 “移出上下文但可按需召回” 的记忆机制 —— 这正是<strong>长期记忆</strong>的核心价值。</p>
<p>长期记忆的实现通常依赖外部存储（如数据库、向量数据库），其核心逻辑是：</p>
<ul>
<li>将不活跃的会话状态（如 24 小时未更新）从上下文移出，存入外部存储；</li>
<li>当用户再次激活对话时，通过检索（如基于用户 ID、主题关键词）将相关历史状态重新导入上下文。</li>
</ul>
<blockquote>
<p><strong>长期记忆的核心不是 “记住一切”，而是 “在需要时，能把正确的信息带回上下文”</strong> —— 它解决的是 “跨时间、跨规模” 的记忆问题。</p>
</blockquote>
<p>此时，一个新的技术出现了：这正是<code>向量检索</code>、<code>RAG</code>等机制存在的根本原因。</p>
<hr>
<h3> 8.5 本章小结：记忆层次决定系统上限</h3>
<p>通过本章的分析，我们可以明确：企业知识库助手的 “记忆” 是分层的策略组合，不同层次解决不同问题：</p>
<ul>
<li>短期记忆：通过受控的上下文拼接，解决 “当前几轮对话的连贯性”；</li>
<li>中期记忆：通过状态摘要，解决 “会话级关键信息的一致性”；</li>
<li>长期记忆：通过外部存储与检索，解决 “跨时间、跨任务的信息召回”。</li>
</ul>
<p>这三层记忆共同构成了系统在时间维度上的可靠性基础。但还有一个关键问题尚未解决：</p>
<blockquote>
<p><em>当用户的问题超出模型自身的知识范围（比如最新的公司政策），仅靠记忆策略如何保证回答准确？</em></p>
</blockquote>
<p>而这自然引出了下一部分的讨论主题：我们将深入探讨 RAG（检索增强生成）技术如何与上下文工程结合，让系统的知识边界可控、可扩展。</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/llm/13-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>第 9 章：上下文工程在企业知识库助手中的落地</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/14.%E4%B8%8A%E4%B8%8B%E6%96%87%E5%B7%A5%E7%A8%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/14.%E4%B8%8A%E4%B8%8B%E6%96%87%E5%B7%A5%E7%A8%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第 9 章：上下文工程在企业知识库助手中的落地</source>
      <description>在前面的章节中，我们已经反复提到几个现象： Prompt 写得再好，对话一长就会失控 模型能力没有变，但系统表现却越来越差 用户的问题越来越“合理”，模型却越来越“跑偏” 这些问题，几乎都不是模型问题，也不是 Prompt 问题。 —— Prompt 解决的是 “单次生成的约束”，模型解决的是 “概率预测的能力”，而它们共同忽略了多轮对话的核心挑战：时间维度上的信息管理。 它们指向的是同一个核心能力： 上下文工程（Context Engineering）</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 15:25:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在前面的章节中，我们已经反复提到几个现象：</p>
<ul>
<li>Prompt 写得再好，对话一长就会失控</li>
<li>模型能力没有变，但系统表现却越来越差</li>
<li>用户的问题越来越“合理”，模型却越来越“跑偏”</li>
</ul>
<p>这些问题，<strong>几乎都不是模型问题，也不是 Prompt 问题</strong>。 —— Prompt 解决的是 “单次生成的约束”，模型解决的是 “概率预测的能力”，而它们共同忽略了多轮对话的核心挑战：<strong>时间维度上的信息管理。</strong></p>
<p>它们指向的是同一个核心能力：</p>
<blockquote>
<p><strong>上下文工程（Context Engineering）</strong></p>
</blockquote>
<p>这门技术看似简单（“管理对话历史”），实则是区分 “玩具级应用” 和 “生产级系统” 的关键 —— 它决定了你的 LLM 应用能在真实场景中 “跑多远”。</p>
<hr>
<h3> 9.1 什么是上下文工程？（不是“多轮对话”）</h3>
<p>很多人第一次听到“上下文工程”时，会把它简单理解为：</p>
<ul>
<li>维护聊天历史</li>
<li>把之前的对话一起传给模型</li>
</ul>
<p>但这只是<strong>最表层、也是最危险的一种理解</strong>。</p>
<p>更准确的定义是：</p>
<blockquote>
<p><strong>上下文工程，是一门关于「在有限窗口内，如何持续、可控地向模型注入信息」的工程学科。</strong></p>
</blockquote>
<p>它关注的不是“聊了多少轮”，而是 “每一轮该让模型看到什么”—— 具体来说，是四个关键决策：</p>
<ul>
<li><strong>哪些信息必须一直存在</strong>：比如系统的核心约束、用户的关键身份信息，这些是维持系统行为一致性的基础；</li>
<li><strong>哪些信息可以被遗忘</strong>：比如对话中的寒暄、临时追问的无关细节，这些信息对后续决策毫无价值；</li>
<li><strong>哪些信息需要被压缩、总结、重写</strong>：比如多轮对话中形成的共识（“用户是销售部员工”），无需保留完整对话，只需提炼核心结论；</li>
<li><strong>哪些信息应该永远不进入上下文</strong>：比如敏感数据（用户手机号）、无效反馈（“谢谢”“好的”）、潜在风险内容（恶意引导的提问）。</li>
</ul>
<p>举个直观的例子：</p>
<p>企业知识库助手的对话中，</p>
<ul>
<li>“仅回答内部政策，禁止泄露未公开信息” 必须一直存在；</li>
<li>用户说的 “我再想想” 可以被遗忘；</li>
<li>“我是销售部的，经常出差” 需要总结为 “用户：销售部，高频出差”；</li>
<li>用户误输入的手机号应该直接过滤，不进入上下文。</li>
</ul>
<p>上下文工程的本质，是对模型的输入进行 “主动治理” —— 而不是被动接受对话的自然增长。</p>
<hr>
<h3> 9.2 为什么“自然增长的上下文一定会失败？”</h3>
<p>让我们先看一种<strong>几乎所有新手都会采用的方式</strong>：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式在前几轮对话中表现良好，但它<strong>从工程角度看是必然失败的</strong>。</p>
<p>前面也提到过，原因有三点：</p>
<ol>
<li>窗口有限 vs 信息无限增长</li>
<li>不同信息的“重要性”并不相同 vs 模型平等对待</li>
<li>模型无治理能力 vs 信息需动态调整</li>
</ol>
<p>更危险的是，这种 “自然增长” 的方式会让问题 “延迟爆发”：前几轮看似正常，等对话达到一定长度后，错误会集中出现，且很难定位问题根源（是哪一轮的信息导致了偏差？）。</p>
<p>因此，上下文工程的核心前提是：<strong>放弃 “全量保留” 的幻想，转向 “精准筛选” 的主动设计</strong>。</p>
<hr>
<h3> 9.3 上下文工程的核心思想：分层，而不是堆叠</h3>
<p>成熟的 LLM 系统都会隐含一个共识：</p>
<blockquote>
<p><strong>上下文不是一条时间线，而是一组“职责不同的信息层”。</strong></p>
</blockquote>
<p>一个通用、但非常重要的抽象可以表示为：</p>
<figure><img src="/imgs/column/llm/14-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这张图背后隐藏着几个关键设计决策,也是上下文工程的核心价值所在：</p>
<ol>
<li>每层信息都有明确的 “职责边界”</li>
</ol>
<ul>
<li><strong>长期不变的系统约束</strong>：负责 “定规矩”，回答 “系统永远不能做什么、必须遵守什么”，是整个系统的 “行为底线”；</li>
<li><strong>跨轮对话的状态摘要</strong>：负责 “记关键”，回答 “对话到目前为止，有哪些确定的事实、未解决的问题”，是维持连贯性的核心；</li>
<li><strong>最近 N 轮对话内容</strong>：负责 “保流畅”，回答 “用户刚刚问了什么、系统刚刚答了什么”，避免对话脱节；</li>
<li><strong>外部注入的知识 / 工具结果</strong>：负责 “补信息”，回答 “当前问题需要哪些额外知识 / 数据”，是解决特定问题的临时补充。</li>
</ul>
<ol start="2">
<li>每层信息都有明确的 “优先级”</li>
</ol>
<ul>
<li>当上下文窗口接近 token 上限时，遵循 “先砍低优先级，再保高优先级” 的原则：</li>
<li>绝对不砍：长期不变的系统约束；</li>
<li>尽量保留：跨轮对话的状态摘要；</li>
<li>可动态截断：最近 N 轮对话内容（比如从 10 轮砍到 5 轮）；</li>
<li>按需筛选：外部注入的知识 / 工具结果（比如只保留与当前问题相关的片段）。</li>
</ul>
<ol start="3">
<li>每层信息都有明确的 “更新规则”</li>
</ol>
<ul>
<li>系统约束：仅在业务规则变更时更新（比如公司政策调整），平时固定不变；</li>
<li>状态摘要：每轮对话结束后更新（新增确认事实、移除已解决问题、修正错误信息）；</li>
<li>最近 N 轮：每轮对话后自动滑动，移除最早的内容；</li>
<li>外部知识：随当前问题动态注入，问题解决后不保留（避免占用窗口）。</li>
</ul>
<p>这种分层设计的优势显而易见：可维护性、可预测性、可扩展性 —— 当你需要调整系统行为时，只需修改对应层的信息，而不用重构整个上下文逻辑。</p>
<hr>
<h3> 9.4 上下文工程 ≠ Prompt 工程</h3>
<p>这是一个非常容易混淆、但必须区分清楚的点。</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Prompt 工程</th>
<th>上下文工程</th>
</tr>
</thead>
<tbody>
<tr>
<td>关注点</td>
<td>单次调用的行为约束</td>
<td>跨调用的信息演进</td>
</tr>
<tr>
<td>核心问题</td>
<td>模型该如何回答</td>
<td>模型“记住了什么”</td>
</tr>
<tr>
<td>时间维度</td>
<td>静态（仅作用于当前轮）</td>
<td>动态 （贯穿整个对话生命周期）</td>
</tr>
<tr>
<td>失败模式</td>
<td>回答不合规</td>
<td>系统逐渐失控</td>
</tr>
<tr>
<td>落地方式</td>
<td>设计结构化 Prompt（Role/Task/Constraints）</td>
<td>设计分层上下文（约束 / 状态 / 近期 / 外部知识）</td>
</tr>
</tbody>
</table>
<p>我们可以用企业知识库助手的场景，更直观地理解两者的区别：</p>
<ul>
<li><strong>Prompt 工程</strong>：解决 “用户问‘差旅报销标准’时，模型能准确引用 2025 年政策”—— 通过 Prompt 中的 Constraints 限定 “仅用提供的政策文档回答”；</li>
<li><strong>上下文工程</strong>：解决 “用户后续问‘我是销售部，能报高铁一等座吗’时，模型能记住‘用户是销售部’，并结合政策给出答案”—— 通过状态摘要层保留 “用户部门” 这一关键信息。</li>
</ul>
<p>简单来说</p>
<blockquote>
<p>Prompt 决定 “这一轮你该怎么想”，上下文决定 “你现在是谁、在干什么”。</p>
</blockquote>
<hr>
<h2> 9.5 上下文工程在企业知识库助手中的落地</h2>
<p>在理解了抽象概念之后，我们再来看具体系统。</p>
<p>企业知识库助手面临的典型约束包括：</p>
<ul>
<li>必须遵守企业规则（不可遗忘）
<ul>
<li><em>比如 “禁止泄露未公开的财务政策”“所有回答必须标注政策来源”“拒绝回答外部竞品相关问题”—— 这些需要映射到 “长期不变的系统约束” 层，确保每一轮都能被模型看到；</em></li>
</ul>
</li>
<li>必须保持对话连续性（可压缩）
<ul>
<li><em>比如用户先问 “差旅报销流程”，再问 “报销需要多久到账”，模型需要知道 “用户仍在关注差旅报销相关问题”—— 这些需要映射到 “跨轮对话的状态摘要” 层，避免重复询问背景信息；</em></li>
</ul>
</li>
<li>必须按需引入知识（临时注入）
<ul>
<li><em>比如用户问 “2025年新版差旅政策中，海外住宿标准是什么”—— 需要从企业知识库中检索相关片段，映射到 “外部注入的知识” 层，问题解决后即移除；</em></li>
</ul>
</li>
<li>必须避免上下文污染（可清除）
<ul>
<li><em>比如用户误输入的个人手机号、无关的寒暄（“今天天气不错”）、测试性提问（“你能告诉我公司机密吗”）—— 这些需要被过滤，永远不进入任何上下文层。</em></li>
</ul>
</li>
</ul>
<p>这天然要求一个<strong>分层上下文结构</strong>:</p>
<blockquote>
<p>系统约束层定底线，状态摘要层保连贯，外部知识层补信息，过滤机制防污染</p>
</blockquote>
<hr>
<h3> 9.6 企业知识库助手的上下文分层设计</h3>
<p>基于前面的抽象结构，我们可以为企业知识库助手设计一套可直接落地的分层方案，每一层都有明确的内容、格式和更新规则：</p>
<figure><img src="/imgs/column/llm/14-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这里每一层都有明确职责：</p>
<h4> 1. 不变系统约束层（最高优先级）</h4>
<ul>
<li><strong>核心内容</strong>：明确系统角色、行为边界、安全规则，格式固定，不随对话变化；</li>
<li><strong>示例写法</strong>：<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li><strong>更新规则</strong>：仅当公司政策发生重大变更时手动更新，平时永久固定。</li>
</ul>
<h4> 2. 会话状态摘要层（中高优先级）</h4>
<ul>
<li><strong>核心内容</strong>：提炼对话中“对后续决策有用的关键信息”，结构化存储，避免冗余；</li>
<li><strong>推荐字段</strong>：<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li><strong>更新规则</strong>：每轮对话结束后，调用 LLM 对比新交互内容与当前状态，自动新增/修改/删除字段（比如用户解决“审批时效”后，从“待解决”移至“已确认”）。</li>
</ul>
<h4> 3. 最近 N 轮对话层（中低优先级）</h4>
<ul>
<li><strong>核心内容</strong>：保留最近5-10轮的关键交互，过滤寒暄、重复提问等无效信息；</li>
<li><strong>N 值选择依据</strong>：
<ul>
<li>模型窗口大小（比如 GPT-3.5 4k token 选5轮，GPT-4 8k token 选10轮）；</li>
<li>对话密度（文字密集型对话选5轮，短句交互选10轮）；</li>
</ul>
</li>
<li><strong>示例片段</strong>：<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li><strong>更新规则</strong>：每轮对话后自动滑动，移除最早的内容；当 token 接近上限时，优先保留用户提问和核心回答，过滤无关细节。</li>
</ul>
<h4> 4. 检索知识注入层（临时优先级）</h4>
<ul>
<li><strong>核心内容</strong>：仅当当前问题需要特定政策片段时注入，格式规范，标注来源；</li>
<li><strong>示例写法</strong>：<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li><strong>更新规则</strong>：随当前问题动态注入，下一轮对话若不涉及相关主题，自动移除；若涉及同一主题，可更新补充新的知识片段。</li>
</ul>
<hr>
<h3> 9.7 一个最小可用的上下文构建示例（伪代码）</h3>
<p>基于上述分层设计，我们可以实现一个最小可用的上下文构建函数。这段代码的核心不是语法，而是背后的工程思想——每一步都体现了“分层、可控、动态”的原则：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p>
<ol>
<li><strong>角色选择技巧</strong>：系统约束和状态摘要用<code>system</code>角色，而不是<code>user</code>或<code>assistant</code>——因为<code>system</code>角色的信息在模型处理中优先级更高，能有效抵抗注意力衰减；</li>
<li><strong>动态截断逻辑</strong>：最近对话的“N轮”不是固定值，而是根据token数动态调整，避免硬编码导致的窗口溢出；</li>
<li><strong>异常处理</strong>：考虑到“首次对话无状态”“无检索知识”等场景，补充默认逻辑，避免模型因输入不完整而产生幻觉；</li>
<li><strong>格式规范</strong>：每层信息都有明确的标签（【系统约束】【会话状态】），帮助模型区分不同类型的信息，减少混淆。</li>
</ol>
<p>重点注意，这段代码真正重要的不是“怎么写”，而是它体现的原则：</p>
<blockquote>
<p><strong>上下文是被设计出来的系统结构，而不是副产品。</strong></p>
</blockquote>
<hr>
<h3> 9.8 本章小结：上下文工程决定系统“能跑多远”</h3>
<p>通过这一章，你应该已经形成这样的核心认知：</p>
<ul>
<li>多轮对话失控不是偶然，也不是“Prompt 技巧不足”，而是<strong>上下文没有被当作一等工程对象来设计</strong>——没有分层、没有优先级、没有动态管理，让低价值信息挤占了高价值信息的生存空间；</li>
<li>上下文工程的本质是“信息治理”：通过分层设计，让系统约束“不被遗忘”、对话共识“不被稀释”、冗余信息“不被保留”、外部知识“按需注入”；</li>
<li>落地上下文工程的关键，是配套三大机制：<strong>分层信息定义机制</strong>（明确每层内容）、<strong>状态动态更新机制</strong>（每轮刷新摘要）、<strong>长度监控截断机制</strong>（避免窗口溢出）。</li>
</ul>
<p>但你也应该意识到一个新的边界：</p>
<blockquote>
<p>即使上下文被精心管理，系统依然只能回答“模型已知或上下文已提供”的内容。</p>
</blockquote>
<p>当用户的问题<strong>超出企业文档覆盖范围，或需要实时数据支撑</strong>（比如“当前我的报销申请审批到哪一步了”）时，仅靠上下文工程无法解决——此时需要引入“外部工具”和“检索增强”，让系统具备“主动获取信息”的能力。</p>
<p>下一部分，我们将聚焦 RAG（检索增强生成）与工具调用，探讨如何让企业知识库助手从“只能回答已知问题”，升级为“能解决未知问题”。</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/llm/14-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>第四部分｜RAG 与外部知识注入：让企业知识库助手具备事实可靠性</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/15.%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%20RAG%E4%B8%8E%E5%A4%96%E9%83%A8%E7%9F%A5%E8%AF%86%E6%B3%A8%E5%85%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/15.%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%20RAG%E4%B8%8E%E5%A4%96%E9%83%A8%E7%9F%A5%E8%AF%86%E6%B3%A8%E5%85%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第四部分｜RAG 与外部知识注入：让企业知识库助手具备事实可靠性</source>
      <description>本部分目标： 回答一个被第三部分自然逼出来的问题：当知识不适合继续放进上下文时，系统还能做什么？ 从“工程决策”的角度理解 RAG，而不是把它当作一个流行方案 让企业知识库助手第一次真正具备事实层面的可靠性 在第三部分中，我们已经明确了一个结论： 上下文与记忆解决的是“时间一致性”，而不是“知识充分性”。</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 15:50:07 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本部分目标：</p>
<ul>
<li>回答一个被第三部分自然逼出来的问题：<strong>当知识不适合继续放进上下文时，系统还能做什么？</strong></li>
<li>从“工程决策”的角度理解 RAG，而不是把它当作一个流行方案</li>
<li>让企业知识库助手第一次真正具备<strong>事实层面的可靠性</strong></li>
</ul>
</blockquote>
<p>在第三部分中，我们已经明确了一个结论：</p>
<blockquote>
<p><strong>上下文与记忆解决的是“时间一致性”，而不是“知识充分性”。</strong></p>
</blockquote>
<p>这意味着：</p>
<ul>
<li>即使你完美管理了上下文（比如精准控制对话历史的长度、按优先级筛选关键信息）</li>
<li>即使 Prompt 约束得再严格（比如明确要求 “只基于给定信息回答”）</li>
</ul>
<p>只要问题超出了模型当前上下文中的信息范围，系统依然会被迫在“回答”和“胡说”之间做选择。而在多数未经特殊设计的系统中，模型会默认选择后者（因为 “生成内容” 是它的核心指令）。</p>
<p>第四部分要解决的，正是这个 “知识覆盖范围” 与 “回答可靠性” 的核心矛盾。</p>
]]></content:encoded>
    </item>
    <item>
      <title>第 10 章：为什么 “把知识塞进 Prompt” 一定会失败？</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/16.%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%86%E7%9F%A5%E8%AF%86%E5%A1%9E%E8%BF%9BPrompt%E4%BC%9A%E5%A4%B1%E8%B4%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/16.%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%86%E7%9F%A5%E8%AF%86%E5%A1%9E%E8%BF%9BPrompt%E4%BC%9A%E5%A4%B1%E8%B4%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第 10 章：为什么 “把知识塞进 Prompt” 一定会失败？</source>
      <description>在真正引入 RAG 之前，我们必须先推翻一个极其常见、也极具诱惑力的想法。 10.1 一个看似合理的技术直觉 很多团队在构建企业知识库助手时，都会自然地想到： 既然模型不知道公司内部知识，那我就把文档直接塞进 Prompt。 在 Demo 阶段，这个方法往往“看起来可行”： 文档不多（比如只有 10 页产品手册） 问题简单（比如 “产品 A 的核心功能是什么”） 回答看似准确（模型能从塞进去的文档里找到关键词）</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 16:02:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在真正引入 RAG 之前，我们必须先推翻一个极其常见、也极具诱惑力的想法。</p>
<hr>
<h3> 10.1 一个看似合理的技术直觉</h3>
<p>很多团队在构建企业知识库助手时，都会自然地想到：</p>
<blockquote>
<p><em>既然模型不知道公司内部知识，那我就把文档直接塞进 Prompt。</em></p>
</blockquote>
<p>在 Demo 阶段，这个方法往往“看起来可行”：</p>
<ul>
<li>文档不多（比如只有 10 页产品手册）</li>
<li>问题简单（比如 “产品 A 的核心功能是什么”）</li>
<li>回答看似准确（模型能从塞进去的文档里找到关键词）</li>
</ul>
<p>但在真实系统中，这条路几乎必然失败。</p>
<blockquote>
<p>关于这个，我们在上下文历史中，同样也提到了这一点，简单的堆砌，必然不会成功</p>
</blockquote>
<hr>
<h3> 10.2 工程约束：为什么这条路走不通？</h3>
<p>把知识直接塞进 Prompt，会很快撞上三个硬性约束：</p>
<h4> 1. 上下文窗口限制：文档规模不可线性扩展</h4>
<p>当前主流大模型的上下文窗口是有限的，一次可以塞入的文档必然存在上限</p>
<p>但真实企业的知识库规模往往是：</p>
<ul>
<li>中型企业：数万份文档（产品手册、流程规范、历史会议纪要等）</li>
<li>大型企业：数十万甚至数百万份文档（跨部门、跨地区、跨时间维度）</li>
</ul>
<p>这意味着：<strong>当文档数量超过窗口承载能力时，你必须人工筛选 “可能相关” 的内容塞进 Prompt—— 但这本质上是让人类代替系统做 “检索”，完全失去了自动化的意义。</strong></p>
<h4> 2. 注意力竞争：约束信息与知识信息相互稀释</h4>
<p>Prompt 里不仅有知识，还有对模型的行为约束（比如 “用中文回答”“语气正式”“只基于给定信息”）。当知识内容过多时，这些关键约束会被海量知识 “淹没”。</p>
<p>举个例子：</p>
<p><em>如果 Prompt 里塞了 10 份产品文档（共 3 万 tokens），而行为约束只有 100 tokens，模型对约束的 “注意力占比” 会从 10%（100/1000）降到 0.3%（100/30100）。此时模型很可能 “忘记” 约束，开始基于自身训练数据回答 —— 这正是我们要避免的 “幻觉”。</em></p>
<p>更危险的是：知识内部也会竞争注意力。</p>
<p>当一份文档里同时包含 “产品 A 的定价” 和 “产品 B 的售后政策”，而用户只问产品 A 时，模型可能被不相关的产品 B 信息干扰，导致回答出错</p>
<h4> 3. 维护成本爆炸：每次文档更新都意味着 Prompt 重写</h4>
<p>企业知识不是静态的：</p>
<ul>
<li>产品迭代会更新功能说明</li>
<li>政策调整会修改流程规范</li>
<li>员工变动会更新负责人信息</li>
</ul>
<p>如果知识直接写在 Prompt 里，每次文档更新都需要人工修改 Prompt—— 这在大型企业中几乎不可执行。</p>
<p>想象一下：当某个部门每周更新 20 份文档时，团队需要每天安排专人修改 Prompt，不仅效率极低，还会引入 “漏改”“错改” 的风险。</p>
<p>在企业知识库助手中，这些共同导致一个致命的结果：</p>
<blockquote>
<p><strong>知识越多，回答反而越不稳定。</strong></p>
</blockquote>
<hr>
<h3> 10.3 技术决策结论</h3>
<p>到这里，我们可以给出一个明确判断：</p>
<blockquote>
<p><strong>Prompt 不是知识载体，而是行为约束载体。</strong></p>
</blockquote>
<p>当你试图让 Prompt 同时承担这两种职责时，系统一定会在规模上崩溃。</p>
<p>这迫使我们进入下一个问题：</p>
<blockquote>
<p><strong>如果知识不能“常驻上下文”，那它应该待在哪里？ 又该如何在需要时精准地 “请” 到上下文里？</strong></p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>第 11 章：RAG 的本质：不是 “外挂知识库”，而是 “受控知识注入”</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/17.RAG%E7%9A%84%E6%9C%AC%E8%B4%A8.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/17.RAG%E7%9A%84%E6%9C%AC%E8%B4%A8.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第 11 章：RAG 的本质：不是 “外挂知识库”，而是 “受控知识注入”</source>
      <description>RAG（Retrieval-Augmented Generation）通常被介绍为： 在生成前检索相关知识，作为上下文提供给模型。 这个定义并没有错，但它隐藏了真正重要的工程价值。 11.1 一个更准确的工程视角 从系统设计角度，RAG 的核心作用可以被描述为： 在生成前，动态构造一个“最小且相关的知识上下文”。 请注意两个关键词：</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 16:12:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>RAG（Retrieval-Augmented Generation）通常被介绍为：</p>
<blockquote>
<p><em>在生成前检索相关知识，作为上下文提供给模型。</em></p>
</blockquote>
<p>这个定义并没有错，但它隐藏了真正重要的工程价值。</p>
<hr>
<h3> 11.1 一个更准确的工程视角</h3>
<p>从系统设计角度，RAG 的核心作用可以被描述为：</p>
<blockquote>
<p><strong>在生成前，动态构造一个“最小且相关的知识上下文”。</strong></p>
</blockquote>
<p>请注意两个关键词：</p>
<ul>
<li><strong>动态</strong>：每次问题都不同，检索的知识也不同（比如用户问 A 产品时找 A 的文档，问 B 产品时找 B 的文档）</li>
<li><strong>最小</strong>：只注入必要信息（比如用户问 “A 产品的定价”，就只塞定价相关的片段，而非整份产品手册）</li>
</ul>
<p>这正好弥补了上下文窗口的先天不足：不再需要把所有知识塞进窗口，而是只在需要时 “临时调取” 相关部分，既避免了窗口溢出，又减少了注意力竞争。</p>
<p>举个实际场景：</p>
<ul>
<li>企业知识库有 1000 份文档（总大小 100 万 tokens）</li>
<li>用户问：“新员工入职流程中，需要提交哪些材料？”</li>
<li>RAG 系统会：
<ul>
<li>从 1000 份文档中检索出 “新员工入职手册 v2.3”</li>
<li>从手册中提取出 “材料提交” 章节的第 3-5 段（共 500 tokens）</li>
<li>把这 500 tokens 作为知识上下文传给模型</li>
</ul>
</li>
<li>最终模型的输入是：行为约束（100 tokens）+ 相关知识（500 tokens）+ 用户问题（50 tokens），总大小 650 tokens，远低于窗口限制。</li>
</ul>
<hr>
<h3> 11.2 RAG 在企业知识库助手中的位置</h3>
<figure><img src="/imgs/column/llm/17-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在这个结构中，每个模块的职责被清晰拆分：</p>
<ul>
<li>**检索器：**负责 “找知识”。输入用户问题，输出最相关的文档片段（比如通过向量相似度计算、关键词匹配等方式）。</li>
<li>**企业知识库：**负责 “存知识”。以结构化 / 非结构化形式存储所有文档（比如拆分成 Chunk 后，用向量数据库存储）。</li>
<li>**上下文构建器：**负责 “拼上下文”。把检索到的知识片段、行为约束、用户问题整合成模型能理解的输入格式。</li>
<li>**LLM：**负责 “生成回答”。基于构建好的上下文，输出符合约束的结果。</li>
</ul>
<p>简单来说：</p>
<ul>
<li>Prompt 负责约束</li>
<li>Context Engineering 负责拼装</li>
<li>RAG 负责<strong>把正确的知识“带回来”</strong></li>
</ul>
<hr>
<h3> 11.3 一个关键结论</h3>
<blockquote>
<p><strong>RAG 并不能保证“回答正确”，
但它能保证：
模型“有机会看到正确答案”。</strong></p>
</blockquote>
<p>这听起来像是退步，但实际上是系统设计的关键飞跃：</p>
<ul>
<li>从不可控 → 可控：以前模型回答错误可能是因为 “没见过正确信息”（无解），现在如果回答错误，至少可以定位到 “检索错了” 或 “模型没理解检索到的信息”（可优化）。</li>
<li>从玄学 → 工程问题：以前解决错误只能 “调 Prompt”“换模型”，现在可以通过优化检索策略、调整 Chunk 大小、完善知识库结构等可量化的工程手段改进。</li>
</ul>
<p>理解了 RAG “动态构造最小相关知识上下文” 的本质后，另一个现实问题随之而来：为什么有些团队明明接入了 RAG，检索效果却始终不理想？是模型不够强，还是哪里出了更基础的问题？</p>
<p>答案往往藏在 RAG 流程的起点 —— 文档如何被处理成可检索的单元。</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/llm/17-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>第 12 章：RAG —— 当模型“不知道”时，系统该如何补偿？</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/18.RAG.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/18.RAG.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第 12 章：RAG —— 当模型“不知道”时，系统该如何补偿？</source>
      <description>在前面的章节中，我们已经逐步解决了： 如何约束模型行为（Prompt） 如何管理对话与上下文（Context / Memory） 但到这里，一个更根本的问题开始浮现： 如果用户的问题，本身就超出了模型的知识边界，或者企业私有知识范围，系统还能做什么？ 这就是我们前面提到 RAG（Retrieval-Augmented Generation）存在的原因。 12.1 先别急着实现：什么是 RAG</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 16:22:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在前面的章节中，我们已经逐步解决了：</p>
<ul>
<li>如何约束模型行为（Prompt）</li>
<li>如何管理对话与上下文（Context / Memory）</li>
</ul>
<p>但到这里，一个更根本的问题开始浮现：</p>
<blockquote>
<p><strong>如果用户的问题，本身就超出了模型的知识边界，或者企业私有知识范围，系统还能做什么？</strong></p>
</blockquote>
<p>这就是我们前面提到 RAG（Retrieval-Augmented Generation）存在的原因。</p>
<hr>
<h2> 12.1 先别急着实现：什么是 RAG</h2>
<p>在上一篇中，已经从工程的视角介绍了RAG: <code>动态构造一个“最小且相关的知识上下文”</code></p>
<p>我们对齐进行展开</p>
<blockquote>
<p><strong>RAG 是一种：
在模型生成之前，
通过外部检索机制，
为模型“临时补充其本不具备的知识”的系统架构。</strong></p>
</blockquote>
<p>注意几个关键词：</p>
<ul>
<li><strong>生成之前</strong></li>
<li><strong>外部</strong></li>
<li><strong>临时</strong></li>
<li><strong>补充</strong></li>
</ul>
<p>这意味着：</p>
<ul>
<li>知识不进入模型参数</li>
<li>不依赖模型“记住”</li>
<li>不污染长期上下文</li>
</ul>
<hr>
<h2> 12.2 RAG 解决的，其实是“知识时效与边界问题”</h2>
<p>为什么只靠模型本身一定不够？</p>
<p>在企业知识库助手中，典型问题包括：</p>
<ul>
<li>企业制度频繁变化</li>
<li>内部流程不对外公开</li>
<li>文档体量远超上下文窗口</li>
<li>法规 / 合同 / SOP 有明确版本边界</li>
</ul>
<p>这些问题有一个共同特征：</p>
<blockquote>
<p><strong>它们不是“模型不聪明”，而是“模型不可能知道”。</strong></p>
</blockquote>
<p>RAG 的核心价值就在于：</p>
<blockquote>
<p><strong>把“知道什么”这个问题，从模型能力中剥离出来，交给系统解决。</strong></p>
</blockquote>
<hr>
<h2> 12.3 从系统角度看：RAG 在整体架构中的位置</h2>
<figure><img src="/imgs/column/llm/18-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从这里你可以看到：</p>
<ul>
<li>
<p>RAG 不是“总会发生”</p>
</li>
<li>
<p>它是一个<strong>条件触发的系统能力</strong></p>
</li>
<li>
<p>并且发生在：</p>
<blockquote>
<p><strong>上下文构建阶段，而不是 Prompt 阶段</strong></p>
</blockquote>
</li>
</ul>
<hr>
<h2> 12.4 一个常见误区：RAG ≠ 万能增强器</h2>
<p>在引入 RAG 后，很多团队会产生一个错误预期：</p>
<blockquote>
<p><em>“只要接了 RAG，模型就不会胡说了。”</em></p>
</blockquote>
<p>现实往往相反：</p>
<ul>
<li>检索结果不相关</li>
<li>模型曲解文档</li>
<li>回答看似“有依据”，但其实错误</li>
</ul>
<p>这引出一个非常重要的事实：</p>
<blockquote>
<p><strong>RAG 的失败，大多数并不是发生在“生成阶段”，而是发生在“检索之前”。</strong></p>
</blockquote>
<p>一旦你真正理解了 RAG 的系统定位，下一个、也是更残酷的问题就会出现：</p>
<blockquote>
<p><strong>为什么我已经“接了 RAG”，效果还是不好？</strong></p>
</blockquote>
<p>很多失败的 RAG 项目，会把问题归因于：</p>
<ul>
<li>向量模型不够好</li>
<li>大模型不够聪明</li>
</ul>
<p>但在绝大多数情况下，真正的瓶颈出现在一个<strong>更早、也更基础的地方</strong>： —— 文档是“如何被拆解与表达的” 。</p>
<p>就像用渔网捕鱼：如果网眼太大，小鱼会漏走；如果网眼太小，会被水草缠住。渔网的设计（对应 Chunk 设计），比 “用什么材质做渔网”（对应向量模型）更重要。</p>
<hr>
<h2> 12.5 文档 → Chunk → Embedding：检索效果的真正上限</h2>
<h3> 12.5.1 Chunk 设计：被严重低估的工程决策</h3>
<p>Chunk（文档片段）是 RAG 的 “原子单元”—— 系统检索的是 Chunk，注入上下文的也是 Chunk。Chunk 的大小与切分方式，直接决定了：</p>
<ul>
<li>能否被检索到：如果 Chunk 包含的信息与问题无关，再先进的检索器也找不到它；</li>
<li>被检索到后是否 “刚好有用”：如果 Chunk 太大，包含大量无关信息（噪声），模型会被干扰；如果太小，关键信息被切碎（比如一个流程的 “步骤 1” 和 “步骤 2” 被分到两个 Chunk），模型无法理解完整逻辑。</li>
</ul>
<p>在企业知识库助手中，Chunk 设计的常见问题：</p>
<ul>
<li>
<p>Chunk 太大：</p>
<ul>
<li>典型场景：直接把整篇文档作为一个 Chunk（比如一份 10 页的产品手册）。</li>
<li>问题：检索时容易 “误中”—— 比如文档里只有 1 段讲 “定价”，但因为整个文档被检索到，模型需要从 5000 字中找答案，很容易被其他内容干扰</li>
</ul>
</li>
<li>
<p>Chunk 太小：</p>
<ul>
<li>典型场景：按固定字数强制拆分（比如每 100 字切一段）。</li>
<li>问题：语义被切碎 —— 比如 “审批流程需要部门经理签字后提交给 HR”，如果被拆成 “审批流程需要部门经理签字” 和 “后提交给 HR” 两个 Chunk，单独检索到任何一个都无法理解完整流程。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Chunk 设计，本质上是在做信息密度的权衡：既要让每个 Chunk 包含 “足够完整的语义”，又要避免 “包含过多无关信息”。</strong></p>
</blockquote>
<hr>
<h3> 12.5.2 一个工程化的 Chunk 决策思路</h3>
<p>你可以从这样的问题开始思考：</p>
<ul>
<li>用户的问题，通常对应文档的哪一层？是段落级？章节级？还是流程级？</li>
<li>文档本身的结构是什么？是否有天然的语义边界（比如标题、列表、表格）？</li>
</ul>
<p>Chunk 应该尽量与 <strong>“被提问的最小语义单元”</strong> 对齐。举几个企业场景的例子：</p>
<ul>
<li>
<p>场景 1：FAQ 文档（比如 “IT 支持常见问题”）</p>
<ul>
<li>特点：每个问题对应一个独立答案（比如 “如何重置密码？”→ 步骤 1-3）。</li>
<li>最优 Chunk：按 “问题 + 答案” 成对切分（每个 Chunk 包含一个完整的问答）。</li>
<li>理由：用户的问题往往直接匹配 FAQ 中的问题，精准切分能确保检索到的 Chunk 刚好包含答案。</li>
</ul>
</li>
<li>
<p>场景 2：产品手册（比如 “CRM 系统操作指南”）</p>
<ul>
<li>特点：按功能模块划分章节（比如 “客户管理”→“新增客户”→“字段说明”）。</li>
<li>最优 Chunk：按 “功能子模块” 切分（比如 “新增客户的 5 个必填字段” 作为一个 Chunk）。</li>
<li>理由：用户的问题多是 “如何操作 XX 功能”，与子模块的语义边界高度匹配。</li>
</ul>
</li>
<li>
<p>场景 3：会议纪要（比如 “Q3 销售策略会记录”）</p>
<ul>
<li>特点：包含多个讨论点（比如 “目标调整”“资源分配”“风险应对”）。</li>
<li>最优 Chunk：按 “讨论主题” 切分（每个主题的讨论过程 + 结论作为一个 Chunk）。</li>
<li>理由：用户可能问 “Q3 的销售目标是多少”，需要定位到 “目标调整” 主题的 Chunk。</li>
</ul>
</li>
</ul>
<p>此外，Chunk 的元数据（Metadata）也很重要 —— 比如给每个 Chunk 标记 “文档类型”“更新时间”“所属部门”，能帮助检索器进一步筛选（比如优先检索 “2024 年更新” 的文档）。</p>
<hr>
<h2> 12.6 RAG工程化建设</h2>
<h3> 12.6.1 从“调用 RAG”到“集成 RAG”：系统视角的转变</h3>
<p>很多教程里的 RAG 看起来像这样：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这在 Demo 中没问题，但在真实系统中，这种方式是不可持续的。</p>
<p>原因在于：</p>
<ul>
<li>RAG 不是一个<strong>函数</strong></li>
<li>它是一个<strong>长期存在的系统能力</strong></li>
</ul>
<p>当我们需要集成RAG能力时，必须完成一个视角转变：</p>
<blockquote>
<p><strong>RAG 不是“我什么时候用一下”，而是“系统在什么条件下，必须依赖它”。</strong></p>
</blockquote>
<h3> 12.6.2 RAG 的第一个工程问题：何时触发？</h3>
<p>一个成熟系统，<strong>不会对所有请求都使用 RAG</strong>。</p>
<p>典型触发条件包括：</p>
<ul>
<li>
<p>用户问题包含：</p>
<ul>
<li>企业私有名词</li>
<li>内部流程 / 制度</li>
</ul>
</li>
<li>
<p>问题涉及：</p>
<ul>
<li>时效性</li>
<li>明确版本</li>
</ul>
</li>
<li>
<p>模型置信度不足（如多次自我矛盾）</p>
</li>
</ul>
<figure><img src="/imgs/column/llm/18-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 12.6.3 RAG 的第二个工程问题：接口如何定义？</h3>
<p>在进阶系统中，RAG 模块不应该“直接拼 Prompt”，而应该返回一个<strong>结构化结果</strong>：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样做的好处是：</p>
<ul>
<li>Prompt 构建不被 RAG 实现绑死</li>
<li>便于调试与评估</li>
<li>便于多模型 / 多策略切换</li>
</ul>
<blockquote>
<p><strong>RAG 的输出，是系统资产，不是 Prompt 片段。</strong></p>
</blockquote>
<h3> 12.6.4 RAG 的第三个工程问题：模型如何“被迫使用”检索结果？</h3>
<p>这是<strong>最容易被忽略、但最致命的一点</strong>。</p>
<p>即使你检索回了正确文档，模型仍然可能：</p>
<ul>
<li>忽略它</li>
<li>曲解它</li>
<li>混合自身知识胡说</li>
</ul>
<p>因此你必须在系统层面做约束。</p>
<h4> 一种常见的工程策略</h4>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/llm/18-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p><strong>RAG 的成功，50% 取决于“生成约束”，而不是“检索准确率”。</strong></p>
</blockquote>
<h3> 12.6.5 RAG 的第四个工程问题：失败如何被定位？</h3>
<p>在应用的实际表现中，一定会遇到这个问题：</p>
<blockquote>
<p><em>“现在效果不好，但我不知道是哪里出了问题。”</em></p>
</blockquote>
<p>一个可诊断的 RAG 系统，至少能回答：</p>
<ul>
<li>是不是根本没召回？</li>
<li>召回的内容是否相关？</li>
<li>模型是否使用了召回内容？</li>
<li>回答是否超出了引用范围？</li>
</ul>
<p>这要求你在系统中明确区分：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>否则，你永远只能“凭感觉调”。</p>
<h3> 12.6.6 企业知识库助手中的 RAG 集成示例</h3>
<p>最后以企业知识库为例，我们看一下RAG的集成示例图</p>
<figure><img src="/imgs/column/llm/18-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 12.7 本章小结：RAG 是系统工程，而不是检索技巧</h2>
<p>通过这一章，你应该已经形成一个完整认知：</p>
<ul>
<li>RAG 不是模型增强，也不是简单的“查资料”</li>
</ul>
<p>而是：</p>
<blockquote>
<p><strong>一种用于突破模型知识边界的系统补偿机制。</strong></p>
</blockquote>
<p>同时你也应该清楚地意识到：</p>
<ul>
<li>RAG 的效果上限，很早就被文档结构与数据工程决定了</li>
</ul>
<p>这意味着：</p>
<blockquote>
<p><strong>RAG 是一个数据工程与系统设计问题，远早于它是一个模型问题。</strong></p>
</blockquote>
<p>即便我们通过精心的 Chunk 设计为 RAG 打下了坚实基础，也无法完全避免检索失败的可能 —— 毕竟用户的问题可能天马行空，知识库的覆盖也总有边界。那么，当检索真的 “空手而归” 时，系统该如何应对才能避免陷入 “胡编乱造” 的陷阱？</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/llm/18-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>第 13 章：当检索失败时，系统应该如何表现？</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/19.%E6%A3%80%E7%B4%A2%E5%A4%B1%E8%B4%A5%E6%97%B6%E5%A6%82%E4%BD%95%E8%A1%A8%E7%8E%B0.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/19.%E6%A3%80%E7%B4%A2%E5%A4%B1%E8%B4%A5%E6%97%B6%E5%A6%82%E4%BD%95%E8%A1%A8%E7%8E%B0.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第 13 章：当检索失败时，系统应该如何表现？</source>
      <description>即使你设计了完美的 Chunk，检索依然可能失败。 用户的问题涉及 “尚未录入知识库的新政策” 问题表述模糊（比如 “那个蓝色的产品多少钱”，但知识库中没有 “蓝色产品” 的明确对应） 文档本身存在信息缺失 这时，一个新的技术决策问题出现了： 系统是否应该“硬着头皮回答”？ 13.1 一个危险但常见的默认行为 在没有检索到合适内容时，如果系统什么都不做（即直接把空的知识上下文传给模型）：</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 16:50:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>即使你设计了完美的 Chunk，检索依然可能失败。</p>
<ul>
<li>用户的问题涉及 “尚未录入知识库的新政策”</li>
<li>问题表述模糊（比如 “那个蓝色的产品多少钱”，但知识库中没有 “蓝色产品” 的明确对应）</li>
<li>文档本身存在信息缺失</li>
</ul>
<p>这时，一个新的技术决策问题出现了：</p>
<blockquote>
<p><strong>系统是否应该“硬着头皮回答”？</strong></p>
</blockquote>
<hr>
<h3> 13.1 一个危险但常见的默认行为</h3>
<p>在没有检索到合适内容时，如果系统什么都不做（即直接把空的知识上下文传给模型）：</p>
<ul>
<li>LLM 会继续生成</li>
<li>幻觉会自然出现</li>
</ul>
<p>这是企业知识库助手中<strong>最危险的失效路径</strong>。</p>
<ul>
<li>对用户：得到错误信息（比如错误的报销流程、过期的产品价格），可能导致实际损失。</li>
<li>对系统：失去用户信任（“这个助手说的都不可信”）。</li>
</ul>
<p>举个例子：用户问 “2025 年新入职员工的社保缴纳基数”，但知识库中只有 2024 年的政策。如果检索失败后系统硬答，可能会把 2024 年的基数当作 2025 年的返回，导致用户按错误标准准备材料，最终影响社保缴纳。</p>
<hr>
<h3> 13.2 工程化的失败处理策略</h3>
<p>在企业场景中，更合理的选择是：明确告知用户 “没有找到相关信息”，并提供替代方案。具体实现需要三个环节：</p>
<h4> 1. 显式判断检索是否成功</h4>
<p>设定 “检索成功阈值”：</p>
<ul>
<li>向量检索：当最高相似度分数低于设定值（比如 0.7）时，判定为失败；</li>
<li>关键词检索：当匹配到的文档数量为 0，或匹配字段的覆盖率低于 30% 时，判定为失败；</li>
<li>混合判断：用小模型（如 GPT-3.5）快速扫描检索结果，判断是否与问题相关（成本稍高但更精准）。</li>
</ul>
<h4> 2. 将 “检索失败” 作为一种状态传入上下文</h4>
<p>在构建上下文时，明确告知模型：“本次检索未找到相关信息，请回复‘暂无相关知识’，并建议用户联系 XX 部门获取帮助”。</p>
<h4> 3. 提供具体的替代方案</h4>
<p>避免简单回复 “不知道”，而是给出行动指引，比如：</p>
<ul>
<li>“抱歉，我暂时没有 2024 年社保缴纳基数的信息。你可以联系人力资源部（hr@company.com）获取最新政策。”</li>
<li>“关于‘蓝色产品定价’，我没有找到明确信息。你可以补充产品型号（如 A100、B200），我会尽力为你查询。”</li>
</ul>
<figure><img src="/imgs/column/llm/19-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 13.3 本章小结：RAG 的边界意识</h3>
<ul>
<li>RAG 扩展了知识边界（让系统能回答超出自身训练数据的问题）</li>
<li>但并没有消除不确定性（总有检索不到的信息）</li>
</ul>
<p>一个成熟系统的标志，不是“总能回答”，而是：</p>
<blockquote>
<p><strong>知道什么时候不该回答,以及不该回答时该做什么。</strong></p>
</blockquote>
<p>这种 “边界意识” 能极大提升系统的可靠性 —— 用户会更信任一个 “只说确定信息” 的助手，而不是一个 “什么都敢说” 的助手。</p>
<hr>
<h2> 第四部分总结：知识注入让系统第一次“接地气”</h2>
<p>通过这一部分，你已经完成了一次关键升级：</p>
<ul>
<li>从“依赖模型知识”（局限于训练数据截止前的公开信息）</li>
<li>到“按需注入外部事实”（可以回答企业内部的、实时的、专属的知识）</li>
</ul>
<p>但你也应该已经意识到：</p>
<ul>
<li>即使有了 RAG，系统仍然是被动的</li>
</ul>
<p>它只能：</p>
<ul>
<li>在被问到时检索（无法主动推送知识）</li>
<li>在给定的检索结果中生成回答（无法自主判断 “是否需要进一步找更多信息”）</li>
</ul>
<p>这自然引出了下一部分的问题：</p>
<blockquote>
<p><strong>如果系统需要主动规划、多步决策，甚至自己决定“下一步该做什么”，该怎么办？</strong></p>
</blockquote>
<p>下一部分，我们将进入：</p>
<blockquote>
<p><strong>Function Calling 与 Agent 的世界。</strong></p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/llm/19-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>第五部分｜Function Calling 与 Agent：让企业知识库助手具备行动与决策能力</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/20.%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%20Function%20Calling%E4%B8%8EAgent.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/20.%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%20Function%20Calling%E4%B8%8EAgent.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第五部分｜Function Calling 与 Agent：让企业知识库助手具备行动与决策能力</source>
      <description>本部分目标： 回答一个在第四部分结尾被自然提出的问题：当系统不只是“回答问题”，而是需要“完成事情”时，该怎么办？ 澄清 Function Calling、Tool、Agent 之间经常被混用的概念 让企业知识库助手从“被动问答系统”，升级为可执行决策的系统 在前四个部分中，我们已经逐步解决了三个问题： 如何让模型的行为可控（Prompt / 约束） 如何让系统在时间上可靠（Context / Memory） 如何让回答在事实层面可信（RAG）</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 17:30:07 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本部分目标：</p>
<ul>
<li>回答一个在第四部分结尾被自然提出的问题：<strong>当系统不只是“回答问题”，而是需要“完成事情”时，该怎么办？</strong></li>
<li>澄清 Function Calling、Tool、Agent 之间经常被混用的概念</li>
<li>让企业知识库助手从“被动问答系统”，升级为<strong>可执行决策的系统</strong></li>
</ul>
</blockquote>
<p>在前四个部分中，我们已经逐步解决了三个问题：</p>
<ol>
<li>如何让模型的行为可控（Prompt / 约束）</li>
<li>如何让系统在时间上可靠（Context / Memory）</li>
<li>如何让回答在事实层面可信（RAG）</li>
</ol>
<p>但到这里，企业知识库助手依然存在一个明显上限：</p>
<blockquote>
<p><strong>它只能回答“你问了什么”，而不能决定“下一步该做什么”。</strong></p>
</blockquote>
<p>第五部分要解决的，正是这个能力缺口：如何让系统从 “解释规则” 走向 “执行流程”，从 “被动响应” 升级为 “主动决策”。</p>
]]></content:encoded>
    </item>
    <item>
      <title>第 14 章：为什么“一次生成”已经不够了？</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/21.%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E6%AC%A1%E7%94%9F%E6%88%90%E5%B7%B2%E7%BB%8F%E4%B8%8D%E5%A4%9F%E4%BA%86.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/21.%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E6%AC%A1%E7%94%9F%E6%88%90%E5%B7%B2%E7%BB%8F%E4%B8%8D%E5%A4%9F%E4%BA%86.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第 14 章：为什么“一次生成”已经不够了？</source>
      <description>在很多入门教程中，LLM 应用被简化为一个公式： Prompt → LLM → Response 这个抽象在前几部分仍然成立，但一旦任务开始具备操作性（需要与外部系统交互、需要分步骤验证、需要动态调整策略，问题就出现了。 14.1 一个真实的企业场景 假设用户对企业知识库助手说： “帮我确认一下，海外员工的差旅报销流程，现在是不是还需要主管审批？”</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 17:50:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在很多入门教程中，LLM 应用被简化为一个公式：</p>
<blockquote>
<p><strong>Prompt → LLM → Response</strong></p>
</blockquote>
<p>这个抽象在前几部分仍然成立，但一旦任务开始具备<strong>操作性</strong>（需要与外部系统交互、需要分步骤验证、需要动态调整策略，问题就出现了。</p>
<hr>
<h3> 14.1 一个真实的企业场景</h3>
<p>假设用户对企业知识库助手说：</p>
<blockquote>
<p>“帮我确认一下，海外员工的差旅报销流程，现在是不是还需要主管审批？”</p>
</blockquote>
<p>表面上看，这是一个 “问答”，但实际上包含了多个隐藏的操作需求：</p>
<ol>
<li><strong>查询最新制度</strong>：差旅报销流程可能在 3 个月前更新过，系统需要找到 2024 年版的《海外差旅管理规范》，而不是 2023 年的旧版本；</li>
<li><strong>定位关键条款</strong>：在文档中找到 “审批环节” 的具体描述，确认是否包含 “主管审批” 这一项；</li>
<li><strong>验证特殊情况</strong>：文档中可能注明 “金额超过 5000 美元需额外审批”，需要确认用户的问题是否涉及这类例外；</li>
<li><strong>对比历史变更</strong>：如果旧流程需要主管审批，而新流程取消了，需要明确说明 “当前已不需要”，而不是沿用旧记忆；</li>
<li><strong>处理不确定性</strong>：如果文档中没有明确说明，需要告知用户 “未找到明确条款，建议咨询行政部”，而不是编造答案。</li>
</ol>
<p>这些步骤环环相扣，且每一步都依赖 “实际执行”（比如真实查询文档、验证版本）—— 模型不可能在 “一次生成” 中完成所有操作，更无法确保中间步骤的准确性。</p>
<hr>
<h3> 14.2 技术决策点：我们要什么？</h3>
<p>在这个阶段，系统设计者必须做出一个选择：</p>
<blockquote>
<p><strong>是让模型“假装想清楚了”，还是让系统真的一步一步做事？</strong></p>
</blockquote>
<p>如果继续依赖 “一次生成” 的模式，后果会很明显：</p>
<ul>
<li>模型只能在 “脑内模拟” 查询、验证等步骤，但无法真正执行
<ul>
<li>—— 比如它可能 “认为” 自己查了最新文档，但实际上用的是训练数据里的旧信息；</li>
</ul>
</li>
<li>中间过程完全不可见，一旦出错无法追溯
<ul>
<li>—— 如果回答错误，我们无法知道是 “查询步骤漏了” 还是 “理解条款错了”；</li>
</ul>
</li>
<li>复杂任务会失控
<ul>
<li>—— 比如当用户要求 “根据最新报销流程，帮我计算这笔海外差旅能报销多少” 时，模型可能会忽略汇率转换、发票类型等细节，直接给出错误结果。</li>
</ul>
</li>
</ul>
<p>这正是 Agent 出现的根本原因：<strong>当任务需要 “做” 而不只是 “说” 时，必须用可执行的步骤替代模型的 “脑内模拟”。</strong></p>
<hr>
<h3> 14.3 本章小结：任务复杂度发生了质变</h3>
<p>简单来说，我们可以用一个标准判断是否需要升级系统：</p>
<ul>
<li>若任务是<strong>问答</strong>（如 “报销标准是什么”）：一次生成可能足够；</li>
<li>若任务是<strong>操作</strong>（如 “确认报销流程是否需要主管审批”）：必须分步骤执行。</li>
</ul>
<p>这引出了下一个问题：</p>
<blockquote>
<p><strong>如果要分步骤，模型如何与系统“对接”？</strong></p>
</blockquote>
<p>模型和外部工具（如文档检索系统、审批系统）之间，需要一个明确的 “对话接口”。这个接口，就是我们下一章要讨论的 Function Calling。</p>
]]></content:encoded>
    </item>
    <item>
      <title>第 15 章：Function Calling 的真实角色</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/22.Function%20Calling.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/22.Function%20Calling.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第 15 章：Function Calling 的真实角色</source>
      <description>在很多介绍中，Function Calling 被描述为： 让模型调用外部函数。 这个说法在概念上并没有错，但在工程上并不够准确。 15.1 一个更贴近系统设计的理解 从工程角度看，Function Calling 的作用是： 为模型提供一种“受约束的行动出口”。 这句话可以拆成两个关键维度： 行动出口：模型的 “思考” 需要转化为具体动作（比如 “查询文档”“调用审批系统”），Function Calling 就是这种转化的标准化格式 —— 比如用{&amp;quot;name&amp;quot;:&amp;quot;search_document&amp;quot;,&amp;quot;parameters&amp;quot;:{&amp;quot;doc_type&amp;quot;:&amp;quot;travel_reimbursement&amp;quot;,&amp;quot;version&amp;quot;:&amp;quot;2025&amp;quot;}}表示 查询 2025 版差旅报销文档。 受约束：模型不能随意定义动作，只能从系统预定义的函数列表中选择。比如如果系统没开放 “删除审批记录” 的函数，模型就无法发起这个操作 —— 这在企业场景中至关重要（想象一下，如果模型能随意调用删除函数，会带来多大风险）。</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 18:10:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在很多介绍中，Function Calling 被描述为：</p>
<blockquote>
<p><em>让模型调用外部函数。</em></p>
</blockquote>
<p>这个说法在概念上并没有错，但在工程上并不够准确。</p>
<hr>
<h3> 15.1 一个更贴近系统设计的理解</h3>
<p>从工程角度看，Function Calling 的作用是：</p>
<blockquote>
<p><strong>为模型提供一种“受约束的行动出口”。</strong></p>
</blockquote>
<p>这句话可以拆成两个关键维度：</p>
<ul>
<li>
<p><strong>行动出口</strong>：模型的 “思考” 需要转化为具体动作（比如 “查询文档”“调用审批系统”），Function Calling 就是这种转化的标准化格式</p>
<ul>
<li>—— 比如用<code>{"name":"search_document","parameters":{"doc_type":"travel_reimbursement","version":"2025"}}</code>表示 <code>查询 2025 版差旅报销文档</code>。</li>
</ul>
</li>
<li>
<p><strong>受约束</strong>：模型不能随意定义动作，只能从系统预定义的函数列表中选择。比如如果系统没开放 “删除审批记录” 的函数，模型就无法发起这个操作</p>
<ul>
<li>—— 这在企业场景中至关重要（想象一下，如果模型能随意调用删除函数，会带来多大风险）。</li>
</ul>
</li>
</ul>
<hr>
<h3> 15.2 Function Calling 在企业知识库助手中的位置</h3>
<figure><img src="/imgs/column/llm/22-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在这个流程中，权责划分非常清晰：</p>
<ul>
<li>LLM 负责“判断要不要做”: 是否需要行动？需要调用哪个函数？参数是否正确？</li>
<li>系统负责“真正去做”: 函数调用的实际操作（如查文档、调接口）由系统完成，模型不直接接触底层资源；</li>
<li>结果 “闭环”：执行结果会返回给 LLM，作为下一步推理的依据（比如查到文档后，模型再基于文档内容生成回答）。</li>
</ul>
<p>举个例子：当用户问 “海外差旅报销是否需要主管审批” 时，</p>
<ol>
<li>LLM 会先判断 “需要查询 2025 版文档”，然后调用<code>search_document</code>函数；</li>
<li>系统执行查询后，将文档中 “审批环节” 的内容返回给 LLM；</li>
<li>最后 LLM 基于这些内容，整理出对用户的回答。</li>
</ol>
<hr>
<h3> 15.3 一个关键工程结论</h3>
<blockquote>
<p><strong>Function Calling 不是为了让模型更强，而是为了让系统更安全。</strong></p>
</blockquote>
<p>它的核心价值，是把 “系统能做什么” 的控制权牢牢握在设计者手中：</p>
<ul>
<li>想开放哪些能力（如查询、提交表单），就定义哪些函数；</li>
<li>想限制哪些风险（如修改数据、删除记录），就不提供对应的函数；</li>
<li>所有动作都有明确日志（哪个函数被调用、参数是什么），便于审计和调试。</li>
</ul>
<p>理解了这一点，我们就能明白：为什么企业场景中，Function Calling 不是 “可选功能”，而是 “必选设计”</p>
<p>—— 它是模型 “智能” 与系统 “安全” 之间的平衡器。</p>
<p>但当任务变得更复杂（比如 “先确认报销流程，再帮我提交报销申请，最后同步给我的直属领导”），单次的 Function Calling 就不够了。</p>
<p>此时需要的，是能协调多个函数、多步操作的 “循环机制” —— 这就是我们接下来要讨论的 Agent。</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/llm/22-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>第 16 章：Agent 的本质：循环，而不是一次调用</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/23.Agent.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/23.Agent.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第 16 章：Agent 的本质：循环，而不是一次调用</source>
      <description>当系统需要处理的任务涉及： 多个工具（比如既需要查文档，又需要调用审批系统） 多个步骤（比如先确认规则，再填写表单，最后验证结果） 动态调整（比如提交失败后，需要根据错误提示修改内容） 单次的 Function Calling 就会力不从心。这时候，我们需要一种能 “持续决策、反复行动” 的机制 —— 这就是 Agent。 16.1 一个常见误解：Agent = 更复杂的 Prompt 很多人尝试实现 Agent 时，会陷入一个误区：认为只要写一个 “更详细的 Prompt”，让模型 “自己规划步骤”，就能实现 Agent 能力。</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 18:30:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>当系统需要处理的任务涉及：</p>
<ul>
<li>多个工具（比如既需要查文档，又需要调用审批系统）</li>
<li>多个步骤（比如先确认规则，再填写表单，最后验证结果）</li>
<li>动态调整（比如提交失败后，需要根据错误提示修改内容）</li>
</ul>
<p>单次的 Function Calling 就会力不从心。这时候，我们需要一种能 “持续决策、反复行动” 的机制 —— 这就是 Agent。</p>
<hr>
<h3> 16.1 一个常见误解：Agent = 更复杂的 Prompt</h3>
<p>很多人尝试实现 <code>Agent</code> 时，会陷入一个误区：认为只要写一个 “更详细的 Prompt”，让模型 “自己规划步骤”，就能实现 Agent 能力。</p>
<p>比如在 Prompt 里写 “你需要先查文档，再调用系统，最后整理结果”。</p>
<blockquote>
<p><strong>它们仍然在用“一次生成”的思维方式。</strong></p>
</blockquote>
<p>没有真正的 “步骤执行与反馈”。实际使用中会出现各种问题：</p>
<ul>
<li>模型可能 “忘记” 中间步骤（比如查了文档后，没调用审批系统就直接返回结果）；</li>
<li>无法处理意外情况（比如调用系统失败时，不知道该重试还是放弃）；</li>
<li>步骤不可控（比如本来 3 步能完成的任务，模型规划了 10 步，导致效率极低）。</li>
</ul>
<p>这就是为什么很多 <code>Agent</code> 实现会失败：</p>
<blockquote>
<p><strong>它们把 “循环执行” 的逻辑交给了模型的 “一次性思考”，而没有在系统层面实现真正的闭环。</strong></p>
</blockquote>
<hr>
<h3> 16.2 Agent 的最小正确抽象</h3>
<p>从系统视角看，一个能正常工作的 Agent 必须包含四个核心环节，形成闭环：</p>
<ol>
<li><strong>思考（Planning）</strong>：拆解任务，决定下一步要做什么（比如 “先查报销流程，再判断是否需要调用提交接口”）；</li>
<li><strong>行动（Execution）</strong>：调用对应的工具 / 函数执行计划（比如调用search_document获取流程，调用submit_reimbursement提交申请）；</li>
<li><strong>反馈（Observation）</strong>：获取行动结果（比如文档内容、接口返回的 “提交成功” 或 “缺少发票” 提示）；</li>
<li><strong>再规划（Replan）</strong>：基于反馈调整下一步计划（比如如果提示 “缺少发票”，就规划 “提醒用户上传发票”）。</li>
</ol>
<figure><img src="/imgs/column/llm/23-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 16.3 企业知识库助手中的 Agent 化形态</h3>
<p>在我们的示例中，Agent 可以：</p>
<ul>
<li><strong>规划阶段</strong>：用户问 “帮我处理这笔海外差旅报销”，Agent 拆解为 “1. 确认报销流程；2. 检查用户提供的信息是否完整；3. 调用提交接口；4. 通知主管”；</li>
<li><strong>执行阶段</strong>：先调用search_document获取流程，再调用check_info验证用户提供的发票、行程单等；</li>
<li><strong>反馈阶段</strong>：发现用户 “缺少电子行程单”，接口返回错误；</li>
<li><strong>再规划阶段</strong>：调整计划为 “先提醒用户补充电子行程单，再重新提交”。</li>
</ul>
<p>这些决策逻辑不是写死在 Prompt 里的，而是 Agent 基于实时反馈动态生成的</p>
<p>—— 这才是 “智能决策” 的核心：不是预设路径，而是根据实际情况灵活调整。</p>
<p>但这里有一个关键问题：如果 Agent 可以无限循环、自由决策，在企业场景中会带来巨大风险（比如反复调用付费接口导致成本失控，或执行未授权操作）。</p>
<p>因此，如何 “控制 Agent 的自由度”，成为下一章的核心话题。</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/llm/23-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>第 17 章：可控 Agent，而不是“放飞自我”</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/24.%E5%8F%AF%E6%8E%A7Agent.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/24.%E5%8F%AF%E6%8E%A7Agent.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">第 17 章：可控 Agent，而不是“放飞自我”</source>
      <description>在 Agent 技术的热潮中，有一种危险的倾向：追求 “让 Agent 自主完成一切”，甚至赋予它 “近乎人类的自主权”。 但在企业场景中，这种 “放飞自我” 的 Agent 几乎一定会出问题 —— 合规性、成本、安全性都无法保障。 17.1 技术决策的核心问题 设计企业级 Agent 时，必须先回答一个问题： Agent 的“自由度”，应该到哪里为止？ 如果不加控制，后果可能包括： 行为不可预测：比如用户让 “处理报销”，Agent 可能擅自调用 “修改薪资系统” 的接口（即使这不在预期内）； 成本不可控：为了完成一个简单任务，Agent 可能反复调用昂贵的工具（如第三方 API），导致费用飙升； 安全边界模糊：当 Agent 遇到 “权限不足” 时，可能尝试 “绕开限制”（比如模仿管理员身份），引发安全风险。</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 18:50:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在 Agent 技术的热潮中，有一种危险的倾向：追求 “让 Agent 自主完成一切”，甚至赋予它 “近乎人类的自主权”。</p>
<p>但在企业场景中，这种 “放飞自我” 的 Agent 几乎一定会出问题 —— 合规性、成本、安全性都无法保障。</p>
<h3> 17.1 技术决策的核心问题</h3>
<p>设计企业级 Agent 时，必须先回答一个问题：</p>
<blockquote>
<p><strong>Agent 的“自由度”，应该到哪里为止？</strong></p>
</blockquote>
<p>如果不加控制，后果可能包括：</p>
<ul>
<li><strong>行为不可预测</strong>：比如用户让 “处理报销”，Agent 可能擅自调用 “修改薪资系统” 的接口（即使这不在预期内）；</li>
<li><strong>成本不可控</strong>：为了完成一个简单任务，Agent 可能反复调用昂贵的工具（如第三方 API），导致费用飙升；</li>
<li><strong>安全边界模糊</strong>：当 Agent 遇到 “权限不足” 时，可能尝试 “绕开限制”（比如模仿管理员身份），引发安全风险。</li>
</ul>
<p>企业场景对 “可控性” 的要求远高于 “智能性” —— 一个偶尔犯错但行为可预测的系统，远好于一个聪明但可能失控的系统。</p>
<hr>
<h3> 17.2 工程化的 Agent 约束手段</h3>
<p>在企业知识库助手中，常见的约束包括：</p>
<ul>
<li><strong>有限的工具集合</strong>：只开放与任务相关的函数（比如处理报销时，只给search_document submit_reimbursement等工具，不开放delete_data modify_user等高危工具）；</li>
<li><strong>明确的终止条件</strong>：提前定义 “任务完成” 的标准（比如 “报销申请提交成功并返回单号”），达到条件后强制终止循环；</li>
<li><strong>最大步数限制</strong>：设置最多执行步骤（比如最多 8 步），避免无限循环（比如遇到错误时反复重试）；</li>
<li><strong>可观测的中间状态</strong>：记录每一步的思考、行动、结果（如 “第 3 步调用了 XX 函数，返回结果是 XX”），便于管理员追溯和干预；</li>
<li><strong>用户确认节点</strong>：关键操作（如提交金额超过 10000 美元的报销）前，必须让用户确认，避免 Agent 擅自决策。</li>
</ul>
<figure><img src="/imgs/column/llm/24-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 17.3 本章小结：Agent 是系统的一部分，而不是“智能体幻想”</h3>
<p>理解 Agent 的关键，是摒弃对 “类人智能” 的幻想，回归工程本质：</p>
<ul>
<li>Agent 不是 “放权给模型”，让它 “自己做主”；</li>
<li>而是把企业中的复杂决策流程，显式建模为 “思考 - 行动 - 反馈” 的系统循环；</li>
<li>这个循环的每一步都需要被约束、被记录、被控制。</li>
</ul>
<p>只有这样，Agent 才能真正成为企业知识库助手的 “能力放大器”，而不是 “风险来源”。</p>
<hr>
<h2> 第五部分总结：系统终于开始“做事”了</h2>
<p>通过 Function Calling 与 Agent 的引入，企业知识库助手完成了一次关键进化：</p>
<ul>
<li>从 “只能解释规则” 到 “可以执行流程”（比如查文档、提交申请）；</li>
<li>从 “被动等待提问” 到 “主动规划步骤”（比如发现信息不全时主动追问）；</li>
<li>从 “单次响应” 到 “闭环决策”（比如根据执行结果动态调整策略）。</li>
</ul>
<p>但能力的提升也带来了新的挑战：</p>
<ul>
<li>系统复杂度大幅增加（从单一的 LLM 调用，变成包含函数、循环、约束的复杂系统）；</li>
<li>调试难度上升（错误可能出在思考环节、执行环节，或反馈环节）；</li>
<li>评估标准变化（不再只看 “回答准不准”，还要看 “步骤合理不合理”“成本高不高”）。</li>
</ul>
<p>这自然引出了最后一个问题：</p>
<blockquote>
<p><strong>当系统变得越来越复杂，我们如何评估、调试、演进它？</strong></p>
</blockquote>
<p>这将是最后一部分要讨论的主题：<strong>评估、监控与工程化落地。</strong></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/llm/24-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>LLM应用开发</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/llmcoding/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">LLM应用开发</source>
      <description>LLM应用开发 LLM应用开发系列教程 零基础篇</description>
      <pubDate>Wed, 31 Dec 2025 02:21:16 GMT</pubDate>
      <content:encoded><![CDATA[<h1> LLM应用开发</h1>
<p>LLM应用开发系列教程</p>
<h2> 零基础篇</h2>
]]></content:encoded>
    </item>
    <item>
      <title>7. Chrome插件Mybatis日志转SQL语句</title>
      <link>https://liuyueyi.github.io/tutorial/tool/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/07.Myabtis%E6%97%A5%E5%BF%97%E5%90%88%E6%88%90SQL%E8%AF%AD%E5%8F%A5%E6%8F%92%E4%BB%B6.html</link>
      <guid>https://liuyueyi.github.io/tutorial/tool/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/07.Myabtis%E6%97%A5%E5%BF%97%E5%90%88%E6%88%90SQL%E8%AF%AD%E5%8F%A5%E6%8F%92%E4%BB%B6.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7. Chrome插件Mybatis日志转SQL语句</source>
      <description>开发调试与生产分析的利器：MyBatis SQL日志合并插件，让复杂日志秒变可执行SQL 一、开篇 在Java开发的世界里，MyBatis作为最受欢迎的ORM框架之一，为我们提供了灵活的SQL操作能力。然而，伴随着这种灵活性，也带来了一个让人头疼的问题：当应用在开发或生产环境中遇到SQL相关问题时，如何快速定位和分析那些被参数化的SQL日志？ 相信各位javaer都会有类似的经历：面对控制台中输出的MyBatis日志，看到类似&amp;quot;Preparing: SELECT * FROM user WHERE id = ? AND status = ?&amp;quot;和&amp;quot;Parameters: 123(Long), active(String)&amp;quot;这样的信息，却需要手动将参数值代入SQL模板中，才能知道这条SQL实际执行的是什么？这个过程不仅繁琐，而且容易出错，尤其是在处理复杂查询时。</description>
      <category>工具</category>
      <category>Chrome</category>
      <pubDate>Mon, 22 Dec 2025 19:22:29 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 开发调试与生产分析的利器：MyBatis SQL日志合并插件，让复杂日志秒变可执行SQL</h1>
<h2> 一、开篇</h2>
<p>在Java开发的世界里，MyBatis作为最受欢迎的ORM框架之一，为我们提供了灵活的SQL操作能力。然而，伴随着这种灵活性，也带来了一个让人头疼的问题：当应用在开发或生产环境中遇到SQL相关问题时，如何快速定位和分析那些被参数化的SQL日志？</p>
<p>相信各位javaer都会有类似的经历：面对控制台中输出的MyBatis日志，看到类似"Preparing: SELECT * FROM user WHERE id = ? AND status = ?"和"Parameters: 123(Long), active(String)"这样的信息，却需要手动将参数值代入SQL模板中，才能知道这条SQL实际执行的是什么？这个过程不仅繁琐，而且容易出错，尤其是在处理复杂查询时。</p>
<figure><img src="/imgs/251223/00.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>下面给大家推荐一个能彻底解决这个问题的神器——MyBatis SQL Log Merger插件，它不仅能大幅提升开发调试效率，更是生产环境SQL分析的得力助手。</p>
<h2> 二、场景痛点分析</h2>
<h3> 1. 开发阶段痛点</h3>
<p>在开发过程中，我们经常需要验证SQL的正确性，分析查询性能，或者调试业务逻辑。传统的做法是：</p>
<ol>
<li>从日志中复制SQL模板和参数信息</li>
<li>手动将参数值代入SQL模板中</li>
<li>将完整的SQL粘贴到数据库客户端执行</li>
<li>分析执行结果</li>
</ol>
<p>这个过程不仅耗时，而且容易出错，特别是当SQL包含大量参数或复杂条件时。</p>
<h3> 2. 生产阶段痛点</h3>
<p>在生产环境中，这个问题更加突出。当系统出现性能问题或异常时，比如现在出现了一个慢SQL，但是面对控制台上输出的SQL模板和传参，需要快速分析MyBatis日志，但：</p>
<ol>
<li>生产环境的SQL通常更加复杂，尤其是涉及多个表关联的场景</li>
<li>不能直接在生产数据库中执行可能影响业务的SQL（业务重放可能加剧问题的影响面）</li>
<li>需要将生产日志带回安全环境进行分析</li>
<li>手动还原SQL既耗时又可能引入错误</li>
</ol>
<p>这些痛点严重影响了问题排查效率，延长了故障恢复时间；同时也极大的降低了程序员的幸福指数</p>
<h2> 三、插件核心功能介绍</h2>
<p>MyBatis SQL Log Merger插件正是为了解决这些痛点而生</p>
<h3> 1. 一键将MyBatis日志转换为可执行SQL</h3>
<p>只需将MyBatis日志复制到插件中，即可一键生成完整的、可直接执行的SQL语句。插件会自动识别SQL模板和参数信息，并将参数值正确地代入SQL中。</p>
<p>如在监控的网页上，开启SQL提取功能，选中sql模板和sql传参，直接生成对应的sql；更能一键导航到您配置的sql管理工具站点</p>
<figure><img src="/imgs/251223/00.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 独立的SQL合成工具页</h3>
<p>除了上面的在目标网站上注入合成按钮之外，这个插件还提供了一个独立的页面，适用于从非浏览器场景获取Mybatis执行日志的场景，如 IDEA 的控制台日志：</p>
<figure><img src="/imgs/251223/01.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在这个独立的SQL合成工具页中，提供了两种输入方式</p>
<ul>
<li><strong>单框模式</strong>：适用于完整的MyBatis日志，插件自动解析SQL模板和参数</li>
<li><strong>双框模式</strong>：分别输入SQL模板和参数信息，提供更精确的控制</li>
</ul>
<table>
<thead>
<tr>
<th>输入模式</th>
<th>示例图</th>
</tr>
</thead>
<tbody>
<tr>
<td>单框模式</td>
<td><img src="/imgs/251223/02.webp" alt="" loading="lazy"> <br> <img src="/imgs/251223/03.webp" alt="" loading="lazy"></td>
</tr>
<tr>
<td>双框模式</td>
<td><img src="/imgs/251223/04.webp" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h3> 3. SQL格式化与语法高亮</h3>
<p>生成的SQL支持进行格式化，提高可读性，并提供语法高亮功能，方便快速识别SQL结构和潜在问题；生成的SQL可以通过一键复制到剪贴板，方便粘贴到数据库客户端或其他工具中执行。</p>
<figure><img src="/imgs/251223/05.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 本地处理，保障数据安全</h3>
<p>所有处理都在浏览器本地进行，无需上传任何数据到服务器，确保敏感的SQL信息不会泄露，特别适合处理生产环境日志。</p>
<h3> 5. 插件优势</h3>
<ul>
<li>提升开发效率
<ul>
<li>通过自动化处理SQL日志，插件可以将原本需要几分钟的手动操作缩短到几秒钟，大幅提升开发效率。开发人员可以将更多时间专注于业务逻辑的实现，而不是繁琐的日志分析。</li>
</ul>
</li>
<li>支持生产环境安全分析
<ul>
<li>插件的本地处理特性使其非常适合分析生产环境日志。无需将敏感数据上传到任何服务器，确保数据安全，同时又能高效地进行SQL分析。</li>
</ul>
</li>
<li>数据本地处理，无泄漏风险
<ul>
<li>所有处理都在浏览器本地完成，没有任何数据传输，完全避免了敏感SQL信息泄露的风险，符合企业安全要求。</li>
</ul>
</li>
<li>多语言支持
<ul>
<li>插件支持中英文界面，满足国际化团队的需求，让不同语言背景的开发人员都能方便使用。</li>
</ul>
</li>
</ul>
<h2> 四、使用方法详解</h2>
<h3> 1. 开发场景应用</h3>
<p>在开发环境中使用MyBatis SQL Log Merger非常简单：</p>
<ol>
<li><strong>安装插件</strong>：从Chrome应用商店安装 <a href="https://chromewebstore.google.com/detail/mybatis-sql-log-merger/ldlekpjpadmkfoohidfgjjcmegdbkbho" target="_blank" rel="noopener noreferrer">MyBatis SQL Log Merger</a></li>
<li><strong>获取日志</strong>：从IDE控制台或日志文件中复制MyBatis的DEBUG级别日志</li>
<li><strong>粘贴处理</strong>：打开插件界面，粘贴日志内容，点击"Process SQL/处理SQL"</li>
<li><strong>验证结果</strong>：查看生成的完整SQL，如有需要可复制到数据库客户端执行</li>
</ol>
<p>这种方式可以大大加快SQL验证和调试的速度。</p>
<figure><img src="/imgs/251223/06.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 生产场景应用</h3>
<p>在生产环境中分析日志时，可以这样使用(对于有网页可以直接查看服务日志的场景)</p>
<ol>
<li><strong>SQL日志查询网页</strong>：安装插件之后，建议将插件固定到外部工具栏；然后导航到目标网站</li>
<li><strong>激活提取SQL按钮</strong>：点击 Chrome 工具栏中的 <code>MyBatis SQL Log Merger</code> 图标，在弹出窗口中，点击非活动状态指示器旁边的"注入 SQL 提取按钮"切换开关</li>
<li><strong>复制SQL</strong>：直接复制包含SQL模板和SQL参数的两行日志</li>
<li><strong>提取SQL</strong>：点击右小角的提取SQL按钮，将自动得到可执行的SQL语句</li>
</ol>
<figure><img src="/imgs/251223/07.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/imgs/251223/08.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/imgs/251223/09.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这种方式既保证了生产数据的安全，又能高效地进行SQL分析。</p>
<h3> 3. 不同日志格式的支持</h3>
<p>插件支持多种MyBatis日志格式：</p>
<ul>
<li>标准MyBatis日志格式</li>
<li>带"Preparing:"和"Parameters:"前缀的日志</li>
<li>不同日志框架（Log4j、Logback等）的输出格式</li>
<li>自定义日志格式</li>
</ul>
<h2> 五、小结</h2>
<p>这个插件的优势还是比较明显的，MyBatis SQL Log Merger插件是一个真正解决开发和运维痛点的工具。它不仅在开发阶段能大幅提升调试效率，在生产环境中也能帮助快速定位和分析SQL相关问题。强烈推荐给每一个有需要的javer开发小伙伴🙂，有兴趣的小伙伴可以直接在谷歌浏览器上点进行下载体验</p>
<ul>
<li>主页：<a href="https://ai.hhui.top/mybatislog/index.html" target="_blank" rel="noopener noreferrer">MyBatis SQL 日志合并工具</a></li>
<li>谷歌插件商店：<a href="https://chromewebstore.google.com/detail/mybatis-sql-log-merger/ldlekpjpadmkfoohidfgjjcmegdbkbho" target="_blank" rel="noopener noreferrer">Chrome商店下载地址</a></li>
<li>项目源码： <a href="https://github.com/liuyueyi/ai-chrome-mysql-merge" target="_blank" rel="noopener noreferrer">ai-chrome-mysql-merge</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/251223/00.webp" type="image/webp"/>
    </item>
    <item>
      <title>15.接入OpenAI接口风格的大模型</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/15.%E6%8E%A5%E5%85%A5OpenAI%E6%8E%A5%E5%8F%A3%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/15.%E6%8E%A5%E5%85%A5OpenAI%E6%8E%A5%E5%8F%A3%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">15.接入OpenAI接口风格的大模型</source>
      <description>15.接入OpenAI接口风格的大模型 鉴于OpenAI在业内的地位，很多大模型的调用接口都是兼容OpenAI的，因此，在接入OpenAI的接口风格大模型时，若官方没有提供高可用的starter，那么直接使用OpenAI的starter就是一个非常好的选择了 接下来我们将演示一下，如何通过OpenAI的starter接入讯飞大模型 一、项目初始化 1. 项目创建 创建一个SpringBoot项目，并引入SpringAI依赖，基本流程如 创建一个SpringAI-Demo工程</description>
      <category>SpringAI</category>
      <pubDate>Tue, 26 Aug 2025 17:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 15.接入OpenAI接口风格的大模型</h1>
<p>鉴于OpenAI在业内的地位，很多大模型的调用接口都是兼容OpenAI的，因此，在接入OpenAI的接口风格大模型时，若官方没有提供高可用的starter，那么直接使用OpenAI的starter就是一个非常好的选择了</p>
<p>接下来我们将演示一下，如何通过OpenAI的starter接入讯飞大模型</p>
<h2> 一、项目初始化</h2>
<h3> 1. 项目创建</h3>
<p>创建一个SpringBoot项目，并引入SpringAI依赖，基本流程如 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 2. 添加依赖</h3>
<p>我们这里直接使用OpenAI的starter作为大模型交互的工具，因此直接在依赖中，添加对应的stater即可</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 配置文件</h3>
<p>以讯飞星火为例，我们首先当官网申请对应的apiKey，并添加到配置文件中(或者通过环境变量、启动参数的方式传入)</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意看上面的配置，参数是放在 <code>spring.ai.openai</code> 下面的</p>
<p>另外一个需要注意的点就是 <code>base-url</code></p>
<figure><img src="/imgs/column/springai/15-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>虽然官方文档中给出的地址是 <a href="https://spark-api-open.xf-yun.com/v1/" target="_blank" rel="noopener noreferrer">https://spark-api-open.xf-yun.com/v1/</a>，但是我们不需要添加 <code>/v1</code>，原因在于OpenAI的实现中，已经自动补上了这个前缀</p>
<figure><img src="/imgs/column/springai/15-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、测试验证</h2>
<p>接下来我们验证一下大模型的调用</p>
<h3> 1. 联调接口实现</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用方式和前面介绍的SpringAI大模型调用没有任何区别，直接使用注入的<code>ChatModel</code>或者基于 <code>ChatModel</code> 创建 <code>ChatClient</code></p>
<h3> 2. 访问验证</h3>
<p>接下来直接访问这个接口，看看是否可以实现大模型的对话</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/15-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 手动创建模型</h3>
<p>上面介绍的是直接使用注入的<code>ChatModel</code>或者基于 <code>ChatModel</code> 创建 <code>ChatClient</code>；若我们一个项目中，存在多个满足OpenAi风格的大模型，则直接使用上面的方式不太优雅，因此，我们可以手动创建模型</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/15-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、总结</h2>
<p>本文主要介绍符合OpenAI接口风格的大模型接入方式，直接通过SpringAI-OpenAI的starter接入，或者手动创建模型，都可以实现便捷的大模型使用</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S15-openai-style-model" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/15-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>16.异步流式模型调用</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/16.%E5%BC%82%E6%AD%A5%E6%B5%81%E5%BC%8F%E6%A8%A1%E5%9E%8B%E8%B0%83%E7%94%A8.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/16.%E5%BC%82%E6%AD%A5%E6%B5%81%E5%BC%8F%E6%A8%A1%E5%9E%8B%E8%B0%83%E7%94%A8.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">16.异步流式模型调用</source>
      <description>异步流式模型调用 前面介绍的教程中，更多的还是是同步调用，对于某些场景，同步调用可能无法满足，比如： 模型返回结果是流式数据，比如：图片生成、语音合成、视频生成等等； 模型返回结果是异步数据，比如：图片识别、语音识别、视频识别等等； 模型返回结果是分批次数据，比如：图片识别、语音识别、视频识别等等； 此外，同步调用需要等待LLM处理完，将所有的结果一并返回；因此对用户的体验并不友好，需要一直空等；因此通过流式的逐步返回，无疑是一个非常好的选择；接下来我们看一下SpringAI如何实现LLM的流式访问</description>
      <category>SpringAI</category>
      <pubDate>Thu, 11 Dec 2025 12:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 异步流式模型调用</h1>
<p>前面介绍的教程中，更多的还是是同步调用，对于某些场景，同步调用可能无法满足，比如：</p>
<ul>
<li>模型返回结果是流式数据，比如：图片生成、语音合成、视频生成等等；</li>
<li>模型返回结果是异步数据，比如：图片识别、语音识别、视频识别等等；</li>
<li>模型返回结果是分批次数据，比如：图片识别、语音识别、视频识别等等；</li>
</ul>
<p>此外，同步调用需要等待LLM处理完，将所有的结果一并返回；因此对用户的体验并不友好，需要一直空等；因此通过流式的逐步返回，无疑是一个非常好的选择；接下来我们看一下SpringAI如何实现LLM的流式访问</p>
<h2> 一、实例演示</h2>
<p>首先我们需要创建一个SpringAI的项目，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 初始化</h3>
<p>创建一个 <code>ChatController</code>，自动注入 ChatModel，并基于 <code>ChatModel</code> 实例化 <code>ChatClient</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. ChatModel流式访问</h3>
<p>对于ChatModel流式访问，与前面直接访问LLM的区别不大，只是将最后的 <code>call</code> 调用改成 <code>stream</code> 调用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 stream() 方法调用，返回的是 <code>Flux&lt;ChatResponse&gt;</code>，我们定义返回头为 <code>text/event-stream</code>，这样客户端就可以接受流式的数据返回</p>
<figure><img src="/imgs/column/springai/16-1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的截图中可以看到，返回的流式数据，每次返回一个 <code>ChatResponse</code> 对象，需要客户端从中解析 <code>output.text</code></p>
<h3> 3. ChatClient流式反问</h3>
<p>对于ChatClient的流式请求，同样是将发起请求的<code>call</code>调用改成<code>stream</code>调用</p>
<p>对于<code>ChatClient.stream()</code>后的结果调用，官方提供了三种方式</p>
<ol>
<li><code>stream().content()</code>: 返回 <code>Flux&lt;String&gt;</code></li>
<li><code>stream().chatClientResponse()</code>: 返回 <code>Flux&lt;ChatClientResponse&gt;</code></li>
<li><code>stream().chatResponse()</code>: 返回 <code>Flux&lt;ChatResponse&gt;</code></li>
</ol>
<p>下面我们使用最简单 <code>content()</code> 进行演示，只关注LLM的返回结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/16-2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 完整结果拼接</h3>
<p>对于某些场景，我们需要将流式数据拼接成完整结果然后再一次返回给客户端，即此时需要我们自己来解析 <code>Flux&lt;ChatReponse&gt;</code>，对于此，可以使用下面几种方式来实现</p>
<p>case1: 直接使用 <code>Flux.collectionList()</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>case2: 使用 <code>Flux.reduce()</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>case3: 使用 <code>subscribe() + SseEmitter</code> 实现更灵活的流式返回</p>
<p>这种方式依然是流式返回给调用方；但是借助SseEmitter，从而实现更灵活的定制化（如后台服务也希望使用LLM的返回结果，此时就可以在subscribe的逻辑中进行定制化开发）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、总结</h2>
<p>本文这里介绍了SpringAI通过stream的方式访问LLM的流式数据，从上面的实际体验来看，和同步访问相比，流式访问的体验更加友好，用户可以更早的看到结果，并且可以更灵活的定制化返回结果；但是从编码的角度出发，两者又没有太明显的区别，对于应用者而言，这一点可以说是非常友好了</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/16-1.png" type="image/png"/>
    </item>
    <item>
      <title>17.推理大模型接入与推理过程返回</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/17.%E6%8E%A8%E7%90%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E4%B8%8E%E6%8E%A8%E7%90%86%E8%BF%87%E7%A8%8B%E8%BF%94%E5%9B%9E.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/17.%E6%8E%A8%E7%90%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E4%B8%8E%E6%8E%A8%E7%90%86%E8%BF%87%E7%A8%8B%E8%BF%94%E5%9B%9E.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">17.推理大模型接入与推理过程返回</source>
      <description>17.推理大模型接入与推理过程返回 对于一些支持推理模型的LLM（如DeepSeekR1 带有推理解析器的vLLM），除了LLM的直接返回结果，推理结果往往也是一个非常有用的返回信息，对于SpringAI，我们可以通过从返回的 Metadata 中获取推理结果。 使用推理的前提是模型必须支持推理，我们可以使用阿里的 qwen-plus-latest 或者智谱的 glm-4.5-flash；这两个都是支持推理过程的模型。 一、实例演示 首先我们需要创建一个SpringAI的项目，基本流程同 创建一个SpringAI-Demo工程</description>
      <category>SpringAI</category>
      <pubDate>Thu, 11 Dec 2025 17:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 17.推理大模型接入与推理过程返回</h1>
<p>对于一些支持推理模型的LLM（如DeepSeekR1 带有推理解析器的vLLM），除了LLM的直接返回结果，推理结果往往也是一个非常有用的返回信息，对于SpringAI，我们可以通过从返回的 Metadata 中获取推理结果。</p>
<p>使用推理的前提是模型必须支持推理，我们可以使用阿里的 <code>qwen-plus-latest</code> 或者智谱的 <code>glm-4.5-flash</code>；这两个都是支持推理过程的模型。</p>
<h2> 一、实例演示</h2>
<p>首先我们需要创建一个SpringAI的项目，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 初始化</h3>
<p>我们借助OpenAI的接口风格来解析推理过程，因此需要引入对应的依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后创建一个 <code>Controller</code> 用于测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，我们基于 OpenAiApi 来创建 ChatModel，在创建创建ChatModel时，通过 <code>extraBody</code> 来传递额外参数，告诉大模型是否开启推理过程</p>
<p>但是请注意，这个推理是否开启的参数依然是取决于具体的模型提供商的要求</p>
<ul>
<li>阿里的百炼模型，推理参数为 <code>enable_thinking</code>，且必须显示传递 <code>.extraBody(Map.of("enable_thinking", true))</code></li>
<li>智谱的glm-4.5-flash模型，默认就是开启推理的，不需要额外传递参数；如果希望关闭，可以设置参数 <code>.extraBody(Map.of("thinking", Map.of("type", "disabled")))</code></li>
</ul>
<figure><img src="/imgs/column/springai/17-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 获取推理结果</h3>
<p>我们先使用同步调用智谱模型，看看表现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试一下，结果返现并没有推理过程；主要原因是推理过程需要是<code>stream()</code>方式调用，然后由用户在 <code>delta</code> 中进行获取</p>
<p>我们在改成 <code>.stream()</code> 方法来获取推理结果</p>
<p>获取推理结果的关键代码在： <code>generation.getOutput().getMetadata().get("reasoningContent");</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/17-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的结果也可以看出，对于推理过程，使用流式调用，然后再metadata中获取</p>
<p>上面是智谱的大模型；阿里百炼的模型，获取推理结果同样也是使用流式调用，区别在于，若开启了推理过程，那么必须使用流式调用；否则，会报错</p>
<h2> 二、小结</h2>
<p>本文介绍了如何与支持推理的LLM进行交互，并获取推理过程；从使用层面来看并没有太多的差异，只是需要注意</p>
<ol>
<li>推理过程需要使用流式调用</li>
<li>根据模型的传参定义，判断是否需要主动设置参数，以开启推理过程</li>
<li>从返回的<code>metadata</code>中，获取 <code>reasoningContent</code> 来获取推理过程</li>
</ol>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/17-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>01.AI Agent Google白皮书</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/01.AI%20Agent%20Google%E7%99%BD%E7%9A%AE%E4%B9%A6.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/01.AI%20Agent%20Google%E7%99%BD%E7%9A%AE%E4%B9%A6.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.AI Agent Google白皮书</source>
      <description>以下内容来自于大模型对 Agents谷歌白皮书 的翻译内容提取 1.序 人类非常擅长识别复杂的模式。他们是怎么做到的呢？ -- 借助于外部外部工具，如书籍、网络搜索或者计算器之类的工具，来补充一有的知识，然后再得出结论 对于生成式人工智能模型，同样也可以通过训练来使用工具，以此来访问实时信息或者给出行动建议，如</description>
      <category>Agent</category>
      <pubDate>Thu, 06 Nov 2025 10:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>以下内容来自于大模型对 <a href="https://drive.google.com/file/d/1oEjiRCTbd54aSdB_eEe3UShxLBWK9xkt/view" target="_blank" rel="noopener noreferrer">Agents谷歌白皮书</a> 的翻译内容提取</p>
<h2> 1.序</h2>
<p>人类非常擅长识别复杂的模式。他们是怎么做到的呢？</p>
<p>-- 借助于外部外部工具，如书籍、网络搜索或者计算器之类的工具，来补充一有的知识，然后再得出结论</p>
<p>对于生成式人工智能模型，同样也可以通过训练来使用工具，以此来访问实时信息或者给出行动建议，如</p>
<ul>
<li>利用数据库查询工具获取客户的购物历史，然后给出购物意见</li>
<li>根据用户的查询，调用相应的API，替用户回复电子邮件或者完成金融交易</li>
</ul>
<p>大模型要实现这个，则要求模型不仅需要访问外部工具，还要能够自主规划和执行任务。 这种具备了<strong>推理、逻辑和访问外部信息</strong>的生成式 AI 模型，就是 Agent 的概念；</p>
<p>换句话说，Agent <strong>是一个扩展了生成式AI模型出厂能力的程序</strong>。</p>
<h2> 2.什么是Agent</h2>
<h3> 2.1 基本概念</h3>
<p>简单说，Agent 是 “带脑子 + 带手脚 + 会规划” 的生成式 AI 应用 —— 它能自己定目标、用工具、调资源，不用人一步步指挥，就能完成任务。</p>
<ul>
<li>Agent拥有自主能力(autonnomous): 只要提供了合适的目标，它们就能独立行动，无需人类干预</li>
<li>即使是模糊的人类指令，Agent也可以推理出它接下来应该做什么，并采取行动，最终实现其目标</li>
</ul>
<h3> 2.2 认知架构(congnitive architecture)</h3>
<p>驱动Agent的行为、动作、决策（behavior, actions, decision marking）共同组合成Agent的认知架构</p>
<p>在这个架构中，有三个核心组件，如下面的认知架构图</p>
<ul>
<li>model: 模型</li>
<li>tool: 工具</li>
<li>orchestration: 编排层</li>
</ul>
<figure><img src="/imgs/column/springai/wp-00.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 2.2.1 模型 model</h4>
<p>在Agent领域中，model通常指的是用于做核心决策的语言模型(LM)</p>
<ul>
<li>可以是大模型，也可以是小模型(LLM/SLM)</li>
<li>需要遵循基于指令的推理和逻辑框架（ReAct, Chain-of-Thought, Tree-of-Thought）</li>
<li>可以是通用、多模态的模型，或者根据特定的Agent架构的需求微调的模型</li>
<li>为了获得更好的执行效果，推荐根据已有的工具、数据集、编排推理设置，对模型进行训练/微调，以此来获得更稳定表现的模型</li>
</ul>
<h4> 2.2.2 工具 tool</h4>
<p>基础模型在文本和图像生成方面非常抢单，但是无法预外部世界联动，则极大的限制了它们的能力。工具(tool)则可以解决这个问题，Agent通过工具与外部数据和服务互动，从而扩展模型的能力边界</p>
<p>工具可以有多种表现形式，最常见的是通过WEB API(如GET/POST/PATCH/DELETE等http调用) 方式提供的工具能力</p>
<h4> 2.2.3 编排层 ochestration</h4>
<p>编排层主要描述了一个循环过程，用于控制Agent如何接收消息、执行内部推理、并使用推来结果来指导下一步的行动或者决策</p>
<p>对于编排层，有两个显著的特点：</p>
<ul>
<li>通常来说，这个循环过程会持续进行，直到Agent达到其目标或触发停止条件</li>
<li>编排层的复杂性和Agent及其执行的任务直接相关，差异可能很大</li>
</ul>
<h4> 2.2.4 Agent vs Model</h4>
<p>代表对比了Agent与模型之间的区别</p>
<table>
<thead>
<tr>
<th>对比</th>
<th>模型</th>
<th>Agent</th>
</tr>
</thead>
<tbody>
<tr>
<td>知识范围</td>
<td>知识仅限于其训练数据。</td>
<td>通过工具连接外部系统，能够在模型自带的知识之外，实时、动态扩展知识。</td>
</tr>
<tr>
<td>状态与记忆</td>
<td>无状态，每次推理都跟上一次没关系，除非在外部给模型加上会话历史或上下文管理能力。</td>
<td>有状态，自动管理会话历史，根据编排自主决策进行多轮推理。</td>
</tr>
<tr>
<td>原生工具</td>
<td>无。</td>
<td>有，自带工具和对工具的支持能力。</td>
</tr>
<tr>
<td>原生逻辑层</td>
<td>无。需要借助提示词工程或使用推理框架（CoT、ReAct  等）来形成复杂提示，指导模型进行预测。</td>
<td>有，原生认知架构，内置 CoT、ReAct 等推理框架或 LangChain  等编排框架。</td>
</tr>
</tbody>
</table>
<h2> 3.认知架构：Agent如何工作</h2>
<h3> 3.1 以厨师为例，类比Agent的工作流程</h3>
<p>厨师的职责是根据顾客的菜单，烹饪对应的菜品。 这个操作流程类似上面说到的<strong>规划——执行——调整</strong>(<code>planning - execution - adjustment</code>)循环过程</p>
<ul>
<li>收集信息(输入)：顾客点的菜单，后厨现有的食材等</li>
<li>推理(思考): 根据收集的信息，判断可以做哪些采</li>
<li>做菜(执行): 切菜、烹饪、出锅</li>
</ul>
<p>在上面的每个阶段过程，厨师都需要根据实际情况进行调整，比如突然某个食材不够了，需要找顾客协商换一道菜；根据顾客的饮食偏好，添加不同的调料（如有人要清淡、有人要重口），通过这些调整，不断的完善整个做菜过程</p>
<p>这个信息接收、规划、执行和调整（information intake, planning, executing, and adjusting）的循环描述的就是一个厨师用来实现其目标的特定认知架构。</p>
<h3> 3.2 Agent 推理框架</h3>
<p>Agent的核心是编排层，负责<strong>维护记忆、状态、推理和规划</strong>（<code>memory, state, reasoning and planning</code>）</p>
<p>使用快速发展的<strong>提示词工程</strong>(prompt engineering)及相关框架来指导推理和规划，使Agent能更有效的与环境互动来完成任务</p>
<p>白皮书中提到了三种推理框架和推理计数</p>
<ul>
<li>ReAct: 为LM提供了一个思考过程的策略</li>
<li>Cot(Chain-of-Thought)：思维链，通过中间步骤实现推理能力 （有各种子技术，如自我一致性、主动提示、多模态CoT）</li>
<li>ToT(Tree-of-Thoughts)：思维树，适合探索或战略前瞻任务。概括了链式思考提示，并允许模型探索各种思考链，作为使用语言模型解决问题的中间步骤。</li>
</ul>
<h3> 3.3 ReAct示例</h3>
<p>Agent 可以使用以上一种或多种推理技术，给特定的用户请求确定下一个最佳行动。 例如，使用 ReAct 的例子</p>
<ol>
<li>用户向 Agent 发送查询。</li>
<li>Agent 开始 ReAct sequence。</li>
<li>Agent 提示模型，要求其生成下一个 ReAct 步骤及其相应的输出：
<ul>
<li>问题：提示词 + 用户输入的问题</li>
<li>思考：模型的想法：下一步应该做什么</li>
<li>行动：模型的决策：下一步要采取什么行动。这里就是可以引入工具的地方， 例如，行动可以是 <code>[Flights, Search, Code, None]</code> 中的一个，前三个代表模型可以选择的已知工具，最后一个代表“无工具选择”。</li>
<li>行动的输入：模型决定是否要向工具提供输入，如果要提供，还要确定提供哪些输入</li>
<li>观察：行动/行动输入序列的结果。根据需要，这个思考/行动/行动输入/观察<code>（thought / action / action input / observation）</code>可能会重复 N 次。</li>
<li>最终答案：模型返回对原始用户查询的最终答案。</li>
</ul>
</li>
<li>ReAct 循环结束，并将最终答案返回给用户。</li>
</ol>
<figure><img src="/imgs/column/springai/wp-01.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如上图，模型、工具和Agent配置共同工作，根据用户的输入，返回一个有根据的、简洁的响应。虽然模型第一轮根据其先前知识猜了一个答案（幻觉），但它接下来使用了一个工具（航班）来搜索实时外部信息，从而能根据真实数据做出更明智的决策，并将这些信息总结回给用户。</p>
<p>Agent 的响应质量与模型的推理能力和执行任务的能力直接相关，包括选择正确工具的能力，以及工具自身的定义的好坏（how well that tools has been defined）。就像厨师精选食材、精心做菜，并关注顾客的反馈一样，Agent 依赖于合理的推理和可靠的信息来提供最佳结果。</p>
<h2> 4.工具：模型链接真实世界的关键</h2>
<p>语言模型很擅长处理信息，但它们缺乏直接感知和影响现实世界的能力。在需要与外部系统或数据联动的情况下，这些模型的实用性就很低了。 某种意义上说，语言模型的能力<strong>受限于它们的训练数据中覆盖到的信息</strong></p>
<p>为了赋予模型与外部系统进行实时、上下文感知的互动能力，通常有下面几种方式（统称为工具 Tools）</p>
<ul>
<li>Functions</li>
<li>Extensions</li>
<li>Data Stores</li>
<li>Plugins</li>
</ul>
<h3> 4.1 Extensions</h3>
<p><code>extension</code> 是一种以标准化方式连接 <code>API</code> 与 <code>Agent</code> 的组件， 使 <code>Agent</code> 能够调用外部 API，而不用管这些 API 背后是怎么实现的。</p>
<p>假设你想创建一个帮用户预定航班的Agent，并使用Google Flights API来搜索航班信息，但不确定如何让你的Agent调用这个API</p>
<figure><img src="/imgs/column/springai/wp-02.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 4.1.1 传统方式</h4>
<p>写代码，从用户输入中解析城市等相关信息，然后调用API，如</p>
<ul>
<li>用户输入 “I want to book a flight from Austin to Zurich”（“我想从奥斯汀飞往苏黎世”）； 我们的代码需要从中提取“Austin”和“Zurich”作为相关信息，然后才能进行 API 调用。</li>
<li>但如果用户输入“I want to book a flight to Zurich”，我们就无法获得出发城市信息，进而无法成功调用 API，所以需要写很多代码来处理边界 case。</li>
</ul>
<p>显然，这种方法维护性和扩展性都很差。有没有更好的解决方式呢？ 这就轮到 exntension 出场了。</p>
<h4> 4.1.2 使用Extension</h4>
<figure><img src="/imgs/column/springai/wp-03.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如图，Extension通过以下方式将Agent与API串起来</p>
<ul>
<li>提供示例信息告诉Agent如何使用API</li>
<li>告诉Agent调用API所需的具体参数</li>
</ul>
<p><code>Extension</code> 可以独立于 <code>Agent</code> 开发，但应作为 <code>Agent</code> 配置的一部分。 <code>Agent</code> 在运行时，根据提供的示例和模型来决定使用哪个 <code>extension</code> 来处理用户的查询， 这突出了 <code>extension</code> 的一个核心优势：<code>built-in example types</code>， 允许 <code>Agent</code> 动态选择最适合所执行任务的 extension，如下图所示</p>
<figure><img src="/imgs/column/springai/wp-04.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4.2 Functions</h3>
<p>在程序员的日常工作中，“函数”指的是自包含的代码模块，用于完成特定任务，并可以复用（被不同地方的代码调用）</p>
<p>在Agent的世界中，函数的工作方式非常相似——知识将软件开发者替换为模型。模型可以设置一组已知的函数，然后就可以根据规范决定何时使用哪个函数，以及函数需要哪些参数</p>
<figure><img src="/imgs/column/springai/wp-05.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol>
<li>模型只输出函数名及参数信息，不会执行函数调用</li>
<li>函数在客户端执行，作为对比的是Extension在Agent端执行</li>
</ol>
<h4> 4.2.1 Functions vs Extention</h4>
<p>对于Function，与Extention的核心区别在于，调用实际API的逻辑和执行将从代理返回给用户，因此开发人员可以对应用程序中的数据流进行更精细的控制，常见于</p>
<ul>
<li>并不希望直接调用API，而是由应用程序的其他层来调用</li>
<li>因为安全身份校验，不支持Agent直接访问的场景</li>
<li>不希望实时调用的场景（如需要人工review执行链路）</li>
</ul>
<figure><img src="/imgs/column/springai/wp-06.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 4.2.2 示例</h4>
<p>考虑以下例子，实现一个 AI Traval Agent，它会与想要旅行的用户互动。 我们的目标是让 Agent 生成一个城市列表，然后就可以下载相应城市的图片、数据等，以供用户旅行规划使用。</p>
<p>用户输入：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>模型输出可能如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然以上输出包含了我们需要的数据（城市名称），但格式不适合解析。 通过 Function，我们可以教模型以结构化风格（如 JSON）输出，以便其他系统解析。</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个Agent应用的整体流程图如下</p>
<figure><img src="/imgs/column/springai/wp-07.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4.3 data storage</h3>
<p>语言模型就像一个大图书馆，其中包含了其训练数据（信息）。但与真实世界的图书馆不同的是，这个图书馆是静态的 —— 不会更新，只包含其最初训练时的知识。而现实世界的知识是不断在演变的，所以静态模型在解决现实世界问题时就遇到了挑战。</p>
<figure><img src="/imgs/column/springai/wp-08.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><code>Data Storage</code> 通过提供动态更新的信息来解决这一问题，</p>
<ul>
<li>允许开发人员以原始格式向 <code>Agent</code> 提供增量数据，将传入的文档转换为一组向量数据库嵌入，<code>Agent</code> 可以使用这些 <code>embedding</code> 来提取信息。</li>
<li>增量数据补充，无需耗时的数据转换、模型重新训练、微调</li>
</ul>
<h4> 4.3.1 实现与应用</h4>
<p>在生成式 AI 场景，Agent 使用的数据库一般是向量数据库 —— 它们以向量 <code>embedding</code> 的形式存储数据，这是一种高维向量或数学表示。</p>
<figure><img src="/imgs/column/springai/wp-09.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>使用语言模型与 Data Storage 的最典型例子是检索增强生成（RAG - Retrieval Augmented Generation），RAG 应用程序通过让模型访问各种格式的数据来扩展模型知识的广度和深度，如：</p>
<ul>
<li>网站内容</li>
<li>结构化数据，如pdf/word/csv/电子表格等</li>
<li>非结构化数据，如HTML/PDF/TXT等</li>
</ul>
<p>用户请求和Agent响应循环的基本过程如下图</p>
<figure><img src="/imgs/column/springai/wp-10.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol>
<li>用户请求 发送到嵌入模型(embedding model)，生成嵌入查询(query embedding)。</li>
<li>将嵌入查询与向量数据库的内容进行匹配，本质上就是在计算相似度。</li>
<li>将相似度最高的内容以文本格式发送回 <code>Agent</code>。</li>
<li><code>Agent</code> 决定响应或行动。</li>
<li>最终响应发送给用户。</li>
</ol>
<h4> 4.3.2 示例</h4>
<p>一个RAG与ReAct推理/规划的Agent示例</p>
<figure><img src="/imgs/column/springai/wp-11.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4.4 小结</h3>
<p>总结来说，Extension、Function 和 Data Storage 是 Agent 在运行时可以使用的几种不同工具类型。 每种工具都有其特定的用途，可以根据 Agent 开发人员的判断单独或一起使用。</p>
<table>
<thead>
<tr>
<th>对比</th>
<th>Extensions</th>
<th>Function Calling</th>
<th>Data Stores</th>
</tr>
</thead>
<tbody>
<tr>
<td>Execution 执行</td>
<td>Agent执行</td>
<td>Client执行</td>
<td>Agent执行</td>
</tr>
<tr>
<td>使用场景</td>
<td>- 开发人员希望 Agent 控制 API 的调用 <br> - 使用 native pre-built Extensions (i.e., Vertex Search, Code Interpreter, etc.) 时比较有用 <br> - Multi-hop planning and API calling (i.e., 下一个 action 取决于前一个 action/API call 的输出)</td>
<td>- 安全或认证等原因，导致 Agent 无法直接调用 API 的场景 <br> - 时序或者操作顺序限制，导致 Agent 无法直接事实调用 API 的场景，(i.e., batch operations, human-in-the-loop review, etc.) <br> - API 没有暴露给公网，只能在内部使用的场景。</td>
<td>RAG</td>
</tr>
</tbody>
</table>
<h2> 5.通过针对性学习提升模型性能</h2>
<p>有效使用模型的一个关键是，让模型具备在生成输出时选择正确工具的能力。虽然一般训练有助于模型获得这种技能，但现实世界的场景通常需要超出训练数据的知识。 这就像是掌握基本做菜技能和精通特定菜系之间的区别，两者都需要基础烹饪知识，但后者需要针对性学习以获得更好的垂类结果。</p>
<p>通常有下面几种方法</p>
<h3> 5.1 In-Context learnging：基于上下文学习</h3>
<p>使用通用模型，但在推理时为模型提供提示词、工具和示例，使模型其能够“即时学习”如何以及何时为特定任务使用这些工具。 如ReAct框架</p>
<h3> 5.2 Retrieval-based in-context learnging: 基于检索的上下文学习</h3>
<p>通过从外部存储中检索相关信息、工具和示例来动态填充模型提示词，如RAG</p>
<h3> 5.3 Fine-utning based learning: 基于微调的学习</h3>
<p>用大量的特定示例对模型进行训练（微调/精调），然后用微调过的模型进行推理。</p>
<p>这有助于模型在接收到任何用户查询之前，理解何时以及如何应用某些工具。</p>
<h2> 6.总结</h2>
<p>本文讨论了生成式 AI Agent 的基础构建模块及工作原理。一些关键信息：</p>
<ol>
<li>Agent 的核心价值：让生成式 AI 从 “生成内容” 升级为 “完成任务”，能自主规划、用工具、对接真实世界</li>
<li>三大关键：模型（思考）、工具（行动）、编排层（流程）</li>
<li>工具选对很重要：直接用 Extension，安全可控用 Function，需要实时 / 私有数据用 Data Store</li>
<li>推理框架：ReAct, CoT, ToT, (以及本文未提到的Plan-and-Execute)</li>
<li>未来方向：多个 Agent 分工合作（比如一个负责旅行规划，一个负责订机票，一个负责订酒店），解决更复杂的问题</li>
</ol>
<p>最后需要说明，复杂的 Agent 架构并不是一蹴而就的，需要持续迭代（iterative approach）。 给定业务场景和需求之后，不断的实验和改进是找到解决方案的关键。</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/wp-00.webp" type="image/webp"/>
    </item>
    <item>
      <title>02.Agent思考框架-CoT思维链</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/02.Agent%E6%80%9D%E8%80%83%E6%A1%86%E6%9E%B6-CoT.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/02.Agent%E6%80%9D%E8%80%83%E6%A1%86%E6%9E%B6-CoT.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">02.Agent思考框架-CoT思维链</source>
      <description>AI智能体思考框架主要是为了赋予AI智能体结构化的推理和决策能力，为AI智能体提供一套完整的方法论，指导其如何理解目标、分解任务、运用工具、处理输入，并依据环境反馈来调整资深行为 当前主流的思考框架有CoT, ReAct, ToT, Plan-and-Execute，本文将主要介绍一下CoT 思维链 1.CoT思维链 Chain-of-Thought(CoT) 来源与论文 《Chain-of-Thought Prompting Elicits Reasoning in Large Language Models》</description>
      <category>Agent</category>
      <pubDate>Thu, 06 Nov 2025 14:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>AI智能体思考框架主要是为了赋予AI智能体结构化的推理和决策能力，为AI智能体提供一套完整的方法论，指导其如何理解目标、分解任务、运用工具、处理输入，并依据环境反馈来调整资深行为</p>
<p>当前主流的思考框架有CoT, ReAct, ToT, Plan-and-Execute，本文将主要介绍一下CoT 思维链</p>
<h2> 1.CoT思维链</h2>
<p>Chain-of-Thought(CoT) 来源与论文 <a href="https://proceedings.neurips.cc/paper_files/paper/2022/file/9d5609613524ecf4f15af0f7b31abca4-Paper-Conference.pdf" target="_blank" rel="noopener noreferrer">《Chain-of-Thought Prompting Elicits Reasoning in Large Language Models》</a></p>
<p>论文中提出，CoT核心是让大模型在输出最终答案前，先用自然语言生成一步步的推理过程，就像人类解数学题时写 “解题步骤”、做决策时列 “思考清单” 一样。而这些推理的中间步骤就被称为思维链</p>
<h3> 1.1 CoT定义</h3>
<blockquote>
<p>以下内容，可来自于论文: <a href="https://arxiv.org/pdf/2311.11797" target="_blank" rel="noopener noreferrer">Igniting Language Intelligence: The Hitchhiker's Guide From Chain-of-Thought Reasoning to Language Agents</a></p>
</blockquote>
<p>区别于传统的 Prompt 从输入直接到输出的方式，CoT完成了从输入到思维链再到输出的转变，即</p>
<p>由 <code>input -&gt; output</code> 转变为 <code>input -&gt; reasoning chain -&gt; output</code></p>
<figure><img src="/imgs/column/springai/ag2-01.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如图，一个完整的包含CoT的提示词，通常由指令(Instruction), 逻辑依据(Rationale), 示例(Examplars)三部分组成</p>
<ul>
<li>指令: 用于描述问题并且告知大模型的输出格式</li>
<li>逻辑: 依据即指 CoT 的中间推理过程，可以包含问题的解决方案、中间推理步骤以及与问题相关的任何外部知识，</li>
<li>示例: 则指以少样本的方式为大模型提供输入输出对的基本格式，每一个示例都包含：问题，推理过程与答案。</li>
</ul>
<p>以是否包含示例为区分，可以将 CoT 分为 Zero-Shot-CoT 与 Few-Shot-CoT</p>
<p>在上图中，Zero-Shot-CoT 不添加示例而仅仅在指令中添加一行经典的“Let's think step by step”，就可以“唤醒”大模型的推理能力。</p>
<p>而 Few-Shot-Cot 则在示例中详细描述了“解题步骤”，让大模型参考样例进行执行，从而得到推理能力。</p>
<h3> 1.2 CoT的作用</h3>
<ol>
<li>CoT允许模型把一个复杂问题拆解成多个步骤，也就是说需要更多推理步骤的问题可以多分点计算量。</li>
<li>CoT提供了一个观察模型为何会犯错的窗口，给观测者了解模型出现幻觉的原因</li>
<li>CoT能用在数学应用题、常识推理和符号操作上，也就有可能用在任何人类通过语言能解决的问题上</li>
<li>CoT支持任何语言模型使用</li>
</ol>
<h3> 1.3 CoT的优势</h3>
<ol>
<li>提高推理性能：CoT 通过将复杂问题分解为多步骤的子问题，相当显著的增强了大模型的推理能力，也最大限度的降低了大模型忽视求解问题的“关键细节”的现象，使得计算资源总是被分配于求解问题的“核心步骤”；</li>
<li>提高可解释性：对比向大模型输入一个问题大模型为我们仅仅输出一个答案，CoT 使得大模型通过向我们展示“做题过程”，使得我们可以更好的判断大模型在求解当前问题上究竟是如何工作的，同时“做题步骤”的输出，也为我们定位其中错误步骤提供了依据；</li>
<li>提高可控性：通过让大模型一步一步输出步骤，我们通过这些步骤的呈现可以对大模型问题求解的过程施加更大的影响，避免大模型成为无法控制的“完全黑盒”</li>
<li>提高灵活性：仅仅添加一句“Let's think step by step”，就可以在现有的各种不同的大模型中使用 CoT 方法，同时，CoT 赋予的大模型一步一步思考的能力不仅仅局限于“语言智能”，在科学应用，以及 AI Agent 的构建之中都有用武之地</li>
</ol>
<h2> 2. CoT原理</h2>
<h3> 2.1 CoT生效原理</h3>
<p>大模型是如何支持CoT的呢？</p>
<p>本质是 <code>大模型支持 CoT 的本质，是通过训练或提示机制，使模型在生成过程中显式或隐式地产生中间推理步骤，从而提高复杂推理任务的可解释性与准确性。</code></p>
<h4> 2.1.1 提示级CoT：基于提示工程的显式引导</h4>
<p>最早、也是目前最常用的方式。其核心思想是不改变模型参数，而是通过提示语（prompt）设计，引导模型在推理过程中显式输出中间步骤。主要分为两类：</p>
<ul>
<li><strong>零样本 CoT（Zero-shot CoT）</strong>：仅在问题末尾添加引导语，例如 <code>Let’s think step by step</code> 或 <code>请先分析步骤，再给出结论</code>。
<ul>
<li>例如，问题“为什么夏天海滩人多？” 加上引导语后</li>
<li>模型会生成类似推理链：
<ul>
<li>第一步，夏天天气炎热，人们倾向于去水边避暑；</li>
<li>第二步，海滩具备娱乐与降温功能；</li>
<li>第三步，夏季假期增加出行需求”，最后得出结论“因此夏天海滩更受欢迎。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这种方式简单有效，但在复杂推理任务中的准确率较低，对模型语言偏好和训练语料敏感。</p>
<ul>
<li>
<p><strong>少样本 CoT（Few-shot CoT）</strong>：在提示中提供若干 <code>问题 + 推理链 + 答案</code></p>
<ul>
<li>示例，使模型通过上下文学习（In-context Learning, ICL）模仿推理模式。</li>
<li>例如在算术任务中提供示例：「问题：10 个橘子吃了 3 个，还剩几个？→ 推理：10−3=7 → 答案：7」。模型据此可类推新问题。</li>
</ul>
</li>
</ul>
<p>这种方式能显著提升推理稳定性，但需要人工构建高质量示例。</p>
<h4> 2.1.2 自举式CoT：利用模型自身能力自动生成示例</h4>
<p>人工编写少样本示例成本高，因而出现了 <strong>自动思维链（Auto-CoT）</strong> 方法。其核心思想是：让模型通过自举（bootstrapping）机制自动生成用于提示的 CoT 示例。典型流程如下：</p>
<ol>
<li><strong>问题聚类（Question Clustering）</strong>：将待解决任务划分为若干语义相近的类别（如“加法”“减法”“应用题”）。</li>
<li><strong>自动示例生成（Automatic Demonstration Generation）</strong>：从每类中选择代表性问题，利用零样本 CoT 生成高质量推理链作为示例。</li>
<li><strong>Few-shot 提示重构</strong>：将自动生成的示例嵌入提示中，引导模型处理同类问题。</li>
</ol>
<p>在实践中，Auto-CoT 常与 <strong>自一致性（Self-consistency）</strong> 策略结合，即采样多条思维链并选取最一致的答案，以减轻错误推理传播问题。
这种方法减少人工干预，能在无需重新训练的前提下，自动获得较强的推理能力。</p>
<h4> 2.1.3 模型级 CoT：在训练阶段内化推理能力</h4>
<p>现在的大模型（如 DeepSeek-R1、GPT-o1 等）已不再依赖提示引导，而是通过训练过程直接“内化”思维链能力。实现路径通常包括以下几个阶段：</p>
<ul>
<li><strong>监督微调（Supervised Fine-tuning, SFT）阶段</strong>：在训练数据中引入大量包含“推理步骤 + 最终答案”的样本，使模型学习生成中间思考过程；</li>
<li><strong>强化优化（RLHF / RLAIF）阶段</strong>：通过人类反馈或自动反馈信号，奖励“逻辑正确、步骤完整”的推理链，惩罚“跳步或错误推理”；</li>
<li><strong>过程监督（Process Supervision）与验证器机制（Verifier-based Fine-tuning）</strong>：进一步强化中间推理过程的可验证性，使模型学会自我审查与修正。</li>
</ul>
<p>经过这样的训练，模型在面对复杂推理任务时，即便没有显式提示，也能自然生成符合逻辑的思维链，表现出“内置的推理习惯”。</p>
<h4> 2.1.4 多模态 CoT：跨模态推理的思维链扩展</h4>
<p>随着多模态大模型的发展（如 GPT-4o、Gemini 2等），CoT 概念已扩展至文字与视觉等多源信息的联合推理。</p>
<p><strong>多模态 CoT（Multimodal CoT）</strong>
旨在让模型在生成答案前，整合图像特征与文本上下文，形成跨模态的推理链。</p>
<p>例如，输入一张“拥挤的海滩”图片并询问“夏天这里会更受欢迎吗？”，模型可能推理：“图片显示人群密集，当前已受欢迎；夏季天气炎热，人们更倾向于去海滩避暑；假期增多会进一步提升出游人数”，最终得出结论“夏天会更受欢迎”。</p>
<p>技术上，多模态 CoT 通过两类机制实现：</p>
<ul>
<li><strong>融合式推理（Fusion-based Reasoning）</strong>：将图像与文本 token 在同一 Transformer 层中联合建模；</li>
<li><strong>递归式推理（Iterative Reasoning）</strong>：先生成初步视觉分析，再结合语言模型多轮细化推理。</li>
</ul>
<p>这类机制显著提升了模型在视觉问答（VQA）、图文逻辑、视频理解等任务中的推理一致性与可解释性。</p>
<h4> 2.1.5 小结</h4>
<p>CoT 的演进体现了从“显式提示驱动”到“内化思维模式”的范式转变：</p>
<ul>
<li><strong>提示级 CoT</strong>：通过设计输入引导模型逐步推理；</li>
<li><strong>自举式 CoT</strong>：让模型利用自身能力自动生成推理示例；</li>
<li><strong>模型级 CoT</strong>：在训练中嵌入推理链能力，实现原生思考；</li>
<li><strong>多模态 CoT</strong>：扩展至跨模态逻辑推理，融合语言与感知信息。</li>
</ul>
<p>这一演化路径标志着大模型从“被提示思考”迈向“自主推理”的阶段性突破。</p>
<h3> 2.2 CoT推理过程</h3>
<p>CoT提示过程，更像是一种提示词工程（Prompt Engineering)，通过向大语言模型展示一些少量的 exapmles，在样例中解释推理过程，大语言模型在回答提示时也会显示推理过程。</p>
<figure><img src="/imgs/column/springai/ag2-02.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如上图，以一个数学题为例，思维链提示会在给出答案之前，还会自动给出推理步骤，基于示例的方式，得到最终的计算结果</p>
<p>请注意，很多人会把 CoT 和 “详细提示” 搞混，其实两者本质不同：</p>
<ul>
<li>普通提示（比如 “请详细回答”）：只要求模型 “把答案说详细”，但没要求 “拆步骤推理”，模型可能还是跳过关键思考环节；</li>
<li>CoT 提示：强制模型 “拆步骤想”，比如在问题结尾加 “Let’s think step by step”（零样本 CoT），或给几个 “问题 + 推理链 + 答案” 的例子（少样本 CoT），让模型模仿 “分步思考” 的模式。</li>
</ul>
<h2> 3. CoT 与 AI Agent</h2>
<p>接下来我们再来看一看CoT为什么会成为Agent的主流推理框架之一</p>
<h3> 3.1 概念层</h3>
<h4> 3.1.1 CoT</h4>
<p>上面说到了Chain-of-Thought (CoT) 是一种推理生成机制（reasoning generation mechanism），让模型在回答问题前显式地展开中间推理步骤。</p>
<p>通俗地说，它让模型不直接“给答案”，而是“先想一想再回答”。
它关注的是 “思考的路径”。</p>
<h4> 3.1.2 Agent</h4>
<p>AI Agent（智能体） 是一种具备自主决策、环境交互与长期目标优化能力的系统架构。
它不只是语言模型，而是一个具备以下循环的系统：</p>
<p>感知（Perceive）→ 推理（Reason）→ 决策（Plan）→ 执行（Act）→ 反馈（Reflect）</p>
<p>Agent 的核心特征在于它必须：</p>
<ul>
<li>面对开放环境；</li>
<li>基于上下文做多步决策；</li>
<li>能调用外部工具或环境接口；</li>
<li>能根据反馈进行自我修正。</li>
</ul>
<h4> 3.1.3 对比</h4>
<table>
<thead>
<tr>
<th>概念</th>
<th>关注点</th>
<th>核心目标</th>
<th>是否可独立存在</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CoT</strong></td>
<td>模型内部的推理路径</td>
<td>提升逻辑一致性与可解释性</td>
<td>✅（单模型即可实现）</td>
</tr>
<tr>
<td><strong>Agent</strong></td>
<td>系统级决策循环</td>
<td>实现自主任务执行</td>
<td>🚫（离不开推理机制）</td>
</tr>
</tbody>
</table>
<p><strong>结论</strong>：CoT 是 Agent 的“推理内核”，Agent 是 CoT 的“应用容器”。</p>
<h3> 3.2 技术逻辑层</h3>
<p>AI Agent 想要具备“智能决策”的能力，必须拥有**多步思考（multi-step reasoning）<strong>和</strong>动态规划（planning）**能力。
而 CoT 正是当前大模型中最有效的“多步思考表示形式”。</p>
<h4> 3.2.1 CoT 提供了 Agent 的“内在思维空间”（Internal Reasoning Space）</h4>
<p>传统语言模型输出的是单步映射：</p>
<blockquote>
<p>输入 → 输出</p>
</blockquote>
<p>但 Agent 需要一个能在内部进行反思、规划、评估的结构化思维过程。</p>
<blockquote>
<p>输入 → （思考链）→ 决策 → 动作 → 环境反馈</p>
</blockquote>
<p>在这一结构中，CoT 就是 Agent 的「<strong>思维工作记忆（Working Memory）</strong>」：
模型通过生成中间推理链，显式地表达自己“在思考什么”，
从而为后续动作提供决策依据。</p>
<p>例如：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Agent 框架中，以上 CoT 输出可直接驱动调用外部工具（日程表API、邮件系统）来执行这些步骤。</p>
<h4> 3.2.2 CoT 是“反思与规划（Reflection &amp; Planning）”机制的基础</h4>
<p>在现代 Agent 设计中，存在两种主流推理范式：</p>
<table>
<thead>
<tr>
<th>推理机制</th>
<th>核心特征</th>
<th>代表实现</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CoT（Chain-of-Thought）</strong></td>
<td>线性推理链条，显式展开思考</td>
<td>GPT-4、DeepSeek-R1</td>
</tr>
<tr>
<td><strong>ToT（Tree-of-Thought）</strong></td>
<td>树状搜索式推理，多路径评估与反思</td>
<td>Tree-of-Thoughts (Yao et al., 2023)</td>
</tr>
<tr>
<td><strong>ReAct（Reason + Act）</strong></td>
<td>推理与行动交替执行</td>
<td>LangChain / ReAct Agents</td>
</tr>
<tr>
<td><strong>Reflexion / Self-Refine</strong></td>
<td>基于 CoT 输出的自我反思与修正</td>
<td>Reflexion (Shinn et al., 2023)</td>
</tr>
</tbody>
</table>
<p>注意：这些框架<strong>都以 CoT 为基础</strong>。</p>
<ul>
<li>ReAct 将 CoT 拓展为 “推理链 + 动作链”；</li>
<li>Tree-of-Thought 则是 CoT 的并行搜索化版本；</li>
<li>Reflexion 则是在 CoT 基础上增加了 “评估与修正” 模块。</li>
</ul>
<p>因此，从技术谱系上看：</p>
<blockquote>
<p><strong>CoT → ReAct / ToT / Reflexion → Agent Frameworks（如 AutoGPT, LangGraph, Voyager 等）</strong></p>
</blockquote>
<p>这也是为什么学术界称 CoT 是 “<strong>AI Agent 的推理基石（reasoning substrate）</strong>”。</p>
<h4> 3.2.3 CoT 支撑 Agent 的“显式可解释推理”能力</h4>
<p>Agent 需要被<strong>监控、调试、解释</strong>。
如果模型的决策过程是黑箱式的 end-to-end 输出（没有中间思考过程），就无法解释为何采取某个行动。</p>
<p>而 CoT 提供了一种<strong>可追踪的决策链条</strong>：</p>
<ul>
<li>每个步骤都可以被解析、验证、修改；</li>
<li>可以通过 reward model（奖励模型）对推理链进行强化或惩罚；</li>
<li>可以为后续的 meta-agent（监督 agent）提供反思依据。</li>
</ul>
<p>例如：</p>
<blockquote>
<p>CoT 输出：“我认为这家公司明天股价会上涨，因为……”，
Agent 上层模块即可分析这条推理链的合理性，并决定是否执行交易动作。</p>
</blockquote>
<p>这也是 OpenAI、Anthropic、DeepSeek 在 2024–2025 年各自的 Agent 架构中，都将 “structured reasoning trace” 作为核心模块的原因。</p>
<h3> 3.3 架构层</h3>
<p>下图描述了 CoT 与 Agent 的架构关系（文字版示意）：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这套架构中：</p>
<ul>
<li><strong>CoT 是核心推理引擎（Reasoning Engine）</strong>；</li>
<li>它与记忆模块、工具模块交互；</li>
<li>输出的思维链结果直接影响行动决策与反馈循环；</li>
<li>高级 Agent（如反思型、自演化型 Agent）则在多轮 CoT 之上再叠加元推理（Meta-Reasoning）。</li>
</ul>
<h3> 3.4 小结</h3>
<p>CoT 作为 Agent 的主流推理框架，其主要原因如下</p>
<table>
<thead>
<tr>
<th>理由</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. CoT 提供了结构化的思维路径</strong></td>
<td>使模型从“直接反应”转为“逐步规划”</td>
</tr>
<tr>
<td><strong>2. CoT 是多步决策的基础</strong></td>
<td>Agent 的计划、反思、行动循环都依赖推理链</td>
</tr>
<tr>
<td><strong>3. CoT 支撑可解释与可控性</strong></td>
<td>让外部系统理解、修改模型思考过程</td>
</tr>
<tr>
<td><strong>4. CoT 是更复杂推理框架（ReAct、ToT、Reflexion）的母体</strong></td>
<td>所有主流 Agent 推理范式都从 CoT 演化而来</td>
</tr>
<tr>
<td><strong>5. 实践验证</strong></td>
<td>从 LangChain 到 OpenAI o1-preview，再到 DeepSeek-R1，均以 CoT 风格思维链为决策基石</td>
</tr>
</tbody>
</table>
<p>一句话总结</p>
<blockquote>
<p><strong>CoT 是 AI Agent 的思维引擎。</strong>
它将大模型从“语言生成器”变为“可思考的决策体”，
是连接自然语言理解与自主行动之间的关键逻辑桥梁。</p>
</blockquote>
<hr>
<p>参考资料:</p>
<ul>
<li><a href="https://blog.csdn.net/qq_36426650/article/details/139452817" target="_blank" rel="noopener noreferrer">大模型Chain-of-Thought（CoT）与Agent基础知识与介绍_cot 大模型-CSDN博客</a></li>
<li><a href="https://www.zhihu.com/tardis/zm/art/670907685?source_id=1003" target="_blank" rel="noopener noreferrer">一文读懂：思维链 CoT（Chain of Thought）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/629087587" target="_blank" rel="noopener noreferrer">大模型思维链（Chain-of-Thought）技术原理 - 知乎</a></li>
<li><a href="https://arxiv.org/pdf/2311.11797" target="_blank" rel="noopener noreferrer">Igniting Language Intelligence: The Hitchhiker’s Guide From Chain-of-Thought Reasoning to Language Agents</a></li>
<li><a href="https://proceedings.neurips.cc/paper_files/paper/2022/file/9d5609613524ecf4f15af0f7b31abca4-Paper-Conference.pdf" target="_blank" rel="noopener noreferrer">Chain-of-Thought Prompting Elicits Reasoning
in Large Language Models</a></li>
<li>大模型：豆包 + ChatGpt</li>
</ul>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/ag2-01.webp" type="image/webp"/>
    </item>
    <item>
      <title>03.Agent思考框架-ReAct</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/03.Agent%E6%80%9D%E8%80%83%E6%A1%86%E6%9E%B6-ReAct.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/03.Agent%E6%80%9D%E8%80%83%E6%A1%86%E6%9E%B6-ReAct.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">03.Agent思考框架-ReAct</source>
      <description>1. 背景与起源 ReAct 框架全称为 [Reason + Act: Synergizing Reasoning and Acting in Language Models](https://react-lm.github.io/)，由 Yao et al.（2022, Google Research） 首次提出。论文标题为： ReAct: Synergizing Reasoning and Acting in Language Models</description>
      <category>Agent</category>
      <pubDate>Thu, 06 Nov 2025 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. 背景与起源</h2>
<p><strong>ReAct 框架</strong>全称为 <code>[Reason + Act: Synergizing Reasoning and Acting in Language Models](https://react-lm.github.io/)</code>，由 <strong>Yao et al.（2022, Google Research）</strong> 首次提出。论文标题为：</p>
<blockquote>
<p><a href="https://arxiv.org/pdf/2210.03629" target="_blank" rel="noopener noreferrer"><em>ReAct: Synergizing Reasoning and Acting in Language Models</em></a></p>
</blockquote>
<p>这篇论文的出发点非常直接：</p>
<blockquote>
<p>仅靠 Chain-of-Thought（CoT）能让模型“思考”，但不能“行动”；
而仅靠 Tool-use 或 Action-based Agent 能“行动”，但不会“思考”。</p>
<p><strong>ReAct 试图让模型在推理（Reason）与行动（Act）之间交替进行，从而实现真正的智能体行为。</strong></p>
</blockquote>
<figure><img src="/imgs/column/springai/ag3-01.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 2. 核心思想：让模型在「思考」与「行动」之间循环</h2>
<p>传统的 CoT 是<strong>静态推理</strong>：</p>
<blockquote>
<p>输入 → 推理链（CoT） → 答案</p>
</blockquote>
<p>而 ReAct 是<strong>动态交互式推理</strong>：</p>
<blockquote>
<p>输入 → 推理步骤（Reason） → 执行动作（Act） → 观察反馈（Observe） → 再推理（Reason） → 再行动（Act） → … → 最终答案</p>
</blockquote>
<p>这种循环让模型不只是生成一条思维链，而是能够：</p>
<ul>
<li><strong>主动与外部环境交互（通过工具或接口）</strong></li>
<li><strong>根据反馈修正推理路径</strong></li>
<li><strong>在多轮循环中完成复杂任务</strong></li>
</ul>
<p>举个例子如你想查 “北京明天是否适合户外施工”，会先想 “我需要知道明天的天气（推理）→ 打开天气 APP 查数据（行动）→ 看到明天有暴雨（观察）→ 得出‘不适合施工’的结论（再推理）”。
放在大模型 / Agent 场景中，ReAct 就是让模型不再局限于 “纯内部推理”（比如 CoT 只在脑子里想），而是通过 “调用工具、获取外部反馈” 来验证和修正推理，形成闭环：</p>
<ul>
<li>推理（Reasoning）：分析目标、拆解步骤、决定下一步 “该做什么”（比如 “用户要订建筑材料，我需要先查库存→ 调用库存工具”）；</li>
<li>行动（Acting）：执行具体操作（调用工具 API、查询数据库、发送指令等），是模型与外部世界交互的核心；</li>
<li>观察（Observation）：获取行动的结果反馈（比如库存工具返回 “钢筋库存充足”“水泥缺货”）；</li>
<li>迭代：根据观察结果调整推理，直到完成目标（比如水泥缺货→ 推理 “需要找替代供应商”→ 行动 “调用供应商匹配工具”）。</li>
</ul>
<h2> 3. ReAct 的机制结构</h2>
<h3> 3.1 核心闭环流程</h3>
<p>ReAct 的核心是一个循环式 Prompt 结构，每一轮由 3 个关键组件构成：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Reason</code></td>
<td>思考步骤</td>
<td>模型分析当前状态，推理下一步要做什么</td>
</tr>
<tr>
<td><code>Act</code></td>
<td>执行动作</td>
<td>模型根据推理结果调用外部工具、API、搜索等</td>
</tr>
<tr>
<td><code>Observe</code></td>
<td>观察反馈</td>
<td>模型读取行动结果，更新内部状态</td>
</tr>
</tbody>
</table>
<p>循环结构如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种结构兼具“推理链的透明性”与“可执行性”，是 CoT 向 Agent 推理自然演化的形式。</p>
<h3> 3.2 关键要素</h3>
<p>要想让上面的ReAct的流程跑通，必须满足三个核心条件</p>
<ol>
<li>明确的目标与终止条件：目标要可量化（如2016年、诺贝尔文学奖获得者），终止条件要清晰（找到用户，任务完成）</li>
<li>标准化的工具接口：Agent 能 “看懂并调用” 工具（网络搜索）</li>
<li>状态记忆模块：Agent 能记录每一轮的 “思考结果、行动内容、观察反馈”，避免重复劳动或者遗忘关键信息</li>
</ol>
<h2> 4. 与 CoT 的关系：ReAct = CoT + 行动接口</h2>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>Chain-of-Thought (CoT)</th>
<th>ReAct (推理行动)</th>
</tr>
</thead>
<tbody>
<tr>
<td>核心功能</td>
<td>静态推理（只思考）</td>
<td>推理 + 行动 + 反馈循环</td>
</tr>
<tr>
<td>是否交互</td>
<td>否（纯语言生成）</td>
<td>是（能调用外部工具/环境）</td>
</tr>
<tr>
<td>信息来源</td>
<td>依赖模型训练时的内部知识</td>
<td>内部知识 + 外部输入 + 工具反馈数据（调用工具获取）</td>
</tr>
<tr>
<td>可解释性</td>
<td>高（显式推理链）</td>
<td>更高（推理+行动全可追溯）</td>
</tr>
<tr>
<td>典型应用</td>
<td>逻辑推理、数学题</td>
<td>工具使用、问答、信息检索、任务规划</td>
</tr>
</tbody>
</table>
<p>可以这样理解：</p>
<blockquote>
<p><strong>CoT 让模型“会思考”；
ReAct 让模型“边思考边行动”。</strong></p>
</blockquote>
<p>ReAct 实际上是将 CoT 的“推理链”扩展为一个“推理-行动交替链（Reason–Act Loop）”，使模型能够通过外部信息验证和修正自身推理过程。</p>
<h2> 5. 典型应用场景</h2>
<p>ReAct 框架已成为众多 <strong>LLM Agent 框架的基础逻辑</strong>，例如：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>知识检索 Agent</strong></td>
<td>模型根据推理决定是否调用搜索 API，检索结果再反馈给模型</td>
</tr>
<tr>
<td><strong>任务执行 Agent</strong></td>
<td>模型通过多轮思考与动作完成复杂流程（如预定行程、分析数据）</td>
</tr>
<tr>
<td><strong>工具调用（Tool Use）</strong></td>
<td>ReAct 框架下的模型能自主判断何时调用计算器、数据库或Python执行环境</td>
</tr>
<tr>
<td><strong>多Agent协作</strong></td>
<td>多个 Agent 间通过 ReAct 循环共享中间推理结果，实现协同任务（如 AutoGen、LangGraph）</td>
</tr>
</tbody>
</table>
<p>ReAct 机制也被广泛集成在框架中：</p>
<ul>
<li><strong>LangChain / LangGraph</strong>：ReAct 是默认的 reasoning template；</li>
<li><strong>OpenAI GPTs / o1 系列</strong>：其系统提示内嵌了类似 ReAct 的隐式结构；</li>
<li><strong>DeepSeek-R1 / Claude 3.5</strong>：均具备“内隐 ReAct”式动态推理循环。</li>
</ul>
<h2> 6. ReAct 的优势</h2>
<table>
<thead>
<tr>
<th>优势</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>融合思考与行动</strong></td>
<td>不再需要人工编排先“思考”还是“执行”，模型可自动判断何时行动。</td>
</tr>
<tr>
<td><strong>支持闭环反馈</strong></td>
<td>环境结果反哺推理过程，形成自我纠错机制。 避免出现纯推理(如CoT)容易出现的“想当然”的错误</td>
</tr>
<tr>
<td><strong>可解释性强</strong></td>
<td>每一步 Reason 与 Action 都是可追踪文本，利于调试与评估。</td>
</tr>
<tr>
<td><strong>易扩展</strong></td>
<td>可嵌入任意工具调用接口（API、DB、Web 搜索等）。</td>
</tr>
<tr>
<td><strong>增强记忆与规划能力</strong></td>
<td>多轮 Reasoning 让模型能规划长序列任务，而非一次性输出。</td>
</tr>
<tr>
<td><strong>通用性强</strong></td>
<td>ReAct 不依赖特定任务或工具，只要能拆解步骤、调用工具，就能适用：比如从 “查天气” 到 “采购建筑材料”，从 “旅游规划” 到 “科研数据分析”，只需替换工具和目标，框架本身无需修改，开发效率高</td>
</tr>
</tbody>
</table>
<h2> 7. ReAct 的局限与改进方向</h2>
<table>
<thead>
<tr>
<th>局限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>推理质量依赖模型本身的 CoT 能力</strong></td>
<td>若模型的逻辑推理弱，ReAct 仍可能走错路线。</td>
</tr>
<tr>
<td><strong>长上下文管理复杂</strong></td>
<td>多轮循环可能导致上下文爆炸，需要 Memory 模块支持。</td>
</tr>
<tr>
<td><strong>计算成本高</strong></td>
<td>每轮 Reason + Act + Observe 都是一条完整的 API 调用。</td>
</tr>
<tr>
<td><strong>缺乏全局规划能力</strong></td>
<td>ReAct 是“逐步决策”，缺乏全局最优策略搜索。</td>
</tr>
</tbody>
</table>
<p>因此，后续研究提出了更高阶的扩展框架，如：</p>
<ul>
<li><strong>Tree-of-Thought (ToT)</strong>：将推理链分支化、多路径搜索；</li>
<li><strong>Reflexion / Self-Refine</strong>：在 ReAct 基础上加入“自我反思”机制；</li>
<li><strong>Graph-of-Thought (GoT)</strong>：通过图结构管理复杂的推理关系。</li>
</ul>
<p>这些框架都继承自 ReAct 的核心思想：<strong>Reason + Act 的循环推理范式</strong>。</p>
<h2> 8. ReAct在Agent中的具体应用示例</h2>
<p><code>ReAct</code> 是 <code>Agent</code> “编排层” 的核心逻辑，要在 <code>Agent</code> 中落地 <code>ReAct</code>，可以按照 “组件搭建→流程设计→优化迭代” 的三板斧进行套路</p>
<h3> 8.1 第一步：搭建Agent的ReAct核心组件</h3>
<p>前面说了ReAct的三个关键组件： Reason(思考)、Act(行动)、Observe(观察)，在具体的Agent实现中，我们还需要额外考虑上下文的管理(Memory)</p>
<p>因此一个Agent要实现ReAct，则应包含下面四个核心模块</p>
<blockquote>
<p>比如我现在给Agent下达一个任务，<code>帮用户采购 100 吨 HRB400E 钢筋，要求 3 天内送达北京朝阳区工地，预算 50 万元</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>组件</th>
<th>功能描述</th>
<th>技术实现参照</th>
</tr>
</thead>
<tbody>
<tr>
<td>思考模块（Reasoner）</td>
<td>接收目标+状态→ 拆解步骤→ 决定下一步行动（比如“调用哪个工具”“参数是什么”）</td>
<td>基于大模型实现（如GPT-4、Gemini、DeepSeek），通过提示工程引导模型生成“行动指令”（比如“调用库存工具，参数：材料型号=HRB400E，数量=100吨”）</td>
</tr>
<tr>
<td>行动执行器（Actor）</td>
<td>解析思考模块的“行动指令”→ 调用对应的工具（API、数据库、RPA等）</td>
<td>搭建工具注册中心（统一管理工具名称、输入输出格式），用函数调用（Function Call）实现模型与工具的对接（比如模型输出JSON格式的行动指令，执行器解析后调用API）</td>
</tr>
<tr>
<td>观察模块（Observer）</td>
<td>获取工具返回结果→ 整理成模型能理解的格式（比如把API返回的JSON转成自然语言）</td>
<td>设计结果标准化模板（比如工具返回“{"supplier":"A","price":3700}"→ 整理为“供应商A的HRB400E钢筋报价3700元/吨”）</td>
</tr>
<tr>
<td>状态记忆模块（Memory）</td>
<td>存储“目标+每一轮的思考/行动/观察结果”→ 为下一轮思考提供上下文</td>
<td>用向量数据库（如Milvus、FAISS）存储长上下文，支持“关键词检索”（比如快速查找“供应商A的履约率”）</td>
</tr>
</tbody>
</table>
<h3> 8.2 第二步：设计 ReAct 闭环执行流程</h3>
<p>依然以上面的建筑材料采购Agent为例</p>
<h4> （1）初始化：明确目标与工具</h4>
<ul>
<li>目标：用户输入“采购100吨HRB400E钢筋，3天内送达北京朝阳工地，预算50万”；</li>
<li>注册工具：库存查询工具、供应商履约率工具、报价对比工具、订单生成工具。</li>
</ul>
<h4> （2）循环执行（直到任务完成/终止）</h4>
<figure><img src="/imgs/column/springai/ag3-02.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>
<p>每一轮的“思考指令”格式示例（模型输出）：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>观察模块整理结果示例：
“库存查询工具返回3家供应商：1. 供应商A（库存150吨，报价3700元/吨，3天达）；2. 供应商B（库存200吨，报价3800元/吨，2天达）；3. 供应商C（库存120吨，报价3600元/吨，4天达，超期）”</p>
</li>
</ul>
<h4> （3）终止条件设计</h4>
<ul>
<li>成功终止：完成目标（如“采购订单提交成功，供应商A将在3天内送达100吨HRB400E钢筋，总价37万元”）；</li>
<li>失败终止：多次迭代后无法满足目标（如“无符合‘3天达+100吨库存’的供应商，建议延长交货期至4天或更换材料型号”）。</li>
</ul>
<h3> 8.3 第三步：优化 ReAct 执行效率</h3>
<p>实际应用中，需解决“循环次数过多、工具调用错误、推理冗余”等问题，常用优化技巧：</p>
<ul>
<li>① 工具选择策略：思考模块优先选择“高优先级工具”（比如先查库存，再查履约率，避免跳过关键步骤）；</li>
<li>② 状态压缩：记忆模块只保留“关键信息”（比如只记“符合条件的供应商A/B”，忽略C的详细信息），减少大模型上下文压力；</li>
<li>③ 错误重试机制：行动失败（如工具调用超时、返回错误）时，思考模块自动调整参数（比如“重新调用库存工具，增加‘北京周边供应商’筛选条件”）；</li>
<li>④ 少样本示例引导：在思考模块的提示中，加入“问题+ReAct循环示例”，让模型更快掌握推理+行动的节奏（比如给一个“采购水泥”的ReAct示例，让模型模仿）。</li>
</ul>
<h2> 9. 总结：一句话概括 ReAct</h2>
<p><strong>ReAct 是连接“语言模型的思考能力（CoT）”与“Agent 的执行能力”的桥梁。</strong></p>
<p>它让大模型不仅能在语言空间中推理，还能在外部世界中行动；最后再以一张图，来重温一下ReAct</p>
<figure><img src="/imgs/column/springai/ag3-03.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/ag3-01.webp" type="image/webp"/>
    </item>
    <item>
      <title>04.Agent思考框架-Plan-and-Execute</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/04.Agent%E6%80%9D%E8%80%83%E6%A1%86%E6%9E%B6-Plan-and-Execute.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/04.Agent%E6%80%9D%E8%80%83%E6%A1%86%E6%9E%B6-Plan-and-Execute.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">04.Agent思考框架-Plan-and-Execute</source>
      <description>Plan-and-Execute 框架：面向复杂任务的层次化推理与行动架构 1. 引言 随着语言模型推理能力与外部工具使用能力的增强，如何高效地解决长程、多步骤、复杂任务成为 AI Agent 的关键挑战。 传统的 Chain-of-Thought (CoT) 与 ReAct 框架虽能支持推理与行动的结合，但它们通常以逐步生成的方式执行任务，容易陷入“短视（myopic）”问题——即模型缺乏全局规划能力，只能在局部推理层面决策。</description>
      <category>Agent</category>
      <pubDate>Fri, 07 Nov 2025 09:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Plan-and-Execute 框架：面向复杂任务的层次化推理与行动架构</p>
</blockquote>
<h2> 1. 引言</h2>
<p>随着语言模型推理能力与外部工具使用能力的增强，如何高效地解决<strong>长程、多步骤、复杂任务</strong>成为 AI Agent 的关键挑战。</p>
<p>传统的 <strong>Chain-of-Thought (CoT)</strong> 与 <strong>ReAct</strong> 框架虽能支持推理与行动的结合，但它们通常以<strong>逐步生成的方式</strong>执行任务，容易陷入“短视（myopic）”问题——即模型缺乏全局规划能力，只能在局部推理层面决策。</p>
<p>基于此，就有了 <strong>Plan-and-Execute（计划–执行）框架</strong>，其核心逻辑是 <strong>“先全局规划，再分步执行，全程监控调整”</strong> —— 模仿人类处理复杂任务的模式（比如项目经理做项目计划、旅行博主规划跨城行程），先拆解出完整的任务步骤，再逐一执行，同时根据执行结果动态优化计划，避免 “边想边做” 导致的返工或偏离目标。</p>
<h2> 2. 核心思想</h2>
<p>Plan-and-Execute 的基本理念是：</p>
<blockquote>
<p><strong>让语言模型先“想清楚要做什么”，再“逐步去做”。</strong></p>
</blockquote>
<h3> 2.1 定义</h3>
<p>Plan-and-Execute（简称 “P&amp;E”）是一种 “目标驱动 + 规划先行” 的 Agent 认知架构，核心是将复杂任务拆解为 “可执行的子步骤（计划）”，再逐个执行子步骤，同时监控执行结果，若出现偏差则修正计划，直至完成整体目标。</p>
<h3> 2.2 子系统</h3>
<p>在该框架中，模型被划分为两个协作子系统：</p>
<ol>
<li><strong>Planner（规划器）</strong> —— 负责全局任务分解与阶段性目标设定；</li>
<li><strong>Executor（执行器）</strong> —— 负责逐步执行具体步骤，并根据反馈调整局部行为。</li>
</ol>
<p>相比 ReAct 的“边想边做”模式，Plan-and-Execute 更接近人类在处理复杂任务时的思维方式：</p>
<h3> 2.3 示例说明</h3>
<p>还是以上一篇ReAct中的示例进行扩展说明：<code>完成 “建筑项目跨区域材料调度”（目标：把北京项目的剩余 100 吨钢材，5 天内运到天津项目，预算 10 万元）</code></p>
<p>对于P&amp;E框架，其执行步骤如下：</p>
<ol>
<li>先规划（Plan）：拆分子步骤→
<ul>
<li>① 确认北京项目钢材库存及规格；</li>
<li>② 联系合规物流商报价；</li>
<li>③ 对比物流方案（成本、时效）；</li>
<li>④ 办理材料运输备案；</li>
<li>⑤ 安排装车运输；</li>
<li>⑥ 天津项目验收；</li>
</ul>
</li>
<li>再执行（Execute）：按步骤逐一落地，比如先调用 “库存工具” 确认钢材，再调用 “物流商工具” 报价；</li>
<li>动态调整：若执行中发现 “某物流商报价超预算”，则回到规划环节，补充 “筛选低价物流商” 子步骤，修正后继续执行。</li>
</ol>
<h2> 3. 框架结构</h2>
<h3> 3.1 流程概览</h3>
<p>Plan-and-Execute 框架的核心流程如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实践中，这两阶段通常由同一个语言模型（或多个模型）协作完成：</p>
<ul>
<li><strong>Planner</strong>：生成多步任务计划，明确每个子任务的目标；</li>
<li><strong>Executor</strong>：逐步执行每个子任务，可调用工具或环境；</li>
<li><strong>Evaluator（可选）</strong>：在执行后评估结果质量，并决定是否重新规划。</li>
</ul>
<h3> 3.2 示例</h3>
<p>假设目标：“为某地铁项目采购3类材料（1000吨HRB400E钢筋、500立方米C30混凝土、200套消防设备），要求20天内全部送达工地，预算800万元，需符合地铁工程质量标准”</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>具体操作（Agent 执行）</th>
</tr>
</thead>
<tbody>
<tr>
<td>① 目标解析（Target Parsing）</td>
<td>拆解目标关键约束：材料类型（3类）、数量、时效（20天）、预算（800万）、质量标准（地铁级）→ 明确“不可妥协条件”（质量、时效）和“可调整条件”（预算浮动5%）</td>
</tr>
<tr>
<td>② 全局规划（Plan Generation）</td>
<td>生成详细子步骤（按逻辑顺序）：<br>1. 校验3类材料的地铁级质量标准参数；<br>2. 筛选符合质量标准的供应商（每类材料≥3家）；<br>3. 向供应商询价，对比报价是否在预算内；<br>4. 确认供应商交货周期（≤20天）；<br>5. 选择最优供应商（质量+价格+时效平衡）；<br>6. 签订采购合同；<br>7. 安排分批次物流运输；<br>8. 工地验收材料（核对质量+数量）</td>
</tr>
<tr>
<td>③ 分步执行（Plan Execution）</td>
<td>按子步骤调用工具执行：<br>- 步骤1：调用“建筑质量标准工具”，获取地铁级材料参数；<br>- 步骤2：调用“供应商筛选工具”，输入参数筛选供应商；<br>- 步骤3：调用“报价工具”，向6家供应商询价；<br>（每执行完一个子步骤，记录结果）</td>
</tr>
<tr>
<td>④ 监控反馈（Monitoring &amp; Feedback）</td>
<td>检查执行结果是否符合计划要求：<br>- 发现“混凝土供应商报价超预算10%”（偏离预算约束）；<br>- 发现“消防设备供应商交货周期25天”（偏离时效约束）；<br>- 整理偏差：2个子步骤未达标，需修正</td>
</tr>
<tr>
<td>⑤ 计划修正（Plan Revision）</td>
<td>基于偏差调整计划：<br>1. 新增“混凝土供应商二次筛选”（要求报价≤预算上限）；<br>2. 新增“消防设备供应商谈判”（要求交货周期≤20天，否则更换）；<br>3. 调整步骤顺序：先谈判消防设备，再二次筛选混凝土供应商；<br>→ 修正后回到“分步执行”环节，继续推进</td>
</tr>
</tbody>
</table>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种结构清晰地展示了规划与执行的分工：Planner 负责构思路线，Executor 负责落实行动。</p>
<h3> 3.3 P&amp;E关键要素</h3>
<p>要让 P&amp;E 框架跑通，Agent 必须具备4个核心能力，对应4个关键组件：</p>
<ul>
<li>① 目标解析能力：能从模糊需求中提取“关键约束”（如质量、时效、预算）和“可调整空间”，避免规划方向跑偏（比如用户没说质量标准，Agent 需自动补充“符合项目所属行业标准”）；</li>
<li>② 规划生成能力：能拆解“颗粒度合适”的子步骤（既不能太粗，比如只拆“选供应商→采购→验收”，也不能太细，比如拆“打开供应商工具→输入参数→点击查询”），且子步骤符合逻辑顺序（如“验收”必须在“运输”之后）；</li>
<li>③ 执行调度能力：能按计划顺序调用工具，处理“并行步骤”（如钢筋和消防设备的询价可同时进行）和“依赖步骤”（如“签订合同”必须在“询价对比”之后）；</li>
<li>④ 监控修正能力：能识别“执行偏差”（如超预算、超时效），并判断是“调整子步骤”（如二次筛选供应商）还是“重新规划”（如预算严重不足，需和用户协商调整目标）。</li>
</ul>
<h2> 4. 与 ReAct 的对比</h2>
<p>P&amp;E 和 ReAct 都属于 Agent 推理框架，但适用场景完全不同，对比清晰：</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>ReAct(推理-行动)</th>
<th>Plan-and-Execute(规划-执行)</th>
</tr>
</thead>
<tbody>
<tr>
<td>推理方式</td>
<td>推理与行动交替进行</td>
<td>规划与执行分阶段进行</td>
</tr>
<tr>
<td>计划优先级</td>
<td>执行是核心，规划服务于单次执行</td>
<td>规划是核心，执行围绕规划展开</td>
</tr>
<tr>
<td>决策粒度</td>
<td>细粒度、即时决策</td>
<td>粗粒度、全局规划</td>
</tr>
<tr>
<td>步骤关联性</td>
<td>子步骤弱关联（比如查价格后可直接反馈，无需后续步骤）</td>
<td>子步骤强关联（比如 “备案” 必须在 “选物流商” 之后）</td>
</tr>
<tr>
<td>优势</td>
<td>灵活、动态响应环境</td>
<td>结构化、全局性强</td>
</tr>
<tr>
<td>局限</td>
<td>容易迷失方向、循环冗长</td>
<td>计划可能过于刚性，缺乏即时反应</td>
</tr>
<tr>
<td>适用任务</td>
<td>开放式问答、信息检索等简单、短流程、不确定性高的任务（查库存、查价格、物流跟踪）</td>
<td>长程任务、复杂流程、多阶段决策（跨项目调度、大型采购、项目管理）</td>
</tr>
</tbody>
</table>
<p>从本质上看，<strong>ReAct 偏向“思考中的即时行动”，而 Plan-and-Execute 偏向“先计划再执行的理性决策”</strong>。</p>
<p>两者可视为 AI Agent 推理架构的两种互补策略。</p>
<h2> 5. 优势分析</h2>
<p>Plan-and-Execute 的主要优势体现在以下几个方面：</p>
<table>
<thead>
<tr>
<th>优势</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>全局可控性强</strong></td>
<td>通过显式规划步骤，模型行为更可预测、更易解释。</td>
</tr>
<tr>
<td><strong>层次化推理能力</strong></td>
<td>模型能在不同抽象层次上思考任务，从全局到局部逐层细化。</td>
</tr>
<tr>
<td><strong>可复用性高</strong></td>
<td>已生成的计划可复用或共享，便于多Agent协作或任务迁移。</td>
</tr>
<tr>
<td><strong>易于监控与调试</strong></td>
<td>Planner 与 Executor 的独立性使得错误定位更清晰。</td>
</tr>
</tbody>
</table>
<h2> 6. 局限与改进方向</h2>
<p>尽管 Plan-and-Execute 提升了任务结构化程度，但也存在一些局限性：</p>
<table>
<thead>
<tr>
<th>局限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>计划僵化</strong></td>
<td>若初始计划不合理，后续执行可能陷入错误路径。</td>
</tr>
<tr>
<td><strong>缺乏动态适应能力</strong></td>
<td>对突发情况或环境变化响应较慢。</td>
</tr>
<tr>
<td><strong>计算成本高</strong></td>
<td>需要额外生成和维护计划文本。</td>
</tr>
<tr>
<td><strong>依赖任务分解质量</strong></td>
<td>Planner 的规划能力直接决定整体表现。</td>
</tr>
</tbody>
</table>
<p>为缓解这些问题，研究者提出了一系列改进版本，例如：</p>
<ul>
<li><strong>Reflexion + Plan-and-Execute</strong>：在执行后引入反思机制；</li>
<li><strong>Hierarchical Agent（分层智能体）</strong>：多层 Planner–Executor 架构；</li>
<li><strong>Adaptive Planning</strong>：执行阶段可根据观察结果动态更新计划。</li>
</ul>
<p>这些方法进一步增强了系统的鲁棒性与灵活性。</p>
<h2> 7. 应用与实践</h2>
<p>按“组件搭建→流程设计→优化迭代”三步走，每个步骤都要结合业务场景细化</p>
<h3> 7.1 第一步：搭建 Agent 的 P&amp;E 核心组件</h3>
<p>Agent 要支持 P&amp;E，必须包含5个核心模块（对应 P&amp;E 闭环流程）：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>功能描述</th>
<th>技术实现建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>目标解析模块（Target Parser）</td>
<td>提取用户需求中的“核心目标+约束条件+可调整空间”，生成标准化目标（如“采购1000吨钢筋，约束：地铁级质量、20天达、预算≤400万”）</td>
<td>基于大模型（如GPT-4、Gemini），通过提示工程引导模型识别约束（比如“从需求中提取材料类型、数量、时效、预算、质量标准”），结合行业数据库补充默认约束（如无质量标准则默认“项目所属行业国标”）</td>
</tr>
<tr>
<td>规划器（Planner）</td>
<td>基于标准化目标，生成“逻辑连贯、颗粒度合适”的子步骤计划，支持“并行/依赖步骤”标记（如“钢筋询价”和“消防设备询价”可并行，“签合同”依赖“询价对比”）</td>
<td>用大模型+少样本示例（比如给“3个采购计划示例”），引导模型生成结构化计划（如JSON格式的子步骤清单，包含“步骤ID、名称、依赖步骤、执行工具、预期结果”）</td>
</tr>
<tr>
<td>执行器（Executor）</td>
<td>按计划顺序调用工具执行子步骤，支持“并行步骤同步执行”“依赖步骤串行执行”，记录每个步骤的实际结果</td>
<td>搭建工具调度中心，管理工具调用优先级（如“验收步骤”优先级高于“询价步骤”），用函数调用（Function Call）对接工具，返回结构化执行结果（如“询价结果：供应商A报价3800元/吨，交货期15天”）</td>
</tr>
<tr>
<td>监控器（Monitor）</td>
<td>对比“执行结果”与“计划预期结果”，识别偏差（如“报价3800元/吨＞预算上限3700元/吨”“交货期15天≤预期20天”），标记偏差类型（预算偏差、时效偏差、质量偏差）</td>
<td>设定偏差阈值（如预算偏差≥5%触发警报），用规则引擎+大模型判断偏差影响（如“预算超10%需重新规划，超3%可谈判”）</td>
</tr>
<tr>
<td>修正器（Reviser）</td>
<td>基于偏差类型，调整计划：① 轻微偏差（如报价超3%）→ 新增子步骤（如“与供应商谈判降价”）；② 严重偏差（如无符合时效的供应商）→ 重新生成全局计划；③ 无法修正（如预算严重不足）→ 反馈用户</td>
<td>用大模型+行业规则，生成修正方案（如“新增谈判步骤，目标降价至3700元/吨以下，若谈判失败则二次筛选供应商”），修正后更新计划清单</td>
</tr>
</tbody>
</table>
<h3> 7.2 第二步：设计 P&amp;E 闭环执行流程（以“跨项目材料调度Agent”为例）</h3>
<h4> （1）初始化：明确目标与资源</h4>
<ul>
<li>目标：用户输入“将北京项目剩余的80吨钢筋、50吨水泥，20天内调度至天津滨海新区项目，总成本≤15万元，钢筋需符合HRB400E标准，水泥需符合P.O42.5标准”；</li>
<li>注册工具：库存盘点工具、供应商资质校验工具、物流报价工具、合规备案工具、运输跟踪工具、验收工具。</li>
</ul>
<h4> （2）闭环执行流程（可视化）</h4>
<figure><img src="/imgs/column/springai/ag4-01.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>
<p>规划器生成的“子步骤计划”示例（JSON格式）：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>监控器识别偏差示例：
“步骤3执行结果：2家物流商报价，分别为15.8万元、16.5万元，均超预算（15万元），偏差类型：预算偏差，偏差率：5.3%（轻微偏差）”</p>
</li>
<li>
<p>修正器调整计划示例：
“新增步骤4：与报价15.8万元的物流商谈判，目标降价至15万元以下；若谈判失败，新增步骤5：筛选天津本地小型物流商补充报价”</p>
</li>
</ul>
<h4> （3）终止条件设计</h4>
<ul>
<li>成功终止：所有子步骤执行完成，满足核心目标（如“材料已送达天津项目，验收合格，总成本14.8万元，耗时18天”）；</li>
<li>失败终止：多次修正后仍无法满足核心约束（如“所有物流商报价均超18万元，无法压缩至15万元内，且无替代物流方案”），反馈用户并提供备选建议（如“延长运输时间至30天，可降低成本至14.5万元”）。</li>
</ul>
<h3> 7.3 第三步：优化 P&amp;E 执行效率</h3>
<p>P&amp;E 框架的落地难点是<code>规划太复杂、执行效率低、修正频繁</code>，需通过以下技巧优化：</p>
<ul>
<li>① 分层规划（Hierarchical Planning）：把复杂计划拆分为 *<em>主计划+子计划</em>
<ul>
<li>比如“跨项目调度主计划”包含“库存盘点、物流规划、验收”3个主步骤</li>
<li>每个主步骤再拆子计划（如“物流规划”拆“询价、谈判、签约”），避免计划过于冗长；</li>
</ul>
</li>
<li>② 计划压缩（Plan Compression）：只保留<strong>关键步骤</strong>和<strong>约束条件</strong>，忽略细节（如无需在计划中写<code>打开物流工具→输入参数</code>，只需写<code>调用物流工具询价</code>），减少大模型上下文压力；</li>
<li>③ 动态资源分配：执行器支持<strong>并行步骤同步执行</strong>（如同时盘点钢筋和水泥库存），缩短整体周期；对<strong>关键步骤</strong>（如合规备案）分配更多资源（如优先调用工具、超时重试3次）；</li>
<li>④ 少样本规划引导：在规划器的提示中，加入<strong>行业相关的规划示例</strong>（如“建筑材料调度的标准步骤清单”），让模型生成的计划更贴合业务实际，减少修正次数；</li>
<li>⑤ 偏差阈值动态调整：根据任务阶段调整偏差阈值（如前期询价阶段，预算偏差阈值设为10%；后期签约阶段，阈值设为3%），避免过度修正影响效率。</li>
</ul>
<h2> 8. 总结</h2>
<p><strong>Plan-and-Execute 框架</strong> 是一种面向复杂任务的层次化推理与行动机制。</p>
<p>它通过“先规划、再执行”的解耦结构，使模型能够在全局视角下进行任务分解与多阶段执行，从而在可解释性、稳定性和任务规划性上优于 ReAct 等即时推理框架。</p>
<blockquote>
<p><strong>一句话总结：</strong>
<strong>Plan-and-Execute 是让 AI Agent 从“即兴思考者”进化为“有计划的行动者”的关键框架。</strong></p>
</blockquote>
<p>最后再以一张图，来重温一下P&amp;E</p>
<figure><img src="/imgs/column/springai/ag3-03.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/ag4-01.webp" type="image/webp"/>
    </item>
    <item>
      <title>Agent篇</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/Agent%E7%AF%87/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Agent篇</source>
      <description>主要介绍AI Agent相关的知识点，包括相关技术栈，应用开发等</description>
      <pubDate>Fri, 07 Nov 2025 06:15:53 GMT</pubDate>
      <content:encoded><![CDATA[<p>主要介绍AI Agent相关的知识点，包括相关技术栈，应用开发等</p>
]]></content:encoded>
    </item>
    <item>
      <title>14.创建一个Langgraph4j实例工程</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/14.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AALanggraph4j%E5%AE%9E%E4%BE%8B%E5%B7%A5%E7%A8%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/14.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AALanggraph4j%E5%AE%9E%E4%BE%8B%E5%B7%A5%E7%A8%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">14.创建一个Langgraph4j实例工程</source>
      <description>14.创建一个Langgraph4j实例工程 沿用阿里的智能体定义，我们将基于SpringAI ChatClient开发的AI应用叫做单智能体应用；对于更复杂的应用场景，比如需要多个工具辅助工作，存在工作流切换的场景（举一个例子：输入一段评价，判断是好评还是差评，如果是好评，则自动回复多谢好评；如果是差评，则提取关键信息，将评价信息转发给人工客服，进行后续的售后维护等）称为多智能体应用 对于多智能体应用，使用python开发的小伙伴，更常接触的是LangGraph；对于java的生态下，目前也有两个替代的选择项</description>
      <category>SpringAI</category>
      <pubDate>Tue, 12 Aug 2025 17:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 14.创建一个Langgraph4j实例工程</h1>
<p>沿用阿里的智能体定义，我们将基于<code>SpringAI ChatClient</code>开发的AI应用叫做单智能体应用；对于更复杂的应用场景，比如需要多个工具辅助工作，存在工作流切换的场景（举一个例子：输入一段评价，判断是好评还是差评，如果是好评，则自动回复多谢好评；如果是差评，则提取关键信息，将评价信息转发给人工客服，进行后续的售后维护等）称为多智能体应用</p>
<p>对于多智能体应用，使用python开发的小伙伴，更常接触的是<code>LangGraph</code>；对于java的生态下，目前也有两个替代的选择项</p>
<ul>
<li><a href="https://github.com/langgraph4j/langgraph4j" target="_blank" rel="noopener noreferrer">LangGraphJ</a></li>
<li><a href="https://java2ai.com/docs/1.0.0.2/get-started/agent/" target="_blank" rel="noopener noreferrer">阿里智能体</a></li>
</ul>
<p>接下来我们来体验一下如何使用<code>LangGraph4J</code>来进行多智能体的开发</p>
<h2> 一、项目创建</h2>
<h3> 1. 创建一个SpringAI项目</h3>
<p>创建一个SpringAI项目，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 2. 添加Langgraph4j依赖</h3>
<p>我们这里以智普大模型作为底层的LLM，因此对应的依赖除了langgraph4j之外就是智普的starter</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 参数配置</h3>
<p>在配置文件中 <code>application.yml</code>，设置大模型的访问密钥</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 创建工具</h3>
<p>我们这里创建一个工具类，内部提供两个工具，分别获取当前的时间和天气</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 创建智能体</h3>
<p>我们直接沿用官方的demo示例，来创建一个采用<code>langGraph4j</code>实现的基于智普大模型的智能体</p>
<figure><img src="/imgs/column/springai/14-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 测试验证</h3>
<p>在上面的Controller中，定义一个访问端点，实现智能体的访问</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/14-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的输出也可以看出，大模型有四次的工具调用，一次是获取北京当前时间，一次是获取北京当前天气，一次是获取伦敦当前时间，一次是获取伦敦当前天气</p>
<p>直接使用<code>langGraph4j</code>实现多轮对话，虽然效果是实现了，从直观感觉上和SpringAI的ChatClient好像没有太大的差别</p>
<p>对<code>langGraph4j</code>不太了解的小伙伴，可能会有很多疑问，工作流体现在什么地方呢，条件决策又该如何使用呢？这个框架是怎么工作的呢？又该如何使用它来开发Agent呢？</p>
<h2> 二、总结</h2>
<p><code>LangGraph4j</code> 是一个 Java 库，用于构建基于大型语言模型 (LLM) 的有状态多代理应用程序。它受 <code>Python</code> 库 <code>LangGraph</code> 的启发，旨在与 <code>Langchain4j</code> 和 <code>Spring AI</code> 等流行的 <code>Java LLM</code> 框架无缝协作。</p>
<p>LangGraph4j 的核心功能是定义循环图，使不同的组件（代理、工具或自定义逻辑）能够以有状态的方式进行交互</p>
<p>本文只能算是初步看了一眼<code>LangGraph4j</code>，演示了如何创建一个智能体开发的项目，接下来我们将逐渐深入探究一下这个框架的使用理念</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects/A05-agent-langgraph-simple" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/14-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>01.从0到1创建一个基于天气的旅游美食推荐智能体</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%BA%94%E7%94%A8%E7%AF%87/D01.%E4%BB%8E0%E5%88%B01%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E5%A4%A9%E6%B0%94%E7%9A%84%E6%97%85%E6%B8%B8%E7%BE%8E%E9%A3%9F%E6%8E%A8%E8%8D%90%E6%99%BA%E8%83%BD%E4%BD%93.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%BA%94%E7%94%A8%E7%AF%87/D01.%E4%BB%8E0%E5%88%B01%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E5%A4%A9%E6%B0%94%E7%9A%84%E6%97%85%E6%B8%B8%E7%BE%8E%E9%A3%9F%E6%8E%A8%E8%8D%90%E6%99%BA%E8%83%BD%E4%BD%93.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.从0到1创建一个基于天气的旅游美食推荐智能体</source>
      <description>01.从0到1创建一个基于天气的旅游美食推荐智能体 本文将演示如何借助LangGraph4j + SpringAI来开发一个完整的智能体应用，实现用户传入地址、大模型通过Function Calling来获取地址天气，调用大模型的旅游项目推荐能力、美食推荐能力，给用返回一个旅游攻略 一、项目创建 1. 工程创建 首先我们需要创建一个 LangGraph4j + SpringAI的项目，对这块不熟悉的小伙伴，请参考 创建一个Langgraph4j示例工程</description>
      <category>SpringAI</category>
      <pubDate>Wed, 13 Aug 2025 10:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 01.从0到1创建一个基于天气的旅游美食推荐智能体</h1>
<p>本文将演示如何借助LangGraph4j + SpringAI来开发一个完整的智能体应用，实现用户传入地址、大模型通过Function Calling来获取地址天气，调用大模型的旅游项目推荐能力、美食推荐能力，给用返回一个旅游攻略</p>
<h2> 一、项目创建</h2>
<h3> 1. 工程创建</h3>
<p>首先我们需要创建一个 LangGraph4j + SpringAI的项目，对这块不熟悉的小伙伴，请参考 <a href="../%E5%9F%BA%E7%A1%80%E7%AF%87/14.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AALanggraph4j%E5%AE%9E%E4%BE%8B%E5%B7%A5%E7%A8%8B">创建一个Langgraph4j示例工程</a></p>
<h3> 2. 核心依赖</h3>
<p>本工程主要使用框架为 <code>SpringAI1.0.1</code> + <code>LangGraph4j1.6.0-rc4</code> + <code>SpringBoot3.5.4</code></p>
<p>对应的大模型为： <code>zhipu</code>，通过SpringMVC提供访问接口</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 配置文件</h3>
<p>我们在配置文件<code>application.yml</code>中配置大模型密钥，使用其他大模型的小伙伴，请自行替换</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：大模型的选择时，需要判断是否支持FunctionCalling，如果不支持，则会影响本项目的实际运行效果</p>
<p>我们的密钥以启动参数的方式传递，方便测试（当然也可以直接写入配置文件、或者系统环境变量，大家按照自己的喜好即可）</p>
<h2> 二、智能体开发</h2>
<h3> 1. 核心功能描述</h3>
<p>智能体的主要功能为：</p>
<ol>
<li>用户传入地址</li>
<li>设计一个WeatherAgent，用于获取给定地方的实时天气情况</li>
<li>若不需要进行旅游推荐，则直接返回</li>
<li>若需要进行旅游推荐
<ul>
<li>调用 TravelAgent，获取给定地址的附近旅游项目推荐</li>
<li>根据选定的旅游项目，调用 FoodAgent，获取给定地址的附近美食推荐</li>
</ul>
</li>
<li>将上面的结果进行整合，以博文的方式返回给用户</li>
</ol>
<figure><img src="/imgs/column/springai/D01-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 实现通用的AgentService</h3>
<p>上面的几个Agent都需要与大模型进行交互，因此我们这里可以抽象出一个通用的AgentService，用于处理Agent与大模型的交互</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为大模型本身是无法获取天气信息的，因此我们这里使用FunctionCalling的方式，给大家装配上天气查询的能力（当然这里也可以直接使用天气相关的McpServer）</p>
<p>我们这里简单的实现一个 WeatherTools 来模拟天气的查询（真实场景中，可以实现第三方天气服务查询API）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 定义TravelState存储上下文</h3>
<p>我们这里定义一个 <code>TravelState</code> 继承自 <code>AgentState</code> 来实现多智能体之间的数据共享，由于我们这里存在4个智能体，我们为每个智能体的返回都定义一个对应的参数进行承接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面定义了五个常量，其中 <code>INPUT</code> 为最开始的输入参数， <code>WEATHER</code> 为 WeatherAgent执行后的返回的天气信息， <code>TRAVEL</code> 为 TravelRecommendAgent 执行后返回推荐游玩项目， <code>FOOD</code> 为 FoodRecommendAgent 执行后返回推荐美食， <code>BLOG</code> 为 XhsBlogGenerateAgent 执行后汇总生成的小红书风格的博文内容</p>
<p>不同的Agent返回的数据内容并不相同，可以是基本类型、字符串，也可以是集合、Java POJO对象，由于<code>LangGraphJ</code>自己实现了一套序列化协议，因此我们这里先提供一个JsonSerializer，用于非简单的对象的序列化处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 实现天气智能体 WeatherAgent</h3>
<p>接下来我们实现第一个智能体，用于获取给定地方的天气</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的整体实现比较简单，核心的在于方法 <code>callWeatherAgent</code>，我们会将它包装为<code>LangGraph4J</code>的Node，这个方法你可以理解为 <code>NodeAction</code> 的实现，对应的使用层Node的注册如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的，我们可以在 <code>TravelState</code> 中，提供一个直接获取天气的方法，返回的类型为String字符串</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 实现推荐项目智能体 TravelRecommendAgent</h3>
<p>接下来我们实现第二个智能体，用于推荐给定地点的游玩项目，具体的实现方式可以参照上面天气智能体的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在旅游项目推荐的实现中，使用了前面返回的天气信息，作为提示词的输入，将大模型的返回结果保存到State中给后续的节点使用；同样的，我们可以在 <code>TravelState</code> 中，提供获取推荐项目的方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 实现美食智能体 FoodAgent</h3>
<p>接下来我们实现第三个智能体，基于旅游项目的美食推荐（如果条件允许，当然是推荐借助百度/高德地图的MCPServer来实现），具体的实现方式可以参照上面天气智能体的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个实现，相比于前面的旅游项目Agent的实现会更复杂一点，利用了前面返回的天气和旅游项目，借助了SpringAI的提示词模板 + 结构化输出来实现美食推荐，我们可以在 <code>TravelState</code> 中，提供获取美食推荐列表的方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7. 实现小红书博文智能体 XhsBlogGenerateAgent</h3>
<p>最后我们实现第四个智能体，基于美食推荐，生成小红书的博文；我们这里做一个分支处理，如果是直接由WeatherAgent转过来的，那么我们作为一个天气预报的Agent；如果是由FoodAgent转过来的，那么我们作为一个小红书的旅游美食推荐Agent</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两个不同的分支，返回的内容稍有区别，定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的，我们可以在 <code>TravelState</code> 中，提供获取最终博文数据的方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8. TravelState序列化</h3>
<p>当上面四个智能体实现完毕之后，<code>TravelState</code>中存储的上下文也都可以确定了，接下来我们定义它的序列化方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9. 实现多智能体调用的 AgentExecutor</h3>
<p>上面的智能体实现之后，我们接下来需要实现 <code>AgentExecutor</code>，在这里定义<code>StateGraph</code>，执行多智能体的调用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的核心在与<code>GraphBuilder.build()</code>的实现，在这个实现中，定义了AgentState、Node、Edge、ConditionEdge，通过他们构建了一个有向图，我们可以通过下面这个方法打印下这个多智能体执行的PantUML</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-plantuml line-numbers-mode" data-ext="plantuml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/D01-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 10. 测试验证</h3>
<p>接下来我们实现一个端点，用于用户的推荐交互</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>小红书生成风格博文生成（传参中包含推荐二字）:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/D01-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>天气预报的信息生成（传参中不包含推荐二字）</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/D01-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、小结</h2>
<p>本文通过逐步拆解的方式，给大家演示了如何借助 <code>SpringAI</code> + <code>LangGraphJ</code> + <code>智普大模型</code> 从0到1创建一个多智能体应用，虽然现在的效果还一般，这个主要还是我的提示词和响应还不够优雅，整个业务的流程还是完整流畅的。有兴趣的小伙伴也可以实际的体验一下</p>
<p>上文虽然实现步骤相对清晰，但是内中原理和知识点，还是比较多的，对于上面实现的步骤有疑问的小伙伴，可以仔细阅读一下我的 <a href="https://hhui.top/tutorial/spring/springai/" target="_blank" rel="noopener noreferrer">SpringAI系列博文</a> 相信能解决你的大部分疑问</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/app-projects/D01-travel-recommend-agent" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/D01-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>04.使用LangGraph4J实现多轮对话</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A04.%E4%BD%BF%E7%94%A8LangGraph4J%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BD%AE%E5%AF%B9%E8%AF%9D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A04.%E4%BD%BF%E7%94%A8LangGraph4J%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BD%AE%E5%AF%B9%E8%AF%9D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">04.使用LangGraph4J实现多轮对话</source>
      <description>04.使用LangGraph4J实现多轮对话 之前介绍的多轮对话，上下文存储主要是SpringAI提供的能力支持；接下来我们看一下，在agent开发时推荐使用的框架LangGraphJ，如何实现多轮对话 一、LangGraphJ实现多轮对话 1. 创建项目 创建一个SpringAI项目，基本流程同 创建一个SpringAI-Demo工程</description>
      <category>SpringAI</category>
      <pubDate>Mon, 11 Aug 2025 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 04.使用LangGraph4J实现多轮对话</h1>
<p>之前介绍的多轮对话，上下文存储主要是SpringAI提供的能力支持；接下来我们看一下，在agent开发时推荐使用的框架LangGraphJ，如何实现多轮对话</p>
<h2> 一、LangGraphJ实现多轮对话</h2>
<h3> 1. 创建项目</h3>
<p>创建一个SpringAI项目，基本流程同  <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 2. 添加依赖</h3>
<p>在pom.xml中添加关键依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们这里直接依赖的是 <code>langgraph4j-springai-agentexecutor</code> 模块，该模块提供了基于SpringAI的AgentExecutor实现；使用的版本为当前(25/08/08)的最新版本，有需要的小伙伴根据实际情况进行调整</p>
<h3> 3. 配置</h3>
<p>在配置文件 <code>application.yml</code> 文件中，添加大模型配置，我们这里依然是使用ZhipuAI的模型进行演示</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. MemAgent实现</h3>
<p>实现一个MemAgent，用于获取对话的<code>CompileGraph</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现， <code>MemorySaver</code> 是一个 <code>BaseCheckpointSaver</code> 的实现，用于实现 Checkpoint 的保存，对话历史保存到jvm内存中；使用<code>org.bsc.langgraph4j.RunnableConfig.threadId</code>来实现不同身份的会话隔离</p>
<h3> 5. 多轮对话端点</h3>
<p>提供一个聊天接口，第一个参数为用户标识，用于区分用户的聊天记录</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/A04-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、小结</h2>
<p>本文演示了通过 LangGraphJ 实现多轮对话的实现，虽然效果是实现了，但是对LangGraphJ不太了解的小伙伴，估计会有很多疑问，这个框架是怎么工作的呢？又该如何使用它来开发Agent呢？</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects/A04-memory-agent-langgraph" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/A04-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>05.使用LangGraph4J实现Agent路由选择</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A05.%E4%BD%BF%E7%94%A8LangGraph4J%E5%AE%9E%E7%8E%B0Agent%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A05.%E4%BD%BF%E7%94%A8LangGraph4J%E5%AE%9E%E7%8E%B0Agent%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">05.使用LangGraph4J实现Agent路由选择</source>
      <description>05.使用LangGraph4J实现Agent路由选择 在 创建一个Langgraph4j示例工程 这一篇文章中，我们介绍了如何创建一个 LangGraph4j 的示例工程； 在上文中介绍到 LangGraph4j 时，就提到了它有一个重要的特性，就是可以定义循环图，使不同的组件（代理、工具或自定义逻辑）能够以有状态的方式进行交互</description>
      <category>SpringAI</category>
      <pubDate>Tue, 12 Aug 2025 11:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 05.使用LangGraph4J实现Agent路由选择</h1>
<p>在 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/14.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AALanggraph4j%E5%AE%9E%E4%BE%8B%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个Langgraph4j示例工程</a> 这一篇文章中，我们介绍了如何创建一个 LangGraph4j 的示例工程；</p>
<p>在上文中介绍到 <code>LangGraph4j</code> 时，就提到了它有一个重要的特性，就是可以定义循环图，使不同的组件（代理、工具或自定义逻辑）能够以有状态的方式进行交互</p>
<p>接下来我们来实际感受一下，上面这个重要的特性是如何表现的</p>
<h2> 一、项目创建</h2>
<h3> 1. 创建LangGraph4j + SpringAI项目</h3>
<p>具体的创建过程，与上文一致，有兴趣的小伙伴请关注 <a href="../%E5%9F%BA%E7%A1%80%E7%AF%87/14.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AALanggraph4j%E5%AE%9E%E4%BE%8B%E5%B7%A5%E7%A8%8B">创建一个Langgraph4j示例工程</a></p>
<h3> 2. 配置大模型密钥</h3>
<p>这里依然使用智谱的免费大模型，使用其他的模型时，请自行替换<code>start</code>和下面的配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、创建一个地点的旅游推荐Agent</h2>
<h3> 1. 工作流程</h3>
<p>在这里，我们设计一个简单的业务流程，开发一个旅游推荐的Agent，在这个agent中，我们需要结合旅游地点的天气，来选择不同的推荐项目</p>
<figure><img src="/imgs/column/springai/A05-1.webp" alt="由LangGraph4j生成的流程图" tabindex="0" loading="lazy"><figcaption>由LangGraph4j生成的流程图</figcaption></figure>
<p>注意上面这个流程图，虽然它是事后由<code>LangGraph4j</code>生成的，实际也是呈现我们的旅游推荐Agent的核心工作流程</p>
<ol>
<li>Weather: 根据传入的地方，获取当前的天气</li>
<li>Router: 作为一个路由节点（实际上啥也没干）
<ul>
<li>当天气为晴天时，路由到 outdoor，推荐一些室外的旅游项目</li>
<li>当天气为雨天时，路由到 indoor，推荐一些室内的旅游项目</li>
<li>当天气为其他情况时，路由到 default，直接结束</li>
</ul>
</li>
</ol>
<h3> 2. 基本概念科普</h3>
<p>在<code>LangGraph</code>中，有几个核心的概念，我们现简单来看一下；后面的实现中，会针对性的实现这些</p>
<blockquote>
<p>以下内容，来自于: <a href="https://github.com/langgraph4j/langgraph4j" target="_blank" rel="noopener noreferrer">langgraph4j</a></p>
</blockquote>
<h4> AgentState</h4>
<p>AgentState（或其扩展类）表示图的共享状态。它本质上是一个映射 (<code>Map&lt;String, Object&gt;</code>)，会在各个节点之间传递。每个节点都可以读取此状态并返回更新。</p>
<ul>
<li><code>Schema</code>：状态的结构由“Schema”定义，它是一个 <code>Map&lt;String, Channel.Reducer&gt;</code> 类型的对象。Map 中的每个键都对应状态中的一个属性。</li>
<li><code>Channel.Reducer</code>：Reducer 定义了如何处理状态属性的更新。例如，新值可能会覆盖旧值，或者添加到现有值列表中。</li>
<li><code>Channel.Default&lt;T&gt;</code>：如果状态属性尚未设置，则为其提供默认值。</li>
<li><code>Channel.Appender&lt;T&gt;</code> <code>/</code> <code>MessageChannel.Appender&lt;M&gt;</code>：一种常见的 Reducer 类型，它将新值附加到与状态属性关联的列表中。这对于累积消息、工具调用或其他数据序列非常有用。MessageChannel.Appender 专为聊天消息而设计，还可以处理通过 ID 删除消息的操作。</li>
</ul>
<h4> Nodes</h4>
<p>节点是构成图的执行操作的基石。节点通常是一个函数（或一个实现 <code>NodeAction&lt;S&gt;</code> 或 <code>AsyncNodeAction&lt;S&gt;</code> 的类），它：</p>
<ul>
<li>接收当前 <code>AgentState</code> 作为输入。</li>
<li>执行某些计算（例如，调用 LLM、执行工具、运行自定义业务逻辑）。</li>
<li>返回一个表示状态更新的 <code>Map&lt;String, Object&gt;</code> 对象。这些更新随后会根据架构的 <code>Reducer</code> 应用于 <code>AgentState</code>。</li>
</ul>
<p>节点可以是同步的，也可以是异步的（CompletableFuture）。</p>
<h4> Edges</h4>
<p>边定义节点之间的控制流。</p>
<ul>
<li>普通边：从一个节点到另一个节点的无条件转换。节点 A 完成后，控制权始终传递给节点 B。您可以使用 <code>addEdge(sourceNodeName, destinationNodeName)</code> 定义普通边。</li>
<li>条件边：下一个节点根据当前 <code>AgentState</code> 动态确定。
<ul>
<li>源节点完成后，将执行 <code>EdgeAction&lt;S&gt;</code>（或 <code>AsyncEdgeAction&lt;S&gt;</code>）函数。</li>
<li>该函数接收当前状态并返回下一个要执行的节点的名称。</li>
<li>这允许分支逻辑（例如，如果代理决定使用某个工具，则转到<code>execute_tool</code>节点；否则，转到<code>respond_to_user</code>节点）。</li>
<li>条件边使用 <code>addConditionalEdges(...)</code> 定义。</li>
</ul>
</li>
<li>入口点：您还可以使用 <code>addConditionalEntryPoint(...)</code> 为图定义条件入口点。</li>
</ul>
<h4> Compilation</h4>
<p>在 <code>StateGraph</code> 中定义好所有节点和边后，可以使用 <code>compile()</code> 将其编译为 <code>CompiledGraph&lt;S extends AgentState&gt;</code>。</p>
<p>这个编译后的图是你的逻辑的不可变且可运行的表示。编译过程会验证图的结构（例如，检查是否存在孤立节点）。</p>
<h4> Checkpoints (Persistence)</h4>
<p><code>LangGraph4j</code> 允许您在任何步骤保存（检查点）图的状态。这在以下情况下非常有用：</p>
<ul>
<li>调试：检查各个点的状态以了解发生了什么。</li>
<li>恢复：将图恢复到之前的状态并继续执行。</li>
<li>长时间运行的进程：持久化长时间运行的代理交互的状态。您通常会使用 <code>CheckpointSaver</code> 实现（例如，使用 <code>MemorySaver</code> 进行内存存储，或者您也可以自己实现持久化存储）。</li>
</ul>
<h3> 3. Node实现</h3>
<p>从上面的流程图中我们也可以看出，这里定义了四个<code>Node</code>，接下来我们分别给于实现</p>
<p><strong>WeatherNode：用于获取地区的天气</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>RouterNode: 路由节点</strong></p>
<p>这个路由节点实际上啥也没干，不要也行，这里主要是用它打印了一下 WeatherNode 的输出</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>OutdoorNode: 室外推荐节点</strong></p>
<p>在这个节点中，我们使用大模型来推荐外出旅游的项目</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>IndoorNode: 室内推荐节点</strong></p>
<p>在这个节点中，我们使用大模型来推荐适合室内游玩的项目</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到这里，我们的四个节点已经定义完成，接下来进行节点的连接</p>
<h3> 4. 节点连接</h3>
<p>节点连接，就是将节点通过<code>addEdge</code>方法进行连接，这里我们连接了四个节点，并且定义了条件边，用于判断当前节点是否需要执行</p>
<p>首先实现路由的条件边判定</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后是完成完整的节点、边定义</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 输出PlantUML</h3>
<p>在上面的节点定义完成后，我们可以通过<code>graph.getGraph()</code>方法，将节点定义转换为PlantUML格式，方便我们查看节点定义</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们拿到上面的内容之后，可以在 <a href="https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa700001" target="_blank" rel="noopener noreferrer">在线plantuml工具</a> 中查看，会生成对应的流程图</p>
<figure><img src="/imgs/column/springai/A05-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. Agent封装</h3>
<p>接下来就是将上面的实现，封装为一个完整的，对外直接使用的Agent，源码可以在最后的项目链接中获取，类名为 <code>WeatherRecommendAgent</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7. 测试验证</h3>
<p>接下来我们进行实例验证，创建一个Controller，调用<code>WeatherRecommendAgent</code>的<code>recommendByLocation</code>方法，传入地区参数，返回结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/A05-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面实际的表现结果也可以看出和我们前面定义的流程图表现一致</p>
<h2> 三、小结</h2>
<p>本文通过实现一个简单的基于地点的天气实现旅游项目推荐，演示了多个单Agent联合组装成一个更复杂、功能更强大Agent示例。</p>
<p>在这个实现过程中，我们实现或者应用了<code>LangGraph4j</code> 框架中定义的Node、边（条件边）、State等，通过这些来生成了一个 <code>CompiledGraph</code>， 通过<code>CompiledGraph</code>来实现多Agent的组合</p>
<p>虽然这个项目实现了一个多Agent的组合，但是善于思考的我们，依然会有一些疑问</p>
<ul>
<li>这里使用的是默认的<code>AgentState</code>，内部是使用Map来传递共享参数，是否有更结构化的方式?</li>
<li><code>addConditionalEdges</code> 条件边定义的具体用法说明</li>
<li><code>GraphRepresentation</code> 节点定义的输出格式，是否可以自定义？ 是否可以结构化输出？</li>
<li>上面整体的实现更多的是借助<code>langgraph4j-core</code>，对于<code>langgraph4j-springai</code>是否会有更简单的使用姿势？</li>
</ul>
<p>接下来我们将努力尝试对上面这些问题进行逐步回答，有兴趣的小伙伴可以持续关注一波</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects/A04-memory-agent-langgraph" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/A05-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>SpringAI</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">SpringAI</source>
      <description>这里主要介绍的是SpringAI进行AI应用开发的系列教程 注意：在使用SpringAI时，对jdk和springboot有最低的版本要求 jdk: 17+ SpringBoot: 3+ 核心技术栈： SpringAI 1.0.1 LangGraph4J 本篇专栏将从四个系列出发 1.基础教程 主要介绍SpringAI的基础使用，对应的项目工程以 Sxx- 开头，通过这些实例，您将掌握SpringAI的基础知识（如提示词、上下文、架构化输出、tool calling, MCP, advise, ChatClient, 多模型等），并开始使用SpringAI进行大模型应用开发</description>
      <pubDate>Fri, 08 Aug 2025 02:51:24 GMT</pubDate>
      <content:encoded><![CDATA[<p>这里主要介绍的是SpringAI进行AI应用开发的系列教程</p>
<p>注意：在使用SpringAI时，对jdk和springboot有最低的版本要求</p>
<ul>
<li>jdk: 17+</li>
<li>SpringBoot: 3+</li>
</ul>
<p>核心技术栈：</p>
<ul>
<li>SpringAI 1.0.1</li>
<li>LangGraph4J</li>
</ul>
<p>本篇专栏将从四个系列出发</p>
<h3> 1.基础教程</h3>
<p>主要介绍SpringAI的基础使用，对应的项目工程以 <code>Sxx-</code> 开头，通过这些实例，您将掌握SpringAI的基础知识（如提示词、上下文、架构化输出、tool calling, MCP, advise, ChatClient, 多模型等），并开始使用SpringAI进行大模型应用开发</p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">01.创建一个SpringAI-Demo工程.md</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/02.%E6%8F%90%E7%A4%BA%E8%AF%8D%E8%AE%BE%E7%BD%AE.html" target="blank">02.提示词的使用.md</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/03.%E7%BB%93%E6%9E%84%E5%8C%96%E8%BF%94%E5%9B%9E.html" target="blank">03.结构化返回</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/04.%E8%81%8A%E5%A4%A9%E4%B8%8A%E4%B8%8B%E6%96%87.html" target="blank">04.聊天上下文实现多轮对话</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-4" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-4"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/05.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5.html" target="blank">05.自定义大模型接入</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-5" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-5"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/06.%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8FunctionCalling.html" target="blank">06.Function Tool工具调用</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-6" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-6"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/07.%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84McpServer.html" target="blank">07.实现一个简单的McpServer</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-7" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-7"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/08.MCP%20Server%E7%AE%80%E5%8D%95%E9%89%B4%E6%9D%83%E7%9A%84%E5%AE%9E%E7%8E%B0.html" target="blank">08.MCP Server简单鉴权的实现</a>]</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-8" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-8"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/09.ChatClient%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html" target="blank">09.ChatClient使用说明</a>]</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-9" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-9"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/10.Advisor%E5%AE%9E%E7%8E%B0SpringAI%E4%BA%A4%E4%BA%92%E5%A2%9E%E5%BC%BA.html" target="blank">10.Advisor实现SpringAI交互增强</a>]</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-10" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-10"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/11.%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%9E%8B.html" target="blank">11.图像模型-生成图片</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-11" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-11"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/12.%E5%A4%9A%E6%A8%A1%E6%80%81%E5%AE%9E%E7%8E%B0%E9%A3%9F%E6%9D%90%E5%9B%BE%E7%89%87%E5%8D%A1%E8%B7%AF%E9%87%8C%E8%AF%86%E5%88%AB%E7%A4%BA%E4%BE%8B.html" target="blank">12.多模态实现食材图片卡路里识别示例</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-12" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-12"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/13.%E6%94%AF%E6%8C%81MCP%20Client%E7%9A%84AI%E5%AF%B9%E8%AF%9D%E5%AE%9E%E7%8E%B0.html" target="blank">13.支持MCP Client的AI对话实现</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-13" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-13"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/14.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AALanggraph4j%E5%AE%9E%E4%BE%8B%E5%B7%A5%E7%A8%8B.html" target="blank">14.创建一个LangGraph4J示例工程</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-14" disabled="disabled"><label class="task-list-item-label" for="task-item-14"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/12.%E9%9F%B3%E9%A2%91%E6%A8%A1%E5%9E%8B.html" target="blank">音频模型</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-15" disabled="disabled"><label class="task-list-item-label" for="task-item-15"> <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/08.%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E7%94%9F%E6%88%90RAG.html" target="blank">检索增强生成RAG</a></label></li>
</ul>
<h3> 2.进阶教程</h3>
<p>进阶相关将主要介绍如何更好的使用SpringAI进行大模型应用开发，对应的实例工程都放在 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects" target="_blank" rel="noopener noreferrer">advance-projects</a> 下</p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-16" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-16"> <a href="/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A01.%E4%BD%BF%E7%94%A8MySql%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html" target="blank">01.使用MySql持久化对话历史</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-17" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-17"> <a href="/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A02.%E4%BD%BF%E7%94%A8H2%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html" target="blank">02.使用H2持久化对话历史</a>]</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-18" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-18"> <a href="/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A03.%E4%BD%BF%E7%94%A8Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html" target="blank">03.使用Redis持久化对话历史</a>]</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-19" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-19"> <a href="/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A04.%E4%BD%BF%E7%94%A8LangGraph4J%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BD%AE%E5%AF%B9%E8%AF%9D.html" target="blank">04.使用LangGraph4J实现多伦对话</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-20" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-20"> <a href="/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A05.%E4%BD%BF%E7%94%A8LangGraph4J%E5%AE%9E%E7%8E%B0Agent%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9.html" target="blank">05.使用LangGraph4J实现Agent路由选择</a></label></li>
</ul>
<h3> 3.应用教程</h3>
<p>以搭建完整可用的SpringAI应用为目的，演示SpringAI的业务边界和表现，对应项目工都放在 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/app-projects" target="_blank" rel="noopener noreferrer">app-projects</a> 下</p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-21" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-21"> <a href="/tutorial/spring/springai/%E5%BA%94%E7%94%A8%E7%AF%87/D01.%E4%BB%8E0%E5%88%B01%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E5%A4%A9%E6%B0%94%E7%9A%84%E6%97%85%E6%B8%B8%E7%BE%8E%E9%A3%9F%E6%8E%A8%E8%8D%90%E6%99%BA%E8%83%BD%E4%BD%93.html" target="blank">从0到1创建一个基于天气的旅游美食推荐智能体</a></label></li>
</ul>
<h3> 4.源码解读</h3>
<p>以源码的视角，介绍SpringAI的核心实现，对应的项目工程以 <code>Yxx-</code> 开头</p>
]]></content:encoded>
    </item>
    <item>
      <title>01.创建一个SpringAI的示例工程</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.创建一个SpringAI的示例工程</source>
      <description>01. 创建一个SpringAI的示例工程 下面介绍一下，如何快速借助官方的启动方式进行快速搭建一个用于体验SpringAI的示例工程 一、项目创建 https://spring.io/projects/spring-ai 借助Spring官方提供的快速创建项目功能，创建一个SpringBoot项目，点击下面的连接进入快速创建Spring-Ai项目</description>
      <category>SpringAI</category>
      <pubDate>Fri, 11 Jul 2025 08:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 01. 创建一个SpringAI的示例工程</h1>
<p>下面介绍一下，如何快速借助官方的启动方式进行快速搭建一个用于体验SpringAI的示例工程</p>
<h2> 一、项目创建</h2>
<blockquote>
<p><a href="https://spring.io/projects/spring-ai" target="_blank" rel="noopener noreferrer">https://spring.io/projects/spring-ai</a></p>
</blockquote>
<p>借助Spring官方提供的快速创建项目功能，创建一个SpringBoot项目，点击下面的连接进入快速创建Spring-Ai项目</p>
<ul>
<li><a href="https://start.spring.io/#!type=maven-project&amp;language=java&amp;platformVersion=3.3.4&amp;packaging=jar&amp;jvmVersion=17&amp;groupId=spring.ai.example&amp;artifactId=spring-ai-demo&amp;name=spring-ai-demo&amp;description=Spring%20AI%20%2C%20getting%20started%20example%2C%20using%20Open%20AI&amp;packageName=spring.ai.example.spring-ai-demo&amp;dependencies=web,spring-ai-openai" target="_blank" rel="noopener noreferrer">start.spring.io</a></li>
</ul>
<figure><img src="/imgs/column/springai/01-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在表格中，填写关键的信息（Group, Artifact, Name, Description, Version, PackageName）</p>
<h2> 二、项目初始化</h2>
<p>将上面生成的工程，解压之后，导入IDEA开发工具，你会得到一个空的Spring项目</p>
<figure><img src="/imgs/column/springai/01-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 1. 配置账号信息</h3>
<p>上面创建的默认是OpenAI(Chatgpt)的大模型访问，这个需要我们提前备好梯子和密钥，账号充值才能使用，只需要在<code>applicatin.properties</code>文件中添加密钥即可</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote>
<p>出于安全考虑，可以通过配置环境变量的方式来配置密钥，如下</p>
</blockquote>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后设置环境变量</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 使用免费的智普大模型体验</h3>
<p>当然若条件不允许，我们可以考虑智普清言的免费大模型</p>
<p>替换依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在智普的开放平台获取密钥：<a href="https://open.bigmodel.cn/usercenter/proj-mgmt/apikeys" target="_blank" rel="noopener noreferrer">https://open.bigmodel.cn/usercenter/proj-mgmt/apikeys</a></p>
<figure><img src="/imgs/column/springai/01-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后在配置文件中，添加智普的密钥，并指定免费的大模型</p>
<blockquote>
<p>在官网的定价中可以找到免费的模型：<a href="https://www.bigmodel.cn/pricing" target="_blank" rel="noopener noreferrer">https://www.bigmodel.cn/pricing</a></p>
</blockquote>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 密钥注入方式</h3>
<p>密钥除了直接再配置文件中写死之外，也可以通过前面介绍的环境变量的方式来注入，除此之外，下面介绍一种本地开发时命令行参数注入的方式</p>
<p>为了避免<code>api-key</code>的泄露，我们借助SpEL的方式来注入，通过在启动时，添加参数来设置apiKey，如下</p>
<ul>
<li>唤起编辑启动命令行窗口</li>
<li>点击<code>Modify options</code></li>
<li>在弹窗中选中 <code>Program arguments</code>，然后会看到再启动类右边新增一个输入框</li>
<li>再输入框中添加<code>--spring.ai.zhipuai.api-key=&lt;your-zhipuai-api-key&gt;</code></li>
</ul>
<figure><img src="/imgs/column/springai/01-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>说明：为什么不建议直接在配置文件中写密钥？</strong></p>
<ul>
<li>因为非常容易泄露，本地测试时，最简单的当然是直接在配置文件中写密钥，但是当我们将项目推送到git时，很容易忘了将密钥删除，这样，密钥就泄露了（即便你后续发现了再删除，但是git的历史提交中依然能找到你的密钥，你就只能删除它了）</li>
</ul>
<h2> 三、项目运行</h2>
<p>再上面初始化完成之后，接下来我们写一个简单的Chat服务，用于体验与大模型对话的感觉</p>
<p>新建一个ChatController类，用于接收用户的提问，并返回模型生成的答案</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面分别提供同步/流式调用大模型两种方式，测试时，你可以选择任意一种方式</p>
<figure><img src="/imgs/column/springai/01-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 四、小结</h2>
<p>从本文搭建的一个示例工程可以看出，借助SpringAI与大模型进行交互可以说是非常简单了，比基于db的CURD效率要高多了。相比起我们自己的实现（比如技术派的大模型调用就是手撸的代码直接实现与大模型交互），实在是轻松太多</p>
<p>文中所有代码可以在<a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S01-chat-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a> 获取</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/01-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>02.提示词的使用</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/02.%E6%8F%90%E7%A4%BA%E8%AF%8D%E8%AE%BE%E7%BD%AE.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/02.%E6%8F%90%E7%A4%BA%E8%AF%8D%E8%AE%BE%E7%BD%AE.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">02.提示词的使用</source>
      <description>02. 提示词的使用 上一篇文章快速带大家基于SpringAi创建了一个调用大模型的示例工程，接下来我们将进入一些大模型交互的细节，这里主要介绍如何使用提示词，以使大模型的输出更加符合我们的需求 一、基础知识 1. 提示词（Prompt） 提示词：Prompt，也可以理解为预设，是模型在开始对话时，预先设定的一些内容，这些内容会作为模型输入，从而影响模型输出的结果。 SpringAI中，我们使用 Prompt 类来表示一个提示词，Prompt 类中包含一个 List&amp;lt;Message&amp;gt; 属性，用于表示提示词中的消息列表。</description>
      <category>SpringAI</category>
      <pubDate>Fri, 11 Jul 2025 10:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 02. 提示词的使用</h1>
<p>上一篇文章快速带大家基于SpringAi创建了一个调用大模型的示例工程，接下来我们将进入一些大模型交互的细节，这里主要介绍如何使用提示词，以使大模型的输出更加符合我们的需求</p>
<h2> 一、基础知识</h2>
<h3> 1. 提示词（Prompt）</h3>
<p>提示词：Prompt，也可以理解为预设，是模型在开始对话时，预先设定的一些内容，这些内容会作为模型输入，从而影响模型输出的结果。</p>
<p>SpringAI中，我们使用 <code>Prompt</code> 类来表示一个提示词，<code>Prompt</code> 类中包含一个 <code>List&lt;Message&gt;</code> 属性，用于表示提示词中的消息列表。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 消息（Message）</h3>
<p>用户与大模型中间的对话，通常是由一个或多个消息组成，其中每个消息都需要与一个角色关联；角色表示消息作者的角色。</p>
<p>SpringAI中，我们使用 <code>Message</code> 类来表示一个消息，<code>Message</code> 类中包含一个 <code>MessageType</code> 属性，用于表示消息的类型。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面定义的<code>MessageType</code>定义消息类型，和大模型中定义的角色进行映射，ChatGPT了解它应该如何行为以及谁在发起调用</p>
<figure><img src="/imgs/column/springai/02-1.webp" alt="https://docs.spring.io/spring-ai/reference/api/prompt.html#_prompt" tabindex="0" loading="lazy"><figcaption><a href="https://docs.spring.io/spring-ai/reference/api/prompt.html#_prompt" target="_blank" rel="noopener noreferrer">https://docs.spring.io/spring-ai/reference/api/prompt.html#_prompt</a></figcaption></figure>
<p>通常有四种角色：</p>
<ul>
<li>system: 系统角色，用于通过分配特定行为给大模型来创建对话的上下文或范围，通常我们预设的提示词会和 <code>system</code> 角色关联</li>
<li>user: 用户角色，用于表示用户输入的文本，通常我们输入的提问也会和 <code>user</code> 角色关联</li>
<li>assistant: 助手角色，用于表示模型生成的文本，通常大模型生成的答案也会和 <code>assistant</code> 角色关联</li>
<li>tool: 工具角色，用于表示模型调用的函数返回的内容，会和 <code>tool</code> 角色关联</li>
</ul>
<h3> 3. 提示词模板</h3>
<p>提示词实际上是一个字符串，若提示词全部由程序预设，会导致提示词的复用性差，因此，SpringAI提供了一种模板语法，用于生成提示词，模板语法如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>模板语法中，<code>{name}</code> 和 <code>{voice}</code> 是模板变量，模板变量的值会根据调用时传入的参数进行替换</p>
<p>关联的类定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、实例演示</h2>
<p>首先我们需要创建一个SpringAI的项目，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 提示词基础使用</h3>
<p>我们这里同样基于智普的免费大模型进行演示，首先创建一个Controller控制器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再定义一个对话的接口，还是与之前的demo工程的一样，接收用户的传入文本，不同的地方在于我们再方式实现中，显示创建一个提示词</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提示词的创建方式比较简单，直接new一个对象，如上面的示例</p>
<ul>
<li>第一个参数：string类型：默认表示用户输入的消息</li>
<li>第二个参数：ChatOptions类型：表示模型调用的参数，如模型名称、温度、用户名称等</li>
</ul>
<ol>
<li>
<p><strong><code>temperature</code> 参数作用</strong>：</p>
<ul>
<li>用于控制生成文本的<strong>随机性或创造性</strong>。</li>
<li>数值范围一般在 <code>0.0</code> 到 <code>1.0</code> 之间（有时也可超出该范围）：
<ul>
<li>当 <code>temperature</code> 接近 <code>0.0</code> 时，输出会趋于确定性和保守，通常选择概率最高的词；</li>
<li>当 <code>temperature</code> 接近 <code>1.0</code> 或更高时，输出更具多样性和创造性，可能会选择低概率但更有趣的词。</li>
</ul>
</li>
<li>示例中设置为 <code>0.7d</code>，表示适度平衡确定性与多样性。</li>
</ul>
</li>
<li>
<p><strong><code>user</code> 参数作用</strong>：</p>
<ul>
<li>用于标识请求的发起者，通常是<strong>用户的唯一标识符</strong>（如用户名、ID 等）。</li>
<li>主要用途包括：
<ul>
<li><strong>日志记录和审计</strong>：便于追踪哪个用户触发了此次 AI 调用；</li>
<li><strong>配额管理</strong>：某些平台依据 <code>user</code> 字段进行使用量统计与限制；</li>
<li><strong>行为分析</strong>：用于后续的数据分析或个性化推荐等场景。</li>
</ul>
</li>
<li>示例中设置为 <code>"一灰灰"</code>，可能代表当前请求来源的用户身份标识。</li>
</ul>
</li>
</ol>
<p>如果我们希望预设一个系统的提示词，比如给大模型定义一个身份：“你现在是一个专注于给3-5岁儿童聊天的助手”，那么我们可以这样创建一个提示词：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们访问对比一下上面两个接口的返回情况，很明显<code>childGenerate</code>生成的笑话内容更适合3-5岁小朋友</p>
<figure><img src="/imgs/column/springai/02-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>小结一下，提示词的使用方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 提示词模板</h3>
<p>接下来我们再来看一下提示词模板的使用示例，创建一个角色扮演的接口，我们预设的系统提示词模板为</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>直接借助SpringAI提供的 <code>PromptTemplate</code> 来实现提示词模板的解析，常见的使用方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们创建一个接口，接收三个参数，分别表示角色的个性、角色名称、用户角色名称，然后使用模板渲染，并创建一个系统提示词，实现与用户的对话</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们看看传入不同的参数的表现情况</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/02-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的输出也可以看出，当我传入不同的角色描述，返回的对话信息也会根据我的描述进行显著的变化</p>
<h3> 3. 提示词高级使用</h3>
<p>通过提示词模板<code>promptTemplate.create</code>创建的提示词，默认是创建<code>UserMessage</code>类型的消息；如果我们希望创建的是系统提示词呢？可以使用<code>SystemPromptTemplate</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>默认情况下，提示词模板中需要替换的内容是放在<code>{}</code>中的，当然我们也可以自定义替换的内容，比如使用<code>&lt;&gt;</code>来替换，此时我们需要在创建<code>PromptTemplate</code>的时候传入一个参数<code>delimiter</code>，表示替换内容的分隔符</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提示词的使用，除了上面的字符串硬编码方式之外，SpringAI还提供了资源注入的方式，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 三、小结</h2>
<p>本文主要介绍在SpringAI中提示词的使用方式，如最基本的大模型交互时，由SpringAI默认根据文本封装一个用户消息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当然也可以手动创建</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如提示词有复用的场景，则优先考虑提示词模板</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S02-prompt-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/02-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>03.结构化返回</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/03.%E7%BB%93%E6%9E%84%E5%8C%96%E8%BF%94%E5%9B%9E.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/03.%E7%BB%93%E6%9E%84%E5%8C%96%E8%BF%94%E5%9B%9E.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">03.结构化返回</source>
      <description>03. 结构化返回 通常情况下，在我们不显示要求大模型返回什么样的数据结构时，大模型返回的大多不是结构化的数据；对于上层的业务开发来说，将大模型返回的关键信息映射为结构化的数据模型是一个非常难受的事情 SpringAI提供了一系列的返回结果结构化转换器来实现上面的痛点；接下来我们来具体看一下，可以怎么处理返回结果 一、实例演示 首先我们需要创建一个SpringAI的项目，基本流程同 创建一个SpringAI-Demo工程</description>
      <category>SpringAI</category>
      <pubDate>Fri, 11 Jul 2025 12:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 03. 结构化返回</h1>
<p>通常情况下，在我们不显示要求大模型返回什么样的数据结构时，大模型返回的大多不是结构化的数据；对于上层的业务开发来说，将大模型返回的关键信息映射为结构化的数据模型是一个非常难受的事情</p>
<p>SpringAI提供了一系列的返回结果结构化转换器来实现上面的痛点；接下来我们来具体看一下，可以怎么处理返回结果</p>
<h2> 一、实例演示</h2>
<p>首先我们需要创建一个SpringAI的项目，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 初始化</h3>
<p>创建一个MVC的API，用于提供与大模型的交互</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. BeanOutputConverter</h3>
<p>借助<code>BeanOutputConverter</code>来实现返回结果映射为java的POJO类，首先我们定义一个提示词模板，主要用于查询某个导演的作品</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们希望返回的结构如下:</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此我们可以定义一个record，用于承接返回的结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>借助<code>ChatClient</code>来实现结果解析</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么上面的方式就可以实现结果映射为java的POJO类呢？ 我们可以debug一下<code>ChatClient.create(chatModel).prompt(prompt).call()</code>返回的对象</p>
<p>从下面的截图中可以看到，在传递给大模型的请求中，context参数中，指定了要求大模型返回的数据格式（这里基于Advisors来实现的上下文数据附加/扩充提示词的功能）</p>
<figure><img src="/imgs/column/springai/03-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>当然也可以显示使用<code>BeanOutputConverter</code>基于<code>ChatModel</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，在提示词模板中，新增了 <code>{format}</code>，其值由 <code>BeanOutputConverter</code> 的 <code>getFormat()</code> 方法获取；其实现原理是直接在提示词中添加了结构化的返回结果格式，因此，大模型返回的数据结构，会按照这个格式进行解析</p>
<p>接下来实际访问看看表现情况</p>
<figure><img src="/imgs/column/springai/03-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从多次体验的结果来看，结果的格式与定义的POJO类一致，因此，基于BeanOutputConverter的实现，可以达到我们想要的结果；但是在有限的几次访问尝试中，返现<code>ChatClient</code>方式，返回的结果中actor可能为null，没有正确获取到值，这也侧面说明，大模型返回数据的不可控性</p>
<h3> 3. 属性排序</h3>
<p>借助<code>@JsonPropertyOrder</code>来实现排序，这个注解适用于record和普通的class</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/03-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. MapOutputConverter</h3>
<p>上面介绍的是返回一个POJO，接下来看一下直接基于<code>MapOutputConverter</code>来实现用map接收返回结果</p>
<p>这里使用的是上面用过的 <code>ParameterizedTypeReference</code> 来指定返回结果的类型</p>
<p>基于 <code>ChatClient</code> 的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于<code>MapOutputConverter</code>结合<code>ChatModel</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两个接口的返回结果如下图，虽然都是返回的Map，但是仔细看之后，会发现他们的层级并不一样，基于<code>ChatClient</code>返回的层级会多一层，返回的电影被放在了<code>movie</code>属性下，以列表的方式组织；而基于<code>MapOutputConverter</code>返回的就是一层的map，key为数字；</p>
<p>至于孰优孰劣，这里就不予置评，看个人喜好了</p>
<figure><img src="/imgs/column/springai/03-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. ListOutputConverter</h3>
<p>除了上面返回Map的case之外，再看一下返回列表的场景，借助<code>ListOutputConverter</code>来实现，基本上和前面介绍的差异不大</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>返回实例如下（你会发现返回数据的不准，当然这个就不属于我们这里的范畴了）</p>
<figure><img src="/imgs/column/springai/03-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、小结</h2>
<p>本文主要介绍在SpringAI中如何结构化的处理大模型返回的结果，从使用方式来看，区分<code>ChatClient</code>和<code>ChatModel</code>两种不同的使用姿势；其中前者更简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，核心发挥作用的是<code>Converter</code>，SpringAI官方提供了下面这些具体的实现，基本上可以覆盖我们90%以上的业务场景； 若覆盖补全，则考虑通过自定义Converter来实现</p>
<figure><img src="/imgs/column/springai/03-6.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S03-structured-output" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/03-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>04.聊天上下文</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/04.%E8%81%8A%E5%A4%A9%E4%B8%8A%E4%B8%8B%E6%96%87.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/04.%E8%81%8A%E5%A4%A9%E4%B8%8A%E4%B8%8B%E6%96%87.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">04.聊天上下文</source>
      <description>04.聊天上下文 大模型本身是无状态的，即你每次和它聊天，对它而言都是一轮全新的对话。但是，这个和我们实际体验大模型产品时，似乎不一样，在聊天的过程中，大模型明显是知道我们之前的问答内容、并可以基于之前的问答进行多伦的沟通，那这是怎么实现的呢？ 具体实现的原理也很简单，你和大模型的对话时，会将你们之前的对话内容也一并传给大模型，即：对于大模型而言，你的一次新的对话，它实际上把你们之前的所有对话都过了一遍；更专业一点的说法是你们的对话 是基于一个上下文，这个上下文会包含你之前和模型交互的所有内容。 若希望实现多轮对话，则每次和模型进行对话时，需要将之前和模型交互的所有内容都传递给模型，这样模型才能基于这些内容进行多轮的沟通。</description>
      <category>SpringAI</category>
      <pubDate>Mon, 14 Jul 2025 14:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 04.聊天上下文</h1>
<p>大模型本身是无状态的，即你每次和它聊天，对它而言都是一轮全新的对话。但是，这个和我们实际体验大模型产品时，似乎不一样，在聊天的过程中，大模型明显是知道我们之前的问答内容、并可以基于之前的问答进行多伦的沟通，那这是怎么实现的呢？</p>
<p>具体实现的原理也很简单，你和大模型的对话时，会将你们之前的对话内容也一并传给大模型，即：对于大模型而言，你的一次新的对话，它实际上把你们之前的所有对话都过了一遍；更专业一点的说法是你们的对话
是基于一个上下文，这个上下文会包含你之前和模型交互的所有内容。</p>
<p>若希望实现多轮对话，则每次和模型进行对话时，需要将之前和模型交互的所有内容都传递给模型，这样模型才能基于这些内容进行多轮的沟通。</p>
<h2> 一、实例演示</h2>
<h3> 1. 基础知识点</h3>
<p>SpringAI提供了自动装备的<code>ChatMemory</code> bean供我们直接注入使用</p>
<p>默认底层使用基于内存的方式存储聊天上下文(<code>InMemoryChatMemoryRepository</code>)，除了它之外，SpringAI还提供了基于数据库的存储方式</p>
<ul>
<li><code>JdbcChatMemoryRepository</code>:
支持多种关系型数据库，适用于需要持久化存储聊天记忆的场景，使用时需要添加 <code>org.springframework.ai:spring-ai-starter-model-chat-memory-repository-jdbc</code>
的依赖</li>
<li><code>CassandraChatMemoryRepository</code>: 基于 Apache Cassandra 实现消息存储，适用于需要高可用、持久化、可扩展及利用 TTL
特性的聊天记忆持久化场景；采用时间序列
Schema，完整记录历史聊天窗口，使用时添加 <code>org.springframework.ai:spring-ai-starter-model-chat-memory-repository-cassandra</code>
的依赖</li>
<li><code>Neo4jChatMemoryRepository</code>: 利用 Neo4j 将聊天消息存储为属性图中的节点与关系，适用于需发挥 Neo4j 图数据库特性的聊天记忆持久化场景。
使用时添加 <code>org.springframework.ai:spring-ai-starter-model-chat-memory-repository-neo4j</code>的依赖</li>
</ul>
<p>为了避免对话内容超过大模型的上下文限制， 使用<code>MessageWindowChatMemory</code>实现管理对话历史，<code>MessageWindowChatMemory</code>
维护固定容量的消息窗口（默认 20 条）。当消息超限时，自动移除较早的对话消息（始终保留系统消息）。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此为 Spring AI 自动配置 ChatMemory Bean 时采用的默认消息类型。</p>
<p>在使用 <code>ChatClient API</code>时，可通过注入 <code>ChatMemory</code> 实现来维护跨多轮交互的会话上下文。接下来我们通过一个案例体验一下实际的效果</p>
<h3> 2. 项目初始化</h3>
<p>首先我们需要创建一个SpringAI的项目，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<p>创建一个MVC的API，用于提供与大模型的交互</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的初始化中，我们制定了ChatClient的默认系统角色，指定了两个<code>Advisor</code></p>
<ul>
<li>SimpleLoggerAdvisor: 主要用于打印大模型的输入输出，以及一些额外的信息</li>
<li>MessageChatMemoryAdvisor: 主要用于从默认的<code>ChatMemory</code>中获取历史消息，并将其作为消息集合注入提示词</li>
</ul>
<h3> 3. 实现测试接口</h3>
<p>基于上面实例的ChatClient，我们来创建一个与大模型进行多轮对话的接口，这个实现与前面介绍的demo并无区别</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们访问接口，并输入内容，看看效果</p>
<figure><img src="/imgs/column/springai/04-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的截图中打印的大模型交互日志也可以看出，大模型会基于我们之前输入的内容进行多轮的沟通，并返回结果</p>
<p>因为默认的ChatMemory是基于内存的（ConcurrentHashMap），所以每次重启服务，都会丢失之前的对话内容，有兴趣的小伙伴可以试试</p>
<h3> 4. 会话隔离</h3>
<p>上面虽然实现了多伦对话，但是有一个比较大的问题，就是多个用户之间会话内容会相互干扰，比如用户A和用户B进行对话，用户B的会话内容会干扰用户A的会话内容，这显然是不符合实际需求的。</p>
<p>为了做好身份隔离，我们希望在记忆库中检索历史对话时，可以有一个区分，同样是借助 <code>advisor</code> 来实现</p>
<p>为了与上面的进行区分，我们调整一下ChatClient的初始化，对话角色可以由用户自由指定</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们创建一个会话隔离的接口，这个接口会根据用户ID进行会话隔离，即同一个用户ID的会话内容不会相互干扰</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/04-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的实现也可以看出，通过设置会话ID，实现了会话的隔离，用户A和用户B的会话内容不会相互干扰</p>
<h3> 5. ChatModel显示管理上下文</h3>
<p>上面介绍的是封装后的ChatClient，我们也可以直接使用<code>ChatModel</code>进行会话，显示管理上下文</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 其他Advisor</h3>
<p>上面介绍的是基于<code>MessageChatMemoryAdvisor</code>将ChatMemory注入到大模型，除此之外，SpringAI还内置了</p>
<ul>
<li><code>PromptChatMemoryAdvisor</code>: 区别于<code>MessageChatMemoryAdvisor</code>将多伦对话（包含内容、角色）返回给大模型，<code>PromptChatMemoryAdvisor</code>主要是将消息内容以文本的方式追加到系统提示词中</li>
<li><code>VectorStoreChatMemoryAdvisor</code>: 通过指定 <code>VectorStore</code> 实现管理会话记忆。每次交互时从向量存储检索历史对话，并以纯文本形式追加至系统（system）消息。</li>
</ul>
<p>还是根据一个实际的对比看看<code>MessageChatMemoryAdvisor</code>与<code>PromptChatMemoryAdvisor</code>的区别：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/04-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>系统提示词的文本内容如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的内容也可以看出，<code>PromptChatMemoryAdvisor</code>将多轮对话（包含内容、角色）拼接成文本的方式，放进了系统提示词中；从数据结构上看 <code>List&lt;Message&gt;</code> 只有两个，一个是System消息，一个是用户新加的User消息</p>
<h2> 二、小结</h2>
<p>本文主要从使用层面介绍了SpringAI中如何实现多伦对话，其中有几个关键概念</p>
<ul>
<li>ChatMemory: 会话记忆，SpringAI内置了基于内存的会话记忆，也可以基于其他数据源进行会话记忆，如向量存储、数据库、Redis等</li>
<li>ChatMemoryRepository：会话记忆的存储，SpringAI内置了基于内存的会话记忆存储，默认使用基于<code>ConcurrentHashMap</code>的会话记忆存储 <code>InMemoryChatMemoryRepository</code>
<ul>
<li>对于有持久化诉求的，可以考虑 <code>JdbcChatMemoryRepository</code>, <code>CassandraChatMemoryRepository</code>, <code>Neo4jChatMemoryRepository</code></li>
</ul>
</li>
<li>MessageWindowChatMemory：会话记忆的窗口</li>
<li>Advisor: 会话记忆的注入，SpringAI内置了多种会话记忆的注入方式，常见的有<code>MessageChatMemoryAdvisor</code>、<code>PromptChatMemoryAdvisor</code>、<code>VectorStoreChatMemoryAdvisor</code></li>
</ul>
<p>使用<code>ChatMemory</code>进行会话记忆时，推荐使用<code>ChatClient</code>方式，借助<code>Advisor</code>进行注入</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S04-chat-memory" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/04-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>05.自定义大模型接入</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/05.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/05.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">05.自定义大模型接入</source>
      <description>05.自定义大模型接入 SpringAI已经集成了很多主流大模型的交互，封装成starter供我们直接使用；比如前面几篇的demo使用的智普大模型，就是直接利用spring-ai-starter-model-zhipuai来进行大模型的交互 但总有例外，比如星火的免费模型Spark Lite(非免费的也没有😂)，在官方的教程中我们就没有找到可以直接使用的starter 接下来我们看一下，基于SpringAI，如果我们要接入一个自定义的大模型，可以怎么处理 一、大模型接入申请 首先是准备好大模型需要的信息(核心就是apiKey)</description>
      <category>SpringAI</category>
      <pubDate>Mon, 21 Jul 2025 14:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 05.自定义大模型接入</h1>
<p>SpringAI已经集成了很多主流大模型的交互，封装成starter供我们直接使用；比如前面几篇的demo使用的智普大模型，就是直接利用<code>spring-ai-starter-model-zhipuai</code>来进行大模型的交互</p>
<p>但总有例外，比如星火的免费模型Spark Lite(非免费的也没有😂)，在官方的教程中我们就没有找到可以直接使用的starter</p>
<p>接下来我们看一下，基于SpringAI，如果我们要接入一个自定义的大模型，可以怎么处理</p>
<h2> 一、大模型接入申请</h2>
<p>首先是准备好大模型需要的信息(核心就是apiKey)</p>
<h3> 1. 星火ApiKey申请</h3>
<p>注册、登录账号相关流程省略，请直接在官网自助完成</p>
<p>进入开放平台: <a href="https://console.xfyun.cn/services/cbm" target="_blank" rel="noopener noreferrer">https://console.xfyun.cn/services/cbm</a></p>
<figure><img src="/imgs/column/springai/05-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>选择 Spark Lite 模型，上图中因为我已经开通了；对于没有开通的场景，可以看到上图中 <code>领取无限量</code> 这个按钮是激活状态，点击之后对于已认证账号即可获取了（未认证的，直接跳转到认账账号进行认证，支持个人/企业认证）</p>
<p>领取之后，在右边的缱绻信息中，将 ApiPassword 复制出来待用</p>
<h3> 2. 阅读官方接口文档</h3>
<p>由于并不是所有的大模型的规范都一样，无法确保它们都能直接适配SpringAI的传入/传出，因此在后续的接入需要重点阅读官方接口文档，对大模型的交互进行适配</p>
<p>所以，我们这里就以星火模型为例，阅读官方接口文档，这里我们使用的是Spark Lite模型，文档地址为：<a href="https://www.xfyun.cn/doc/spark/HTTP%E8%B0%83%E7%94%A8%E6%96%87%E6%A1%A3.html" target="_blank" rel="noopener noreferrer">https://www.xfyun.cn/doc/spark/HTTP调用文档.html</a></p>
<h2> 二、项目创建</h2>
<p>项目创建方式与之前并无差别，创建一个SpringBoot项目，并引入SpringAI的依赖，有需要的小伙伴参考 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 依赖配置</h3>
<p>由于我们不直接使用官方的starter, 因此需要主动依赖SpringAI的一些核心包</p>
<p>在pom配置文件中添加</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置参数</h3>
<p>同样的，我们可以将大模型的一些参数，统一维护在<code>application.yml</code>配置文件中，关键的信息为 <code>api-key</code></p>
<p>关于配置的维护，我们可以直接参考官方提供的starter的实现（比如智普的starter）</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：本文以实现一个最基础的大模型交互为例，因此更多的参数相关组织配置，将留待后续的文章进行扩充实现；这里只介绍最核心的参数</p>
<h3> 3. 实现大模型接口</h3>
<p>对于自定义的大模型的接口实现，最最核心的，就是实现<code>ChatModel</code>接口，这个接口定义了模型交互的参数，以及模型交互的返回结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于这个<code>ChatModel</code>的实现，关键在于 <code>public ChatResponse call(Prompt prompt)</code> 这个方法的实现，其他的都非必须</p>
<p>对于<code>call(Prompt prompt)</code>方法，内部需要实现的就是和大模型的交互，以同步的http协议的方式，我们需要干的事情，就三个</p>
<ul>
<li>将 <code>prompt</code> 转换为大模型的传入参数</li>
<li>发起<code>http</code>请求</li>
<li>将大模型的返回对象封装为 <code>ChatResponse</code> 对象</li>
</ul>
<p>在上面的具体实现中，我们直接使用Spring的<code>restClient</code>作为http交互的工具(对于需要流式异步交互的场景，可以考虑WebClient)，麻烦的点(或者说脏活累活)就是请求返回的解析映射</p>
<p>对于此，我们定义一个<code>SparkPOJO</code>来保存讯飞大模型的返回结果；</p>
<p>如下面这个json为大模型的真实返回结果</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于上面的json，我们你定义的POJO，可以分为</p>
<ul>
<li><code>ChatCompletionChunk</code>对应完整的返回</li>
<li><code>Choice</code> 对应大模型返回结果中的<code>choices</code>数组，<code>SparkMsg</code>对应choices数组中的message元素；</li>
<li><code>Usage</code> 对应大模型返回结果中的<code>usage</code>元素</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义 <code>POJOConvert</code> 来实现请求返回的对象转换为 <code>ChatResponse</code></p>
<ul>
<li><code>List&lt;Generation&gt;</code> 生成的结果
<ul>
<li>ChatGenerationMetadata： 返回的元数据</li>
<li>AssistantMessage：包含具体返回的文本</li>
</ul>
</li>
<li><code>ChatResponseMetadata</code>: 返回的元数据</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 大模型使用示例</h3>
<p>上面完成了自定义大模型的交互，接下来我们试试效果；使用方法基本上和前面介绍的没有任何区别</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/05-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、小结</h2>
<p>本文通过非官方提供的start，实现了一个自定义大模型的接入过程，其核心关键在于 <code>ChatModel</code> 接口的实现，小结一下自定义大模型接入的关键点</p>
<ul>
<li>继承 <code>ChatModel</code> 接口，实现 <code>ChatModel</code> 接口的 <code>call</code> 方法，返回 <code>ChatResponse</code> 对象</li>
<li>实现SpringAI定义的<code>Prompt</code>对象转大模型传参</li>
<li>实现大模型的返回结果转 <code>ChatResponse</code></li>
</ul>
<p>本文仅作为参考，目前只实现了基础的大模型聊天问答，接下来我们将介绍了SpringAI的更多高级功能（比如Function tool工具调用, 多模态, MCP, RAG等）；</p>
<p>同时也会在介绍这些高级功能时 ，给出自定义的大模型接入的相关能力扩展，辅助加深理解。</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S05-self-model" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/05-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>06.工具调用 FunctionCalling</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/06.%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8FunctionCalling.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/06.%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8FunctionCalling.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">06.工具调用 FunctionCalling</source>
      <description>06.工具调用 FunctionCalling 我们知道大模型是基于一系列数据进行训练的，且每次训练的成本很高；那么大模型是怎么样表现得十八般武艺样样精通的呢？ function calling就是设计出来给大模型当外挂的瑞士工具包，通过给大模型设计一个与外部工具进行交互的方式，来扩展大模型在训练时缺失或者不够与时俱进的能力 一、工作原理 SpringAi 提供了完备工具调用封装，可以非常方便的将本地方法封装成工具，供大模型调用 1. 工具调用流程 Spring AI工具调用流程</description>
      <category>SpringAI</category>
      <pubDate>Mon, 28 Jul 2025 08:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 06.工具调用 FunctionCalling</h1>
<p>我们知道大模型是基于一系列数据进行训练的，且每次训练的成本很高；那么大模型是怎么样表现得十八般武艺样样精通的呢？</p>
<p>function calling就是设计出来给大模型当外挂的瑞士工具包，通过给大模型设计一个与外部工具进行交互的方式，来扩展大模型在训练时缺失或者不够与时俱进的能力</p>
<h2> 一、工作原理</h2>
<p>SpringAi 提供了完备工具调用封装，可以非常方便的将本地方法封装成工具，供大模型调用</p>
<h3> 1. 工具调用流程</h3>
<figure><img src="/imgs/column/springai/06-1.webp" alt="Spring AI工具调用流程" tabindex="0" loading="lazy"><figcaption>Spring AI工具调用流程</figcaption></figure>
<p>工具调用流程如下：</p>
<ol>
<li>在向大模型发起请求时，将工具信息传递给大模型
<ul>
<li>每个工具的定义都包含名称、描述、输入参数</li>
</ul>
</li>
<li>大模型根据工具信息，会发送包含工具名称、亲求参数的请求给工具服务</li>
<li>应用程序根据工具名称，识别到对应的工具，调用工具方法</li>
<li>工具执行结果返回给应用程序进行处理（可能是直接返回给用户，也可能是返回给大模型）</li>
<li>应用程序将工具执行结果返回给大模型</li>
<li>大模型利用工具返回的结果，构建返回结果给用户</li>
</ol>
<h3> 2. SpringAI关键实现</h3>
<p>SpringAI主要提供了两种内置方式将本地方法封装成工具</p>
<ul>
<li>声明式：通过注解 <code>@Tool</code></li>
<li>编程式：通过底层的 <code>MethodToolCallback</code> <code>FunctionToolCallback</code></li>
</ul>
<figure><img src="/imgs/column/springai/06-2.webp" alt="https://java2ai.com/docs/dev/tutorials/function-calling/" tabindex="0" loading="lazy"><figcaption><a href="https://java2ai.com/docs/dev/tutorials/function-calling/" target="_blank" rel="noopener noreferrer">https://java2ai.com/docs/dev/tutorials/function-calling/</a></figcaption></figure>
<p>上图中橙色的部分，就是SpringAI将我们本地方法封装成工具，供大模型进行交互；接下来我们看一下SpringAI的关键类</p>
<h4> a. ToolCallback</h4>
<p>ToolCallback 接口提供了定义 AI 模型可调用工具的方式，包含工具定义和执行逻辑。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SpringAI提供了两种内置实现</p>
<ul>
<li>MethodToolCallback: 将本地方法定义为AI模型可调用的工具</li>
<li>FunctionToolCallback: 将函数定义为AI模型可调用的工具</li>
</ul>
<h4> b. ToolDefinition</h4>
<p>ToolDefinition 接口提供 AI 模型识别工具可用性所需的信息，包括工具名称、描述及输入模式。每个 ToolCallback 实现必须提供 ToolDefinition 实例来定义工具。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>若需要手动创建的工具定义，可以使用<code>ToolDefinition.Builder</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了上面的方式，对于本地java方法，可以直接通过反射的方式来生成基于方法的工具定义</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> c. JSON Schema</h4>
<p>向 AI 模型提供工具时，模型需要知道工具调用输入类型的模式，Spring AI 通过 JsonSchemaGenerator 类内置支持生成工具输入类型的 JSON Schema</p>
<p>下面是一个json schema的示例（在前面<a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/03.%E7%BB%93%E6%9E%84%E5%8C%96%E8%BF%94%E5%9B%9E.html" target="blank">结构化返回</a>中，实际上也用到了 JSON Schema，用于告知大模型如何返回我们希望格式的数据）</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的json schema主要用于方法/函数调用的传参定义，SpringAI内置支持下面四种基于注解升成输入参数描述、是否必传</p>
<ul>
<li><code>Spring AI</code> 的 <code>@ToolParam(description = "…", required=false)</code>： 参数描述 + 是否必传</li>
<li><code>Jackson</code> 的 <code>@JsonClassDescription(description = "…)</code>: 参数描述</li>
<li><code>Jackson</code> 的 <code>@JsonPropertyDescription(description = "…")</code> : 参数描述</li>
<li><code>Jackson</code> 的 <code>@JsonProperty(required = false)</code> : 参数是否必传</li>
<li><code>Swagger</code> 的<code> @Schema(description = "…", required = false)</code> ： 参数描述 + 是否必传</li>
<li><code>Spring</code> 的 <code>@Nullable</code> ： 参数是否必传</li>
</ul>
<p>示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> d. 结果转换</h4>
<p>通常方法/函数返回的是Object对象，需要转换给大模型使用，SpringAI定义<code>ToolCallResultConverter</code>对返回进行序列化，实现将返回结果转换为String对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SpringAI默认的结果转换为基于Jackson的json序列化（<code>DefaultToolCallResultConverter</code>），当然如果你喜欢，也可以换成gson、fastjson或者自定义的转换实现</p>
<h4> e. ToolContext</h4>
<p>Spring AI 支持通过 <code>ToolContext</code> API向工具传递额外的上下文信息，ToolContext 中的数据由用户调用 ChatClient 时提供。后面的使用示例会进行案例介绍</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ToolContext的实现也非常简单，一个不可变对象Map来承接工具调用上下文数据</p>
<h2> 二、使用示例</h2>
<h3> 1. 项目创建</h3>
<p>项目创建方式与之前并无差别，创建一个SpringBoot项目，并引入SpringAI的依赖，有需要的小伙伴参考 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<p>在pom中添加相关依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们这里使用智谱的免费大模型，虽然免费但它依然支持工具调用（请注意，并不是所有的模型都支持工具调用的，在使用之前到官方的说明确认是否支持）</p>
<h3> 2. 声明式使用方式</h3>
<p>我们定义一个简单、基础可用的工具方法，主要用于获取当前时间，核心点就是在方法上添加注解 <code>@Tool</code></p>
<ul>
<li>注解的 description 属性非常重要，用于知道模型判断何时调用这个工具；当描述不够清晰时，可能导致模型在该调用工具时没有调用，或者调用错了工具</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于使用 <code>ChatClient</code> 来使用工具调用，就非常简单了，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面有提供了两个接口， getTime 接口使用了工具，getTimeNoTools 接口没有使用工具；使用方式形如</p>
<ul>
<li><code>chatClient.prompt().tools(xxx)</code>：通过tools方法注入工具</li>
</ul>
<p>接下来我们看一下表现情况</p>
<figure><img src="/imgs/column/springai/06-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p>说明：虽然上面的访问对比中，在请求 <code>time</code> 接口时，正确的返回了时间，但是大模型并不总是和我们预期的一致，同样的提问，它有时不会主动调用我们注入的工具</p>
</blockquote>
<h3> 3. 带参数的工具方法</h3>
<p>前面定义的工具没有参数，接下来我们在看一下带参数的工具方法</p>
<p>在方法参数上，可以通过 <code>@ToolParam</code> 注解对参数进行解释说明（这个注解是非必填的）,注解内有两个属性</p>
<ul>
<li><code>description</code>：参数描述，用于帮助模型更准确地理解如何使用该参数。例如：参数格式要求、允许取值范围等。</li>
<li><code>required</code>：指定参数是否为必需项（默认值：<code>true</code>，即所有参数默认必需）。</li>
</ul>
<p>比如我现在定义一个返回不同时区的当前时间的工具，供大模型调用，参数是时区，同样放在 <code>DateTimeTools</code> 类中，这样就可以直接使用上面的api</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/06-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的访问示例也可以看出，我们询问某个地区的时间时，大模型会自动根据地区找到时区，然后调用我们的工具返回结果</p>
<p>但是一个问题来了，直接问时间时，它不会调用我们之前定义的那个方法，返回时间，这是为什么呢？</p>
<p>我们尝试调整一下，之前定义获取当前时间的工具方法说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再多问几次，你就会发现大模型会主动调用我们定义的这个方法，返回时间（但是并不能始终保证它总是表现正确）</p>
<ul>
<li>所以一个何时的、精确的工具描述，对于大模型的决策是否调用，非常重要</li>
</ul>
<figure><img src="/imgs/column/springai/06-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 添加默认工具</h3>
<p>上面介绍的是在用户发起对话时，设置Prompt时指定工具调用，同样的，SpringAI也提供了默认工具的设置方式，在<code>ChatClient</code>创建时，指定默认的工具，这样只要用这个<code>ChatClient</code>进行对话，这些工具都会提供给大模型，而不在需要单独进行设置</p>
<p>使用方式形如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个就不做具体的演示了，没有什么特殊的地方</p>
<h3> 5. ChatModel 添加工具</h3>
<p>如果某些场景下，我们不是通过<code>ChatClent</code>而是直接借助<code>ChatModel</code>进行对话，同样也可以添加工具，通过 ChatOptions 来实现</p>
<p>具体的使用姿势如下，借助<code>ToolCallbacks</code>来获取工具集，借助<code>ToolCallingChatOptions</code>来添加工具集</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 编程式使用方式</h3>
<p>前面介绍的都是基于<code>@Tool</code>注解的声明式定义工具，这种适用于工具实现完全由我们掌控的场景；对于一些非控制的工具实现（如三方sdk），或者需要动态获取工具参数的场景，我们可以使用编程式定义工具</p>
<p>编程式的使用方式，主要是借助<code>MethodToolCallback.Builder</code>来构建我们需要的<code>MethodToolCallback</code></p>
<p>使用这种方式时，需要重点看一下前面第一节的内容，<code>ToolCallback</code> <code>ToolDefinition</code>的类结构定义，清楚之后，再看下面的参数设置就会更轻轻松（也知道为什么要这么实现）</p>
<ul>
<li><code>toolDefinition</code>：定义工具名称、描述及输入模式的 <code>ToolDefinition</code> 实例（必需项）
<ul>
<li>可通过 <code>ToolDefinition.Builder</code> 类构建。</li>
</ul>
</li>
<li><code>toolMetadata</code>: 定义额外设置的 <code>ToolMetadata</code> 实例，非必需
<ul>
<li>可通过 <code>ToolMetadata.Builder</code> 类构建</li>
<li>returnDierect<code>: 是否直接返回结果（默认为 </code>false`），为true时表示直接将结果返回给用户、而不是给大模型进行调用</li>
</ul>
</li>
<li><code>toolMethod</code>: 工具方法的<code>Method</code>实例 （必需项）</li>
<li><code>toolObject</code>: 包含工具方法的对象实例（若方法为静态方法则可省略此参数）</li>
<li><code>toolCallResultConverter</code>：用于将工具调用结果转换为 <code>String</code> 对象并返回 AI 模型
<ul>
<li><code>ToolCallResultConverter</code> 实例（未配置时默认使用 <code>DefaultToolCallResultConverter</code>）。</li>
</ul>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在使用方法工具时，需要注意一些限制</p>
<p>以下类型目前不支持作为工具方法的参数或返回类型：</p>
<ul>
<li>Optional</li>
<li>异步类型（如 CompletableFuture、Future）</li>
<li>响应式类型 （如 Flow、Mono、Flux）</li>
<li>函数式类型（如 Function、Supplier、Consumer）</li>
</ul>
<h3> 7. 函数作为工具调用的使用示例</h3>
<p>到现在为止，我们都是将方法作为工具给大模型进行调用，在java8+之后，除了方法还有些函数式接口，比如<code>Function</code>、<code>Consumer</code>、<code>Supplier</code>、<code>Predicate</code>等，这些函数式接口也可以作为工具进行调用，使用方式如下：</p>
<p>通过 <code>FunctionToolcallback</code> 来将函数式类型，转换为工具</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体的使用方式，和上面介绍的方法的编程式相差不大，但是有一个需要格外注意的事项</p>
<ul>
<li>函数输入和输出可以是 Void 或 POJO。输入和输出的 POJO 必须是可序列化的，因为结果将被序列化并发送回模型。</li>
<li>函数及输入输出类型必须是 public 的。</li>
</ul>
<p>以下类型目前不支持作为工具函数的输入或输出类型：</p>
<ul>
<li>基本类型</li>
<li>Optional</li>
<li>集合类型 （如 List、Map、Array、Set）</li>
<li>异步类型（如 CompletableFuture、Future）</li>
<li>响应式类型（如 Flow、Mono、Flux）</li>
</ul>
<h3> 8. 动态范式 @Bean</h3>
<p>这种类似于声明式的函数工具，Spring AI 通过 <code>ToolCallbackResolver</code> 接口（SpringBeanToolCallbackResolver具体实现），在运行时动态解析</p>
<p>可以将任意 <code>Function</code>、<code>Supplier</code>、<code>Consumer</code> 或 <code>BiFunction</code> 类型的 <code>Bean</code> 作为工具使用。</p>
<ul>
<li><code>Bean</code> 名称将作为工具名称`</li>
<li><code>Spring Framework</code> 的 <code>@Description</code> 注解提供工具描述</li>
</ul>
<p>实测，没有成功，待后续确认这个逻辑是否和官网说的一致</p>
<h2> 三、小结</h2>
<p>本篇文章主要介绍了SpringAI如何定义、使用工具调用，包括方法工具/函数工具两类，有基于@Tool注解的声明式，也有借助 <code>MethodToolCallback</code> 和 <code>FunctionToolCallback</code> 实现的编程式</p>
<p>在工具的定义上，我们需要额外关注工具的描述，传参和返回；其中传参是通过 <code>Json Schema</code> 的形式给到的大模型</p>
<p>默认行为时，Spring AI 会自动拦截模型的工具调用请求，执行工具并将结果返回模型。这些操作均由各 ChatModel 实现通过 ToolCallingManager 透明完成，如下图</p>
<figure><img src="/imgs/column/springai/06-6.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol>
<li>当需要向模型提供工具时，我们将其定义包含在聊天请求（Prompt）中，并调用 ChatModel API 将请求发送至 AI 模型。</li>
<li>当模型决定调用工具时，它会发送包含工具名称及符合定义模式的输入参数的响应（ChatResponse）。</li>
<li>ChatModel 将工具调用请求发送至 ToolCallingManager API。</li>
<li>ToolCallingManager 负责识别需调用的工具并使用提供的输入参数执行该工具。</li>
<li>工具调用结果返回至 ToolCallingManager。</li>
<li>ToolCallingManager 将工具执行结果返回给 ChatModel。</li>
<li>ChatModel 将工具执行结果返回AI模型（ToolResponseMessage）。</li>
<li>AI 模型利用工具调用结果作为附加上下文生成最终响应，并通过 ChatClient 将其返回调用方（ChatResponse）。</li>
</ol>
<p>目前与模型交互的工具执行，是由SpringAI托管的，内部的工具选择等逻辑对用户是不透明的，当然也可以通过将 <code>ToolCallingChatOptions</code> 的 <code>internalToolExecutionEnabled</code> 属性设为 <code>false</code>，来实现自行控制工具执行的生命周期；这块的内容，将在下一章节进行介绍</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S06-function-tool" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/06-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>07.实现一个查询不同时区当前时间的MCP Server</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/07.%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84McpServer.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/07.%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84McpServer.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">07.实现一个查询不同时区当前时间的MCP Server</source>
      <description>07.实现一个查询不同时区当前时间的MCP Server MCP可以说是25年最火的协议来了，MCP（Model Context Protocol，模型上下文协议）是由 Anthropic 公司于 2024 年底开源的标准化通信协议，旨在解决大模型与外部工具、数据源之间的碎片化集成问题，被誉为 “AI 领域的 USB-C 接口”。 其核心作用是通过统一的协议规范，让大模型（如 Claude、GPT-4、LLaMA 等）能够安全、高效地连接任意工具和数据，而无需为每个系统单独开发适配代码 一、MCP简介 在正式创建一个MCP Server之前，我们先了解一下mcp的相关概念</description>
      <category>SpringAI</category>
      <pubDate>Mon, 28 Jul 2025 11:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 07.实现一个查询不同时区当前时间的MCP Server</h1>
<p>MCP可以说是25年最火的协议来了，MCP（Model Context Protocol，模型上下文协议）是由 Anthropic 公司于 2024 年底开源的标准化通信协议，旨在解决大模型与外部工具、数据源之间的碎片化集成问题，被誉为 “AI 领域的 USB-C 接口”。</p>
<p>其核心作用是通过统一的协议规范，让大模型（如 Claude、GPT-4、LLaMA 等）能够安全、高效地连接任意工具和数据，而无需为每个系统单独开发适配代码</p>
<h2> 一、MCP简介</h2>
<p>在正式创建一个MCP Server之前，我们先了解一下mcp的相关概念</p>
<h3> 1.1 MCP是什么</h3>
<blockquote>
<p>MCP （Model Context Protocol，模型上下文协议），它提供了一个通用的开放标准，用于将 AI 系统与数据源连接起来，用单一协议取代碎片化的集成。结果是一种更简单、更可靠的方法，使 AI 系统能够访问所需的数据。这是一种将 AI 助手连接到数据所在的系统（包括内容存储库、业务工具和开发环境）的新标准。其目的是帮助前沿模型产生更好、更相关的响应。</p>
</blockquote>
<p>简单来讲，mcp就是定义了标准，对于所有希望给大模型提供能力的小伙伴来说，只要按照这个标准完成能力封装，那么大模型就可以直接加载这些能力从而实现某些特定的功能。</p>
<p>举一个例子，usb大家应该都不陌生，如果你只买一个台式机主机，这个时候你会发现我除了按它的开关按钮之外，好像什么也干不了。然后我买了键盘、鼠标、显示器、摄像头等外设，然后通过usb接口插上之后就可以操作电脑了，电脑是怎么识别这些外接设备（键盘、鼠标、摄像头等）的呢？ 这就是usb协议的作用了，外接设备和电脑，都遵循usb协议，然后大家就可以在同一个频道进行交流了；同样的MCP就是为了干这件事情，让大模型和给大模型提供增强能力的服务能同频进行交流</p>
<figure><img src="/imgs/column/springai/07-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 1.2 MCP总体架构</h3>
<p>MCP遵循客户端-服务端（CS）的架构，一个主机可以连接多个MCP服务端</p>
<figure><img src="/imgs/column/springai/07-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的描述和整体架构图，可以看到在MCP的架构中，有三个重要的角色</p>
<ul>
<li>MCP Hosts(MCP主机)： 通过mcp协议获取数据的程序（比如 Claude Desktop, IDE 或者 ai工具）</li>
<li>MCP Clients(MCP客户端): mcp协议客户端，作为调用者，通常与mcp服务端是成对出现，用于连接mcp server，实现双方通信</li>
<li>MCP Servers(MCP服务端): mcp协议服务端，作为提供者，实现MCP协议提供特定的功能</li>
</ul>
<p>除了上面三个角色之外，在架构图中，还有两个</p>
<ul>
<li>Local Data Sources: MCPServer所在的计算机上本地的资源信息，如文件、数据库、应用服务等，即MCP通过操作(读取、访问、写入等)这些本地资源来提供特定能力</li>
<li>Remote Service: MCPServer通过调用远程的服务来提供能力</li>
</ul>
<h3> 1.3 MCP工作原理</h3>
<p>mcp只是一个协议，和http协议一样，本身不直接提供能力或者服务，我们能实际感知到的服务表现只是协议上层的应用封装</p>
<p>比如http协议，常见的工作流程是我们打开浏览器，点开网页，通过http协议访问到对应的后台服务器，然后对方将网页信息传输到我们的浏览器上展示为可视化的网页内容，从而实现信息的曝光</p>
<p>那么mcp协议是怎么工作的呢？</p>
<ol>
<li>用户通过客户端发起提问</li>
<li>客户端将问题传递给 LLM</li>
<li>LLM 分析并选择合适的工具</li>
<li>通过 MCP 协议向服务端发送工具执行指令</li>
<li>工具执行后结果返回给 LLM</li>
<li>LLM 生成最终回复</li>
<li>回复通过客户端展示给用户</li>
</ol>
<figure><img src="/imgs/column/springai/07-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 1.4 SpringAI MCP 实现</h3>
<p>SpringAI提供了MCP的Client/Server的集成，对于上层业务而言，要想实现一个MCP Server/Client比较简单</p>
<p><strong>MCP客户端</strong></p>
<p>MCP 客户端是 Model Context Protocol（MCP）架构的核心组件，负责建立并管理与 MCP 服务器的连接。它实现协议的客户端逻辑，主要处理以下功能：</p>
<ul>
<li>协议版本协商以确保与服务器的兼容性</li>
<li>功能协商以确定可用特性</li>
<li>消息传输及 JSON-RPC 通信</li>
<li>工具发现与执行</li>
<li>资源访问与管理</li>
<li>提示词系统交互</li>
<li>可选功能
<ul>
<li>根目录管理</li>
<li>采样支持</li>
</ul>
</li>
<li>同步与异步操作</li>
<li>传输协议选项：
<ul>
<li>基于 Stdio 的进程间通信传输协议</li>
<li>基于 Java HttpClient 的 SSE 客户端传输协议</li>
<li>WebFlux SSE 客户端传输协议（用于响应式 HTTP 流式通信）</li>
</ul>
</li>
</ul>
<figure><img src="/imgs/column/springai/07-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>MCP服务端</strong></p>
<p>MCP 服务器是 Model Context Protocol（MCP）架构的基础组件，用于向客户端提供工具、资源和功能。它实现协议的服务端逻辑，主要职责包括：</p>
<ul>
<li>服务端协议操作的实现
<ul>
<li>工具暴露与发现</li>
<li>基于 URI 的资源管理及访问</li>
<li>提示（Prompt）模板的提供与处理</li>
<li>与客户端的功能协商</li>
<li>结构化日志记录与通知</li>
</ul>
</li>
<li>并发客户端连接管理</li>
<li>同步与异步 API 支持</li>
<li>传输协议实现：
<ul>
<li>基于 Stdio 的进程间通信传输协议</li>
<li>基于 Servlet 的 SSE 服务器传输协议</li>
<li>WebFlux SSE 服务器传输协议（用于响应式 HTTP 流式通信）</li>
<li>WebMVC SSE 服务器传输协议（用于基于 Servlet 的 HTTP 流式通信）</li>
</ul>
</li>
</ul>
<figure><img src="/imgs/column/springai/07-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、创建一个MCP Server</h2>
<p>接下来我们进入正文，如何创建一个MCP Server，并且让我们的大模型能够访问这个MCP Server</p>
<h3> 1. 项目创建</h3>
<p>项目创建方式与之前并无差别，创建一个SpringBoot项目，并引入SpringAI的依赖，有需要的小伙伴参考 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 依赖配置</h3>
<p>在pom配置文件中需要添加核心的依赖，这里是 <code>spring-ai-starter-mcp-server-webmvc</code></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在<code>application.yml</code>配置文件中，设置MVC Server的相关参数 (下面基本都是默认配置)</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点参数说明：</p>
<ul>
<li>sse-endpoint: 用于 <code>Web</code> 传输的自定义 <code>SSE</code> 端点路径，MCP Client主要连接的就是这个端点</li>
<li>sse-message-endpoint: 客户端用于发送消息的端点路径,如后续大模型调用工具时，走的就是这个端点</li>
<li>type: 服务器类型（同步/异步）</li>
</ul>
<h3> 2. 创建一个MCP Server</h3>
<p>对于SpringAI而言，创建MCP Server和Function calling有点相似，也是通过 <code>@Tool</code> 注解将方法声明为工具，区别是一个作为mcp的工具，一个是作为function calling的回调方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后将这个工具注册为MCP工具暴露给大模型</p>
<p>SpringAI的自动配置将检测并注册来自以下组件的所有工具回调</p>
<ul>
<li>独立的 ToolCallback Bean</li>
<li>ToolCallback Bean 列表</li>
<li>ToolCallbackProvider Bean</li>
</ul>
<p>工具按名称去重，每个工具名称仅保留首次出现的实例，如下创建一个<code>ToolCallbackProvider</code>的 <code>@Bean</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 启动项目</h3>
<p>启动项目，访问<a href="http://localhost:8080/sse" target="_blank" rel="noopener noreferrer">http://localhost:8080/sse</a>, 可以看到MCP Server已经启动了</p>
<figure><img src="/imgs/column/springai/07-6.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. Trae配置MCP</h3>
<p>接下来我们使用Trae来连接上面实现的mcp server，并使用mcp server提供的工具</p>
<p>以 TraeCN 2.0 为例，下面介绍下具体的配置过程</p>
<figure><img src="/imgs/column/springai/07-7.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>需要贴在trae中的mcp server的json配置如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再来访问看看实际的效果</p>
<figure><img src="/imgs/column/springai/07-8.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>大模型准确的调用了我们刚才创建的MCPServer，分别返回了伦敦和巴黎的时间</p>
<h3> 5. 小结</h3>
<p>到这里我们已经实现了一个功能齐备的MCPServer，整体的代码实现非常简单，在需要作为MCP工具的，在方法上添加<code>@Tool</code>注解，然后借助创建<code>ToolCallbackProvider</code>将这些工具注册出来即可</p>
<p>本文介绍的是MCP通过http sse实现的，创建MCP Server的实现方式有很多种，这里只是介绍最简单的一种web同步请求，且没有权限管控</p>
<p>在创建一个生成可用的mcp server，目前还缺一个非常关键的认证机制，这个会在接下来的文章进行说明</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S07-mcp-server" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/07-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>08.MCPServer简单鉴权的实现</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/08.MCP%20Server%E7%AE%80%E5%8D%95%E9%89%B4%E6%9D%83%E7%9A%84%E5%AE%9E%E7%8E%B0.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/08.MCP%20Server%E7%AE%80%E5%8D%95%E9%89%B4%E6%9D%83%E7%9A%84%E5%AE%9E%E7%8E%B0.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">08.MCPServer简单鉴权的实现</source>
      <description>08.MCPServer简单鉴权的实现 上面一篇 实现一个简单的McpServer 带大家构建了一个自己的McpServer，其功能非常简单，接下来我们尝试逐步进行补全，我们下来看一下，如何给其加上权限管控，避免服务被白嫖 一、MCP Server搭建</description>
      <category>SpringAI</category>
      <pubDate>Mon, 28 Jul 2025 14:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 08.MCPServer简单鉴权的实现</h1>
<p>上面一篇 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/07.%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84McpServer.html" target="blank">实现一个简单的McpServer</a> 带大家构建了一个自己的McpServer，其功能非常简单，接下来我们尝试逐步进行补全，我们下来看一下，如何给其加上权限管控，避免服务被白嫖</p>
<h2> 一、MCP Server搭建</h2>
<p>我们直接在前面的搭建的McpServer基础上进行能力扩展，因此整个项目的搭建和相关配置与上文一致，这里不再赘述过程，只贴下核心的信息</p>
<h3> 1. 项目配置</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置文件指定mcp server相关参数：<code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. MCP Server创建</h3>
<p>一个根据传入时区，返回对应的时间的工具</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、权限管控</h2>
<h3> 1. 权限管理</h3>
<p>我们这里直接采用Http的权限管控，即在请求头中添加<code>Authorization</code>字段，值为<code>Bearer &lt;token&gt;</code> 或者 <code>Basic &lt;user:password&gt;</code>方式</p>
<p>为了针对MCP Server的权限进行管理，我们考虑通过自定义的<code>Filter</code>来实现，具体的逻辑为：</p>
<ul>
<li>拦截 <code>/sse</code>, <code>/mcp/messages</code>请求</li>
<li>校验请求头中的<code>Authorization</code>字段，判断是否满足要求</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的实现中，注意两点：</p>
<ul>
<li>注解<code>@WebFilter</code>，表示这是一个过滤器，并且异步支持（这个异步支持必须开启，否则mcp客户端无法正常连接）</li>
<li>拦截的url为<code>/sse</code>或者<code>/mcp/messages</code>: 这里我们分别处理sse请求和mcp请求，将他们与其他的请求区分开
<ul>
<li>鉴权逻辑：从请求头中获取<code>Authorization</code>字段，判断是否满足要求</li>
</ul>
</li>
</ul>
<p>然后调整启动类，支持扫描自定义的过滤器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. Trae调整MCP配置</h3>
<p>因为添加了权限管控，所以需要调整MCP的配置，在之前的基础上，加一个请求头</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来走一个验证对比，分别是没有添加权限的以及加了权限管控的</p>
<figure><img src="/imgs/column/springai/08-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>说明：如果是用户名+密码的鉴权方式，则可以将上面json配置中的 <code>Authorization</code>相关内容替换为:</p>
<ul>
<li><code>"Authorization": "Basic eWlodWk6MTIzNDU2Nzg="</code></li>
<li><code>eWlodWk6MTIzNDU2Nzg=</code> 为用户名密码的base64编码，解码之后为 <code>yihui:12345678</code></li>
</ul>
<h3> 3. 小结</h3>
<p>这里我们实现了一个简单的权限管控，通过自定义的过滤器来实现，具体的逻辑为：</p>
<ul>
<li>拦截 <code>/sse</code>, <code>/mcp/messages</code>请求</li>
<li>校验请求头中的<code>Authorization</code>字段，判断是否满足要求</li>
<li>添加权限的MCP配置</li>
</ul>
<p>当然，这里只是简单的实现，实际生产中，我们可以通过数据库来实现权限的存储和查询，也可以通过其他方式来实现权限的验证，例如通过JWT+OAuth2.0的方式来实现；不管是哪种方式，核心的原理依然是web应用鉴权这一套，无非是应用的场景不同，一个是web用户、一个是mcp客户端而已</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S08-mcp-server-basic-auth" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/08-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>09.ChatClient使用说明</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/09.ChatClient%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/09.ChatClient%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">09.ChatClient使用说明</source>
      <description>09.ChatClient使用说明 SpringAI中，ChatModel作为与大模型交互的具体实现，更上一层的应用推荐则是使用ChatClient，特别是在结构化输出、多轮对话的场景，ChatClient提供了更方便的调用方式 如结构化输出，两者的写法对比如下 // 结构化返回场景: // chatModel方式 BeanOutputConverter&amp;lt;ActorsFilms&amp;gt; beanOutputConverter = new BeanOutputConverter&amp;lt;&amp;gt;(ActorsFilms.class); String format = beanOutputConverter.getFormat(); PromptTemplate template = new PromptTemplate(&amp;quot;&amp;quot;&amp;quot; 帮我返回五个{actor}导演的电影名 {format} &amp;quot;&amp;quot;&amp;quot;); Prompt prompt = template.create(Map.of(&amp;quot;actor&amp;quot;, actor, &amp;quot;format&amp;quot;, format)); Generation generation = chatModel.call(prompt).getResult(); if (generation == null) { return null; } return beanOutputConverter.convert(generation.getOutput().getText()); // ChatClient方式 PromptTemplate template = new PromptTemplate(&amp;quot;帮我返回五个{actor}导演的电影名，要求中文返回&amp;quot;); Prompt prompt = template.create(Map.of(&amp;quot;actor&amp;quot;, actor)); ActorsFilms films = ChatClient.create(chatModel).prompt(prompt).call().entity(ActorsFilms.class);</description>
      <category>SpringAI</category>
      <pubDate>Fri, 01 Aug 2025 18:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 09.ChatClient使用说明</h1>
<p>SpringAI中，<code>ChatModel</code>作为与大模型交互的具体实现，更上一层的应用推荐则是使用<code>ChatClient</code>，特别是在结构化输出、多轮对话的场景，<code>ChatClient</code>提供了更方便的调用方式</p>
<p>如结构化输出，两者的写法对比如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 一、基本使用</h2>
<h3> 1. 创建ChatClient</h3>
<p><strong>使用自动配置的<code>ChatClient.Builder</code></strong></p>
<p>如果你的项目中，只有一个大模型使用，且使用的是官方提供的<code>starter</code>进行的接入，那么你可以直接使用SpringBoot自动装配的<code>ChatClient.Builder</code>来创建<code>ChatClient</code></p>
<p>如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，请注意，当一个应用中需要使用多个聊天模型时，则不能使用上面这种方式了，因为很难知道底层到底用的是哪个模型，此时则建议使用<code>ChatModel</code>进行创建</p>
<p><strong>使用ChatModel创建ChatClient</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. OpenAI兼容API的客户端初始化方式</h3>
<p>借助 <code>OpenAiApi</code> 与 <code>OpenAiChatModel</code> 类提供的 mutate() 方法，来实现兼容OpenAI API 的调用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 提示词传入</h3>
<p>创建<code>ChatClient</code>时，需要传入的<code>Prompt</code>对象用于和大模型进行交互，提供了三种方式</p>
<p><strong>直接接收String</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这种表示传入的文本，作为用户消息传送给大模型</p>
<p><strong>接收Prompt对象</strong></p>
<p>直接接收<code>Prompt</code>对象，具体的交互信息封装在<code>Prompt</code>对象中，由用户来管控</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>Fluent式</strong></p>
<p>通过无参方式启动FluentAPI，支持逐步构建系统消息、用户消息提示词</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 响应</h3>
<p>AI 模型返回的 <code>ChatResponse</code> 对象，封装了模型返回的 <code>Generation</code> 对象，以及一些元数据、token统计</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如我们希望获取用户的token情况，则可以在元数据中获取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>获取返回的消息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结构化输出，如需将返回的String映射为实体类，则可以考虑使用 <code>entity()</code> 来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/09-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>当然，前面介绍的结构化输出时，也提到了可以借助 <code>ParameterizedTypeReference</code> 来实现泛型等复杂类型的指定，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/09-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 流式调用</h3>
<p>流式调用，前面介绍的通过<code>call</code>方法实现同步请求大模型，等待模型返回结果，然后进行结果处理。我们平时使用大模型时，更常见的是流式的交互方式，问一个问题，对方一点一点的返回结果</p>
<p>对于<code>ChtClient</code>而言，要想实现流式调用，则需要借助<code>stream()</code>方法，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>访问示例如下：</p>
<figure><img src="/imgs/column/springai/09-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、进阶使用</h2>
<h3> 1. 提示词模板</h3>
<p><code>ChatClient</code> <code>Fluent</code> 式 API 支持提供含变量的用户/系统消息模板，运行时进行替换。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>默认使用的是 <code>{}</code> 的模板变量替换，当然如果你有诉求，想用 <code>&lt;&gt;</code> 进行替换（如提示词中包含json时，<code>{}</code>的方式可能不太适合了），可以如下进行调整</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. stream结构化返回</h3>
<p>使用 <code>call()</code> 同步调用时，结构化输出比较简单，直接通过 <code>entity()</code> 方法传入对象类型即可；对于流式的场景，由于大模型是逐步返回的，没有获取到完整的内容直接转换为目标对象，基本就是序列化异常了</p>
<p>对于 <code>stream</code> 方式，需要接过话输出时，可以考虑使用下面的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 默认值</h3>
<p>我们可以在<code>ChatClient</code>创建时，使用一些默认的系统消息、提示词设置（通过 <code>defaultXxx</code> 的方式）</p>
<p>如下面给出了提供默认的消息提示词（支持带参数） 和默认的模型参数设置</p>
<ul>
<li>说明：默认的配置，可以通过不带 <code>default</code> 前缀的相同方法进行覆盖</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/09-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. Advisor</h3>
<p><code>Advisor</code> API 为 Spring 应用中的 AI 驱动交互提供灵活强大的拦截、修改和增强能力。这个思路基本和AOP 类似，但是 <code>Advisor</code> 允许在运行时动态修改方法调用，从而实现更灵活的逻辑处理。</p>
<p>如我们希望在用户消息基础上追加或增强上下文数据时</p>
<ul>
<li>可以是RAG技术给大模型喂资料</li>
<li>也可以是集成聊天历史，实现多轮对话</li>
</ul>
<p>比如之前在介绍聊天上下文时，提到的借助<code>MessageChatMemoryAdvisor</code>来实现多轮对话</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/09-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>除了上面这个之外，另外一个记录<code>ChatClient</code>请求和返回的 <code>SimpleLoggerAdvisor</code> 也是常用的增强</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要查看日志，需要调整 advisor 包的日志级别设为 <code>DEBUG</code>，如下设置即可</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果觉得默认的输出不合心意，也可以在创建时，指定传参、返回的打印方式，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，当传入多个 <code>advisor</code> 时，传入的顺序很重要，决定了它们的执行顺序。每个 Advisor 都会以某种方式修改提示词或上下文，且一个 Advisor 所做的更改会传递给链中的下一个 Advisor。</p>
<h2> 三、小结</h2>
<p>本文的内容主要是相对成体系的介绍了一下前面几篇文章示例中的 <code>ChatClient</code> 的使用方式，同时也将前面的内容或多或少都覆盖了一部分。 通常来讲，我们与大模型之间的交互，更推荐的是基于<code>ChatClient</code>来实现,SpringAI对其上层使用，封装的很是齐全了，有兴趣的小伙伴可以赶紧体验一下</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S09-chat-client" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/09-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>10.Advisor实现SpringAI能力增强</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/10.Advisor%E5%AE%9E%E7%8E%B0SpringAI%E4%BA%A4%E4%BA%92%E5%A2%9E%E5%BC%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/10.Advisor%E5%AE%9E%E7%8E%B0SpringAI%E4%BA%A4%E4%BA%92%E5%A2%9E%E5%BC%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">10.Advisor实现SpringAI能力增强</source>
      <description>10.Advisor实现SpringAI能力增强 SpringAI通过Advisor API为拦截、修改、增强Spring应用中的AI交互提供了灵活且强大的能力支撑 核心优势在于：封装可复用的生成式AI模式、转换与大语言模型（LLM）交互的数据、实现跨模型与用例的可移植性。 一、基础知识 1. 核心组件 因为大模型一般支持同步/异步流式两种访问方式，相应的SpringAI也提供同步调用call 和 流式调用 stream 两种方式；</description>
      <category>SpringAI</category>
      <pubDate>Mon, 04 Aug 2025 14:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 10.Advisor实现SpringAI能力增强</h1>
<p>SpringAI通过<code>Advisor API</code>为拦截、修改、增强Spring应用中的AI交互提供了灵活且强大的能力支撑</p>
<p>核心优势在于：封装可复用的生成式AI模式、转换与大语言模型（LLM）交互的数据、实现跨模型与用例的可移植性。</p>
<h2> 一、基础知识</h2>
<h3> 1. 核心组件</h3>
<p>因为大模型一般支持同步/异步流式两种访问方式，相应的SpringAI也提供同步调用<code>call</code> 和 流式调用 <code>stream</code> 两种方式；</p>
<p>这两种不同的方式，对应的<code>Advisor</code>也不太一样</p>
<ul>
<li>流式：<code>StreamAdvisor</code> 和 <code>StreamAdvisorChain</code></li>
<li>非流式：<code>CallAdvisor</code> 和 <code>CallAdvisorChain</code></li>
</ul>
<p>接口定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>ChatClientRequest</code>表示未密封的请求参数，<code>ChatClientResponse</code>表示的聊天完成响应的结果</p>
<figure><img src="/imgs/column/springai/10-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的继承关系图也可以看出，核心的方法为 <code>adviseCall</code> 和 <code>adviseStream</code>，在这两个方法内，执行检查未密封的 Prompt 数据、定制与增强 Prompt 内容、调用 Advisor 链中的下一实体、选择性阻断请求、分析聊天完成响应，并通过抛出异常标识处理错误等步骤</p>
<ul>
<li>getOrder() 方法决定 Advisor 在链中的执行顺序</li>
<li>getName() 则提供唯一的 Advisor 标识名称</li>
</ul>
<h3> 2. Advisor执行流程</h3>
<p>下面流程图展示了 <code>Advisor</code> 链与聊天模型的交互过程：</p>
<figure><img src="/imgs/column/springai/10-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol>
<li>封装用户的提示词，创建 <code>ChatClientRequest</code> 对象，并创建一个空的 <code>Advisor</code>上下文对象</li>
<li>链中每个 <code>Advisor</code> 依次处理请求并可进行修改，也可选择阻断请求（不调用下一实体）。若选择阻断，该 <code>Advisor</code> 需负责填充响应内容。</li>
<li>链中的最后一个 <code>Advisor</code> 调用模型</li>
<li>聊天模型响应结果返回给 <code>Advisor Chain</code>，并被转换为包含共享 AdvisorContext 实例的 AdvisedResponse 对象。</li>
<li>链中每个 <code>Advisor</code> 一次处理或修改响应</li>
<li>通过提取 <code>ChatCompletion</code> 内容，最终生成的 <code>ChatClientResponse</code> 将返回给客户端</li>
</ol>
<h3> 3. 执行顺序</h3>
<p>链中 Advisor 的执行顺序由 getOrder() 方法决定</p>
<ol>
<li>数值越小，优先级越高</li>
<li><code>Advisor</code> 链采用栈式结构运作
<ul>
<li>链首的 <code>Advisor</code> 优先处理请求</li>
<li>链尾的 <code>Advisor</code> 优先处理响应</li>
</ul>
</li>
<li>控制执行顺序
<ul>
<li>通过调整 <code>order</code> 值，来控制执行顺序</li>
<li>当多个<code>Advisor</code>的<code>order</code>值相同时，则无法完全确认执行顺序</li>
</ul>
</li>
</ol>
<h2> 二、自定义<code>Advisor</code>开发</h2>
<p>接下来我们通过实现一个自定义的 <code>Advisor</code> 来实现大模型交互的耗时统计</p>
<h3> 1. 耗时统计Advisor</h3>
<p>接下来，我们实现一个简单的 <code>advisor</code> 用于统计大模型的耗时情况。首先创建一个 <code>CostAdvisor</code> 分别实现 <code>CallAdvisor</code> 和 <code>StreamAdvisor</code> 接口，让它同时适用于同步/流式场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来是关键的类实现，既然是耗时统计，那就设定这个 <code>Advisor</code> 优先级最高，在执行前后分别计时，用于获取耗时情况；并将相关信息写入到上下文中</p>
<p>因此一个完整的实现可以如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同步的实现比较好理解，重点说一下流式调用中，耗时时间的打印情况，这里借助的<code>MessageAggregator</code>工具类，用于将 Flux 响应聚合为 <code>AdvisedResponse</code>。适用于观察完整响应（即回答完毕之后），记录耗时时间</p>
<p>其次就是上下文的传递，可以通过 <code>chatClientRequest.context().put("start-time", start);</code> 和 <code>response.context().put("end-time", end);</code> 方式设置用于共享的上下文参数</p>
<h3> 2. 测试验证</h3>
<p>写一个简单的端点用于验证 CostAdvisor</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/10-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的访问截图也可以看出，<code>CostAdvisor</code> 拦截了请求，并记录了耗时情况，并打印在控制台</p>
<h2> 三、小结</h2>
<p>本篇文章主要介绍了SpringAI如何通过 <code>Advisor</code> 来实现大模型交互能力的增强，并通过实现了一个简单的 <code>CostAdvisor</code> 演示如何实现自定义的advisor</p>
<p>SpringAI 内置了一些常用的 advisor， 比如我们之前介绍过的上下文、日志打印等</p>
<ol>
<li>对话历史相关</li>
</ol>
<ul>
<li><code>MessageChatMemoryAdvisor</code>
<ul>
<li>检索记忆并将其作为信息集合添加到提示中。这种方法可以保持对话历史的结构。注意，并非所有人工智能模型都支持这种方法。</li>
</ul>
</li>
<li><code>PromptChatMemoryAdvisor</code>
<ul>
<li>检索记忆内容并将其整合到提示词的系统文本中。</li>
</ul>
</li>
<li><code>VectorStoreChatMemoryAdvisor</code>
<ul>
<li>从向量存储库检索记忆内容并注入提示词的系统文本。该 Advisor 能高效搜索海量数据集中的相关信息。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>问答相关</li>
</ol>
<ul>
<li><code>QuestionAnswerAdvisor</code>
<ul>
<li>该 Advisor 通过向量存储实现问答功能，采用检索增强生成（RAG）模式。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>内容安全</li>
</ol>
<ul>
<li><code>SafeGuardAdvisor</code>
<ul>
<li>基础防护型 Advisor，用于阻止模型生成有害或不恰当内容。</li>
</ul>
</li>
</ul>
<p>此外需要重点注意的是，我们实现的 <code>advisor</code> 需要同时考虑同步和流式的两种方式</p>
<figure><img src="/imgs/column/springai/10-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>非流式 Advisor 处理完整请求与响应。</li>
<li>流式 Advisor 采用响应式编程理念（如 Flux 处理响应），以连续流形式处理请求与响应。</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S10-cost-advise" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/10-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>11.图像模型生成图片</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/11.%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%9E%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/11.%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%9E%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">11.图像模型生成图片</source>
      <description>11.图像模型生成图片 截止到目前为止，我们所有的体验的还仅限于聊天模型，一问一答，且都是基于文本的交互方式；现在主流的模型的应用场景，涉及图像识别、图像生成、图像检索、图像处理等等，SpringAI也提供了相应的模型接口，方便开发者进行图像模型应用的开发 接下来我们通过一个实例，来看一下在SpringAI中，如何接入图像模型 一、准备工作 首先还是得准备一个大模型的开发者账号，同样的为了简化大家的使用成本，我们依然采用免费的大模型 - 智谱 来完成</description>
      <category>SpringAI</category>
      <pubDate>Mon, 04 Aug 2025 15:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 11.图像模型生成图片</h1>
<p>截止到目前为止，我们所有的体验的还仅限于聊天模型，一问一答，且都是基于文本的交互方式；现在主流的模型的应用场景，涉及图像识别、图像生成、图像检索、图像处理等等，SpringAI也提供了相应的模型接口，方便开发者进行图像模型应用的开发</p>
<p>接下来我们通过一个实例，来看一下在SpringAI中，如何接入图像模型</p>
<h2> 一、准备工作</h2>
<p>首先还是得准备一个大模型的开发者账号，同样的为了简化大家的使用成本，我们依然采用免费的大模型 - <a href="https://www.bigmodel.cn/pricing" target="_blank" rel="noopener noreferrer">智谱</a> 来完成</p>
<h3> 1. 模型选择</h3>
<p>智谱官方提供了两个免费的多模态模型，分别为</p>
<ul>
<li>CogView-3-Flash: 生成图片</li>
<li>CogVideoX-Flash: 生成视频</li>
</ul>
<figure><img src="/imgs/column/springai/11-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 创建密钥</h3>
<p>在智普的开放平台获取密钥：<a href="https://open.bigmodel.cn/usercenter/proj-mgmt/apikeys" target="_blank" rel="noopener noreferrer">https://open.bigmodel.cn/usercenter/proj-mgmt/apikeys</a></p>
<figure><img src="/imgs/column/springai/01-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后在配置文件中，添加智普的密钥</p>
<h3> 3. 配置密钥</h3>
<p>在配置文件 <code>application.yml</code> 中，指定密钥和默认的模型</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的 model，这里使用是图像生成的模型，与前面介绍的聊天模型中的 <code>GLM-4-Flash</code> 不一致</p>
<h2> 二、图像模型使用</h2>
<p>接下来我们正式进入图像模型的使用环节，具体的项目创建过程，与之前的并无差别，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 依赖配置</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 创建一个控制器</h3>
<p>我们创建一个文生图的控制器，定义一个基于智谱图像模型的端点 <code>/genImg</code>， 生成之后，将返回的图片链接下载图片文件，直接返回给前端</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p>
<ul>
<li>具体的使用方式，直接基于 <code>ImageModel</code> 的调用来实现图片生成</li>
<li>实测： <code>ImageOptions</code> 中 <code>model</code> 参数，比填，不然不会使用配置中默认指定的 <code>CogView-3-Flash</code></li>
</ul>
<p>官方实现这里存在bug，由于传参没指定model，被sdk中默认的<code>cogview-3</code>给覆盖了（而不是默认选项中的 <code>CogView-3-Flash</code>）</p>
<figure><img src="/imgs/column/springai/11-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/imgs/column/springai/11-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 测试验证</h3>
<p>接下来我们启动项目，验证一下图像模型的实际表现</p>
<figure><img src="/imgs/column/springai/11-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>题外话：生成的卡通图片还差强人意，如果换成写实风，这个模型的表现效果就很不理想了😂 （不过毕竟是免费的，还能要求啥呢~）</p>
<p>请重点注意： 智谱的 <code>ImageModel</code> 的实现是不支持生成视频的，最直接的证据就是 <code>ZhiPuAiImageApi</code> 的实现中访问的path路径是 <code>/v4/images/generations</code>，而视频的访问路径应该是 <code>/v4/videos/generations</code>，且交互方式也不一致（视频是异步查询返回结果）;</p>
<p>目前<code>1.0.0</code>版本以及<code>1.1.0-SNAPSHOT</code>的<code>spring-ai-zhipuai</code>客户端，没有实现视频模型的访问；如有需要，需自己实现</p>
<h2> 三、小结</h2>
<p>本文主要介绍了图像模型的使用，虽然是以智谱为例进行的实例介绍；其他的模型使用姿势，实际也差不多，通用的使用方式如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S11-image-model" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/11-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>12.多模态实现图片卡路里识别</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/12.%E5%A4%9A%E6%A8%A1%E6%80%81%E5%AE%9E%E7%8E%B0%E9%A3%9F%E6%9D%90%E5%9B%BE%E7%89%87%E5%8D%A1%E8%B7%AF%E9%87%8C%E8%AF%86%E5%88%AB%E7%A4%BA%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/12.%E5%A4%9A%E6%A8%A1%E6%80%81%E5%AE%9E%E7%8E%B0%E9%A3%9F%E6%9D%90%E5%9B%BE%E7%89%87%E5%8D%A1%E8%B7%AF%E9%87%8C%E8%AF%86%E5%88%AB%E7%A4%BA%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">12.多模态实现图片卡路里识别</source>
      <description>12.多模态实现图片卡路里识别 现在大模型的快速发展，已经让其不仅只接受文本，也可以接受图像、音频、视频等多模态数据，SpringAI也提供了相应的模型接口，方便开发者进行多模态模型应用开发 如如 OpenAI 的GPT-4o、Google 的Vertex AI Gemini 1.5、Anthropic 的 Claude3，以及开源模型 Llama3.2、LLaVA 和 BakLLaVA，都能接受文本、图像、音频和视频等多种输入，并通过整合这些输入生成文本响应。 SpringAI提供了非常简单的多模态输入集成，接下来我们通过一个简单实例，来看一下在SpringAI中，如何接入多模态模型</description>
      <category>SpringAI</category>
      <pubDate>Mon, 04 Aug 2025 17:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 12.多模态实现图片卡路里识别</h1>
<p>现在大模型的快速发展，已经让其不仅只接受文本，也可以接受图像、音频、视频等多模态数据，SpringAI也提供了相应的模型接口，方便开发者进行多模态模型应用开发</p>
<p>如如 OpenAI 的GPT-4o、Google 的Vertex AI Gemini 1.5、Anthropic 的 Claude3，以及开源模型 Llama3.2、LLaVA 和 BakLLaVA，都能接受文本、图像、音频和视频等多种输入，并通过整合这些输入生成文本响应。</p>
<p>SpringAI提供了非常简单的多模态输入集成，接下来我们通过一个简单实例，来看一下在SpringAI中，如何接入多模态模型</p>
<h2> 一、准备工作</h2>
<p>首先还是得准备一个大模型开发者账号，同样的为了简化大家使用的成本，我们依然采用免费的大模型 - <a href="https://www.bigmodel.cn/pricing" target="_blank" rel="noopener noreferrer">智谱</a> 来完成</p>
<h3> 1. 模型选择</h3>
<p>我们这里选择的是官方提供的免费图像理解模型 <code>GLM-4V-Flash</code>，基于它来做一个食物图片的分类和卡路里计算</p>
<h3> 2. 项目创建</h3>
<p>创建一个SpringBoot项目，并引入SpringAI依赖，基本流程如 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：我们这里使用 huttol-http 进行互联网的图片下载</p>
<h3> 3. 密钥配置</h3>
<p>在配置文件中，指定密钥和默认的模型</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、多模态使用</h2>
<p>接下来我们进入多模态的实例开发</p>
<h3> 1. 图片识别控制器</h3>
<p>定义一个图片识别控制器，接收图片的URL，并返回识别结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的实现方式也可以看出，多模态的使用方式与<code>ChatModel</code>的使用方式基本一致，只是在构建用户消息的时候，携带了一个 <code>Media</code> 类型的输入</p>
<h3> 2. 测试</h3>
<p>为了测试，使用大模型帮我们生成一张食物图，避免版权纷争</p>
<figure><img src="/imgs/column/springai/12-1.webp" alt="待识别图" tabindex="0" loading="lazy"><figcaption>待识别图</figcaption></figure>
<p>然后访问测试接口，传入图片的URL，并指定识别的提示语</p>
<div class="language-curl line-numbers-mode" data-ext="curl"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/12-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 结构化输出</h3>
<p>上面直接返回的文本，不太方便我们的业务使用，因此可以考虑将返回结果进行结构化约束，比如，定义我们希望接受的对象（通过 <code>@JsonPropertyDescription</code> 注解来约束字段描述，在生成jsonSchema给大模型时，会将这些描述信息返回给模型）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后调整下多模态的调用，通过<code>entity()</code>来定义返回</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/12-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、小结</h2>
<p>本文主要介绍了多模态的使用，虽然以智谱为例进行了实例介绍；其他的模型使用姿势，实际也差不多，基本上都是<code>ChatModel/ChatClient</code>的使用方式，通过在构建用户消息的时候，携带一个 <code>Media</code> 类型的图片或者音视片资源，即可实现多模态的调用</p>
<p>但是，请注意，在使用多模态之前，前先确认对应的大模型是否支持多模态的调用，否则，可能会导致调用失败</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S12-multimodality-model" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/12-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>13.支持MCP Client的AI对话实现</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/13.%E6%94%AF%E6%8C%81MCP%20Client%E7%9A%84AI%E5%AF%B9%E8%AF%9D%E5%AE%9E%E7%8E%B0.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/13.%E6%94%AF%E6%8C%81MCP%20Client%E7%9A%84AI%E5%AF%B9%E8%AF%9D%E5%AE%9E%E7%8E%B0.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">13.支持MCP Client的AI对话实现</source>
      <description>13.支持MCP Client的AI对话实现 前面介绍了通过SpringAI来实现MCP Server，接下来我们再看一下，通过SpringAI来实现一个支持上次实现的MCP Client的AI对话 一、项目初始化 SpringAI MCP客户端的starter，提供了MCP客户端的自动配置，支持多种传输方式（本地+网络），支持同步、异步的调用 1. 项目创建 创建一个SpringBoot项目，并引入SpringAI依赖，基本流程如 创建一个SpringAI-Demo工程</description>
      <category>SpringAI</category>
      <pubDate>Tue, 05 Aug 2025 17:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 13.支持MCP Client的AI对话实现</h1>
<p>前面介绍了通过SpringAI来实现MCP Server，接下来我们再看一下，通过SpringAI来实现一个支持上次实现的<code>MCP Client</code>的<code>AI</code>对话</p>
<h2> 一、项目初始化</h2>
<p>SpringAI MCP客户端的starter，提供了MCP客户端的自动配置，支持多种传输方式（本地+网络），支持同步、异步的调用</p>
<h3> 1. 项目创建</h3>
<p>创建一个SpringBoot项目，并引入SpringAI依赖，基本流程如 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>spring-ai-starter-mcp-client</code>依赖，提供了MCP客户端的starter，使用的是智谱的免费大模型<code>GLM-4-Flash</code></p>
<p>其次我们使用 <code>thymeleaf + htmx</code> 来实现一个简单的聊天界面</p>
<h3> 2. 项目配置</h3>
<p>在配置文件中，除了指定大模型的密钥、模型之外，还需要配置MCP客户端的参数</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们这里的使用的<code>MCP Server</code>为<a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S07-mcp-server" target="_blank" rel="noopener noreferrer">S07-mcp-server</a>中实现的根据地区获取当前时间的服务</p>
<h2> 二、MCP Client实现</h2>
<p>SpringAI 对MCP Client 的实现封装的非常好了，对于上层应用而言，直接可以通过自定注入的 <code>ToolCallbackProvider</code>，将mcp client作为大模型的工具调用添加到模型中，然后通过模型调用，即可完成MCP的使用演示</p>
<h3> 1. 初始化ChatClient</h3>
<p>直接通过模型和<code>ToolCallbackProvider</code>，来创建支持mcp调用的 <code>ChatClient</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 实现聊天对话</h3>
<p>聊天对话的实现，非常简单，通过 <code>ChatClient</code> 调用模型，并返回结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 前端聊天页面实现</h3>
<p>聊天主页 index.html</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对话历史 <code>chat.html</code></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 使用测试</h3>
<p>首先，启动mcp server， 然后再启动聊天对话框；然后开始对话</p>
<figure><img src="/imgs/column/springai/13-1.webp" alt="直接询问当前时间" tabindex="0" loading="lazy"><figcaption>直接询问当前时间</figcaption></figure>
<figure><img src="/imgs/column/springai/13-2.webp" alt="业务场景中携带时间" tabindex="0" loading="lazy"><figcaption>业务场景中携带时间</figcaption></figure>
<h2> 三、小结</h2>
<p>本文主要介绍将MCP Client的使用，整体应用起来，比较简单，甚至是比function calling更简单（因为自动将mcp服务注入为<code>ToolCallbackProvider</code>，可以直接传入<code>ChatClient</code>用作大模型的工具调用）</p>
<p>当然除了上面这种方式之外，我们也可以直接使用MCP Client来进行交互</p>
<blockquote>
<p>MCPClient 使用姿势参考官方文档： <a href="https://modelcontextprotocol.io/sdk/java/mcp-client" target="_blank" rel="noopener noreferrer">java-mcp-client</a></p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/13-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S13-mcp-client-chat" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/13-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>基础篇</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">基础篇</source>
      <description>主要介绍SpringAI的基础使用，对应的项目工程以 Sxx- 开头，通过这些实例，您将掌握SpringAI的基础知识（如提示词、上下文、架构化输出、tool calling, MCP, advise, ChatClient, 多模型等），并开始使用SpringAI进行大模型应用开发</description>
      <pubDate>Fri, 08 Aug 2025 02:51:24 GMT</pubDate>
      <content:encoded><![CDATA[<p>主要介绍SpringAI的基础使用，对应的项目工程以 <code>Sxx-</code> 开头，通过这些实例，您将掌握SpringAI的基础知识（如提示词、上下文、架构化输出、tool calling, MCP, advise, ChatClient, 多模型等），并开始使用SpringAI进行大模型应用开发</p>
]]></content:encoded>
    </item>
    <item>
      <title>应用篇</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E5%BA%94%E7%94%A8%E7%AF%87/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E5%BA%94%E7%94%A8%E7%AF%87/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">应用篇</source>
      <description>以搭建完整可用的SpringAI应用为目的，演示SpringAI的业务边界和表现</description>
      <pubDate>Fri, 08 Aug 2025 02:51:24 GMT</pubDate>
      <content:encoded><![CDATA[<p>以搭建完整可用的SpringAI应用为目的，演示SpringAI的业务边界和表现</p>
]]></content:encoded>
    </item>
    <item>
      <title>源码篇</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E6%BA%90%E7%A0%81%E7%AF%87/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E6%BA%90%E7%A0%81%E7%AF%87/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">源码篇</source>
      <description>以源码的视角，介绍SpringAI的核心实现</description>
      <pubDate>Fri, 08 Aug 2025 02:51:24 GMT</pubDate>
      <content:encoded><![CDATA[<p>以源码的视角，介绍SpringAI的核心实现</p>
]]></content:encoded>
    </item>
    <item>
      <title>01.使用数据库持久化对话历史</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A01.%E4%BD%BF%E7%94%A8MySql%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A01.%E4%BD%BF%E7%94%A8MySql%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.使用数据库持久化对话历史</source>
      <description>01.使用数据库持久化对话历史 本文作为SpringAI的进阶篇，将介绍一些在实际应用中，可能用到的小技巧。在基础篇的 04.聊天上下文 中，介绍并演示了基于 InMemoryChatMemoryRepository 来存储对话历史，从而实现多轮对话 在实际的业务场景中，用InMemoryChatMemoryRepository的场景可能还会更少一点，毕竟上下文放在内存中，不利于后续的审计以及应用重启之后数据就丢失了</description>
      <category>SpringAI</category>
      <pubDate>Thu, 07 Aug 2025 10:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 01.使用数据库持久化对话历史</h1>
<p>本文作为SpringAI的进阶篇，将介绍一些在实际应用中，可能用到的小技巧。在基础篇的 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/04.%E8%81%8A%E5%A4%A9%E4%B8%8A%E4%B8%8B%E6%96%87.html" target="blank">04.聊天上下文</a>
中，介绍并演示了基于 <code>InMemoryChatMemoryRepository</code> 来存储对话历史，从而实现多轮对话</p>
<p>在实际的业务场景中，用<code>InMemoryChatMemoryRepository</code>的场景可能还会更少一点，毕竟上下文放在内存中，不利于后续的审计以及应用重启之后数据就丢失了</p>
<p>那么如何将对话持久化存储呢?</p>
<p>本文将介绍基于数据库的持久方案，将从两个方面进行介绍</p>
<ol>
<li>通过实例演示数据库的持久化使用方式</li>
<li>介绍一些关键的实现技术点</li>
</ol>
<h2> 一、项目演示</h2>
<h3> 1. 创建项目</h3>
<p>创建一个SpringAI项目，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 2. 添加依赖</h3>
<p>在pom.xml中添加关键依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 配置数据库连接</h3>
<p>在配置文件 <code>application.yml</code> 文件中，指定SpringAI配置 + 数据库连接信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于<code>spring.ai.chat.memory.repository.jdbc</code>的配置进行一些必要的说明</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
<th>取值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>spring.ai.chat.memory.repository.jdbc.initialize-schema</code></td>
<td>控制什么时候初始化schema</td>
<td>embeded(默认)/always/never</td>
</tr>
<tr>
<td><code>spring.ai.chat.memory.repository.jdbc.schema</code></td>
<td>指定数据库的schema的位置</td>
<td><code>classpath:org/springframework/ai/chat/memory/repository/jdbc/schema-@@platform@@.sql</code></td>
</tr>
<tr>
<td><code>spring.ai.chat.memory.repository.jdbc.platform</code></td>
<td>数据库平台，如mysql/h2/postgresql等</td>
<td>默认会自动检测</td>
</tr>
</tbody>
</table>
<p>在上面的配置中，我们的 <code>initialize-schema</code> 配置为 <code>always</code>，表示在启动的时候会自动创建数据库表（即便表存在，也会尝试执行脚本；我们这里使用的是MySql，因此需要自动创建表<code>SPRING_AI_CHAT_MEMORY</code>）</p>
<ol>
<li>ALWAYS</li>
</ol>
<ul>
<li>无论何时都会执行数据库初始化</li>
<li>即使数据库已存在，也会尝试运行初始化脚本</li>
<li>适用于每次启动都需要重新初始化数据库的场景</li>
</ul>
<ol start="2">
<li>EMBEDDED</li>
</ol>
<ul>
<li>仅在使用嵌入式数据库时执行初始化</li>
<li>对于H2、HSQL、Derby等嵌入式数据库会自动初始化</li>
<li>对于外部数据库（如MySQL、PostgreSQL）则跳过初始化</li>
<li>这是大多数情况下的推荐设置</li>
</ul>
<ol start="3">
<li>NEVER</li>
</ol>
<ul>
<li>从不执行数据库初始化</li>
<li>完全跳过所有数据库schema和data脚本的执行</li>
<li>适用于生产环境或已有数据库结构的情况</li>
</ul>
<p>对应的Schema所在的位置如下图</p>
<figure><img src="/imgs/column/springai/A01-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 初始化 ChatMemory</h3>
<p>当我们引入 <code>spring-ai-starter-model-chat-memory-repository-jdbc</code> 之后，会自动注入 <code>ChatMemoryRepository</code>
的bean对象，我们接下来基于它来创建<code>ChatMemory</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. ChatClient 配置</h3>
<p>然后通过<code>MessageChatMemoryAdvisor</code>来为<code>ChatClient</code>提供聊天历史能力支撑</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 示例测试</h3>
<p>提供一个聊天接口，第一个参数为用户标识，用于区分用户的聊天记录</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/A01-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、关键技术点</h2>
<p>使用MySql来存储用户与大模型的对话情况，从使用角度来看，还比较简单；接下来我们抓一下技术要点，从疑问出发，看下能否完成解惑</p>
<ol>
<li>持久化的数据表结构是如何设计的？</li>
<li>数据库表是如何初始化的？</li>
<li>又是如何实现自动识别数据库平台的？</li>
<li>如果想使用自定义的数据库表，替代默认的，可以怎么实现？</li>
</ol>
<h3> 1. 默认的表结构设计</h3>
<p>关于这个一点，前面介绍配置的时候也提到了，在<code>spring-aimodel-chat-memory-repository-jdbc</code>的包中，提供了5个schema文件，对应的源码工程结果如下</p>
<figure><img src="/imgs/column/springai/A01-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>以mysql为例，对应的schema如下</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义了四个字段，分别为：</p>
<ul>
<li><code>conversation_id</code>: 会话ID，用于区分不同的会话</li>
<li><code>content</code>: 会话内容，可以是用户输入，也可以是模型输出</li>
<li><code>type</code>: 会话类型，可以是用户输入，也可以是模型输出，也可以是系统信息，也可以是工具信息</li>
<li><code>timestamp</code>: 会话时间，用于排序</li>
</ul>
<h3> 2. 数据库初始化</h3>
<p>通过配置 <code>spring.ai.chat.memory.repository.jdbc.initialize-schema</code> 来控制； 为 <code>always</code>，会自动创建数据库表（即便表存在，也会尝试执行脚本）</p>
<p>这里主要是通过<code>JdbcChatMemoryRepositorySchemaInitializer</code>来实现schema脚本的初始化行为，依赖的是Spring Boot 中用于数据库初始化的组件<code>DataSourceScriptDatabaseInitializer</code></p>
<ul>
<li>检查数据库初始化模式（DatabaseInitializationMode）</li>
<li>根据配置查找相应的 SQL 脚本文件</li>
<li>使用配置的 DataSource 连接数据库</li>
<li>按顺序执行 schema 脚本和 data 脚本</li>
<li>处理脚本执行过程中的异常</li>
</ul>
<h3> 3. 自动识别数据库平台</h3>
<p>关键实现逻辑  <code>org.springframework.ai.chat.memory.repository.jdbc.JdbcChatMemoryRepositoryDialect.from</code></p>
<figure><img src="/imgs/column/springai/A01-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>根据数据库连接来判断当前使用的是哪个数据库，默认的是 <code>postgresql</code></p>
<h3> 4. 自定义数据库表结构</h3>
<p>默认的表结构满足大部分场景，如果需要自定义表结构，可以通过实现 <code>JdbcChatMemoryRepositoryDialect</code> 接口来自定义，并注册到 Spring 容器中</p>
<p>比如默认的MySql相关sql如下，若需要调整表名、字段名，替换下面的这个类，然后注册到 <code>JdbcChatMemoryRepository</code> 中即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点说明：换表名、字段名还好，如果我想额外存储用户的token使用情况，可行吗？</p>
<p>从源码来看，不可行，上面的 <code>Dialect</code> 中的<code>insert</code>，已经绑定了字段，无法进行动态扩展</p>
<figure><img src="/imgs/column/springai/A01-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、小结</h2>
<p>本文介绍的是基于MySql持久化对话历史的实现方案，Spring AI 默认使用 JdbcChatMemoryRepository 来实现，基于 MySql 的表结构，可以满足大部分场景，如果需要自定义表结构，可以通过实现 <code>JdbcChatMemoryRepositoryDialect</code> 接口来自定义</p>
<p>通过使用实例和一些关键性的技术说明，对于官方未直接支持的数据库，我们也可以很方便的进行扩展；当然现在的实现还存在一点缺陷，那就是无法自定义持久化的信息</p>
<p>接下来一篇博文，我们将实例演示，如何使用 h2 数据库进行持久化</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects/A01-memory-jdbc-mysql" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/A01-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>02.使用H2持久化对话历史</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A02.%E4%BD%BF%E7%94%A8H2%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A02.%E4%BD%BF%E7%94%A8H2%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">02.使用H2持久化对话历史</source>
      <description>02.使用H2持久化对话历史 上面一篇文章介绍了 SpringAI官方提供的 jdbc start来实现持久化对话历史 使用MySql持久化对话历史，官方实现的几个数据库已经很有代表性了，接下来我们将看一下，如果沿用官方的思路，来为h2添加持久化对话历史功能。</description>
      <category>SpringAI</category>
      <pubDate>Thu, 07 Aug 2025 11:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 02.使用H2持久化对话历史</h1>
<p>上面一篇文章介绍了 SpringAI官方提供的 jdbc start来实现持久化对话历史 <a href="/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A01.%E4%BD%BF%E7%94%A8MySql%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html" target="blank">使用MySql持久化对话历史</a>，官方实现的几个数据库已经很有代表性了，接下来我们将看一下，如果沿用官方的思路，来为h2添加持久化对话历史功能。</p>
<h2> 一、H2持久化对话历史</h2>
<h3> 1. 创建项目</h3>
<p>创建一个SpringAI项目，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 2. 添加依赖</h3>
<p>在pom.xml中添加关键依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 配置数据库连接</h3>
<p>在配置文件 <code>application.yml</code> 文件中，指定SpringAI配置 + 数据库连接信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明，虽然我们这里使用的是 H2，但是 <code>spring.ai.chat.memory.repository.jdbc.initialize-schema</code> 配置项，还是建议选择 <code>always</code>，因为上面配置的是使用文件来存储db；如果使用内存 <code>jdbc:h2:mem</code> 的方式，则这里可以选择 <code>embedded</code></p>
<figure><img src="/imgs/column/springai/A02-1.webp" alt="embeded是否创建表的关键判断逻辑" tabindex="0" loading="lazy"><figcaption>embeded是否创建表的关键判断逻辑</figcaption></figure>
<p>其次就是我们需要指定 <code>schema</code> 文件，这个文件，就是用来创建数据库表结构，这里我们使用 <code>h2</code> 的默认结构，因此这里我们使用 <code>classpath:schema-h2.sql</code></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 初始化 ChatMemory</h3>
<p>因为我们使用的是系统未提供支持的h2，因此无法使用自动注入的<code>ChatMemoryRepository</code>，因为它选择的Dialect是 <code>PostgresChatMemoryRepositoryDialect</code>，无法支持h2的使用场景</p>
<p>我们这里直接使用<code>MysqlChatMemoryRepositoryDialect</code>来作为h2的Dialect（当然也可以自行实现一个Dialect）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. ChatClient 配置</h3>
<p>然后通过<code>MessageChatMemoryAdvisor</code>来为<code>ChatClient</code>提供聊天历史能力支撑</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 示例测试</h3>
<p>提供一个聊天接口，第一个参数为用户标识，用于区分用户的聊天记录</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动成功之后，我们可以在h2-console中看到新增了一个表 <code>SPRING_AI_CHAT_MEMORY</code></p>
<figure><img src="/imgs/column/springai/A02-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后进行多轮对话，看看效果，表现和我们预期一致，聊天记录被保存在数据库中</p>
<figure><img src="/imgs/column/springai/A02-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、小结</h2>
<p>本文介绍的是如何借助 <code>spring-ai-starter-model-chat-memory-repository-jdbc</code> 来实现自定义的对话持久化，通过实现h2的Dialect，我们可以轻松实现自定义的持久化逻辑；若希望了解持久化的更多实现细节，可以查看上篇 <a href="/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A01.%E4%BD%BF%E7%94%A8MySql%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html" target="blank">使用MySql持久化对话历史</a></p>
<p>这里实现的是基于数据库来进行持久化，那么如果我不是用数据库，比如希望用文件或者redis来实现，又可以怎么做呢？</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects/A02-memory-jdbc-h2" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/A02-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>03.使用Redis持久化对话历史</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A03.%E4%BD%BF%E7%94%A8Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/A03.%E4%BD%BF%E7%94%A8Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">03.使用Redis持久化对话历史</source>
      <description>03.使用Redis持久化对话历史 前面介绍了使用关系数据库来存储对话历史，接下来我们更进一步，通过扩展ChatMemoryRepository来实现基于Redis的持久化 一、Redis持久化对话历史 1. 创建项目 创建一个SpringAI项目，基本流程同 创建一个SpringAI-Demo工程</description>
      <category>SpringAI</category>
      <pubDate>Thu, 07 Aug 2025 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 03.使用Redis持久化对话历史</h1>
<p>前面介绍了使用关系数据库来存储对话历史，接下来我们更进一步，通过扩展<code>ChatMemoryRepository</code>来实现基于Redis的持久化</p>
<h2> 一、Redis持久化对话历史</h2>
<h3> 1. 创建项目</h3>
<p>创建一个SpringAI项目，基本流程同 <a href="/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 2. 添加依赖</h3>
<p>在pom.xml中添加关键依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接依赖<code>spring-ai-starter-model-chat-memory</code>来实现聊天记录，这里采用redis来进行持久化，因此我们添加redis的相关依赖（这里一jedis客户端为例，对于lettuce或者redisson实际上没有太大的差别）</p>
<h3> 3. 配置</h3>
<p>在配置文件 <code>application.yml</code> 文件中，指定redis相关配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们这里使用单节点的redis进行演示；对于集群的场景，除了配置不一样之外，实际上对于我们的实现并没有太大的差别（因为我们利用的是Spring封装的RedisTemplate进行操作，因此对于集群的场景，实际上也是可以的）</p>
<h3> 4. 实现RedisChatMemoryRepository</h3>
<p>通过实现接口<code>ChatMemoryRepository</code>来完成我们的 RedisChatMemoryRepository</p>
<p>对于用户聊天记录，我们采用redis的列表的数据结构进行存储(具体实现除了这种方案之外，也可以使用hash数据结构来存储，field为会话id，value为对话记录)</p>
<ul>
<li>key: <code>chat:${conversationId}</code></li>
<li>value: [] , 消息列表</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于redis的存储实现相对来讲并不算复杂，无非就是Message的读取与写入，这里我们采用json进行序列化与反序列化</p>
<p>我们实现一个自定义的反序列化策略，在获取数据时，只要Message中的 <code>messageType</code> + <code>text</code>，因为这些会一并传递给大模型，其他的元数据并没有太大意义，还会消耗我们的token</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的JsonUtil的实现则比较基础，一个统一的json工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 定义ChatMemory</h3>
<p>定义一个自定义的ChatMemory，这里我们使用 <code>RedisChatMemoryRepository</code> 来作为消息的存储仓库</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 示例测试</h3>
<p>提供一个聊天接口，第一个参数为用户标识，用于区分用户的聊天记录</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/A03-1.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、小结</h2>
<p>本文介绍的是如何通过实现SpringAI定义的<code>ChatMemoryRepository</code>接口来完成自定义的对话记录持久化，通过这种方式，可以实现更灵活的上下文管控</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects/A03-memory-redis" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/springai/A03-1.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>进阶篇</title>
      <link>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/springai/%E8%BF%9B%E9%98%B6%E7%AF%87/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">进阶篇</source>
      <description>进阶相关将主要介绍如何更好的使用SpringAI进行大模型应用开发</description>
      <pubDate>Fri, 08 Aug 2025 02:51:24 GMT</pubDate>
      <content:encoded><![CDATA[<p>进阶相关将主要介绍如何更好的使用SpringAI进行大模型应用开发</p>
]]></content:encoded>
    </item>
    <item>
      <title>7. 基于AI开发三端产品-文渊阁原型设计</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aicoding/07.%E5%9F%BA%E4%BA%8EAI%E5%BC%80%E5%8F%91%E4%BA%A7%E5%93%81-%E6%96%87%E6%B8%8A%E9%98%81%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aicoding/07.%E5%9F%BA%E4%BA%8EAI%E5%BC%80%E5%8F%91%E4%BA%A7%E5%93%81-%E6%96%87%E6%B8%8A%E9%98%81%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">7. 基于AI开发三端产品-文渊阁原型设计</source>
      <description>一恍惚25年就已经过了一半，上半年借助AI开发工具也做了不少小玩具；在下半年，给自己订一个小目标，做一个完整功能更完整的产品，计划做三端（PC、小程序、APP），并且包含独立的后端服务能力。 实际上我个人也没有特别想做的东西，正好小朋友最近开始学习识字、背诗，那就做一个中华文化知识相关的产品得了 一、 前置准备 有想法之后，第一件事情，当然是全网搜一下，有没有类似的可以学习致敬（抄袭）的竞品 知乎上有一个挺好的话题，- 有没有公认比较好的诗词APP推荐？ - 知乎</description>
      <category>AI</category>
      <pubDate>Tue, 08 Jul 2025 07:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>一恍惚25年就已经过了一半，上半年借助AI开发工具也做了不少小玩具；在下半年，给自己订一个小目标，做一个完整功能更完整的产品，计划做三端（PC、小程序、APP），并且包含独立的后端服务能力。</p>
<p>实际上我个人也没有特别想做的东西，正好小朋友最近开始学习识字、背诗，那就做一个中华文化知识相关的产品得了</p>
<h2> 一、 前置准备</h2>
<p>有想法之后，第一件事情，当然是全网搜一下，有没有类似的可以学习致敬（抄袭）的竞品</p>
<p>知乎上有一个挺好的话题，- <a href="https://www.zhihu.com/question/21528388" target="_blank" rel="noopener noreferrer">有没有公认比较好的诗词APP推荐？ - 知乎</a></p>
<p>推荐的产品还挺多，app/网站/小程序均有，下面是摘抄目录</p>
<figure><img src="/imgs/column/ai/7-1.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>产品有一些可以学习的对象；接下来再看看开源社区上是否有可以拿来当“基座”的原型😊</p>
<p>比如一些数据源：</p>
<ul>
<li><a href="https://github.com/caoxingyu/chinese-gushiwen" target="_blank" rel="noopener noreferrer">caoxingyu/chinese-gushiwen: 中华古诗文数据库和API。包含10000首古文(诗、词、歌、赋以及其它形式的文言文)，近4000名作者，10000名句</a></li>
<li><a href="https://github.com/chanind/hanzi-writer-data" target="_blank" rel="noopener noreferrer">chanind/hanzi-writer-data: The data used by Hanzi Writer</a></li>
</ul>
<p>一些可用的产品：</p>
<ul>
<li><a href="https://github.com/hefengbao/jingmo/tree/main" target="_blank" rel="noopener noreferrer">hefengbao/jingmo: 『京墨』开源的中华文化宝典 APP，诗（词）文（名句）、汉字、成语、词语、歇后语、绕口令、传统节日、传统色、节气、人物等。</a></li>
<li><a href="https://github.com/a2636340559/YaFeng" target="_blank" rel="noopener noreferrer">a2636340559/YaFeng: “雅风”古诗词APP</a></li>
<li><a href="https://github.com/SongC1229/song" target="_blank" rel="noopener noreferrer">SongC1229/song: 基于Flutter框架的诗词app,采用sqlite数据库</a></li>
</ul>
<h2> 二、 原型设计</h2>
<p>基于上面的过程我们大概知道自己想做些啥，但是具体的产品设计这块由于并不专业不知道该怎么做，既然我不会，那就借助一下AI来帮我整一下</p>
<p>直接大力出奇迹，对于小白完全不考虑什么提示词</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/ai/7-2.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>省略调整的过程，看看AI生成的原型方案</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然对于一个研发而言，上面的这套设计方案仅使用参考，我还是更喜欢可视化的交互页面</p>
<h2> 三、快速原型实现</h2>
<p>使用AI体验最好的就在这里了，我可以直接让它快速将上面的设计实现一个demo出来看看效果</p>
<figure><img src="/imgs/column/ai/7-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这个生成的网页效果实际上超出了我的预期，至少我自己是设计不出来的。 接下来我们就是基于这个原型进行丰富补全</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/ai/7-1.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>1. “绝对色感”的闯关游戏（一）</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aigame/01.%E7%BB%9D%E5%AF%B9%E8%89%B2%E6%84%9F%E7%9A%84%E9%97%AF%E5%85%B3%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aigame/01.%E7%BB%9D%E5%AF%B9%E8%89%B2%E6%84%9F%E7%9A%84%E9%97%AF%E5%85%B3%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1. “绝对色感”的闯关游戏（一）</source>
      <description>作为一个游戏开发门外汉，接下来我将挑战一下，从0到1，完整记录一下如何借助AI来生成一个完整的可上架的游戏APP 一、游戏产品设计 首先明确一下我们要做什么，产品的核心玩法： 一个简单的闯关游戏，每一关中由系统自动生成一些色块，其中只要一个色块的颜色与其他的不一样，只有选中不一样颜色的色块才会进入下一关 关卡难度设计：随着关卡的增加，色块数变多； 不同颜色的色块与其他颜色的rgb差值更小 关卡本身功能比较简单，我们需要为它添加一个排行榜竞技/或者在线PK的功能，增加互动性 接下来就是确定研发路线</description>
      <category>AI</category>
      <pubDate>Wed, 09 Jul 2025 07:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>作为一个游戏开发门外汉，接下来我将挑战一下，从0到1，完整记录一下如何借助AI来生成一个完整的可上架的游戏APP</p>
<h2> 一、游戏产品设计</h2>
<p>首先明确一下我们要做什么，产品的核心玩法：</p>
<p>一个简单的闯关游戏，每一关中由系统自动生成一些色块，其中只要一个色块的颜色与其他的不一样，只有选中不一样颜色的色块才会进入下一关</p>
<ul>
<li>关卡难度设计：随着关卡的增加，色块数变多； 不同颜色的色块与其他颜色的rgb差值更小</li>
</ul>
<p>关卡本身功能比较简单，我们需要为它添加一个排行榜竞技/或者在线PK的功能，增加互动性</p>
<p>接下来就是确定研发路线</p>
<p>借助trae/cursor来实现代码编程，技术栈选择uniapp来实现实现一次编写，多端运行</p>
<h2> 二、项目初始化与快速原型设计</h2>
<h3> 2.1 项目初始化</h3>
<p>使用uniapp进行开发，首先需要安装HBuilder，这里省略安装步骤；接下来我们创建一个空的项目</p>
<figure><img src="/imgs/column/aigame/1-01.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>使用Cursor打开项目，快速实现一个应用原型</p>
<figure><img src="/imgs/column/aigame/1-02.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2.2 快速原型设计</h3>
<p>首次提交信息时，cursor只会帮我们输出一个空的架子，接下来我们回复确认让它补全具体的游戏逻辑，快速实现一个基础可运行的原型</p>
<figure><img src="/imgs/column/aigame/1-03.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>全部接受之后，我们通过uniapp体验一下实际的效果</p>
<figure><img src="/imgs/column/aigame/1-04.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后一个核心游戏玩法的应用基本算是完成了</p>
<figure><img src="/imgs/column/aigame/1-05.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、验证可行性、制定迭代计划</h2>
<p>从上面的流程也可以看出，借助cursor快速设计一个原型用于我们的想法验证，成本非常低；现在ai对于普通人的一个友好点在于可以快速的让我们脑子里的想法先落地，不管它靠不靠谱</p>
<p>接下来就是实际体验一下，看看我们的想法是否靠谱，以及这个原型还有哪些需要改进和优化的地方</p>
<p>从原型的交互体验来看，核心玩法没问题，生成色块、选择、进入下一关；但是从实际体验来看，玩法比较单调、且后面关卡的色块rgb差异太小了，肉眼太难识别了</p>
<p>因此后面的迭代方向可以分为两块：</p>
<ol>
<li>游戏策略</li>
</ol>
<ul>
<li>设计更优雅的难度升级策略</li>
</ul>
<ol start="2">
<li>游戏可玩性</li>
</ol>
<ul>
<li>增加游戏的可玩性/竞技性 - 比如排行榜，在线PK，每一关添加倒计时增加紧迫感，当思考方式太久/闯关失败时输出一些嘲讽意味强的弹幕？闯过一些特定关卡时，增加一些喝彩的氛围</li>
<li>单纯的色块可能吸引力不够，那么是否可以在色块中放一些漂亮的小姐姐图片？</li>
</ul>
<p>前期准备工作就绪，接下来我们开始进入游戏的调教正文</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/aigame/1-01.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>AI游戏开发</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aigame/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aigame/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">AI游戏开发</source>
      <description>氛围编程 借助AiCoding（如cursor windsurf trae copilot）来实现低门槛的编程</description>
      <pubDate>Wed, 09 Jul 2025 09:51:04 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 氛围编程</h1>
<p>借助AiCoding（如cursor windsurf trae copilot）来实现低门槛的编程</p>
]]></content:encoded>
    </item>
    <item>
      <title>1. 首个完全由AI生成的APP-ColorPicker上架啦</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aicoding/01.%E9%A6%96%E4%B8%AA%E5%AE%8C%E5%85%A8%E7%94%B1AI%E7%94%9F%E6%88%90%E7%9A%84APP%E4%B8%8A%E6%9E%B6%E5%95%A6.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aicoding/01.%E9%A6%96%E4%B8%AA%E5%AE%8C%E5%85%A8%E7%94%B1AI%E7%94%9F%E6%88%90%E7%9A%84APP%E4%B8%8A%E6%9E%B6%E5%95%A6.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1. 首个完全由AI生成的APP-ColorPicker上架啦</source>
      <description>hello大家好，我是一灰灰，距离上一次和大家分享技术相关内容已经过去了两年多了；若不是最近AICoding的大火，估计也不会继续发文啦。最近这个月深度体验了ai coding的能力，也借助字节的Trae完成了几个产品，借着首个app上架一周的时间、并获得首个自然用户的评价（虽然是个差评）这个时机，给大家分享一下我最近在筹划的一个专栏 -- 《人人都是程序员》 第一手原文：首个完全由AI生成的APP-ColorPicker上架啦 | 一灰灰blog的公众号</description>
      <category>AI</category>
      <pubDate>Mon, 24 Mar 2025 21:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>hello大家好，我是一灰灰，距离上一次和大家分享技术相关内容已经过去了两年多了；若不是最近AICoding的大火，估计也不会继续发文啦。最近这个月深度体验了ai coding的能力，也借助字节的Trae完成了几个产品，借着首个app上架一周的时间、并获得首个自然用户的评价（虽然是个差评）这个时机，给大家分享一下我最近在筹划的一个专栏 -- 《人人都是程序员》</p>
<blockquote>
<p>第一手原文：<a href="https://mp.weixin.qq.com/s/qtxF-vnUeKrp9BZZRaeeSw" target="_blank" rel="noopener noreferrer">首个完全由AI生成的APP-ColorPicker上架啦 | 一灰灰blog的公众号</a></p>
</blockquote>
<figure><img src="/imgs/column/ai/1_1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>确实是没想到外国人也会因为语言问题给差评，谁说欧洲人素质高来着😡</p>
<h2> 1. ColorPicker上架谷歌应用市场</h2>
<p>最近这段时间的各种AI工具的使用，加上首个99%以上内容由AI生成的APP（ColorPicker）在谷歌应用市场的成功上线，忽然意识到“人人都是程序员”这一现实好像在加速到来。</p>
<p>还记得我在初入这一行时，当时的TL推荐我们程序员要有产品思维，多看看《人人都是产品经理》这一本书，没想到今天我要开始着手准备《人人都是程序员》了。</p>
<p>首先给大家看一下这个完全由AI完成的APP（3.17号上架通过）</p>
<figure><img src="/imgs/column/ai/1_2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>下面是实际的体验效果（整体功能齐全啦）</p>
<blockquote>
<p>点击查看原文：<a href="https://mp.weixin.qq.com/s/qtxF-vnUeKrp9BZZRaeeSw" target="_blank" rel="noopener noreferrer">演示视频原文</a></p>
</blockquote>
<p>希望体验h5的小伙伴可以访问下面两个地址（一个是自己的域名，一个是白嫖的cloudflare服务），或者直接点击文末的访问原文直达</p>
<ul>
<li><a href="http://cdn.hhui.top/app/color-picker/index.html#/" target="_blank" rel="noopener noreferrer">http://cdn.hhui.top/app/color-picker/index.html#/</a></li>
<li><a href="https://colorpicker-bpx.pages.dev/#/" target="_blank" rel="noopener noreferrer">https://colorpicker-bpx.pages.dev/#/</a></li>
</ul>
<p><strong>1. 主要的业务逻辑：</strong></p>
<p>• 照相 + 本地相册读取图片，识别图片颜色
• 支持颜色分组，收藏
• 颜色详情，支持全屏显示
• 系统推荐色彩专栏
• APP国际化</p>
<p><strong>2. 集成谷歌Admob广告，支持变现</strong></p>
<p><strong>3. 多端支持</strong></p>
<p>•android 版本 （已上架）
•ios 版本（没有苹果应用账号，因此没上架）
•h5/pc 版本: 已上线   <a href="https://colorpicker-bpx.pages.dev/#/" target="_blank" rel="noopener noreferrer">https://colorpicker-bpx.pages.dev/#/</a>
•小程序版（未备案，所以未上线）</p>
<h2> 2. AI生成APP的契机</h2>
<p>ColorPicker的诞生也比较偶然，今年年初的DeepSeek掀起AI届的新一轮高潮，好久没怎么学习的我也凑了一波热闹，借助字节提供的免费AI编辑器Trae，看一下现在的ai工具代码到底写得怎么样。</p>
<p>如到现在，基于Trae我共实现了三个应用：</p>
<h3> 2.1. 像素图填色游戏</h3>
<blockquote>
<p>源码：<a href="https://liuyueyi.github.io/ai-web-case/" target="_blank" rel="noopener noreferrer">https://liuyueyi.github.io/ai-web-case/</a></p>
</blockquote>
<p>1.一个简单的单页面web应用，通过解析给定的配置文件，生成像素图；用户可以根据自己选择的颜色对像素进行填色
2.特点：页面布局单一、业务逻辑简单，交互不多</p>
<figure><img src="/imgs/column/ai/1_3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这个web页面的开发过程非常顺利，基本上没有什么特别糟心的事情，整个实现也就两天的时间（关于将图片转换为用于渲染像素图的二维矩阵花了我一天，这块还是借助我的老本行java实现的😂），接下来我就想上点难度，看下AICoding的能力在哪里，接下来就有了下面的AI对战游戏</p>
<h3> 2.2. AI人机对战棋牌游戏</h3>
<p>1.人机对战的棋牌游戏，原定计划实现 五子棋、黑白棋、三子/九子棋、中国象棋、国际象棋等经典棋牌的人机方式
2.最终结果：完成五子棋、黑白棋、三子棋的基础实现
3.特点：布局相对复杂（比如三子棋盘的绘制），算法要求高（AI下棋策略，人机交互策略）</p>
<figure><img src="/imgs/column/ai/1_4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>相较于像素填色，这个AI棋盘对战的开发过程就比较难受了，不管是棋盘的布局（尤其是三子棋的棋盘，反复修改调整)、AI的游戏策略/判定策略调教，都不是一个轻松的活，原定计划的中国象棋和国际象棋也没有耐心继续调教了。</p>
<p>这个游戏差不多花了我一周的时间，做完之后，感受就是AICoding确实方便，虽然离取代资深程序员还是有不小的距离，但是对初级程序员的挑战就很非常大了。这个项目做完之后，我就萌生了一个“人人都是程序员”的想法，这好像并不是不可能</p>
<h3> 2.3. ColorPicker 图片颜色提取APP</h3>
<blockquote>
<p>源码 <a href="https://github.com/liuyueyi/ai-color-picker" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/ai-color-picker</a></p>
</blockquote>
<p>接下来就准备开始验证这个“人人都是程序员”是否属于我的异想天开了。</p>
<p>直接在应用市场，按照工具类进行下载、好评进行搜索，然后看到了一个百万下载量，而且功能不复杂应用，看到它的时候我就深信这个app完全可以有AI来生成，于是就有了下面的Ai生成应用</p>
<figure><img src="/imgs/column/ai/1_5.png" alt="AI致敬版，百万下载量的高分APP" tabindex="0" loading="lazy"><figcaption>AI致敬版，百万下载量的高分APP</figcaption></figure>
<figure><img src="/imgs/column/ai/1_6.webp" alt="AI生成的ColorPicker" tabindex="0" loading="lazy"><figcaption>AI生成的ColorPicker</figcaption></figure>
<p>AI生成的ColorPicker 谷歌市场下载地址 -&gt; <a href="https://play.google.com/store/apps/details?id=com.git.hui.colorpicker.google" target="_blank" rel="noopener noreferrer">https://play.google.com/store/apps/details?id=com.git.hui.colorpicker.google</a></p>
<ol>
<li>根据上传的图片，识别指定位置的图片颜色的工具</li>
<li>特点：一个完全由AI设计原型、实现业务逻辑细节，并且最终打包为Android APP，集成Admob广告，并上架谷歌应用市场，走通app的开发到上线全流程</li>
</ol>
<h2> 3. ColorPicker的历程</h2>
<p>接下来我将回顾一下 ColorPicker 的诞生历程 <a href="https://github.com/liuyueyi/ai-color-picker/commits/main/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/ai-color-picker/commits/main/</a></p>
<figure><img src="/imgs/column/ai/1_7.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol>
<li>
<p>3.11 号确定应用的主体功能、展现形式，开始编码
• a. 功能：图片提色
• b. 展现形式：wap应用 + 小程序 + app
• c. 技术栈：基于uniapp的技术栈来实现一套代码，多端生成
• d. 编程工具：HBuilder + AndroidStudio + Trae</p>
</li>
<li>
<p>3.12 号完成主体业务功能</p>
</li>
<li>
<p>3.13 号打包到apk，到android进行运行，尝试集成谷歌广告；并提交谷歌应用市场</p>
</li>
<li>
<p>3.14 号谷歌应用市场审批通过；开始第二版的迭代更新 a. 第二版新增：颜色搜索功能、分组、系统推荐色等能力</p>
</li>
<li>
<p>3.15 号解决uniapp上架到谷歌应用市场之后下载安装白屏问题（uniapp的bug)</p>
</li>
</ol>
<p>从想法诞生到最终的落地实现，基本上在五天内（其中app的相干样式适配、广告集成等问题最少花了两天😂），排除android相关的一些改造，其他的内容99.9%的内容全部由Trae来提供支撑，通过实际体验，“人人都是程序员”好像还挺容易成真的；</p>
<p>事后我重新复盘了一下这个开发过程，我将尝试以最大的可能性，给不是程序员这一行的小伙伴，介绍一条可以完全按照自己的想法设计app的小路，让你的创业不再停留在“就缺一个程序员”上了</p>
<h2> 4. 人人都是程序员专栏</h2>
<p>按照个人经验，拟定的专栏内容如下：（当然什么时候更新，我也无法给出肯定的承诺，欢迎关注公众号“一灰灰blog”蹲守第一手信息）</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/ai/1_1.webp" type="image/webp"/>
    </item>
    <item>
      <title>2. 图文手把手教你由0到1基于AI完成“垃圾消除小游戏”</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aicoding/02.%E4%BB%8E0%E5%88%B01%E5%9F%BA%E4%BA%8EAI%E7%94%9F%E6%88%90%E5%B0%8F%E6%B8%B8%E6%88%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aicoding/02.%E4%BB%8E0%E5%88%B01%E5%9F%BA%E4%BA%8EAI%E7%94%9F%E6%88%90%E5%B0%8F%E6%B8%B8%E6%88%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2. 图文手把手教你由0到1基于AI完成“垃圾消除小游戏”</source>
      <description>上一篇文章 首个完全由AI生成的APP上架啦 - ColorPicker 被喷得有点惨，本来是想分享一下最近使用AiCoding的探索发现，结果被好些大佬说是 “毫无技术含量、全是生产互联网垃圾”。说实话，看到这些评论还有点伤心，毕竟八年技术分享无人问，一朝水文大众喷。 虽然不被技术大咖认可，但我的初衷依然和上篇文章回复保持一致</description>
      <category>AI</category>
      <pubDate>Sat, 29 Mar 2025 21:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇文章  <a href="https://mp.weixin.qq.com/s/qtxF-vnUeKrp9BZZRaeeSw" target="_blank" rel="noopener noreferrer">首个完全由AI生成的APP上架啦 - ColorPicker</a>  被喷得有点惨，本来是想分享一下最近使用AiCoding的探索发现，结果被好些大佬说是 “毫无技术含量、全是生产互联网垃圾”。说实话，看到这些评论还有点伤心，毕竟八年技术分享无人问，一朝水文大众喷。</p>
<p>虽然不被技术大咖认可，但我的初衷依然和上篇文章回复保持一致</p>
<figure><img src="/imgs/column/ai/2-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>既然大家都说没有技术难度、是在制造互联网垃圾，那正好可以拿这个主题来校验一下，搞一个毫无技术难度的垃圾消除游戏，下面完整记录这个AICoding生成的游戏全过程，给对这方面感兴趣的小伙伴一个路线参考</p>
<p>全程挑战一下，由AI来生成一个毫无技术难度的小游戏 -- 羊了个羊-垃圾消除版，并分别生成wap版/小程序版/apk版输出</p>
<blockquote>
<p>点击试玩： <a href="https://ai.hhui.top/sheepgame/#/" target="_blank" rel="noopener noreferrer">https://ai.hhui.top/sheepgame/#/</a></p>
</blockquote>
<p>首先是技术栈与开发工具如下：</p>
<p>Uniapp</p>
<p>HBuilder + Trae + Android Studio + 微信小程序开发</p>
<h2> 一、初始化一个项目工程</h2>
<p>打开HBuilder，依次点击：</p>
<h3> 1. 新建项目</h3>
<p>方案1：文件 -&gt; 新建 -&gt; 项目</p>
<figure><img src="/imgs/column/ai/2-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>方案2：点击快速创建项目的按钮，如下图</p>
<figure><img src="/imgs/column/ai/2-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 指定项目信息</h3>
<ul>
<li>由于我们希望一套代码，多端运行（wap--手机浏览器，小程序，APP），因此最左边选择 uni-app</li>
<li>输入项目名、存储路径，选择应用模板</li>
</ul>
<figure><img src="/imgs/column/ai/2-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 使用Trae加载上面的工程</h3>
<ul>
<li>打开应用，会看到下面的截图</li>
<li>然后点击打开文件夹 -- 找到上面生成工程指定的文件夹，选中即可</li>
</ul>
<p><img src="/imgs/column/ai/2-5.webp" alt="" loading="lazy">
<img src="/imgs/column/ai/2-6.webp" alt="" loading="lazy"></p>
<p>此时我们的前置准备工作已经完成，即将进入正式的AICoding阶段</p>
<h2> 二、AICoding阶段</h2>
<h3> 1. 首先在HBuilder上运行一下项目</h3>
<ol>
<li>点击下图中所示的播放图标</li>
<li>在弹出的下拉框中，选择 运行到 Chrome</li>
</ol>
<figure><img src="/imgs/column/ai/2-7.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后你就会看到一个自动打开了一个浏览器，内容长下面这样</p>
<figure><img src="/imgs/column/ai/2-8.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>因为我们的目标输出是基于手机玩耍的小游戏，因此我们可以在浏览器这里按住F12/或者鼠标右键，点击检查，进入开发者模式</p>
<figure><img src="/imgs/column/ai/2-9.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>按照下图的方式进入移动视角</p>
<figure><img src="/imgs/column/ai/2-10.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 进入Trae，让他帮我们生成小游戏</h3>
<ol>
<li>在编辑器的右边AI对话框中，选择 Builder模式，大模型选择 Claude-3.7-Sonnet</li>
</ol>
<figure><img src="/imgs/column/ai/2-11.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="2">
<li>开始提问，给出我们的诉求，下面的描述文案没有任何修辞，就是普通的大白话(毫无技巧可言）</li>
</ol>
<figure><img src="/imgs/column/ai/2-12.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后我们就等待大模型帮我们生成各种代码，在这个过程中，会不断的出现下面这种询问你<strong>是否接受</strong>的情况，一路无脑选择<strong>全部接受</strong>即可</p>
<figure><img src="/imgs/column/ai/2-13.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在最后输出完成之后，它想要运行项目，查看实现的羊了个羊游戏效果；因为我们是HBuilder进行预览，所以直接拒绝它就行</p>
<figure><img src="/imgs/column/ai/2-14.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后我们切换回上一步打开的Chrome浏览器，看看效果；结果很不幸的是并不是我们预期的内容</p>
<figure><img src="/imgs/column/ai/2-15.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 错误调试阶段</h3>
<blockquote>
<p>小概率情况，首次生成的内容不可用，我们需要将对应的错误喂给大模型，让他自己去修复</p>
</blockquote>
<p>上面这种样式，表示生成的代码有问题，那么我们就直接告诉它，修改这些问题</p>
<ul>
<li>将上面的错误截图，丢到对话框，直接让Claude来修正</li>
</ul>
<figure><img src="/imgs/column/ai/2-16.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如果你有编程经验的话，上面这种问题实际上也很好发现，如我们看下它生成的代码</p>
<ul>
<li>正常的代码，标签都是配套出现的，这里 只有<code>&lt;script&gt;</code> 没有<code>&lt;/script&gt;</code>； 只有 <code>&lt;/style&gt;</code> 没有开头的<code>&lt;style&gt;</code></li>
</ul>
<figure><img src="/imgs/column/ai/2-17.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>等上面修复完毕之后，我们在看看Chrome浏览器的运行情况</p>
<ul>
<li>第一张图，为启动页</li>
<li>第二张图为开始游戏之后的页面（没有出现预期的游戏画面，需要我们继续进行调试）</li>
<li>第三张图为游戏介绍页面</li>
</ul>
<figure><img src="/imgs/column/ai/2-18.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>虽然功能还不齐全，但至少没有报错了，UI美化的问题我们放在最后；接下来我们重点调教一下游戏界面</p>
<h3> 4. 游戏界面显示调教</h3>
<p>我们直接对话让它进行修改，这个过程可能需要多轮对话（对于小白而言，这个过程就只能看玄学了，当然如果你掌握一些编程基础，也可以快速发现问题，让后针对性的让AI进行修正）</p>
<figure><img src="/imgs/column/ai/2-19.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>实际不展示游戏区域的原因并不是上面第一轮截图提示的钩子问题，而是样式的问题（大多数白屏都是样式原因导致的）</p>
<figure><img src="/imgs/column/ai/2-20.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>当我们将游戏区域换出来之后发现底部的候选区域当前页显示不出来，还需要下滑；说明游戏区域太大了，我们可以调整一下游戏区域的高度，比如最高占屏幕的 2/3； 其次就是每个卡片太大了，也需要调整一下</p>
<p>然后开始新一轮的样式调整</p>
<figure><img src="/imgs/column/ai/2-21.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>调整完毕之后再看看效果，比之前要好一点了，当然依然存在问题，部分卡片超出游戏区域了，没关系继续让它调整</p>
<figure><img src="/imgs/column/ai/2-22.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 游戏逻辑调教</h3>
<p>我们需要修复一些游戏性的问题：</p>
<ul>
<li>如游戏模式，取消倒计时；改为候选区域填满表示游戏失败</li>
<li>比如同一层的卡片，不应该存在位置重叠的情况</li>
<li>为了更好的游戏性，可以固定限制相邻两层的间距为1/2个卡片</li>
</ul>
<figure><img src="/imgs/column/ai/2-23.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后再游戏试玩的过程中，你还会发现其他的一些问题，比如（底部卡槽填满了，没有告诉用户失败； 卡片明显被遮挡但是又可以被选中等）</p>
<ul>
<li>发现问题不要怕，一给个让它改就行，默默安慰自己享受老板吩咐人干活的快感吧~</li>
</ul>
<figure><img src="/imgs/column/ai/2-24.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>下面是一些游戏逻辑相关的改造问答，就不详细列举了</p>
<figure><img src="/imgs/column/ai/2-25.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>一些调整之后，我们再看看最终的效果</p>
<figure><img src="/imgs/column/ai/2-26.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. UI样式调整</h3>
<p>到应用商店，找一下羊了个羊的官方宣传图，或者下载游戏截个图，丢给trae来调整下整体布局样式，使其更美观一点</p>
<figure><img src="/imgs/column/ai/2-27.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>整体调整之后，比之前稍微好看一点了，不满意的小伙伴可以继续进行调教； 为了更贴合主题，我们将卡片的icon，从现在的动物换成各种垃圾</p>
<figure><img src="/imgs/column/ai/2-28.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>最后再整体调整一下游戏的各个布局（包括开始界面，游戏卡片中图标的大小，游戏logo等），改完之后我们完整的体验一下这个 “垃圾消除游戏”</p>
<p>找豆包，帮我生成icon的文生图提示词；然后再用豆包的文生图获取我们的游戏logo</p>
<figure><img src="/imgs/column/ai/2-29.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>第一次生成的图片不适合作为app的icon，需要更简约一点，就简单的调整下,一次不行多试几次</li>
</ul>
<p>基本功能完成，接下来我们整体体验一下这个垃圾小游戏</p>
<blockquote>
<p>打开公众号原文，体验视频的演示效果： <a href="https://mp.weixin.qq.com/s/mu9l0y18mNE3PlI8EQhrYw" target="_blank" rel="noopener noreferrer">
毫无技术难度：由0到1基于AI完成“垃圾消除小游戏”
</a></p>
</blockquote>
<h2> 三、小结</h2>
<p>这一篇主要通过图文的方式，演示了如何借助Trae来从0到1实现一个小游戏；接下来我们如何将同样通过图文的方式，手把手教你将上面实现的小游戏，打包上线，请看下一篇</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/ai/2-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>3. 图文教你打包基于AI完成“垃圾消除小游戏”</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aicoding/03.%E4%BB%8E0%E5%88%B01%E6%95%99%E4%BD%A0%E6%89%93%E5%8C%85AI%E7%94%9F%E6%88%90%E7%9A%84%E5%B0%8F%E6%B8%B8%E6%88%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aicoding/03.%E4%BB%8E0%E5%88%B01%E6%95%99%E4%BD%A0%E6%89%93%E5%8C%85AI%E7%94%9F%E6%88%90%E7%9A%84%E5%B0%8F%E6%B8%B8%E6%88%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3. 图文教你打包基于AI完成“垃圾消除小游戏”</source>
      <description>上一篇使用图文的方式演示了如何从0到1借助ai生成一个可运行的小游戏，接下来我将通过图文的方式，手把手教你将上面生成的小游戏，打包出来供其他人玩耍 接下来将分别介绍常见的三种打包发行方式 接下来的动作将主要在HBuilder中执行 一、打包成H5游戏 h5游戏，主要用于浏览器直接访问玩耍，需要配置域名，没有域名的小伙伴，可以考虑一些云服务的PAGES服务来实现，接下来介绍下Cloudflare的托管部署方式 Step1. 打包 Hbuilder ，一次点击 发行 -&amp;gt; 网站PC Web 或手机H5 如果出现下面的异常，则按照下图方式进行修正</description>
      <category>AI</category>
      <pubDate>Sat, 29 Mar 2025 21:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇使用图文的方式演示了如何从0到1借助ai生成一个可运行的小游戏，接下来我将通过图文的方式，手把手教你将上面生成的小游戏，打包出来供其他人玩耍</p>
<p>接下来将分别介绍常见的三种打包发行方式</p>
<blockquote>
<p>接下来的动作将主要在HBuilder中执行</p>
</blockquote>
<h2> 一、打包成H5游戏</h2>
<p>h5游戏，主要用于浏览器直接访问玩耍，需要配置域名，没有域名的小伙伴，可以考虑一些云服务的PAGES服务来实现，接下来介绍下Cloudflare的托管部署方式</p>
<h3> Step1. 打包</h3>
<p>Hbuilder ，一次点击 发行 -&gt; 网站PC Web 或手机H5 如果出现下面的异常，则按照下图方式进行修正</p>
<figure><img src="/imgs/column/ai/3-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>打开项目下的 manifest.json 文件</li>
<li>在右边的视图中，点击重新获取按钮
<ul>
<li>如果没有登录的，会让你输入unicod的账号密码，登录即可</li>
<li>成功之后，就会得到下面3所示的AppID</li>
</ul>
</li>
</ul>
<figure><img src="/imgs/column/ai/3-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面问题修复之后，再次进行打包，正确的样式如下</p>
<ul>
<li>因为接下来的演示是基于Cloudflare进行托管，所以下面的域名可以先随便填一个</li>
</ul>
<figure><img src="/imgs/column/ai/3-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后进入上面的输出目录，将目录下的内容打包为zip文件，如下图操作</p>
<figure><img src="/imgs/column/ai/3-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Step2. 发行Cloudflare</h3>
<blockquote>
<p>没有账号的小伙伴自行注册，后续教程给出完整的注册使用流程，敬请蹲守一波😄</p>
</blockquote>
<ul>
<li>直接进入 Workers &amp; Pages 目录</li>
<li>点击create按钮，进入创建应用页面</li>
<li>切换Tab页到Pages -&gt; 点击Upload assets -&gt; 进入发布页面</li>
<li>输入项目名，此时会自动给你分配一个访问域名</li>
<li>接着上传zip压缩包</li>
<li>最后点击发布按钮</li>
</ul>
<figure><img src="/imgs/column/ai/3-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>发布成功的页面如下，我们可以直接点击域名，看一下效果（重点说明一下：上传的压缩包，请确保index.html在最外层）</p>
<figure><img src="/imgs/column/ai/3-6.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>直接点击上面的域名，就可以访问我们的小游戏啦</p>
<ul>
<li>域名是： <a href="https://sheepremove.pages.dev/" target="_blank" rel="noopener noreferrer">https://sheepremove.pages.dev/</a></li>
</ul>
<figure><img src="/imgs/column/ai/3-7.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Step3. 发行到自己的服务器或者OSS托管</h3>
<p>当然如果你有自己的服务器或者OSS，也是可以将h5游戏部署上去的，下面简单介绍下将H5游戏托管到免费的七牛云空间下</p>
<ol>
<li>首先在oss上，创建对应的目录空间，如 /app/sheepremove</li>
</ol>
<figure><img src="/imgs/column/ai/3-8.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="2">
<li>修改HBuilder中web打包的输出前缀</li>
</ol>
<ul>
<li>manifest.json 文件 -&gt; web配置 -&gt; 运行的基础路径</li>
<li>启用https协议这个看你自己的托管域名，支不支持https，支持就选中；不支持就取消</li>
<li>然后重新发行一次： 菜单发行 -&gt; 网站-PC</li>
</ul>
<figure><img src="/imgs/column/ai/3-9.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="3">
<li>上传文件到七牛云</li>
</ol>
<blockquote>
<p>注意此时是文件的形式上传，不用之前的zip压缩包了</p>
</blockquote>
<figure><img src="/imgs/column/ai/3-10.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="4">
<li>体验一下</li>
</ol>
<blockquote>
<p><a href="http://cdn.hhui.top/app/sheepremove/index.html" target="_blank" rel="noopener noreferrer">http://cdn.hhui.top/app/sheepremove/index.html</a></p>
</blockquote>
<figure><img src="/imgs/column/ai/3-11.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、打包成微信小游戏</h2>
<blockquote>
<p>接下来我们看一下将上面的垃圾小游戏生成微信小游戏来体验一下，此时我们需要借助微信开发工具</p>
</blockquote>
<h3> Step1: 微信开发者工具，生成appid</h3>
<ul>
<li>将生成的appid记录出来，后续打包时会用到</li>
<li>注意：这里选择小程序，如果选择小游戏时，uniapp输出到微信时会报错</li>
</ul>
<figure><img src="/imgs/column/ai/3-12.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Step2: 打包微信小程序</h3>
<p>配置小程序AppID</p>
<figure><img src="/imgs/column/ai/3-13.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>case1：运行小程序</strong></p>
<figure><img src="/imgs/column/ai/3-14.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后hbuilder会自动打开微信开发者工具，启动我们的 垃圾消除游戏 , 如下图</p>
<figure><img src="/imgs/column/ai/3-15.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p>说明：多平台时，可能出现各种奇怪的问题，需要针对性的进行提问解决 如：在微信小程序运行时，也出现了一个小问题，游戏区域未显示，同样将问题抛给Trae来修复</p>
</blockquote>
<figure><img src="/imgs/column/ai/3-16.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>case2: 发行小程序</strong></p>
<p>这种场景适用于我们开发完毕，准备提交给微信后台去申请上线，流程如下（由于没准备上线小程序，所以就不演示小程序上线流程了，放在后续的教程进行介绍）</p>
<figure><img src="/imgs/column/ai/3-17.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、打包成Android app</h2>
<p>接下来我们再来演示一下如何将上面的小游戏打包成android 应用包</p>
<h3> Step1: uniapp开发者后台配置签名</h3>
<p>首先进入开发者后台：<a href="https://dev.dcloud.net.cn/pages/app/list" target="_blank" rel="noopener noreferrer">https://dev.dcloud.net.cn/pages/app/list</a></p>
<p>然后点击应用，进入详情：</p>
<ul>
<li>各平台信息 -&gt; 点击新增</li>
<li>进入编辑页，依次补齐下面几个信息</li>
<li>Android App</li>
<li>正式版/测试版 -- 都可以</li>
<li>包名：打包出来的签名，按照惯性约定命名即可</li>
<li>应用签名 SHA1, SHA256 ---&gt; 这个是基于你打包时的签名证书生成的 （后续android输出篇教程详细介绍）</li>
</ul>
<figure><img src="/imgs/column/ai/3-18.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>配置完毕之后，点击提交，返回应用列表</p>
<ul>
<li>点击创建离线Key，再弹窗中点击创建</li>
<li>然后应用列表的按钮变成查看离线key</li>
<li>然后保存弹窗出来的appid</li>
</ul>
<figure><img src="/imgs/column/ai/3-19.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Step2: 打包生成Android的离线资源</h3>
<ul>
<li>菜单点击发行</li>
<li>依次执行 App-Andoird/IOS-本地打包 -&gt; 生成本地打包App资源</li>
</ul>
<figure><img src="/imgs/column/ai/3-20.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Step3: AndroidStudio实现apk输出</h3>
<p>这里直接使用我已经封装好的Android基础工程，跳过基于uniapp的原始项目工程的改造过程；我们接下来看一下如何基于这个基础工程来生成我们的apk包</p>
<p>1.拷贝资源</p>
<ul>
<li>进入android项目的 simpleDemo/src/main/assets/apps 目录</li>
<li>删除目录下的文件</li>
<li>将上面hbuilder生成的资源拷贝进来</li>
</ul>
<figure><img src="/imgs/column/ai/3-21.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="2">
<li>修改data/dcloud_control.xml中的appid</li>
</ol>
<p>将appid改为上面文件夹名（也可以直接在uniapp的后台查看appid)</p>
<figure><img src="/imgs/column/ai/3-22.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="3">
<li>修改AndroidManifest.xml中包名和dcloud_appkey</li>
</ol>
<ul>
<li>package：Step2中填的包名</li>
<li>appKey: Step2中获取的离线key</li>
</ul>
<figure><img src="/imgs/column/ai/3-23.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="4">
<li>修改build.gradle中的包名</li>
</ol>
<ul>
<li>Namespace: 上面的包名</li>
<li>applicationid：上面的包名</li>
</ul>
<figure><img src="/imgs/column/ai/3-24.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="5">
<li>修改应用名和logo</li>
</ol>
<ul>
<li>应用名：res/values/strings.xml 文件中 app_name</li>
</ul>
<figure><img src="/imgs/column/ai/3-25.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>logo:  res/drawable 下的 icon.9.png</li>
</ul>
<p>将前面生成的icon，拷贝到上面的drawable目录下，然后删除原来的icon.9.png</p>
<figure><img src="/imgs/column/ai/3-26.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="6">
<li>打包 - 步骤如下：</li>
</ol>
<ul>
<li>菜单，点击 Build</li>
<li>在下拉框中，选择 Generate Signed App Bundle/APK</li>
<li>选择APK</li>
<li>点击Next</li>
<li>输入打包证书地址、密码、别名等信息</li>
<li>选择release</li>
<li>点击create，等待下面打包成功的提示</li>
<li>在 simpleDemo/release 目录下可以看到输出的apk包</li>
</ul>
<figure><img src="/imgs/column/ai/3-27.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Step4：安装体验</h3>
<p>直接用手机安装一下上面的apk，下面是实际的体验视频（在视频中你也会发现打开会有版本的弹窗提示，这个是uniapp的提醒，可以消除掉；以及android端的样式还需要调整下，这里就不详细展开了）</p>
<p>有兴趣体验的小伙伴，可以下载apk:（说明，这个安装包中集成了谷歌的测试广告，后续在apk打包篇中会介绍如何给应用加上广告变现）</p>
<ul>
<li><a href="http://cdn.hhui.top/app/sheepremove/%E5%9E%83%E5%9C%BE%E6%B6%88%E9%99%A4%E5%B0%8F%E6%B8%B8%E6%88%8F.apk" target="_blank" rel="noopener noreferrer">APK下载地址: </a></li>
</ul>
<p>演示视频，原文查看: - <a href="https://mp.weixin.qq.com/s/mu9l0y18mNE3PlI8EQhrYw" target="_blank" rel="noopener noreferrer">毫无技术难度：由0到1基于AI完成“垃圾消除小游戏”</a></p>
<h2> 四、小结</h2>
<p>这个垃圾消除小游戏的开动到apk的手机完整运行，再加上完成本篇文章，总计耗时 5 小时左右，说长不长，说短不短。</p>
<p>上面小游戏的所有代码全部由AI生成，我主要发挥的作用就是给ai喂我的想法、以及适当的告诉它怎么解决问题（有时候ai解决问题的速度有点让人难受），一个完整的流程下来，编程小白想要完成一个自己的h5/小程序/app游戏可能有点挑战，但是耐心怼一波，也不是不可能出现奇迹</p>
<p>最后我想说的一点是，AI正在飞速发展，作为一个十年的互联网的coder真心希望所有的程序员不要傲慢，你可能认为AICoding还很初级、经常制造各种垃圾，但不得不说现如今AiCoding已经对初级程序员已经发起了挑战，同时也为所有的非程序员，打开了一个实现自己想法/产品的大门。</p>
<p>我是一灰灰，后续我将会给大家带来更多的AICoding的系列教程，比如上面提到但是没有展开的</p>
<p>• 各编程工具的安装、调试、基本使用姿势介绍
• 项目开发管理的阶段性保存方案
• H5托管相关知识点：CloudFlare、GitHub Pages、自己专属服务器托管，接入Google AdSense变现
• 微信小程序的发包上线全流程
• Android的广告集成相关</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/ai/3-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>4. 不借助AI也可以实现图片转线稿</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aicoding/04.%E4%B8%8D%E5%80%9F%E5%8A%A9AI%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AC%E7%BA%BF%E7%A8%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aicoding/04.%E4%B8%8D%E5%80%9F%E5%8A%A9AI%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AC%E7%BA%BF%E7%A8%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">4. 不借助AI也可以实现图片转线稿</source>
      <description>最近准备实现一个根据图片生成简笔画的应用，研究了下现在的ai能力，在使用百度的图片提取线稿的时候发现AI处理能力是真的强，比如下面是几个提取case 从整体的实现效果来看，还是非常不错的，对于现实人物、3d图、2d卡通、建筑的线稿提取结果可以说几近完美了。唯一的小问题就是处理时间长了一点，也不免费... 那么有没有其他开源的工具可以直接使用呢，发现了两个有意思的开源项目，一个是基于机器学习训练结果的，另一个则是直接使用算法(代码行&amp;lt;50行)进行提取转换</description>
      <category>AI</category>
      <pubDate>Wed, 11 Jun 2025 10:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>最近准备实现一个根据图片生成简笔画的应用，研究了下现在的ai能力，在使用百度的图片提取线稿的时候发现AI处理能力是真的强，比如下面是几个提取case</p>
<figure><img src="/imgs/column/ai/4-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从整体的实现效果来看，还是非常不错的，对于现实人物、3d图、2d卡通、建筑的线稿提取结果可以说几近完美了。唯一的小问题就是处理时间长了一点，也不免费...</p>
<p>那么有没有其他开源的工具可以直接使用呢，发现了两个有意思的开源项目，一个是基于机器学习训练结果的，另一个则是直接使用算法(代码行&lt;50行)进行提取转换</p>
<h3> 基于训练模型 rocca/informative-drawings-line-art-onnx</h3>
<p>模型地址-&gt; <a href="https://huggingface.co/rocca/informative-drawings-line-art-onnx" target="_blank" rel="noopener noreferrer">https://huggingface.co/rocca/informative-drawings-line-art-onnx</a></p>
<p>项目源码：<a href="https://github.com/josephrocca/image-to-line-art-js" target="_blank" rel="noopener noreferrer">https://github.com/josephrocca/image-to-line-art-js</a></p>
<p>使用约17兆的模型即可实现线图提取功能，下面是官方的demo表现情况</p>
<figure><img src="/imgs/column/ai/4-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的处理结果也可以看出，对于卡通图像的转换效果还是可以的；但是对于显示人物、建筑之类的效果就一一般般了</p>
<h3> 算法提取</h3>
<p>项目源码：<a href="https://github.com/FlandreDaisuki/Outline-Extractor" target="_blank" rel="noopener noreferrer">Outline-Extractor</a></p>
<p>核心算法</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在线体验地址: <a href="https://ai.hhui.top/app/imgline.html" target="_blank" rel="noopener noreferrer">https://ai.hhui.top/app/imgline.html</a></p>
<p>整体表现效果如下:</p>
<figure><img src="/imgs/column/ai/4-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从实际的效果来看，和上面的训练模型的处理结果半斤八两，不过好处也很明显，处理效率明显更高，且无外部依赖</p>
<h3> 小结</h3>
<p>下面是具体的对照结果，对于卡通图片，如果希望提取线稿，会发现即便不使用大模型、机器学习的能力，借助最基础的算法处理，不超过50行的代码也可以实现相对理想的效果</p>
<table>
<thead>
<tr>
<th>原图</th>
<th>百度提取线图</th>
<th>训练模型处理</th>
<th>算法提取</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/imgs/column/ai/4-4-0.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-b-0.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-t-0.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-s-0.jpg" alt="" loading="lazy"></td>
</tr>
<tr>
<td><img src="/imgs/column/ai/4-4-1.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-b-1.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-t-1.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-s-1.jpg" alt="" loading="lazy"></td>
</tr>
<tr>
<td><img src="/imgs/column/ai/4-4-2.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-b-2.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-t-2.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-s-2.jpg" alt="" loading="lazy"></td>
</tr>
<tr>
<td><img src="/imgs/column/ai/4-4-3.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-b-3.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-t-3.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-s-3.jpg" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/ai/4-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>5. 浏览器中跑大模型-搭建一个自动抠图服务</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aicoding/05.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%B7%91%E5%A4%A7%E6%A8%A1%E5%9E%8B-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E6%8A%A0%E5%9B%BE%E6%9C%8D%E5%8A%A1.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aicoding/05.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%B7%91%E5%A4%A7%E6%A8%A1%E5%9E%8B-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E6%8A%A0%E5%9B%BE%E6%9C%8D%E5%8A%A1.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">5. 浏览器中跑大模型-搭建一个自动抠图服务</source>
      <description>抠图的场景大家应该很熟悉了，使用大模型来抠图也属于很常见的功能了，但是在操作一些相对隐私的图片总会有一点点担心。那么在自己的电脑上跑一个大模型？ 电脑的性能够呛！ 难道就没有什么离线的大模型可以用嘛？ 相信很多小伙伴都听过Transformers.js，一个JavaScript库，它允许开发者在浏览器或Node.js环境中使用Hugging Face的预训练机器学习模型，无需服务器支持 最近花了一点时间（主要是借助豆包）来写了一个网页，支持在浏览器本地直接跑RMBG V1.4模型，实现离线的智能抠图功能。 下来看看整体的表现情况</description>
      <category>AI</category>
      <pubDate>Fri, 13 Jun 2025 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>抠图的场景大家应该很熟悉了，使用大模型来抠图也属于很常见的功能了，但是在操作一些相对隐私的图片总会有一点点担心。那么在自己的电脑上跑一个大模型？ 电脑的性能够呛！ 难道就没有什么离线的大模型可以用嘛？</p>
<p>相信很多小伙伴都听过<code>Transformers.js</code>，一个JavaScript库，它允许开发者在浏览器或Node.js环境中使用Hugging Face的预训练机器学习模型，无需服务器支持</p>
<p>最近花了一点时间（主要是借助豆包）来写了一个网页，支持在浏览器本地直接跑RMBG V1.4模型，实现离线的智能抠图功能。 下来看看整体的表现情况</p>
<figure><img src="/imgs/column/ai/5-1.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>支持本地上传图片、粘贴上传图片、拖拽上传图片三种方式；首次访问网页时，会自动下载大模型(约40M)，下载成功之后会在提示区域显示“模型已加载完成”，之后所有的操作将基于用户的浏览器进行操作，无后端交互，隐私无忧</p>
<figure><img src="/imgs/column/ai/5-2.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 实际体验</h3>
<p>有兴趣的小伙伴可以实际体验，访问地址：<a href="https://ai.hhui.top/app/rmBg.html" target="_blank" rel="noopener noreferrer">https://ai.hhui.top/app/rmBg.html</a></p>
<p>它的核心玩法很简单粗暴：</p>
<ol>
<li>打开网页。</li>
<li>选择本地图片（或拖拽或粘贴一个图片）。</li>
<li>点击开始处理图片</li>
<li>几秒后（看图片大小和机器性能），抠好的图直接显示/下载。</li>
</ol>
<figure><img src="/imgs/column/ai/5-3.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>这体验就丝滑了：</strong></p>
<ul>
<li><strong>速度起飞：</strong> 省了上传下载的大头时间，处理速度就看用户本机CPU/GPU了。</li>
<li><strong>隐私拉满：</strong> 用户数据本地处理，安全感爆棚，合规风险骤降。</li>
<li><strong>零成本调用：</strong> 对开发者/服务提供方来说，没有图片传输的带宽成本，没有按次调用的API费用，服务器压力？不存在的！</li>
<li><strong>开箱即用：</strong> 用户不用装软件，不用注册，打开就用，用完就走。</li>
</ul>
<h3> 关键技术说明</h3>
<p>怎么做到的？关键点在这儿（技术老铁们看过来）：</p>
<ol>
<li><strong>模型本地化：</strong> 这个网页背后，在首次加载时（或按需），把训练好的抠图模型（onnx）<strong>直接下载到了用户的浏览器缓存里</strong>。模型大小约40M，百兆网速的小伙伴也就是几秒的加载时间。</li>
<li><strong>浏览器内推理引擎：</strong> 依靠的是强大的 <strong><code>transformers.js</code></strong> 。它们提供了在浏览器JavaScript环境中直接加载和运行AI模型的能力。</li>
</ol>
<p>对咱们开发者有啥启发？</p>
<ol>
<li><strong>边缘计算的魅力：</strong> 这就是“边缘计算”在Web端的生动体现啊！把计算负载从中心服务器下放到终端设备（浏览器），解决延迟、隐私、成本问题。想想看，除了抠图，像简单的图像分类、风格迁移、文本摘要、甚至轻量级的语音识别，是不是都有可能搬到浏览器里？</li>
<li><strong>Web ML 生态成熟：</strong> <code>transformers.js</code>、ONNX Runtime Web、TensorFlow.js 这些工具链越来越成熟，让在Web端部署和运行（尤其是优化后的）模型不再是天方夜谭。前端工程师的武器库又丰富了！</li>
<li><strong>用户体验新思路：</strong> 对于需要处理用户本地数据的应用（图片、文档、音视频片段），<strong>“本地优先”</strong> 的处理策略能极大提升用户体验和信任度。这个抠图工具就是个很好的样板。</li>
<li><strong>模型优化是王道：</strong> 浏览器环境资源有限（内存、算力），模型必须<strong>轻量化、高效化</strong>。这倒逼我们在模型设计、剪枝、量化、格式转换上做更多优化工作。</li>
</ol>
<p><strong>值得一试吗？</strong></p>
<p>当然！无论你是：</p>
<ul>
<li><strong>好奇宝宝：</strong> 想看看浏览器里跑模型到底啥感觉？</li>
<li><strong>前端攻城狮：</strong> 想探索Web ML的可能性边界？</li>
<li><strong>后端/全栈：</strong> 在琢磨如何降低服务端负载、优化成本结构？</li>
<li><strong>产品经理：</strong> 在寻找提升用户体验、增强隐私卖点的方案？</li>
</ul>
<p>这个网页都值得你点开玩一玩：<strong><a href="https://ai.hhui.top/app/rmBg.html" target="_blank" rel="noopener noreferrer">https://ai.hhui.top/app/rmBg.html</a></strong></p>
<p><strong>实际体验感受：</strong></p>
<ul>
<li>首次加载可能需要下载模型（40MB级别），有点耐心。</li>
<li>抠图速度取决于你电脑性能，实测普通照片几秒到十几秒搞定，效果在浏览器里跑成这样相当不错了（当然不能和顶级桌面软件比）。</li>
<li>最大的爽点：图片真的没上传！打开浏览器开发者工具 - 网络（Network）标签页，你会看到除了加载网页本身和模型文件，<strong>处理过程中没有任何图片上传的请求！</strong> 这感觉，踏实。</li>
</ul>
<p><strong>最后叨叨：</strong></p>
<p>这个网页虽然是个工具，但它展示的思路非常有价值。随着Web ML技术的进步和终端设备算力的提升，<strong>把更多AI能力“沉”到浏览器端</strong>，会是优化用户体验、降低成本、保护隐私的一个重要方向。对于隐私优先的小伙伴，不妨收藏一波😊</p>
<p><strong>链接再放一次，动手试试吧：</strong>
<a href="https://ai.hhui.top/app/rmBg.html" target="_blank" rel="noopener noreferrer">https://ai.hhui.top/app/rmBg.html</a></p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/ai/5-1.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>6. 基于Trae开发android原生应用，顺利上架谷歌应用市场</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aicoding/06.%E5%9F%BA%E4%BA%8ETrae%E5%BC%80%E5%8F%91android%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E5%B9%B6%E4%B8%8A%E6%9E%B6%E5%BA%94%E7%94%A8%E5%B8%82%E5%9C%BA.html</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aicoding/06.%E5%9F%BA%E4%BA%8ETrae%E5%BC%80%E5%8F%91android%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E5%B9%B6%E4%B8%8A%E6%9E%B6%E5%BA%94%E7%94%A8%E5%B8%82%E5%9C%BA.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">6. 基于Trae开发android原生应用，顺利上架谷歌应用市场</source>
      <description>之前使用Trae开发的项目主要是基于web技术栈来搭建的，借助uniapp的生态体系，来生成多端可运行的应用，整体实现链路还是很顺畅的。但是最近准备开发一个android的小部件，需要使用原生的kotlin进行开发，发现直接使用Trae做原生开发，也意外的顺利 下来进行简单的记录一下，使用Trae进行原生开发的过程 一、应用预览 需要开发的应用本身比较简单，主要是为用户提供两种类型的小组件，文本小组件 + 计时小组件 支持用户在手机桌面上，添加一些豆腐块的文案/倒计时，用于装饰or提醒</description>
      <category>AI</category>
      <pubDate>Mon, 16 Jun 2025 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>之前使用Trae开发的项目主要是基于web技术栈来搭建的，借助uniapp的生态体系，来生成多端可运行的应用，整体实现链路还是很顺畅的。但是最近准备开发一个android的小部件，需要使用原生的kotlin进行开发，发现直接使用Trae做原生开发，也意外的顺利</p>
<p>下来进行简单的记录一下，使用Trae进行原生开发的过程</p>
<h2> 一、应用预览</h2>
<p>需要开发的应用本身比较简单，主要是为用户提供两种类型的小组件，文本小组件  + 计时小组件</p>
<p>支持用户在手机桌面上，添加一些豆腐块的文案/倒计时，用于装饰or提醒</p>
<figure><img src="https://ai.hhui.top/static/textwidget/s0.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>app体验地址： <a href="https://play.google.com/store/apps/details?id=com.github.hui.textwidget" target="_blank" rel="noopener noreferrer">https://play.google.com/store/apps/details?id=com.github.hui.textwidget</a></p>
<figure><img src="/imgs/column/ai/6-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、原生开发流程</h2>
<p>接下来我们看一下使用trae进行原生开发的流程，基本思路和之前介绍的 <a href="https://mp.weixin.qq.com/s/mu9l0y18mNE3PlI8EQhrYw" target="_blank" rel="noopener noreferrer">毫无技术难度：由0到1基于AI完成“垃圾消除小游戏”</a> 一致，只是部分具体的操作有些差异</p>
<h3> 1. 新建项目</h3>
<p>使用android studio创建一个空的项目</p>
<figure><img src="/imgs/column/ai/6-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在弹窗中，输入项目相关信息</p>
<figure><img src="/imgs/column/ai/6-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 使用Trae打开项目</h3>
<p>使用trae打开刚才创建的项目，然后进行初始化</p>
<figure><img src="/imgs/column/ai/6-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>首先声明项目类型，然后给出指令，让trae帮我们自动生成对应的界面；</p>
<p>需要注意的时，首次进行kotlin开发时，trae对kotlin语言的支持不够友好，我们需要在插件市场中安装相关插件</p>
<figure><img src="/imgs/column/ai/6-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 基于对话的功能实现</h3>
<p>因为这个app的设计非常简单，一个文本小部件、一个计时小部件；</p>
<p>因此核心的功能实现分两块</p>
<ul>
<li>小部件设置相关</li>
<li>小部件展示相关</li>
</ul>
<p>其中小部件的设置，主要是支持用户设置自己想要展示的文本、倒计时还是正计时，背景颜色、文字颜色、对齐方式等</p>
<figure><img src="/imgs/column/ai/6-6.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>小部件因为有两种不同的类型：文本 + 计时，因此我们也需要实现两个小部件</p>
<figure><img src="/imgs/column/ai/6-7.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p>说明：由于原生开发不像页面开发可以直接浏览器实时预览效果；原生开发过程中，我们需要不断的使用android studio查看生成的代码是否存在语法问题，借助Android Studio的模拟器来预览生成的效果</p>
</blockquote>
<figure><img src="/imgs/column/ai/6-8.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 打包上传</h3>
<p>相比较于uniapp的打包，原生开发就简单很多了，无需额外操作；直接在原生项目中打包即可</p>
<figure><img src="/imgs/column/ai/6-9.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、上架应用市场</h2>
<p>上架应用市场的流程之前介绍过，有兴趣的小伙伴可以翻一下</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/e3wZ7wMnKepm6R1Cz2DbAw?token=32118257&amp;lang=zh_CN" target="_blank" rel="noopener noreferrer">AI生成的垃圾小游戏-上架谷歌应用市场全流程-图文介绍</a></li>
</ul>
<p>我们在上架之前，先集成一下admob广告（赚一点是一点嘛），这里的广告集成与之前介绍的有一些区别，因为原生开发主要是基于Jetpack来实现的，因此我们的广告sdk的集成方式也需要相应的进行调整</p>
<p>比如新增一个底部的banner广告 ，直接在官方的demo扣过来，让trae进行二次改造</p>
<figure><img src="/imgs/column/ai/6-10.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 四、小结</h2>
<p>作为一个业余前端选手，借助热火朝天的“氛围编程”也实现了一些没什么鸟用的应用，没有太大障碍的完成了webapp、网页开发、浏览器插件、基于uniapp的跨端开发(小程序、h5、安卓应用)，现在也完成了基于原生kotlin的app开发全流程，整体感受就是只要你愿意折腾，技术的门槛是越来越低的</p>
<p>下面是一些借助Trae进行开发的过程，有兴趣的小伙伴可以看看</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487677&amp;idx=1&amp;sn=3cb47b3c8d84c7f3d299174205bdaa07&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">首个完全由AI生成的APP上架啦 - ColorPicker</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487748&amp;idx=1&amp;sn=eac77c82547603cd19725260d1bb584a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">毫无技术难度：由0到1基于AI完成“垃圾消除小游戏”</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487847&amp;idx=1&amp;sn=ee5bea7a986f364314c50f667bbe9dfb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">AI生成的垃圾小游戏-上架谷歌应用市场全流程-图文介绍</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487868&amp;idx=1&amp;sn=2a80743e416a3b00e3c66421547c5c94&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">AI 生成 web 应用，如何通过广告变现 “钱” 景无限</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487901&amp;idx=1&amp;sn=d7130ffcb19fde9d7ac23cdc529c08df&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">AI生成APP-接入谷歌变现图文攻略</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487950&amp;idx=1&amp;sn=09a9823ebdee85fb2d5bf0331504b48b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">借助AI赚美刀-谷歌广告收款攻略</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487936&amp;idx=1&amp;sn=eafd7f1c95e06fff4f5ed1092ae68508&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">借助Trae的智能体完成我的浏览器主页个性化改造图文全流程</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247488002&amp;idx=1&amp;sn=5400567e26ca17710b923b3fb119b873&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">AI生成插件上架Chrome应用商店全流程</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247488089&amp;idx=1&amp;sn=8c57c677237861f88f705918186b7b4c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">浏览器里直接跑大模型抠图？试试这个借助transform.js搭建网页神器吧</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://ai.hhui.top/static/textwidget/s0.webp" type="image/webp"/>
    </item>
    <item>
      <title>AI专栏</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">AI专栏</source>
      <description>AI专栏 氛围编程 | 人人都是程序员</description>
      <pubDate>Fri, 30 May 2025 08:22:22 GMT</pubDate>
      <content:encoded><![CDATA[<h1> AI专栏</h1>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> <a href="/tutorial/column/ai/aicoding/" target="blank">氛围编程 | 人人都是程序员</a></label></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>人人都是程序员</title>
      <link>https://liuyueyi.github.io/tutorial/column/ai/aicoding/</link>
      <guid>https://liuyueyi.github.io/tutorial/column/ai/aicoding/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">人人都是程序员</source>
      <description>氛围编程 借助AiCoding（如cursor windsurf trae copilot）来实现低门槛的编程</description>
      <pubDate>Fri, 30 May 2025 08:22:22 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 氛围编程</h1>
<p>借助AiCoding（如cursor windsurf trae copilot）来实现低门槛的编程</p>
]]></content:encoded>
    </item>
    <item>
      <title>3. Kotlin Lambda表达式</title>
      <link>https://liuyueyi.github.io/tutorial/codelan/kotlin/03.Kotlin%20Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/codelan/kotlin/03.Kotlin%20Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">3. Kotlin Lambda表达式</source>
      <description>以下是关于 Kotlin Lambda 表达式的深度解析，包含核心概念、使用方式、工作原理及最佳实践： 一、Lambda 表达式的本质 定义：Lambda 是一个匿名函数，可作为参数传递或赋值给变量。 Kotlin 中的 Lambda 是函数式编程的核心工具，用于简化代码和实现高阶函数。 基本语法： { 参数列表 -&amp;gt; 函数体 } // 示例：加法 Lambda val sum: (Int, Int) -&amp;gt; Int = { a, b -&amp;gt; a + b }</description>
      <category>Kotlin</category>
      <pubDate>Thu, 22 May 2025 08:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>以下是关于 Kotlin Lambda 表达式的深度解析，包含核心概念、使用方式、工作原理及最佳实践：</p>
<h3> <strong>一、Lambda 表达式的本质</strong></h3>
<p><strong>定义</strong>：Lambda 是一个<strong>匿名函数</strong>，可作为参数传递或赋值给变量。</p>
<p>Kotlin 中的 Lambda 是<strong>函数式编程</strong>的核心工具，用于简化代码和实现高阶函数。</p>
<p><strong>基本语法</strong>：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>二、Lambda 的使用方式</strong></h3>
<h4> <strong>1. 作为函数参数</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>2. 集合操作（最常见场景）</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>3. 作用域函数（let/run/with/apply/also）</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>4. 替代接口实现（SAM 转换）</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>三、Lambda 的关键特性</strong></h3>
<h4> <strong>1. 自动推断参数类型</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>2. 单个参数的隐式名称 <code>it</code></strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>3. 闭包特性（捕获外部变量）</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>4. 匿名函数（Lambda 的变体）</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>四、Lambda 的工作原理</strong></h3>
<h4> <strong>1. 编译后的实现</strong></h4>
<ul>
<li><strong>非内联 Lambda</strong>：编译为实现 <code>FunctionN</code> 接口的匿名类（如 <code>Function0</code>、<code>Function1</code>）。<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li><strong>内联 Lambda</strong>：编译时直接替换函数体，避免类创建（见下文）。</li>
</ul>
<h4> <strong>2. 闭包的实现</strong></h4>
<ul>
<li>捕获的变量被封装在一个对象中，Lambda 持有该对象的引用。<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h3> <strong>五、内联 Lambda（性能优化）</strong></h3>
<p><strong>问题</strong>：普通 Lambda 会生成匿名类，带来额外内存开销。<br>
<strong>解决方案</strong>：使用 <code>inline</code> 关键字消除此类开销。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>限制</strong>：</p>
<ul>
<li>内联 Lambda 中不能使用非局部返回（除非用 <code>crossinline</code>）。</li>
<li>大型 Lambda 可能导致代码膨胀。</li>
</ul>
<h3> <strong>六、常见陷阱与注意事项</strong></h3>
<h4> <strong>1. 非局部返回</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>2. 内存泄漏风险</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>3. 过度使用 Lambda 导致可读性下降</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>七、最佳实践推荐</strong></h3>
<h4> <strong>1. 优先使用 Lambda 简化代码</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>2. 避免长 Lambda，保持简洁</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>3. 利用 Lambda 实现 DSL</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>4. 合理使用内联优化性能</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>八、Lambda 与其他 Kotlin 特性的结合</strong></h3>
<h4> <strong>1. 与委托属性结合</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>2. 与协程结合</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>3. 与集合操作结合</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>九、性能考量</strong></h3>
<ol>
<li><strong>普通 Lambda</strong>：每次调用创建新对象，适合低频场景。</li>
<li><strong>内联 Lambda</strong>：避免对象创建，适合高频场景（如集合操作）。</li>
<li><strong>静态 Lambda</strong>：使用 <code>@JvmStatic</code> 注解减少实例创建（Kotlin/Java 互操作）。</li>
</ol>
<h3> <strong>总结</strong></h3>
<p>Kotlin Lambda 是函数式编程的核心工具，通过简洁的语法和强大的功能大幅提升代码可读性和生产力。其核心优势在于：</p>
<ul>
<li><strong>简化代码</strong>：替代冗长的匿名类和循环结构。</li>
<li><strong>高阶函数</strong>：支持将函数作为一等公民传递。</li>
<li><strong>闭包特性</strong>：自然捕获和操作外部变量。</li>
<li><strong>性能优化</strong>：通过内联消除运行时开销。</li>
</ul>
<p>掌握 Lambda 需要理解其语法糖背后的实现原理，避免常见陷阱（如非局部返回、内存泄漏），并结合内联等特性优化性能。在实际项目中，Lambda 特别适合集合操作、异步回调和 DSL 构建等场景。</p>
]]></content:encoded>
    </item>
    <item>
      <title>1.Spring7.0特性预览</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E8%BF%AD%E4%BB%A3/01.Spring7.0%E7%89%B9%E6%80%A7%E9%A2%84%E8%A7%88.html</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E8%BF%AD%E4%BB%A3/01.Spring7.0%E7%89%B9%E6%80%A7%E9%A2%84%E8%A7%88.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1.Spring7.0特性预览</source>
      <description>Spring 官方已经发布了 Spring Boot 4.0 的快照版本，内置 Spring Framework 7.0。 接下来我们快速预览一下Spring7.0又带来了哪些改变 以下所有内容来自官方WiKi: Spring-Framework-7.0-Release-Notes</description>
      <category>SpringBoot</category>
      <category>迭代</category>
      <pubDate>Fri, 30 May 2025 12:55:36 GMT</pubDate>
      <content:encoded><![CDATA[<p>Spring 官方已经发布了 Spring Boot 4.0 的快照版本，内置 Spring Framework 7.0。</p>
<p>接下来我们快速预览一下Spring7.0又带来了哪些改变</p>
<blockquote>
<p>以下所有内容来自官方WiKi: <a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-7.0-Release-Notes" target="_blank" rel="noopener noreferrer">Spring-Framework-7.0-Release-Notes</a></p>
</blockquote>
<h2> 1. 最低环境要求</h2>
<p>JDK的版本要求没有变更， JDK 17-27 均支持</p>
<ul>
<li>Jakarta EE 11 (Tomcat 11+)</li>
<li>Kotlin 2.x</li>
<li>JSONassert 2.0</li>
<li>GraalVM 23</li>
</ul>
<h2> 2. 移除的API</h2>
<h3> 2.1 Spring JCL 停用</h3>
<p><code>Java Commons Logging（JCL）</code> 是 Apache 提供的日志门面（Facade），允许开发者通过统一接口调用不同底层日志框架;</p>
<h3> 2.2 移除 <code>javax.annotation</code> 和 <code>javax.inject</code>注解</h3>
<p>这两个包下我们常见的注解有 <code>@Resource</code> ， <code>@PostConstruct</code>, <code>@Inject</code>，这些在SpringBoot2+的生态下，应该是非常常见的使用注解了，如果你在SpringBoot4(Spring7)之后继续使用，那么需要改成 <code>jakarta.annotation</code> 和 <code>jakarta.inject packages</code>下的依赖</p>
<h3> 2.3 路径映射选项删除</h3>
<p>自 6.0 版本以来，多个路径映射选项已被标记为删除。 下面这些选项现已被彻底删除。 其中包括：</p>
<ol>
<li><code>suffixPatternMatch</code>/<code>registeredSuffixPatternMatch</code> 注解控制方法</li>
</ol>
<p>控制是否允许通过 <strong>URL 路径后缀</strong>（如 .json、.xml）匹配控制器方法。</p>
<ul>
<li><code>suffixPatternMatch=true</code>：允许通过后缀匹配（例如 /data.json 映射到 @RequestMapping("/data")）。</li>
<li><code>registeredSuffixPatternMatch=true</code>：仅允许匹配已注册的后缀（需配合 ContentNegotiationManager 配置）。</li>
</ul>
<p>一个简单使用场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong>：</p>
<ul>
<li>启用后缀匹配可能导致安全风险（如通过 .jsp 访问未授权资源），建议结合白名单使用。</li>
<li>默认情况下，registeredSuffixPatternMatch 为 false。</li>
</ul>
<ol start="2">
<li><code>trailingSlashMatch</code> （AbstractHandlerMapping 扩展）</li>
</ol>
<p><strong>作用</strong>：
控制是否忽略 URL 末尾的斜杠（/）。</p>
<ul>
<li>trailingSlashMatch=true：/path 和 /path/ 视为同一路径。</li>
<li>trailingSlashMatch=false：严格区分末尾斜杠。</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意事项</strong>：
Spring Boot 2.3+ 默认禁用末尾斜杠匹配，需手动启用。</p>
<ol start="3">
<li>内容协商配置</li>
</ol>
<p><strong>favorPathExtension / ignoreUnknownPathExtensions</strong></p>
<p><em>作用</em>：</p>
<ul>
<li>favorPathExtension=true：优先通过 URL 后缀（如 .json）决定响应内容类型。</li>
<li>ignoreUnknownPathExtensions=true：忽略未识别的后缀（返回默认内容类型）。</li>
</ul>
<p><em>关联策略类</em>：</p>
<ul>
<li>PathExtensionContentNegotiationStrategy：基于路径后缀协商。</li>
<li>ServletPathExtensionContentNegotiationStrategy：基于 Servlet 容器特性协商。</li>
</ul>
<p><em>Java Config 示例</em>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em>MVC Java Config</em></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4">
<li>路径模式解析配置</li>
</ol>
<p><strong><code>matchOptionalTrailingSeparator</code> in <code>PathPatternParser</code></strong></p>
<p><em>作用</em>：
控制路径匹配时是否允许可选的尾部斜杠。</p>
<ul>
<li>true：/path 和 /path/ 匹配同一控制器方法。</li>
<li>false：严格区分尾部斜杠。</li>
</ul>
<p><em>配置示例</em>（Spring Boot 2.3+）</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>需配合 PathPatternParser 使用（默认策略为 AntPathMatcher）</p>
<h2> 3.弃用</h2>
<ol>
<li>Spring MVC 的 <code>&lt;mvc:*&gt;</code> XML 配置命名空间现已弃用，推荐改用 Java 配置方式。目前暂无完全移除 XML 配置的计划，但后续更新将不再适配 Java 配置模型。其他命名空间（如 <code>&lt;bean&gt;</code>）未弃用。</li>
<li>Kotlin 团队计划在未来的 Kotlin 2.x 版本中移除对 JSR 223 的支持，因此 Spring 中针对 Kotlin 脚本的模板功能已被标记为弃用。</li>
<li>Spring TestContext Framework 对 JUnit 4 的支持已弃用，推荐使用 JUnit Jupiter 的 SpringExtension。<br>
弃用的类包括：
<ul>
<li>SpringRunner</li>
<li>SpringClassRule</li>
<li>SpringMethodRule</li>
<li>AbstractJUnit4SpringContextTests</li>
<li>AbstractTransactionalJUnit4SpringContextTests及相关支持类。</li>
</ul>
</li>
<li>Jackson 2.x 的支持已弃用，推荐迁移到 Jackson 3.x</li>
</ol>
<h2> 4. Null安全</h2>
<p>新版本采用 JSpecify 注解来声明 API 的空值安全性，使用 @Nullable 表示可为 Null，使用 @NonNull 表示不能为空，并且会通过 Idea 配合提示警告或错误信息，例如以下代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5. HTTP代理</h2>
<p>新版本提供了 @ImportHttpServices 注解，让你为 HTTP 接口创建代理更加容易，示例代码如下（它允许您轻松声明、检测和配置整个 HTTP 服务组）：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 6. Bean注入</h2>
<p>Bean 注册器实现使用 BeanRegistry 和 Environment API，以简洁灵活的方式通过编程方式注册 Bean。例如，它允许通过 if 表达式、for 循环等进行自定义注册。</p>
<p>在之前，我们使用Configuration来注册bean，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在则可以通过实现<code>BeanRegistrar</code>来实现更灵活的bean注册</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 7. 接口版本控制</h2>
<p>新版本引入了优雅的 API 版本控制支持，允许开发者通过 @RequestMapping 注解中的 version 参数来实现版本控制，如下代码所示</p>
<blockquote>
<p><a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-7.0-Release-Notes" target="_blank" rel="noopener noreferrer">https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-7.0-Release-Notes</a></p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>匹配任何版本</li>
<li>匹配 version 1.1</li>
<li>匹配 1.2 and above</li>
<li>匹配 1.5</li>
</ol>
<p>然后通过请求参数来控制不同的版本，v1/v2的请求分别为</p>
<ul>
<li><a href="http://localhost:8080/account/1?version=1" target="_blank" rel="noopener noreferrer">http://localhost:8080/account/1?version=1</a>  getAccount()</li>
<li><a href="http://localhost:8080/account/1?version=1.1" target="_blank" rel="noopener noreferrer">http://localhost:8080/account/1?version=1.1</a>   对应 getAccount1_1()</li>
<li><a href="http://localhost:8080/account/1?version=1.3" target="_blank" rel="noopener noreferrer">http://localhost:8080/account/1?version=1.3</a>   对应 getAccount1_2()， 因为没有直接的1.3版本，因此找最近的一个满足的</li>
<li><a href="http://localhost:8080/account/1?version=1.5" target="_blank" rel="noopener noreferrer">http://localhost:8080/account/1?version=1.5</a>   对应 getAccount1_5()</li>
<li><a href="http://localhost:8080/account/1?version=1.6" target="_blank" rel="noopener noreferrer">http://localhost:8080/account/1?version=1.6</a>   正常1、3都可以匹配，但是因为有了4对应的1.5版本，但是没有1.6版本，则1、3都无法正确响应，返回400错误
<ul>
<li>这种场景表示当前请求的版本比我们服务提供的最大版本还高，不响应</li>
</ul>
</li>
</ul>
<h2> 8.其他优化</h2>
<ol>
<li>SPEL 表达式升级：SPEL 表达式中支持空安全和 Elvis 运算符，例如以下代码：</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它表示，将注入系统属性 pop3.port 的值，如果未定义该属性值，注入 25 这个值。</p>
<ol start="2">
<li>
<p>GraalVM 原生应用支持：借助 Spring AOT 技术，将应用编译成原生镜像，极大地缩短了启动时间。</p>
</li>
<li>
<p>支持 Jackson 3.x：放弃对 Jackson 2.x 的支持，升级为 Jackson 3.x。</p>
</li>
<li>
<p>Servlet 和 WebSocket 版本升级：使用 Servlet 6.1 和 WebSocket 2.2 作为 Web 应用程序的底层实现，这意味着应用程序应该部署在最新的 Servlet 容器上，比如 Tomcat 11+ 和 Jetty 12.1+。</p>
</li>
<li>
<p>HttpHeaders 优化：HttpHeaders 操作如下：</p>
</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 9.小结</h2>
<p>SpringBoot3+都还没尝上鲜，这下4.0就来了，还在用java8的小伙伴，你们还学得动吗😭</p>
]]></content:encoded>
    </item>
    <item>
      <title>Spring迭代记录</title>
      <link>https://liuyueyi.github.io/tutorial/spring/basic/%E8%BF%AD%E4%BB%A3/</link>
      <guid>https://liuyueyi.github.io/tutorial/spring/basic/%E8%BF%AD%E4%BB%A3/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">Spring迭代记录</source>
      <pubDate>Fri, 30 May 2025 07:04:38 GMT</pubDate>
    </item>
    <item>
      <title>编程语言</title>
      <link>https://liuyueyi.github.io/tutorial/codelan/</link>
      <guid>https://liuyueyi.github.io/tutorial/codelan/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">编程语言</source>
      <description>Kotlin专栏 kotlin编程语言</description>
      <pubDate>Wed, 21 May 2025 11:07:19 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Kotlin专栏</h2>
<p><a href="/tutorial/codelan/kotlin/" target="blank">kotlin编程语言</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>1. Kotlin基础语法的核心总结</title>
      <link>https://liuyueyi.github.io/tutorial/codelan/kotlin/01.Kotlin%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93.html</link>
      <guid>https://liuyueyi.github.io/tutorial/codelan/kotlin/01.Kotlin%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1. Kotlin基础语法的核心总结</source>
      <description>1. 变量与数据类型 // 不可变变量（推荐优先使用） val name: String = &amp;quot;John&amp;quot; val age = 30 // 类型自动推断 // 可变变量 var score: Double = 95.5 var isActive = true // 布尔类型 // 空安全 var nullableStr: String? = null // 允许为 null val length = nullableStr?.length ?: 0 // 安全调用 + Elvis 操作符</description>
      <category>Kotlin</category>
      <pubDate>Wed, 21 May 2025 21:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 1. 变量与数据类型</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 函数</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 条件表达式</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 循环</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 集合</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 类与对象</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7. 空安全</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8. 扩展函数 / 属性</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9.高阶函数与 Lambda</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 10. 异常处理</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 11. 作用域函数</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 12. main启动</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 13. 其他特性</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>2. Kotlin协程</title>
      <link>https://liuyueyi.github.io/tutorial/codelan/kotlin/02.Kotlin%E5%8D%8F%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.html</link>
      <guid>https://liuyueyi.github.io/tutorial/codelan/kotlin/02.Kotlin%E5%8D%8F%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">2. Kotlin协程</source>
      <description>以下是关于 Kotlin 协程的深度解析，包含核心概念、线程对比、使用方式、工作原理及最佳实践： 一、协程的本质与核心概念 定义：协程是一种轻量级的线程替代方案，由程序控制调度，而非操作系统。它允许代码暂停（suspend）和恢复执行，无需阻塞线程。 核心特性： 轻量级：单个线程可运行数千个协程，内存占用仅 ~1KB（对比线程的 MB 级）。 非阻塞：协程挂起时不阻塞线程，线程可执行其他任务。 结构化并发：通过作用域管理协程生命周期，避免内存泄漏。 挂起函数：使用 suspend 标记的函数，可暂停和恢复执行。</description>
      <category>Kotlin</category>
      <pubDate>Wed, 21 May 2025 22:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>以下是关于 Kotlin 协程的深度解析，包含核心概念、线程对比、使用方式、工作原理及最佳实践：</p>
<h3> <strong>一、协程的本质与核心概念</strong></h3>
<p><strong>定义</strong>：协程是一种轻量级的线程替代方案，由程序控制调度，而非操作系统。它允许代码暂停（<code>suspend</code>）和恢复执行，无需阻塞线程。</p>
<p><strong>核心特性</strong>：</p>
<ul>
<li><strong>轻量级</strong>：单个线程可运行数千个协程，内存占用仅 ~1KB（对比线程的 MB 级）。</li>
<li><strong>非阻塞</strong>：协程挂起时不阻塞线程，线程可执行其他任务。</li>
<li><strong>结构化并发</strong>：通过作用域管理协程生命周期，避免内存泄漏。</li>
<li><strong>挂起函数</strong>：使用 <code>suspend</code> 标记的函数，可暂停和恢复执行。</li>
</ul>
<h3> <strong>二、协程 vs 线程</strong></h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>协程（Coroutine）</th>
<th>线程（Thread）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>调度</strong></td>
<td>由程序（协程调度器）控制</td>
<td>由操作系统内核调度</td>
</tr>
<tr>
<td><strong>创建成本</strong></td>
<td>极低（约 1KB 内存）</td>
<td>高（约 1MB 内存，视平台而定）</td>
</tr>
<tr>
<td><strong>切换开销</strong></td>
<td>极小（纳秒级，仅涉及上下文切换）</td>
<td>高（微秒级，涉及内核态切换）</td>
</tr>
<tr>
<td><strong>并发性</strong></td>
<td>单线程可运行数千个协程</td>
<td>受限于系统资源（通常数百个）</td>
</tr>
<tr>
<td><strong>阻塞影响</strong></td>
<td>仅挂起当前协程，不影响线程</td>
<td>阻塞整个线程，其他任务需等待</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>I/O 密集型任务（如网络请求）</td>
<td>CPU 密集型任务（如计算）</td>
</tr>
</tbody>
</table>
<h3> <strong>三、协程的基本使用姿势</strong></h3>
<h4> <strong>1. 启动协程的方式</strong></h4>
<p>所有的协程必须在一个作用域内执行，使用方式为</p>
<p><code>作用域.launch {}</code></p>
<p>其中 launch 是一个函数，用于创建协程并将其函数主体的执行分派给相应的调度程序</p>
<p><a href="http://Dispatchers.IO" target="_blank" rel="noopener noreferrer">Dispatchers.IO</a> 指示此协程应在为 I/O 操作预留的线程上执行。</p>
<p>一个基础的使用示例：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>2. 挂起函数（Suspend Functions）</strong></h4>
<p>在函数前添加关键字<code>suspend</code>，声明这个函数为挂起函数； 若我们希望两个挂起函数顺序调用，在协程中，按照正常的顺序书写即可，后面的挂起函数可以正常获取前面的挂起函数，即两者是顺序执行的</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>3. 异步任务与结果获取</strong></h4>
<p>若两个挂起函数之间没有依赖，我希望它们能并行调度，方便我快速获取结果，此时可以借助 <code>async</code> 来实现</p>
<blockquote>
<p>在概念上，async 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。</p>
</blockquote>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>四、协程的核心组件</strong></h3>
<h4> <strong>1. 协程作用域（CoroutineScope）</strong></h4>
<p>管理协程的生命周期，确保资源正确释放：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Android 开发过程中，我们需要理解一些协程代码运行的范围。而所有的Scope 如 <code>GlobalScope</code> 都是 <code>CoroutineScope</code> 的子类，我们的协程创建都需要这样一个 <code>CoroutineScope</code> 来启动。</p>
<p>一些常见的作用域 <code>CoroutineScope</code> 对象。</p>
<ul>
<li>GlobeScope：全局范围，不会自动结束执行。</li>
<li>MainScope：主线程的作用域，全局范围</li>
<li>lifecycleScope：生命周期范围，用于activity等有生命周期的组件，在DESTROYED的时候会自动结束。</li>
<li>viewModelScope：viewModel范围，用于ViewModel中，在ViewModel被回收时会自动结束</li>
</ul>
<p>手动创建一个作用域</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> <strong>2. 协程调度器（Dispatchers）</strong></h4>
<p>指定协程执行的线程池：</p>
<ul>
<li><code>Dispatchers.Main</code>：主线程（UI 线程），用于更新 UI。</li>
<li><code>Dispatchers.IO</code>：适合 I/O 密集型任务（默认 64 线程）。</li>
<li><code>Dispatchers.Default</code>：适合 CPU 密集型任务（默认线程数为 CPU 核心数）。</li>
<li><code>newSingleThreadContext</code>：创建专用单线程。</li>
</ul>
<h4> <strong>3. Job 与协程生命周期</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>五、协程的工作原理</strong></h3>
<ol>
<li>
<p><strong>挂起与恢复</strong>：</p>
<ul>
<li>协程通过状态机实现挂起，将局部变量保存在对象中。</li>
<li>挂起时释放线程，恢复时从上次暂停处继续执行。</li>
</ul>
</li>
<li>
<p><strong>Continuation Passing Style (CPS)</strong>：</p>
<ul>
<li>
<p>编译器将 <code>suspend</code> 函数转换为带 <code>Continuation</code> 参数的状态机。</p>
</li>
<li>
<p>示例：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p><strong>调度器工作流程</strong>：</p>
<ul>
<li>协程调度器管理线程池，将协程任务分发给空闲线程。</li>
<li>非阻塞操作（如 <code>delay</code>）通过回调机制恢复执行。</li>
</ul>
</li>
</ol>
<h3> <strong>六、协程的异常处理</strong></h3>
<h4> <strong>1. 结构化异常处理</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>2. 全局异常处理器</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>七、协程的最佳实践</strong></h3>
<h4> <strong>1. 避免使用 GlobalScope</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>2. 选择合适的调度器</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>3. 避免协程嵌套</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>4. 处理背压（Backpressure）</strong></h4>
<p>当生产者速度快于消费者时，使用 <code>Channel</code> 或 <code>Flow</code>：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>5. 资源管理</strong></h4>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>八、协程的性能优化</strong></h3>
<ol>
<li>
<p><strong>减少协程创建开销</strong>：</p>
<ul>
<li>避免在循环中创建大量协程，使用 <code>map</code> + <code>awaitAll</code> 批量处理。</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p><strong>复用调度器</strong>：</p>
<ul>
<li>避免频繁创建新的 <code>SingleThreadContext</code>，使用共享实例。</li>
</ul>
</li>
<li>
<p><strong>监控协程泄漏</strong>：</p>
<ul>
<li>使用 <code>DebugProbes</code>（测试环境）检测未完成的协程。</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h3> <strong>九、常见陷阱与注意事项</strong></h3>
<ol>
<li>
<p><strong>阻塞 vs 挂起</strong>：</p>
<ul>
<li>避免在协程中使用 <code>Thread.sleep()</code>（阻塞线程），应使用 <code>delay()</code>（挂起协程）。</li>
</ul>
</li>
<li>
<p><strong>线程安全</strong>：</p>
<ul>
<li>协程不保证线程安全，共享可变状态时需同步（如使用 <code>Mutex</code>）。</li>
</ul>
</li>
<li>
<p><strong>内存泄漏</strong>：</p>
<ul>
<li>长生命周期协程引用短生命周期对象（如 Activity）时需谨慎。</li>
</ul>
</li>
<li>
<p><strong>测试协程代码</strong>：</p>
<ul>
<li>使用 <code>TestCoroutineDispatcher</code> 控制协程执行：</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h3> <strong>十、协程的应用场景</strong></h3>
<ol>
<li>
<p><strong>异步 I/O 操作</strong>：</p>
<ul>
<li>网络请求、文件读写等。</li>
</ul>
</li>
<li>
<p><strong>UI 响应性优化</strong>：</p>
<ul>
<li>将耗时操作放在后台协程，保持 UI 流畅。</li>
</ul>
</li>
<li>
<p><strong>并发任务处理</strong>：</p>
<ul>
<li>并行执行多个独立任务，合并结果。</li>
</ul>
</li>
<li>
<p><strong>数据流处理</strong>：</p>
<ul>
<li>使用 <code>Flow</code> 处理异步数据流。</li>
</ul>
</li>
<li>
<p><strong>状态机实现</strong>：</p>
<ul>
<li>通过协程实现复杂的状态流转逻辑。</li>
</ul>
</li>
</ol>
<h3> <strong>总结</strong></h3>
<p>Kotlin 协程通过轻量级、非阻塞的特性，彻底改变了异步编程的体验。其核心优势在于：</p>
<ul>
<li><strong>高效资源利用</strong>：减少线程创建开销，提升系统吞吐量。</li>
<li><strong>简洁代码结构</strong>：使用同步写法实现异步逻辑，避免回调地狱。</li>
<li><strong>安全的并发模型</strong>：通过结构化并发和作用域管理，降低内存泄漏风险。</li>
</ul>
<p>掌握协程需要理解其核心概念（作用域、调度器、挂起函数）和最佳实践，避免常见陷阱。在实际项目中，协程特别适合处理 I/O 密集型任务和需要高响应性的应用场景。</p>
]]></content:encoded>
    </item>
    <item>
      <title>1. MCP协议</title>
      <link>https://liuyueyi.github.io/tutorial/git/mcp/01.MCP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/git/mcp/01.MCP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">1. MCP协议</source>
      <description>本文主要内容来自官方文档，按照更适合国人的阅读习惯进行重整，介绍一下MCP协议的具体的内容 官方文档 Introduction - Model Context Protocol 1. 整体介绍 1.1 MCP是什么 MCP （Model Context Protocol，模型上下文协议），它提供了一个通用的开放标准，用于将 AI 系统与数据源连接起来，用单一协议取代碎片化的集成。结果是一种更简单、更可靠的方法，使 AI 系统能够访问所需的数据。这是一种将 AI 助手连接到数据所在的系统（包括内容存储库、业务工具和开发环境）的新标准。其目的是帮助前沿模型产生更好、更相关的响应。</description>
      <category>QuickMCP</category>
      <pubDate>Tue, 13 May 2025 07:26:49 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文主要内容来自官方文档，按照更适合国人的阅读习惯进行重整，介绍一下MCP协议的具体的内容</p>
<blockquote>
<p>官方文档 <a href="https://modelcontextprotocol.io/introduction" target="_blank" rel="noopener noreferrer">Introduction - Model Context Protocol</a></p>
</blockquote>
<h2> 1. 整体介绍</h2>
<h3> 1.1 MCP是什么</h3>
<blockquote>
<p>MCP （Model Context Protocol，模型上下文协议），它提供了一个通用的开放标准，用于将 AI 系统与数据源连接起来，用单一协议取代碎片化的集成。结果是一种更简单、更可靠的方法，使 AI 系统能够访问所需的数据。这是一种将 AI 助手连接到数据所在的系统（包括内容存储库、业务工具和开发环境）的新标准。其目的是帮助前沿模型产生更好、更相关的响应。</p>
</blockquote>
<p>简单来讲，mcp就是定义了标准，对于所有希望给大模型提供能力的小伙伴来说，只要按照这个标准完成能力封装，那么大模型就可以直接加载这些能力从而实现某些特定的功能。</p>
<p>举一个例子，usb大家应该都不陌生，如果你只买一个台式机主机，这个时候你会发现我除了按它的开关按钮之外，好像什么也干不了。然后我买了键盘、鼠标、显示器、摄像头等外设，然后通过usb接口插上之后就可以操作电脑了，电脑是怎么识别这些外接设备（键盘、鼠标、摄像头等）的呢？ 这就是usb协议的作用了，外接设备和电脑，都遵循usb协议，然后大家就可以在同一个频道进行交流了；同样的MCP就是为了干这件事情，让大模型和给大模型提供增强能力的服务能同频进行交流</p>
<figure><img src="/imgs/column/mcp/02-mcp协议类比.jpg" alt="mcp整体架构" tabindex="0" loading="lazy"><figcaption>mcp整体架构</figcaption></figure>
<h3> 1.2 MCP总体架构</h3>
<p>MCP遵循客户端-服务端（CS）的架构，一个主机可以连接多个MCP服务端</p>
<figure><img src="/imgs/column/mcp/01-mcp整体架构.jpg" alt="mcp整体架构" tabindex="0" loading="lazy"><figcaption>mcp整体架构</figcaption></figure>
<p>从上面的描述和整体架构图，可以看到在MCP的架构中，有三个重要的角色</p>
<ul>
<li>MCP Hosts(MCP主机)： 通过mcp协议获取数据的程序（比如 Claude Desktop, IDE 或者 ai工具）</li>
<li>MCP Clients(MCP客户端): mcp协议客户端，作为调用者，通常与mcp服务端是成对出现，用于连接mcp server，实现双方通信</li>
<li>MCP Servers(MCP服务端): mcp协议服务端，作为提供者，实现MCP协议提供特定的功能</li>
</ul>
<p>除了上面三个角色之外，在架构图中，还有两个</p>
<ul>
<li>Local Data Sources: MCPServer所在的计算机上本地的资源信息，如文件、数据库、应用服务等，即MCP通过操作(读取、访问、写入等)这些本地资源来提供特定能力</li>
<li>Remote Service: MCPServer通过调用远程的服务来提供能力</li>
</ul>
<h3> 1.3 MCP工作原理</h3>
<p>mcp只是一个协议，和http协议一样，本身不直接提供能力或者服务，我们能实际感知到的服务表现只是协议上层的应用封装</p>
<p>比如http协议，常见的工作流程是我们打开浏览器，点开网页，通过http协议访问到对应的后台服务器，然后对方将网页信息传输到我们的浏览器上展示为可视化的网页内容，从而实现信息的曝光</p>
<p>那么mcp协议是怎么工作的呢？</p>
<ol>
<li>用户通过客户端发起提问</li>
<li>客户端将问题传递给 LLM</li>
<li>LLM 分析并选择合适的工具</li>
<li>通过 MCP 协议向服务端发送工具执行指令</li>
<li>工具执行后结果返回给 LLM</li>
<li>LLM 生成最终回复</li>
<li>回复通过客户端展示给用户</li>
</ol>
<figure><img src="/imgs/column/mcp/03-mcp工作原理.jpg" alt="mcp工作原理" tabindex="0" loading="lazy"><figcaption>mcp工作原理</figcaption></figure>
<h3> 1.4</h3>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/mcp/02-mcp协议类比.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>MCP</title>
      <link>https://liuyueyi.github.io/tutorial/git/mcp/</link>
      <guid>https://liuyueyi.github.io/tutorial/git/mcp/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">MCP</source>
      <description>MCP协议 官方文档：modelcontextprotocol</description>
      <pubDate>Wed, 21 May 2025 11:07:19 GMT</pubDate>
      <content:encoded><![CDATA[<p>MCP协议</p>
<p>官方文档：<a href="https://modelcontextprotocol.io/" target="_blank" rel="noopener noreferrer">modelcontextprotocol</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>01.Java 9新集合工厂方法：开启高效编程新时代</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/01.Java9%EF%BC%9A%E6%96%B0%E9%9B%86%E5%90%88%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/01.Java9%EF%BC%9A%E6%96%B0%E9%9B%86%E5%90%88%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.Java 9新集合工厂方法：开启高效编程新时代</source>
      <description>嘿，各位Java开发者！是不是每次看到代码里那些冗长的集合初始化，就感觉像是在做“体力活”？别担心，Java 9带着它的集合工厂方法来拯救我们啦！这就好比是给你配了一把“魔法棒”，轻轻一挥，集合就创建好了，再也不用写那些繁琐的代码了。接下来，就让我们一起探索Java 9集合工厂方法的神奇之处吧！ Java 9之前的集合创建方式：累觉不爱 在Java 9出现之前，创建集合简直就像是一场“苦力之旅”。比如，创建一个List，你得先创建一个ArrayList对象，然后一个接一个地往里加元素。看看下面这串代码，是不是感觉有点“眼熟”？</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 08:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>嘿，各位Java开发者！是不是每次看到代码里那些冗长的集合初始化，就感觉像是在做“体力活”？别担心，Java 9带着它的集合工厂方法来拯救我们啦！这就好比是给你配了一把“魔法棒”，轻轻一挥，集合就创建好了，再也不用写那些繁琐的代码了。接下来，就让我们一起探索Java 9集合工厂方法的神奇之处吧！</p>
<h2> Java 9之前的集合创建方式：累觉不爱</h2>
<p>在Java 9出现之前，创建集合简直就像是一场“苦力之旅”。比如，创建一个<code>List</code>，你得先创建一个<code>ArrayList</code>对象，然后一个接一个地往里加元素。看看下面这串代码，是不是感觉有点“眼熟”？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这还不算完，要是创建一个<code>Set</code>，你也得先实例化一个<code>HashSet</code>，再逐个添加元素。而<code>Map</code>就更麻烦了，得先创建一个<code>HashMap</code>，然后用<code>put</code>方法一个一个塞进去。这就好比是让你用勺子一勺一勺地往桶里装水，效率低得可怜！</p>
<p>而且，这种方式创建的集合，一旦初始化完成，要是想改点东西，还得小心翼翼，生怕出错。这就好比是用橡皮泥捏了个小雕塑，稍微一动，可能就变形了。Java 9的集合工厂方法，就是来解决这些问题的！</p>
<h2> Java 9集合工厂方法闪亮登场：魔法棒上线！</h2>
<h3> （一）List集合的of方法：一键搞定</h3>
<p>Java 9的<code>List.of</code>方法，简直就是给<code>List</code>集合插上了“翅膀”。只需要一行代码，就能创建一个不可变的<code>List</code>集合。看看下面这串代码，是不是感觉眼前一亮？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这就好比是用魔法棒一挥，一个装满水果的篮子就出现了！而且，这个方法还能创建空的集合，就像变出一个空篮子一样简单：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要是你想创建一个超大的集合，<code>List.of</code>也完全没问题！你可以直接传入一堆参数，或者把多个<code>List.of</code>组合起来，再用<code>Stream</code>拼成一个大集合。这就好比是把几个小篮子合并成一个大篮子，超方便！</p>
<h3> （二）Set集合的of方法：拒绝“撞衫”</h3>
<p><code>Set.of</code>方法也超级厉害！它不仅能让你快速创建一个不可变的<code>Set</code>集合，还能自动帮你检查重复元素。要是你不小心传了重复的元素，它就会直接“抗议”，抛出一个<code>IllegalArgumentException</code>异常。看看下面这串代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要是你写成这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它就会直接“炸毛”，告诉你不能有重复元素。这就好比是去参加派对，坚决不允许“撞衫”，保证了集合的“独一无二”。</p>
<h3> （三）Map集合的of和ofEntries方法：键值对的“完美搭档”</h3>
<p>对于<code>Map</code>集合，Java 9提供了两个超厉害的方法：<code>of</code>和<code>ofEntries</code>。<code>Map.of</code>方法适合创建包含少量键值对的不可变<code>Map</code>，而且键值对必须成对出现。看看下面这串代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这就好比是把名字和分数一一对应起来，超直观！不过，要是你传了重复的键，它也会直接“抗议”，抛出<code>IllegalArgumentException</code>异常。</p>
<p>要是你想创建一个超大的<code>Map</code>，<code>Map.ofEntries</code>方法就派上用场了。你可以传入一堆<code>Map.Entry</code>对象，轻松搞定。看看下面这串代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就好比是把一堆“名字 - 国籍”的卡片整齐地排列起来，超方便！</p>
<h2> 对比：新老方法的差异与优势</h2>
<h3> （一）代码简洁性与可读性：从“长篇大论”到“一句话搞定”</h3>
<p>Java 9的集合工厂方法，简直是把代码简洁性提升到了一个新的高度。以前创建一个<code>List</code>，得写一大堆代码；现在只需要一行代码。这就好比是从写一篇长篇大论，变成了只说一句话就能搞定。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这种简洁的写法，不仅减少了代码量，还让代码结构更加清晰，一眼就能看出集合里有什么东西。这就好比是把一堆杂物整齐地摆放在柜子里，一目了然。</p>
<h3> （二）性能与不可变性：多线程的“守护神”</h3>
<p>Java 9的集合工厂方法创建的集合是不可变的，这意味着一旦创建，就不能再修改。这在多线程环境中简直是“神器”！因为不可变集合不需要额外的同步机制来保证线程安全。比如，在一个多线程读取集合的场景中，使用不可变集合就不用担心数据不一致的问题。</p>
<p>而且，不可变集合在内存管理上也更有优势。JVM可以对它们进行优化，比如缓存哈希码。这就好比是给集合穿上了一件“保护衣”，让它们在运行时更加高效。</p>
<h3> （三）开发效率提升：从“搬砖”到“魔法”</h3>
<p>使用Java 9的集合工厂方法，开发效率简直提升了一个档次！以前创建集合，得像搬砖一样，一个一个往里加元素；现在只需要“魔法棒”一挥，集合就创建好了。这就好比是从“人力运输”升级到了“传送门”，效率提升可不是一点半点。</p>
<p>而且，简洁的代码也减少了出错的概率，调试起来也更轻松。这就好比是少走了很多弯路，直接到达目的地。</p>
<h2> 使用注意事项：别踩“雷区”</h2>
<h3> （一）不可变性：别试图“逆天改命”</h3>
<p>使用<code>List.of</code>、<code>Set.of</code>和<code>Map.of</code>方法创建的集合是不可变的，这意味着一旦创建，就不能再添加、删除或修改元素。要是你试图这么做，就会直接“触雷”，抛出<code>UnsupportedOperationException</code>异常。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，使用这些方法时，一定要想清楚集合的内容是否还会变化。如果还会变，那就老老实实使用传统的集合创建方式。</p>
<h3> （二）元素的唯一性：别“撞车”</h3>
<p>对于<code>Set</code>和<code>Map</code>集合，Java 9的工厂方法会严格检查元素的唯一性。如果传入了重复的元素或键，就会直接“抗议”，抛出<code>IllegalArgumentException</code>异常。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这就好比是开车时不能“撞车”，否则就会直接“报废”。</p>
<h3> （三）空值的处理：别“放空炮”</h3>
<p>在使用集合工厂方法时，<code>List.of</code>和<code>Set.of</code>都不允许传入<code>null</code>元素，<code>Map.of</code>的键和值也不允许是<code>null</code>。要是你传了<code>null</code>，就会直接“放空炮”，抛出<code>NullPointerException</code>异常。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，使用这些方法时，一定要确保传入的元素都是有效的，别让<code>null</code>来“搅局”。</p>
<h2> 实际应用场景举例：魔法棒的“实战演练”</h2>
<h3> （一）数据初始化：轻松搞定</h3>
<p>在很多业务场景中，我们需要初始化一些固定的数据集合。比如在一个电商系统中，商品分类是固定的。使用Java 9的集合工厂方法，就可以轻松搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这就好比是用魔法棒一挥，一个装满商品分类的“宝箱”就出现了，而且保证了这些分类不会被误改，超安全！</p>
<h3> （二）配置文件读取：清晰明了</h3>
<p>在读取配置文件时，我们常常需要把配置信息存储在集合中。比如一个数据库连接配置，使用<code>Map.of</code>方法就可以清晰地搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就好比是把配置信息整齐地摆放在一个“展示柜”里，一目了然，再也不用担心配置错误了。</p>
<h3> （三）常量定义：稳如泰山</h3>
<p>在定义常量集合时，Java 9的集合工厂方法也超有用。比如在一个游戏开发项目中，定义游戏角色的属性集合：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这就好比是给游戏角色的属性加上了一层“保护罩”，保证了它们的“独一无二”和“不可篡改”，让游戏运行得更稳定。</p>
<h2> 总结与展望：魔法棒的“未来篇章”</h2>
<p>Java 9的集合工厂方法，无疑是Java集合框架发展历程中的一个重要里程碑。它就像是一把“魔法棒”，让集合的创建变得简洁、高效，还自带“保护罩”，让数据更安全。无论是代码的可读性、性能，还是开发效率，都提升了一个档次。</p>
<p>通过实际应用场景的举例，我们可以看到，Java 9的集合工厂方法在各个领域都能轻松应对，无论是数据初始化、配置文件读取还是常量定义，都能发挥出强大的作用。</p>
<p>展望未来，随着Java版本的不断更新，我们有理由期待它会带来更多“魔法”功能，让集合操作更加简单高效。也许有一天，我们真的可以用魔法棒一挥，就能搞定一切！让我们一起期待吧！</p>
]]></content:encoded>
    </item>
    <item>
      <title>02.Java 9新玩法：Stream API的超能力进化</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/02.Java9%EF%BC%9AStream%20API%E7%9A%84%E8%B6%85%E8%83%BD%E5%8A%9B%E8%BF%9B%E5%8C%96.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/02.Java9%EF%BC%9AStream%20API%E7%9A%84%E8%B6%85%E8%83%BD%E5%8A%9B%E8%BF%9B%E5%8C%96.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">02.Java 9新玩法：Stream API的超能力进化</source>
      <description>嘿，朋友们！今天咱们来聊聊Java开发中的一个超级神器——Stream API。如果你是Java开发者，那你肯定知道，每次JDK版本更新都像是给开发者们打开了一扇新世界的大门，带来各种新特性和优化。而JDK 9的发布，简直就是Java开发界的“大事件”，尤其是Stream API的增强，更是让无数开发者眼前一亮。 想象一下，你手头有一堆数据，比如一堆水果，你得挑出所有的苹果，还得把它们按大小排个序。用传统的Java代码，你可能得写一大堆循环和条件判断，代码又长又难懂。但有了Stream API，这一切都变得简单了！它就像一个超级智能的助手，帮你轻松搞定这些繁琐的任务。</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 09:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>嘿，朋友们！今天咱们来聊聊Java开发中的一个超级神器——Stream API。如果你是Java开发者，那你肯定知道，每次JDK版本更新都像是给开发者们打开了一扇新世界的大门，带来各种新特性和优化。而JDK 9的发布，简直就是Java开发界的“大事件”，尤其是Stream API的增强，更是让无数开发者眼前一亮。</p>
<p>想象一下，你手头有一堆数据，比如一堆水果，你得挑出所有的苹果，还得把它们按大小排个序。用传统的Java代码，你可能得写一大堆循环和条件判断，代码又长又难懂。但有了Stream API，这一切都变得简单了！它就像一个超级智能的助手，帮你轻松搞定这些繁琐的任务。</p>
<p>那么，JDK 9到底给Stream API带来了哪些新花样呢？接下来，咱们就一起探索一下，看看这些新特性到底有多厉害！</p>
<h2> JDK 8中Stream API基础回顾</h2>
<figure><img src="/imgs/column/java/jdk8_stream.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在JDK 8时代，Stream API横空出世，彻底改变了Java开发者处理集合数据的方式。它就像一个神奇的魔法棒，让代码变得简洁又高效。用Stream API，你可以轻松地对集合进行过滤、映射、归约等操作。比如，你想从一堆水果里挑出苹果，用<code>filter</code>方法，告诉Stream“我只要苹果”，它就能帮你搞定。是不是很神奇？</p>
<p>再比如，你手头有一个员工信息列表，你想把每个员工的工资提取出来，用<code>map</code>方法，就能轻松得到一个工资列表。要是想计算工资总和，<code>reduce</code>方法也能帮你搞定。这比传统的循环累加方式简洁多了，代码可读性也高了不少。</p>
<p>总之，JDK 8的Stream API已经很厉害了，但JDK 9又给它加了不少新功能。接下来，咱们来看看JDK 9到底带来了哪些惊喜！</p>
<h2> JDK 9中Stream API的增强特性</h2>
<h3> takeWhile：精准提取流元素</h3>
<p>想象一下，你手头有一串数字，比如1到10，你只想挑出小于5的那些。在JDK 9之前，你可能得写个循环，一个个判断，代码又长又麻烦。但JDK 9的<code>takeWhile</code>方法，就像一个聪明的“筛选器”，能帮你轻松搞定。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“从头开始，只要数字小于5，就把它挑出来。”一旦遇到不小于5的数字，它就会停下来。这比<code>filter</code>方法更高效，因为<code>filter</code>会检查整个列表，而<code>takeWhile</code>一旦找到不满足条件的数字就直接“刹车”。</p>
<p><strong>小贴士</strong>：<code>takeWhile</code>特别适合处理大数据量的流，因为它能提前结束操作，节省时间和资源。</p>
<h3> dropWhile：反向筛选流数据</h3>
<p><code>dropWhile</code>和<code>takeWhile</code>正好相反，它会从流的开头开始，删掉满足条件的元素，直到遇到第一个不满足条件的元素。比如，你还是想处理1到10的数字，但这次你想去掉所有小于5的数字。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“从头开始，把小于5的数字都删掉。”这样一来，结果就只剩下5到10的数字了。这在处理日志数据时特别有用，比如跳过开头的无用信息，直接处理有用的部分。</p>
<h3> ofNullable：优雅处理空值流</h3>
<p>在实际开发中，空值（<code>null</code>）总是让人头疼。不小心碰到<code>null</code>，代码就可能直接崩溃。JDK 9的<code>ofNullable</code>方法，就像一个“保镖”，帮你安全地处理空值。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码中，<code>ofNullable</code>会检查<code>name</code>是否为<code>null</code>。如果是<code>null</code>，它就生成一个空流；如果不是<code>null</code>，就生成一个包含<code>name</code>的流。这样一来，你就不怕空指针异常了。</p>
<p><strong>小贴士</strong>：<code>ofNullable</code>是处理空值的神器，能让你的代码更安全、更健壮。</p>
<h3> iterate：灵活迭代流数据</h3>
<p>在JDK 8中，<code>iterate</code>方法只能生成无限流，用起来有点局限。但在JDK 9中，<code>iterate</code>变得更强大了，你可以给它设置一个结束条件。</p>
<p>比如，你想生成斐波那契数列，直到某个数字超过100：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“从<code>[0, 1]</code>开始，每次生成新的数对，直到第一个数字超过100为止。”这样一来，你就能灵活地生成和处理各种序列了。</p>
<h3> Optional与Stream的深度融合</h3>
<p>在JDK 9中，<code>Optional</code>和<code>Stream</code>也“牵手”了。<code>Optional</code>新增了<code>stream()</code>方法，可以把它转换成Stream，然后继续用Stream的各种方法。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“把<code>Optional</code>里的字符串转成大写，然后打印出来。”如果<code>Optional</code>是空的，<code>stream()</code>方法会返回一个空流，后续操作也不会执行，完美避免了空指针异常。</p>
<p><strong>小贴士</strong>：<code>Optional</code>和<code>Stream</code>的结合，让代码更简洁、更安全。用起来就像“双剑合璧”，威力倍增！</p>
<h2> 增强特性在实际开发中的应用场景</h2>
<h3> 数据处理与分析</h3>
<p>在大数据时代，处理海量数据是家常便饭。JDK 9的Stream API增强特性，让这些任务变得简单又高效。</p>
<p>比如，你手头有一个员工信息列表，你想找出年龄大于30岁、工资高于5000元的员工，并按工资从高到低排序。用JDK 9的Stream API，几行代码就能搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“筛选出符合条件的员工，按工资排序，然后收集到一个列表里。”是不是很简洁？</p>
<p>再比如，你想把一个数字列表分成每10个一组，用<code>takeWhile</code>和<code>dropWhile</code>也能轻松搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“每次跳过已经处理过的数字，然后取出10个一组的数字。”这样一来，分组处理就变得超简单了。</p>
<h3> 集合操作优化</h3>
<p>在日常开发中，集合操作是家常便饭。JDK 9的Stream API增强特性，让这些操作变得更简单、更高效。</p>
<p>比如，你想处理一个字符串列表，直到遇到第一个空字符串为止。用<code>takeWhile</code>方法，几行代码就能搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“从头开始，打印出所有非空字符串，直到遇到第一个空字符串。”这样一来，集合操作就变得更灵活了。</p>
<p><strong>小贴士</strong>：<code>takeWhile</code>和<code>dropWhile</code>是处理集合的利器，能让你的代码更简洁、更高效。</p>
<h2> 性能与代码简洁性分析</h2>
<h3> 性能表现</h3>
<p>咱们来对比一下JDK 8和JDK 9的性能。假设你有一个包含10000个数字的列表，你想计算所有偶数的和。用JDK 8的代码可能长这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而在JDK 9中，你可以用<code>takeWhile</code>优化一下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际测试发现，JDK 9的<code>takeWhile</code>方法在处理大数据量时更快，因为它能提前结束操作，避免不必要的计算。</p>
<h3> 代码简洁性</h3>
<p>再看看代码简洁性。比如，你想从员工列表中筛选出年龄大于30岁、工资高于5000元的员工，并按工资排序。用JDK 8的代码可能长这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而在JDK 9中，你可以用<code>dropWhile</code>进一步简化代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“跳过年龄小于等于30岁的员工，然后筛选出工资高于5000元的员工，按工资排序。”这样一来，代码不仅更简洁，逻辑也更清晰。</p>
<p><strong>小贴士</strong>：JDK 9的Stream API增强特性，让代码更简洁、更高效。用起来就像“开了挂”，能让你的开发效率直线提升！</p>
<h2> 总结与展望</h2>
<p>JDK 9的Stream API增强特性，简直就是Java开发界的“超级英雄”。从精准提取数据，到优雅处理空值，再到强大的迭代和融合能力，这些新特性让我们的代码更简洁、更优雅、更健壮。</p>
<p>在实际开发中，这些特性已经展现出了巨大的优势。它们不仅能帮助我们高效处理海量数据，还能优化集合操作，提升代码的可读性和可维护性。无论是新手还是老司机，都能从这些增强特性中受益。</p>
<p>那么，你还在等什么呢？赶紧在你的项目中试试JDK 9的Stream API增强特性吧！相信我，一旦你用上了，就会发现它的魅力和价值。</p>
<p>最后，如果你对Stream API的更多高级用法感兴趣，我建议你去读读《Java Stream API Cookbook》这本书，里面有不少实用的案例和技巧，能帮你进一步提升开发技能。</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/java/jdk8_stream.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>03.Java 10：集合能力大升级，开发效率狂飙！</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/03.Java10%EF%BC%9A%E9%9B%86%E5%90%88%E8%83%BD%E5%8A%9B%E5%8D%87%E7%BA%A7.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/03.Java10%EF%BC%9A%E9%9B%86%E5%90%88%E8%83%BD%E5%8A%9B%E5%8D%87%E7%BA%A7.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">03.Java 10：集合能力大升级，开发效率狂飙！</source>
      <description>嘿，Java开发者们！是不是觉得每次Java版本更新都像是拆盲盒，不知道里面藏着什么惊喜？今天咱们就来聊聊Java 10，这个在2018年3月21日发布的版本，虽然新特性不多，但每一个都超有用，尤其是集合能力的升级，简直是开发效率的加速器！ 不可变集合创建的进化 Java 9的基础：of()方法 想象一下，你手头有一个水果列表，想把它变成一个不可变的集合，防止别人乱改。在Java 9之前，这事儿可麻烦了，得用Collections.unmodifiableXXX方法。代码长这样：</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 10:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>嘿，Java开发者们！是不是觉得每次Java版本更新都像是拆盲盒，不知道里面藏着什么惊喜？今天咱们就来聊聊Java 10，这个在2018年3月21日发布的版本，虽然新特性不多，但每一个都超有用，尤其是集合能力的升级，简直是开发效率的加速器！</p>
<h2> 不可变集合创建的进化</h2>
<h3> Java 9的基础：<code>of()</code>方法</h3>
<p>想象一下，你手头有一个水果列表，想把它变成一个不可变的集合，防止别人乱改。在Java 9之前，这事儿可麻烦了，得用<code>Collections.unmodifiableXXX</code>方法。代码长这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉有点绕？Java 9终于“开窍”了，直接引入了<code>of()</code>方法，几行代码就能搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>简单吧！而且<code>Set</code>和<code>Map</code>也有类似的<code>of()</code>方法，创建不可变集合就像点外卖一样方便。</p>
<p><strong>小贴士</strong>：不可变集合一旦创建，就不能修改，这在多线程环境下超有用，不用担心数据被乱改。</p>
<h3> Java 10的拓展：<code>copyOf()</code>方法</h3>
<p>Java 10又给我们加了个“新玩具”——<code>copyOf()</code>方法。假设你已经有一个集合，可能是可变的，也可能是不可变的，现在想把它变成不可变的副本，<code>copyOf()</code>就派上用场了。</p>
<p>比如，你有一个可变的水果列表：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>immutableCopy</code>现在就是不可变的了，别人想改？没门！而且，如果原集合本身就是不可变的，<code>copyOf()</code>会直接返回原集合，效率超高。</p>
<p><strong>小贴士</strong>：<code>copyOf()</code>方法不仅能帮你快速创建不可变副本，还能避免重复创建不必要的集合，节省内存。</p>
<h2> 流操作与不可变集合的融合</h2>
<p>Java 10还把流操作和不可变集合“拉郎配”了。比如，你有一个字符串列表，想过滤出长度大于3的字符串，然后收集为不可变集合。以前可能得写一堆代码，现在一行搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉代码瞬间清爽多了？要是想收集为不可变的<code>Set</code>或<code>Map</code>，也有对应的<code>Collectors.toUnmodifiableSet()</code>和<code>Collectors.toUnmodifiableMap()</code>方法。</p>
<p><strong>小贴士</strong>：流操作和不可变集合的结合，让代码不仅简洁，还更安全。再也不用担心数据被误改了！</p>
<h2> 集合能力增强的优势</h2>
<h3> 安全性提升</h3>
<p>为啥不可变集合这么重要？想象一下，你在一个电商系统里，有个商品类别集合，里面装着电子产品、服装、食品等。如果这个集合是可变的，万一某个模块不小心删了某个类别，整个页面可能就乱了。而不可变集合就像给数据加了个“保护罩”，别人想改都改不了。</p>
<p>在多线程环境下，不可变集合更是“救星”。以前，多个线程读取共享数据时，得小心翼翼地同步，不然就容易出错。现在，有了不可变集合，线程们可以放心大胆地读，不用担心数据被改，简直是多线程开发的“福音”。</p>
<h3> 代码简洁性</h3>
<p>Java 10的集合增强，让代码简洁到飞起。以前创建不可变集合，得先创建可变集合，再包装，代码又长又复杂。现在，<code>List.of()</code>和<code>List.copyOf()</code>几行代码就能搞定，简直不要太爽！</p>
<p><strong>小贴士</strong>：简洁的代码不仅开发效率高，还更容易维护。少写代码，少出错，何乐而不为呢？</p>
<h2> 实际开发案例</h2>
<h3> 案例一：配置信息管理</h3>
<p>假设你有个应用程序，配置信息都存在一个<code>properties</code>文件里。以前，读取配置文件后，可能会不小心改了配置信息，导致程序出错。现在，用Java 10的集合增强特性，可以这样写：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样一来，<code>configMap</code>就是不可变的了，不用担心被误改，配置信息的安全性瞬间拉满。</p>
<h3> 案例二：数据处理流程</h3>
<p>再比如，你有个学生成绩的CSV文件，想读取数据，计算每个学科的平均分。用Java 10的集合增强特性，可以这样写：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉代码清晰又高效？不可变集合让数据处理结果更安全，再也不用担心数据被误改了。</p>
<h2> 总结与展望</h2>
<p>Java 10的集合能力增强，简直是开发者的“超级英雄”。不可变集合的创建更简单，流操作和不可变集合的结合更无缝，代码不仅更安全，还更简洁。这些改进在实际开发中超有用，能让你的开发效率狂飙！</p>
<p>最后，如果你在使用Java集合时有什么有趣的经验，或者遇到过什么坑，欢迎在评论区分享哦！</p>
]]></content:encoded>
    </item>
    <item>
      <title>04.Java 11新宠：异步 HTTP 客户端，你的网络请求加速神器！</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/04.Java11%EF%BC%9A%E5%BC%82%E6%AD%A5HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/04.Java11%EF%BC%9A%E5%BC%82%E6%AD%A5HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">04.Java 11新宠：异步 HTTP 客户端，你的网络请求加速神器！</source>
      <description>嘿，Java开发者们！是不是每次看到HTTP请求处理就头大？以前用HttpURLConnection，那复杂的设置步骤、繁琐的参数配置，还有对异步操作的不友好，简直能把人逼疯！每次发起请求，都像是在写一篇冗长的小说，从打开连接到处理响应，每一步都要小心翼翼，稍不留神就可能出错。 但现在，Java 11像是派来了一个超级英雄，带来了全新的异步HTTP客户端。这玩意儿简直太厉害了！它把HTTP请求处理变得像点外卖一样简单，不仅高效、简洁，还充满了现代感。再也不用为复杂的连接设置烦恼，也不用在多线程环境下为异步操作绞尽脑汁。Java 11的异步HTTP客户端，就是你的网络请求加速神器！接下来，咱们就一起看看它是怎么做到的。</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 12:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>嘿，Java开发者们！是不是每次看到HTTP请求处理就头大？以前用<code>HttpURLConnection</code>，那复杂的设置步骤、繁琐的参数配置，还有对异步操作的不友好，简直能把人逼疯！每次发起请求，都像是在写一篇冗长的小说，从打开连接到处理响应，每一步都要小心翼翼，稍不留神就可能出错。</p>
<p>但现在，Java 11像是派来了一个超级英雄，带来了全新的异步HTTP客户端。这玩意儿简直太厉害了！它把HTTP请求处理变得像点外卖一样简单，不仅高效、简洁，还充满了现代感。再也不用为复杂的连接设置烦恼，也不用在多线程环境下为异步操作绞尽脑汁。Java 11的异步HTTP客户端，就是你的网络请求加速神器！接下来，咱们就一起看看它是怎么做到的。</p>
<h2> 传统HTTP客户端的困境</h2>
<p>想象一下，你手头有个任务，需要从网上抓取一些数据。你打开IDE，开始用<code>HttpURLConnection</code>写代码。是不是瞬间感觉头皮发麻？看看这段代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉像在做复杂的拼图游戏？仅仅是发送一个GET请求，就得写这么多代码！而且，要是网络不好，或者服务器不给力，你的程序就得卡在那里，啥也干不了。这就好比你在网上下单买东西，然后一直盯着物流信息，直到快递送到家门口。这体验，太差了！</p>
<p><strong>小贴士</strong>：如果你还在用<code>HttpURLConnection</code>，那可真是太委屈自己了。Java 11的异步HTTP客户端，能让你的代码瞬间清爽起来！</p>
<h2> Java 11 HTTP客户端特性大揭秘</h2>
<h3> 现代化API，简洁又强大</h3>
<p>Java 11的异步HTTP客户端，就像是给你的代码装上了“超能力”。它的API非常简洁，用起来就像搭积木一样简单。看看下面的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉清爽多了？几行代码就搞定了！而且，它的设计非常现代化，支持链式调用，让你的代码不仅简洁，还超容易读。</p>
<p><strong>小贴士</strong>：<code>HttpRequest.newBuilder()</code>是创建请求的神器，用它来设置URI、头信息和请求方法，简直不要太方便！</p>
<h3> 异步加持，并发性能飞升</h3>
<p>Java 11的异步HTTP客户端，最大的亮点就是支持异步操作。这意味着你可以同时发起多个请求，而不用傻等一个完成后再处理下一个。就像你在网上买东西，下单后可以继续干别的事，快递到了自然会有通知。看看这个异步请求的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是很酷？用<code>sendAsync</code>方法发起请求后，程序可以继续干别的事，等响应到了再处理。这不仅让代码更高效，还能大大提升用户体验。</p>
<p><strong>小贴士</strong>：<code>CompletableFuture</code>是异步操作的“瑞士军刀”，用它来处理异步响应，简直不要太方便！</p>
<h3> HTTP/2原生支持，速度飙升</h3>
<p>Java 11的HTTP客户端还支持HTTP/2协议，这可是个大杀器！HTTP/2采用了二进制分帧、多路复用等技术，能让数据传输速度飞起来。就好比在高速公路上开了多车道，多个请求可以同时传输，再也不用排队等了。</p>
<p><strong>小贴士</strong>：HTTP/2的多路复用技术，能让你的程序在高并发场景下表现得超棒！</p>
<h3> 其他贴心特性</h3>
<p>Java 11的HTTP客户端还有很多贴心的小功能。比如，它原生支持WebSocket，让你轻松实现客户端和服务器之间的实时通信。还有，它支持自动重定向，再也不用手动处理那些繁琐的重定向逻辑了。</p>
<p><strong>小贴士</strong>：WebSocket是实时通信的“神器”，用Java 11的HTTP客户端，实现起来超简单！</p>
<h2> 实战演练：异步HTTP客户端上手</h2>
<h3> 环境搭建</h3>
<p>在开始之前，先确保你的开发环境已经配置好Java 11。要是还没装，赶紧去Oracle官网下载吧！安装完成后，用下面的命令检查一下版本：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要是看到Java 11或更高版本，那就万事俱备，只欠东风了！</p>
<h3> 发送GET请求</h3>
<p>咱们先从最简单的GET请求开始。看看下面的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉超简单？几行代码就搞定了！<code>HttpClient.newHttpClient()</code>是创建客户端的入口，<code>HttpRequest.newBuilder()</code>是构建请求的神器，<code>sendAsync</code>是发起异步请求的关键方法。</p>
<p><strong>小贴士</strong>：<code>sendAsync</code>方法返回的是一个<code>CompletableFuture</code>对象，用它来处理异步响应，简直不要太方便！</p>
<h3> 发送POST请求</h3>
<p>要是需要发送POST请求，也是一样简单。看看下面的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉超爽？几行代码就搞定了一个POST请求！<code>HttpRequest.BodyPublishers.ofString</code>是设置请求体的神器，用它来发送JSON数据，简直不要太方便！</p>
<p><strong>小贴士</strong>：发送POST请求时，别忘了设置<code>Content-Type</code>头信息，否则服务器可能会懵圈。</p>
<h2> 与其他HTTP客户端的较量</h2>
<p>Java 11的异步HTTP客户端并不是唯一的HTTP客户端，Apache HttpClient和OkHttp也很厉害。但Java 11的异步HTTP客户端有它的独特优势。</p>
<h3> 性能对比</h3>
<p>在高并发场景下，Java 11的异步HTTP客户端表现超棒！因为它支持异步操作，程序可以在等待响应时干别的事，大大提高了效率。HTTP/2的多路复用技术也让它在高并发场景下表现得超给力！</p>
<p><strong>小贴士</strong>：如果你的应用需要处理大量并发请求，Java 11的异步HTTP客户端绝对是你的不二之选！</p>
<h3> 功能特性对比</h3>
<p>Java 11的异步HTTP客户端API超简洁，用起来就像搭积木一样简单。而且，它原生支持WebSocket和HTTP/2，功能强大到飞起！相比之下，Apache HttpClient和OkHttp虽然也很厉害，但Java 11的异步HTTP客户端绝对是“开挂”一样的存在！</p>
<p><strong>小贴士</strong>：如果你还在犹豫用哪个HTTP客户端，试试Java 11的异步HTTP客户端吧！它绝对会让你眼前一亮！</p>
<h2> 实际应用场景探索</h2>
<h3> 微服务架构中的通信</h3>
<p>在微服务架构中，各个服务之间需要频繁通信。Java 11的异步HTTP客户端就像是服务之间的“快递小哥”，能高效地传递数据。比如，订单服务需要调用库存服务查询库存，用Java 11的异步HTTP客户端，订单服务可以在等待库存服务响应时，继续处理其他任务，大大提高了效率。</p>
<p><strong>小贴士</strong>：在微服务架构中，异步通信是提升性能的关键，Java 11的异步HTTP客户端能帮你轻松搞定！</p>
<h3> 数据抓取与处理</h3>
<p>如果你需要从网上抓取数据，Java 11的异步HTTP客户端也能大显身手。比如，你需要从多个新闻网站抓取最新资讯，用异步HTTP客户端可以同时向多个网站发送请求，大大提高了抓取效率。</p>
<p><strong>小贴士</strong>：异步抓取数据，效率飞起！试试Java 11的异步HTTP客户端吧，绝对让你爽到飞起！</p>
<h2> 总结与展望</h2>
<p>Java 11的异步HTTP客户端，绝对是Java开发者的新宠！它不仅解决了传统HTTP客户端的痛点，还带来了超强大的异步处理能力和超简洁的API。无论是微服务架构中的通信，还是数据抓取与处理，它都能帮你轻松搞定。</p>
<p>展望未来，Java网络编程还会带来更多惊喜。比如，Java HTTP客户端可能会在性能优化和功能拓展上继续发力，进一步提升它的表现。作为开发者，我们一定要紧跟技术发展的步伐，不断学习和探索，让Java网络编程变得更强大！</p>
<p>最后，如果你在使用Java 11的异步HTTP客户端时有任何有趣的经验，或者遇到过什么坑，欢迎在评论区分享哦！</p>
]]></content:encoded>
    </item>
    <item>
      <title>05.Java 9+：日期时间的焕新升级，你跟上了吗？</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/05.Java9_%EF%BC%9A%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E8%BF%AD%E4%BB%A3.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/05.Java9_%EF%BC%9A%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E8%BF%AD%E4%BB%A3.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">05.Java 9+：日期时间的焕新升级，你跟上了吗？</source>
      <description>嘿，Java开发者们！是不是每次看到日期时间处理就头大？别担心，Java 9+来帮你搞定！今天咱们就聊聊Java日期时间处理的前世今生，顺便看看Java 9+给我们带来了哪些惊喜。 1. Java日期时间处理的前世今生 想象一下，你正在开发一个电商系统，突然老板说：“嘿，我们的订单日期处理太慢了，能不能优化一下？”你心里想：“这不就是Java的老毛病吗？”别急，Java 9+已经帮你解决了这些问题。 在Java早期，我们主要靠java.util.Date和java.util.Calendar来处理日期时间。但这两个家伙实在是让人头疼。Date类是可变的，多线程环境下很容易出问题；它的很多方法还被弃用了，用起来特别不方便。Calendar类虽然功能多一些，但API设计太繁琐，代码写起来又长又容易出错。</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 13:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>嘿，Java开发者们！是不是每次看到日期时间处理就头大？别担心，Java 9+来帮你搞定！今天咱们就聊聊Java日期时间处理的前世今生，顺便看看Java 9+给我们带来了哪些惊喜。</p>
<h2> 1. Java日期时间处理的前世今生</h2>
<p>想象一下，你正在开发一个电商系统，突然老板说：“嘿，我们的订单日期处理太慢了，能不能优化一下？”你心里想：“这不就是Java的老毛病吗？”别急，Java 9+已经帮你解决了这些问题。</p>
<p>在Java早期，我们主要靠<code>java.util.Date</code>和<code>java.util.Calendar</code>来处理日期时间。但这两个家伙实在是让人头疼。<code>Date</code>类是可变的，多线程环境下很容易出问题；它的很多方法还被弃用了，用起来特别不方便。<code>Calendar</code>类虽然功能多一些，但API设计太繁琐，代码写起来又长又容易出错。</p>
<p>举个栗子，以前你想获取当前日期，<code>Date</code>类会给你一个包含日期和时间的完整信息，你还得费劲巴拉地提取日期部分。这就好比你只想知道今天是几号，但它却告诉你：“今天是2024年10月25日，星期五，下午3点45分。”你心里想：“我要这么多信息干啥？”</p>
<p><strong>小贴士</strong>：如果你还在用<code>java.util.Date</code>或<code>Calendar</code>，那可真是太委屈自己了。Java 8之后的日期时间API绝对会让你眼前一亮！</p>
<h2> 2. Java 8日期时间API基础回顾</h2>
<p>Java 8终于“开窍”了，引入了全新的<code>java.time</code>包，彻底改变了日期时间处理的现状。这个包借鉴了第三方库Joda - Time的设计思想，用起来特别顺手。</p>
<h3> 2.1 核心类介绍</h3>
<p>Java 8的日期时间API里，<code>LocalDate</code>、<code>LocalTime</code>和<code>ZonedDateTime</code>是最常用的三个类。</p>
<ul>
<li><code>LocalDate</code>只表示日期，不包含时间和时区信息。比如，你想记录今天是几号，用<code>LocalDate</code>就够了。</li>
<li><code>LocalTime</code>只表示时间，也不包含日期和时区信息。比如，你想记录某件事情发生的具体时间，用它就合适。</li>
<li><code>ZonedDateTime</code>则是日期、时间和时区的“全家桶”，特别适合处理跨国业务。</li>
</ul>
<p>这些类都是不可变的，线程安全，用起来特别放心。比如，多个线程同时读取当前日期，<code>LocalDate</code>的不可变特性保证了每个线程看到的日期都是一样的。</p>
<p><strong>小贴士</strong>：<code>LocalDate</code>和<code>LocalTime</code>是处理日常日期时间问题的“瑞士军刀”，用起来特别方便。</p>
<h3> 2.2 常用操作示例</h3>
<h4> 日期解析</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 日期格式化</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 日期增减</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些操作是不是特别简单？Java 8的日期时间API就是这么贴心！</p>
<h2> 3. Java 9+对日期时间的优化亮点</h2>
<p>Java 9+在Java 8的基础上又加了不少新功能，让日期时间处理变得更强大。</p>
<h3> 3.1 Java9 新增方法增强功能</h3>
<h4> truncatedTo方法</h4>
<p>Java 9+在日期时间类中新增了很多实用方法。比如，<code>LocalDateTime</code>的<code>truncatedTo</code>方法可以截断时间到指定单位。你想把时间截断到小时？几行代码搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还有<code>OffsetDateTime</code>的<code>withOffsetSameInstant</code>方法，可以更改时区偏移量，同时保持时间不变。这在处理跨国业务时特别有用。</p>
<p><strong>小贴士</strong>：<code>truncatedTo</code>方法是处理日期时间的“剪刀”，用它来裁剪多余的时间部分，特别方便。</p>
<h4> datesUntil方法</h4>
<p>从Java 9开始，<code>LocalDate</code>类中新增了一个超实用的方法——<code>datesUntil()</code>。这个方法可以生成一个日期范围内的所有日期序列，就像一个“日期生成器”。它特别适合处理日期范围的场景，比如计算两个日期之间的所有日期，或者生成未来一段时间内的日期列表。</p>
<p><strong>用法示例</strong></p>
<p>假设你想生成从今天开始，未来一周内的所有日期，用<code>datesUntil()</code>方法可以轻松搞定：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“从今天开始，生成到一周后的所有日期。”<code>datesUntil()</code>方法返回一个<code>Stream&lt;LocalDate&gt;</code>，你可以用<code>forEach</code>打印出来，或者用<code>collect</code>收集到一个列表中。</p>
<p><strong>小贴士</strong>：<code>datesUntil()</code>方法返回的是一个流（<code>Stream</code>），这意味着你可以用流的操作（比如<code>filter</code>、<code>map</code>）来处理日期序列。超灵活！</p>
<h3> 3.2 Java 16中的 <code>InstantSource</code> 接口</h3>
<h4> <code>InstantSource</code>是啥？</h4>
<p>从Java 16开始，Java日期时间API又新增了一个接口——<code>InstantSource</code>。这个接口的作用是提供一个统一的方式来获取当前时间戳（<code>Instant</code>）。它特别适合在需要动态获取时间戳的场景中使用。</p>
<h4> 用法示例</h4>
<p>假设你想在代码中动态获取当前时间戳，但又不想直接调用<code>Instant.now()</code>，可以用<code>InstantSource</code>来实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“通过<code>InstantSource</code>获取当前时间戳。”<code>InstantSource</code>是一个函数式接口，可以用Lambda表达式实现。</p>
<h3> 3.3 性能与内存优化</h3>
<p>Java 9+在性能和内存方面也做了不少优化。比如，创建<code>LocalDate</code>对象的速度更快了，处理大量日期时间数据时，性能提升特别明显。</p>
<p>举个栗子，你想计算100万个日期的下一天，Java 9+的代码不仅更简洁，运行速度也更快。不信？你可以试试！</p>
<h3> 3.4 时区处理的改进</h3>
<p>Java 9+对时区处理也做了优化。比如，获取时区规则的速度更快了，而且对历史时区数据的更新也更灵活。这意味着，即使某个地区的夏令时规则变了，Java 9+也能及时调整，不会出错。</p>
<p><strong>小贴士</strong>：时区处理是全球化业务的“刚需”，Java 9+绝对能帮你搞定！</p>
<h2> 4. 实际应用案例与代码演示</h2>
<h3> 4.1 业务场景中的优化体现</h3>
<h4> 电商订单处理</h4>
<p>假设你正在开发一个电商系统，需要计算订单的预计发货时间。Java 8的代码可能有点复杂，但Java 9+的代码更简洁：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java 9+的<code>truncatedTo</code>方法让代码更清晰，逻辑也更简单。</p>
<h4> 金融交易记录</h4>
<p>假设你需要将纽约时区的交易时间转换为上海时区的时间。Java 9+的代码更简洁：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java 9+的<code>withOffsetSameInstant</code>方法让时区转换变得超简单！</p>
<h4> 实际场景：计算工作日</h4>
<p>假设你想计算从今天开始，未来一周内的所有工作日（排除周末），可以用<code>datesUntil()</code>结合流操作来实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“从今天开始，生成未来一周内的所有日期，然后过滤掉周末。”是不是超方便？</p>
<h4> 实际场景：测试和模拟</h4>
<p><code>InstantSource</code>在测试和模拟场景中特别有用。比如，你想在测试中模拟一个固定的时间戳，可以用<code>InstantSource</code>来实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的意思是：“通过<code>InstantSource</code>模拟一个固定的时间戳。”这样，你就可以在测试中控制时间戳，而不用担心实际时间的变化。</p>
<p><strong>小贴士</strong>：<code>InstantSource</code>是Java 16的新特性，如果你还在用Java 9 - 15，可以考虑升级到Java 16，或者用其他方式实现类似的功能。</p>
<h3> 4.2 性能对比</h3>
<p>我们来做一个简单的性能测试，看看Java 9+的优势。比如，计算100万个日期的下一天，Java 9+的代码不仅更简洁，运行速度也更快。</p>
<p>Java 8 的代码实现如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java9+ 的代码实现如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>测试次数</th>
<th>Java 8 耗时（毫秒）</th>
<th>Java 9 + 耗时（毫秒）</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1234</td>
<td>987</td>
</tr>
<tr>
<td>2</td>
<td>1198</td>
<td>1023</td>
</tr>
<tr>
<td>3</td>
<td>1210</td>
<td>995</td>
</tr>
<tr>
<td>4</td>
<td>1205</td>
<td>1002</td>
</tr>
<tr>
<td>5</td>
<td>1222</td>
<td>1010</td>
</tr>
</tbody>
</table>
<p>测试结果表明，Java 9+的性能确实更优！</p>
<h2> 5. 开发者如何平滑过渡与升级</h2>
<h3> 5.1 升级步骤与注意事项</h3>
<p>从Java 8迁移到Java 9+，你需要检查项目中所有使用日期时间API的代码。虽然Java 9+的API和Java 8基本一致，但新增的方法可以让代码更高效。</p>
<p><strong>小贴士</strong>：升级前，一定要仔细阅读Java 9+的官方文档，了解API的变化和兼容性问题。别忘了检查第三方库是否支持Java 9+，否则可能会出问题。</p>
<h3> 5.2 学习资源推荐</h3>
<p>如果你还想了解更多关于Java 9+日期时间优化的内容，我推荐你看看这些资源：</p>
<ol>
<li>Java官方文档：最权威的学习资料，详细介绍了Java 9+的新特性和优化点。</li>
<li>技术博客：比如InfoQ、开源中国等，有很多技术专家分享的实战经验。</li>
<li>专业书籍：《Java核心技术》和《Effective Java》都更新了相关内容，特别值得一读。</li>
</ol>
<h2> 6. 总结与展望</h2>
<p>Java 9+的日期时间优化，绝对能让你的代码更高效、更简洁。新增的方法、性能优化和时区处理改进，让日期时间处理变得超简单。无论是电商、金融还是其他业务场景，Java 9+都能帮你轻松搞定。</p>
<p>所以，如果你还在用Java 8的日期时间API，不妨试试Java 9+。相信我，它绝对会让你眼前一亮！</p>
<p>最后，如果你在使用Java 9+日期时间API时有任何有趣的经验，或者遇到过什么坑，欢迎在评论区分享哦！</p>
]]></content:encoded>
    </item>
    <item>
      <title>06.Java 10新特性：局部变量类型推断，让代码飞起来！</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/06.Java10%EF%BC%9A%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/06.Java10%EF%BC%9A%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">06.Java 10新特性：局部变量类型推断，让代码飞起来！</source>
      <description>引言 嘿，Java开发者们！是不是每次写代码，都要在类型声明上浪费好多时间？比如，声明一个变量，还得写上长长的类型名，感觉特别繁琐？别担心，Java 10来救场啦！它带来了一个超酷的新特性——局部变量类型推断。用var关键字，编译器就能自动帮你搞定类型声明，代码瞬间变得简洁又清爽！今天，咱们就来聊聊这个新特性，看看它是怎么让代码“飞起来”的。 什么是局部变量类型推断 传统局部变量声明方式回顾 想象一下，你正在写代码，突然需要声明一个整型变量。你得这么写： int num = 10;</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 14:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 引言</h2>
<p>嘿，Java开发者们！是不是每次写代码，都要在类型声明上浪费好多时间？比如，声明一个变量，还得写上长长的类型名，感觉特别繁琐？别担心，Java 10来救场啦！它带来了一个超酷的新特性——局部变量类型推断。用<code>var</code>关键字，编译器就能自动帮你搞定类型声明，代码瞬间变得简洁又清爽！今天，咱们就来聊聊这个新特性，看看它是怎么让代码“飞起来”的。</p>
<h2> 什么是局部变量类型推断</h2>
<h3> 传统局部变量声明方式回顾</h3>
<p>想象一下，你正在写代码，突然需要声明一个整型变量。你得这么写：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>是不是感觉有点多余？再看看声明一个字符串变量：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要是类型更复杂，比如声明一个存储整数的<code>ArrayList</code>，代码就更长了：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这代码写起来是不是有点累？要是类型声明能简单点就好了，对吧？</p>
<h3> Java 10的变革：<code>var</code>关键字登场</h3>
<p>Java 10终于“开窍”了！它引入了<code>var</code>关键字，让你再也不用显式声明变量类型。编译器会自动根据变量的初始值推断类型。比如，上面的代码可以改写成这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是瞬间清爽多了？编译器会根据右侧的值推断出变量的类型，<code>num</code>是<code>int</code>，<code>str</code>是<code>String</code>，<code>list</code>是<code>ArrayList&lt;Integer&gt;</code>。这不仅减少了代码冗余，还让代码更易读。</p>
<p><strong>小贴士</strong>：<code>var</code>是Java 10的新宠，用它来简化代码，绝对让你爽到飞起！</p>
<h2> 局部变量类型推断的工作原理</h2>
<h3> 编译器如何推断类型</h3>
<p>编译器是怎么做到的呢？其实很简单，它会根据变量初始化表达式的右侧值来推断类型。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>编译器看到<code>10</code>是一个整数，就会推断<code>num</code>是<code>int</code>类型。再复杂一点：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>编译器会根据<code>new ArrayList&lt;Integer&gt;()</code>推断出<code>list</code>是<code>ArrayList&lt;Integer&gt;</code>类型。</p>
<p>要是不信，可以反编译代码看看。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>反编译后，代码会变成这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是很神奇？编译器在编译阶段就把<code>var</code>替换成了具体类型。</p>
<h3> 静态类型语言的本质未变</h3>
<p>虽然有了<code>var</code>，但Java依然是静态类型语言。变量的类型在编译时就已经确定，不是运行时才决定的。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器会报错，因为<code>num</code>的类型已经被推断为<code>int</code>，你不能给它赋一个字符串值。这就是Java的静态类型特性，即使用了<code>var</code>，代码依然安全可靠。</p>
<p><strong>小贴士</strong>：<code>var</code>只是让代码更简洁，Java的类型安全依然有保障！</p>
<h2> <code>var</code>的使用场景</h2>
<h3> 基础类型变量声明</h3>
<p>声明基础类型变量时，<code>var</code>让代码更简洁。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别清爽？类型一目了然，代码也更紧凑。</p>
<h3> 泛型类型变量声明</h3>
<p>对于复杂的泛型类型，<code>var</code>的优势更明显。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要是不用<code>var</code>，就得写<code>Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();</code>，代码瞬间变长。</p>
<p><strong>小贴士</strong>：<code>var</code>是处理复杂类型的好帮手，用它来简化代码，特别方便！</p>
<h3> 循环中的应用</h3>
<p>在循环中，<code>var</code>也能大显身手。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>i</code>的类型被推断为<code>int</code>，代码更简洁。在增强的<code>for</code>循环中：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>item</code>的类型会根据<code>list</code>的元素类型被推断为<code>String</code>，代码看起来更自然。</p>
<h3> 方法中的局部变量与返回值</h3>
<p>在方法内部，<code>var</code>也能让代码更清晰。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉代码瞬间清爽多了？</p>
<h3> 三元运算结果存储</h3>
<p>使用三元运算符时，<code>var</code>也能派上用场。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器会根据三元运算的结果类型推断出<code>result</code>是<code>String</code>类型，代码更简洁。</p>
<h3> 流操作中的应用</h3>
<p>在流操作中，<code>var</code>也能简化代码。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>var</code>让流操作的代码更简洁流畅，不用再写长长的类型声明。</p>
<h2> 使用<code>var</code>的注意事项和限制</h2>
<h3> 必须初始化变量</h3>
<p>用<code>var</code>声明变量时，必须同时初始化，因为编译器需要通过初始值来推断类型。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但下面的代码会报错：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：用<code>var</code>时，记得初始化变量，否则编译器会懵圈。</p>
<h3> 不能用于特定场景</h3>
<p>虽然<code>var</code>很强大，但它不能用于所有场景。比如，它不能用于类的实例变量、方法参数、方法返回类型、<code>catch</code>块或<code>lambda</code>表达式中。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些场景还是得用传统的显式类型声明。</p>
<p><strong>小贴士</strong>：<code>var</code>是局部变量的专属，其他地方别乱用哦！</p>
<h3> 避免影响代码可读性</h3>
<p>虽然<code>var</code>能简化代码，但过度使用可能会让代码难以理解。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果方法的返回类型很复杂，用<code>var</code>可能会让读者摸不着头脑。所以，类型不明显时，还是老老实实写类型吧。</p>
<p><strong>小贴士</strong>：用<code>var</code>要适度，别让代码变得晦涩难懂。</p>
<h2> 总结与展望</h2>
<p>Java 10的局部变量类型推断功能，绝对是Java开发者的福音！用<code>var</code>关键字，代码不仅更简洁，还保持了Java的类型安全性。在实际开发中，合理使用<code>var</code>，能让代码更易读，开发效率也更高。</p>
<p>不过，用<code>var</code>时，记得遵循它的规则和限制，避免滥用。比如，记得初始化变量，别在不适用的场景中乱用，类型不明显时别偷懒。</p>
<p>如果你对<code>var</code>还有疑问，或者在实际开发中遇到过有趣的场景，欢迎在评论区分享哦！</p>
]]></content:encoded>
    </item>
    <item>
      <title>07.Java 15新特性：文本块，代码书写的新利器</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/07.Java15%EF%BC%9A%E6%96%87%E6%9C%AC%E5%9D%97.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/07.Java15%EF%BC%9A%E6%96%87%E6%9C%AC%E5%9D%97.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">07.Java 15新特性：文本块，代码书写的新利器</source>
      <description>Java 15新特性：文本块，代码书写的新利器！ 传统字符串拼接的痛点 嘿，Java开发者们！有没有遇到过这样的烦恼：写代码时，字符串拼接写得自己都快崩溃了？比如，写SQL查询语句或者HTML代码片段，一不小心就拼错，还得花时间去排查问题。这事儿是不是特别烦人？ 想象一下，你正在写一个SQL查询语句，代码可能是这样的： String sql = &amp;quot;SELECT * FROM users &amp;quot; + &amp;quot;WHERE age &amp;gt; 18 &amp;quot; + &amp;quot;AND gender = &amp;apos;male&amp;apos; &amp;quot; + &amp;quot;ORDER BY username;&amp;quot;;</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 15:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 15新特性：文本块，代码书写的新利器！</h1>
<h2> 传统字符串拼接的痛点</h2>
<p>嘿，Java开发者们！有没有遇到过这样的烦恼：写代码时，字符串拼接写得自己都快崩溃了？比如，写SQL查询语句或者HTML代码片段，一不小心就拼错，还得花时间去排查问题。这事儿是不是特别烦人？</p>
<p>想象一下，你正在写一个SQL查询语句，代码可能是这样的：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉代码特别冗长，还容易出错？要是SQL语句更复杂，那代码简直就像“迷宫”一样，让人摸不着头脑。</p>
<p>再看看HTML代码片段的拼接：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种拼接方式不仅代码结构不清晰，还特别容易漏掉某个连接符。要是字符串里有特殊字符，还得用转义字符，比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>是不是感觉特别麻烦？这些痛点不仅让代码看起来很乱，还容易出错，降低开发效率。那有没有更好的办法呢？别急，Java 15的文本块来救场啦！</p>
<h2> Java 15文本块闪亮登场</h2>
<h3> 文本块是什么</h3>
<p>Java 15引入了一个超酷的新特性——文本块（Text Blocks）。它就像一个“魔法盒子”，能让你用更直观、更简洁的方式定义多行字符串。简单来说，文本块就是用三个双引号（<code>"""</code>）作为分隔符的字符串。在这对分隔符之间的所有内容，都会被视为字符串的一部分，而且会保留文本的格式和缩进。</p>
<p>举个栗子，上面的SQL查询语句用文本块写起来就超简单：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是瞬间清爽多了？代码不仅更短，还一目了然。</p>
<h3> 文本块的使用规则</h3>
<p>使用文本块时，有几条简单的规则：</p>
<ol>
<li><strong>分隔符</strong>：文本块以三个双引号（<code>"""</code>）开始，以三个双引号结束。开始和结束的<code>"""</code>必须单独成行，中间不能有其他字符（除了空格和换行符）。</li>
<li><strong>内容</strong>：在三个双引号内，可以插入任何字符，包括换行符、制表符等。这让你定义多行文本时特别自然。</li>
<li><strong>缩进</strong>：文本块支持缩进，缩进会被保留在最终的字符串中。这对于保持代码的结构和格式特别有帮助。</li>
<li><strong>转义字符</strong>：虽然文本块减少了对转义字符的需求，但仍然可以使用<code>\</code>来转义特殊字符，比如<code>\"</code>表示双引号，<code>\\</code>表示反斜杠。</li>
</ol>
<h3> 示例代码</h3>
<p>看看下面这些示例，感受一下文本块的强大：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行这段代码，你会发现输出的字符串完美地保留了你在文本块中定义的格式，是不是很神奇？</p>
<p><strong>小贴士</strong>：文本块特别适合处理多行文本，比如SQL语句、HTML代码、JSON和XML等，让代码更清晰、更易读。</p>
<h2> 文本块在实际开发中的强大应用</h2>
<h3> SQL语句编写</h3>
<p>想象一下，你正在写一个复杂的SQL查询语句，用传统方式拼接字符串，代码可能会变成这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉代码特别乱？要是用文本块，代码瞬间变清爽：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别清晰？文本块不仅让代码更简洁，还减少了出错的可能性。</p>
<h3> HTML代码构建</h3>
<p>再看看HTML代码的构建。传统方式拼接字符串，代码可能是这样的：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别冗长？用文本块，代码瞬间变清爽：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别清晰？文本块不仅让代码更简洁，还减少了出错的可能性。</p>
<h3> 其他场景应用拓展</h3>
<p>除了SQL语句和HTML代码，文本块在其他场景中也特别有用。比如，写JSON字符串：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者写配置文件内容：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些示例展示了文本块的强大功能。无论是处理结构化文本还是复杂的字符串内容，文本块都能让代码更简洁、更易读，提高开发效率和代码质量。</p>
<p><strong>小贴士</strong>：文本块特别适合处理多行文本，让代码更清晰、更易读。用它来写SQL、HTML、JSON和XML，绝对让你爽到飞起！</p>
<h2> 文本块与传统字符串的深度对比</h2>
<h3> 代码简洁性</h3>
<p>文本块在代码简洁性方面绝对秒杀传统字符串拼接。比如，写SQL语句，传统方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用文本块：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉文本块特别清爽？代码量瞬间减少，逻辑也更清晰。</p>
<h3> 可读性</h3>
<p>代码的可读性对于开发和维护特别重要。传统字符串拼接方式在处理多行文本时，代码逻辑结构特别模糊。比如，写JSON字符串，传统方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>用文本块：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉文本块特别清晰？代码结构一目了然，开发人员可以轻松理解和修改内容。</p>
<h3> 维护难度</h3>
<p>当代码需要修改时，维护的难度就特别明显。对于传统字符串拼接的代码，如果需要修改某一部分，比如修改SQL语句中的一个条件，传统方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别麻烦？还得小心连接符和空格。用文本块：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别简单？直接修改就行，不用担心连接符和转义字符。</p>
<h2> 总结与展望</h2>
<p>Java 15的文本块特性绝对是个“神器”，它解决了传统字符串拼接的痛点，让代码更简洁、更易读、更易维护。无论是写SQL语句、HTML代码，还是处理JSON和XML，文本块都能让你的代码瞬间“飞起来”。</p>
<p>未来，Java还会带来更多实用的新特性。希望你在新项目中，或者在合适的旧项目重构中，积极尝试使用文本块，让代码更优雅、更高效。</p>
<p>最后，如果你在使用文本块时有任何有趣的经验，或者遇到过什么坑，欢迎在评论区分享哦！</p>
]]></content:encoded>
    </item>
    <item>
      <title>08.Java 16纪录类：告别繁琐，让代码起飞</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/08.Java16%EF%BC%9A%E7%BA%AA%E5%BD%95%E7%B1%BB.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/08.Java16%EF%BC%9A%E7%BA%AA%E5%BD%95%E7%B1%BB.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">08.Java 16纪录类：告别繁琐，让代码起飞</source>
      <description>告别繁琐！Java 16记录类让代码起飞 一、引言：Java 16的新成员 嘿，Java开发者们！是不是每次写代码，都要在数据类上浪费好多时间？构造函数、getter/setter、equals、hashCode、toString……这些代码写起来特别繁琐，还容易出错。Java 16终于“开窍”了！它带来了一个超酷的新特性——记录类（Record Classes）。用它，你只需要一行代码，就能搞定一个数据类！是不是很爽？接下来，咱们就一起看看这个新特性到底有多厉害！</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 16:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 告别繁琐！Java 16记录类让代码起飞</h1>
<h2> 一、引言：Java 16的新成员</h2>
<p>嘿，Java开发者们！是不是每次写代码，都要在数据类上浪费好多时间？构造函数、<code>getter/setter</code>、<code>equals</code>、<code>hashCode</code>、<code>toString</code>……这些代码写起来特别繁琐，还容易出错。Java 16终于“开窍”了！它带来了一个超酷的新特性——记录类（Record Classes）。用它，你只需要一行代码，就能搞定一个数据类！是不是很爽？接下来，咱们就一起看看这个新特性到底有多厉害！</p>
<h2> 二、传统Java类的痛点</h2>
<p>想象一下，你正在写一个表示用户信息的类，包含用户名、年龄和邮箱。按照传统的Java类定义方式，代码可能是这样的：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别繁琐？写完这些代码，估计你都快累死了。而且，要是类的属性变了，你还得挨个修改这些方法，维护成本特别高。</p>
<p><strong>小贴士</strong>：传统Java类的痛点就是代码繁琐、容易出错、维护成本高。Java 16的记录类就是来解决这些问题的！</p>
<h2> 三、记录类初体验</h2>
<h3> （一）基本语法与定义</h3>
<p>Java 16的记录类简直是“代码减负神器”。用它定义数据类，只需要一行代码！比如，上面的<code>User</code>类用记录类来写，就变成了这样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>是不是瞬间清爽多了？记录类会自动帮你生成构造函数、访问器方法、<code>equals</code>、<code>hashCode</code>和<code>toString</code>方法。你再也不用写那些繁琐的代码了！</p>
<h3> （二）自动生成的方法</h3>
<h4> 构造函数</h4>
<p>记录类会自动生成一个构造函数，参数和属性顺序一致。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 访问器方法</h4>
<p>记录类会为每个属性生成访问器方法，方法名和属性名一样。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是特别简洁？再也不用写那些冗长的<code>getUsername()</code>方法了。</p>
<h4> equals和hashCode方法</h4>
<p>记录类的<code>equals</code>和<code>hashCode</code>方法会自动比较所有属性值。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> toString方法</h4>
<p>记录类的<code>toString</code>方法会返回一个包含所有属性值的字符串。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类自动生成的方法，让你的代码不仅简洁，还功能完整。再也不用担心忘记写某个方法了！</p>
<h2> 四、记录类的特性深度剖析</h2>
<h3> （一）不可变性</h3>
<p>记录类的实例是不可变的，这意味着一旦对象被创建，属性值就不能被修改。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>不可变性的好处特别多。首先，代码更安全，不用担心属性被误改；其次，在多线程环境下，不可变对象天生就是线程安全的，不用担心数据一致性问题。</p>
<p><strong>小贴士</strong>：不可变性是记录类的核心特性之一，它让代码更安全、更可靠。</p>
<h3> （二）构造器的奥秘</h3>
<h4> 标准构造器</h4>
<p>记录类会自动生成一个标准构造器，参数和属性顺序一致。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 紧凑构造器</h4>
<p>记录类还支持紧凑构造器，可以省略形参列表和字段赋值语句。比如，你可以在这里加一些参数校验：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：紧凑构造器让你在创建对象时进行必要的校验，同时保持代码简洁。</p>
<h3> （三）成员声明规则</h3>
<h4> 字段声明</h4>
<p>记录类中只能声明静态变量，不能声明实例变量。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 方法声明</h4>
<p>记录类中可以声明实例方法和静态方法，但不能声明抽象方法或原生方法。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类的成员声明规则既保证了不可变性，又提供了足够的扩展能力。</p>
<h3> （四）实现接口</h3>
<p>记录类可以实现接口，这让你可以在保持简洁的同时，扩展更多的功能。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类实现接口，让你的代码更灵活，应用场景更广泛。</p>
<h2> 五、实际应用场景</h2>
<h3> （一）数据传输对象（DTO）</h3>
<p>在企业级开发中，DTO是一种常用的设计模式。以前，定义一个DTO类需要写一大堆代码，现在用记录类，一行代码搞定！比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在Spring MVC中，你可以这样接收前端数据：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类作为DTO，代码简洁，不可变性还保证了数据的安全性。</p>
<h3> （二）配置项表示</h3>
<p>记录类特别适合表示配置项。比如，加载数据库配置信息：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类的不可变性确保了配置在运行期间不会被误改，提高了系统的稳定性。</p>
<h3> （三）日志记录</h3>
<p>记录类也可以用来表示日志条目。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在业务代码中：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类的不可变性和自动生成的<code>toString</code>方法，让日志记录更安全、更清晰。</p>
<h2> 六、与其他技术的结合</h2>
<h3> （一）Lombok对比</h3>
<p>Lombok是一个流行的Java库，通过注解自动生成样板代码。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然Lombok也很方便，但记录类是Java语言层面的解决方案，不需要额外依赖。而且，记录类的代码更简洁，访问器方法更直观。</p>
<p><strong>小贴士</strong>：记录类和Lombok都能减少样板代码，但记录类更简洁、更安全。</p>
<h3> （二）在Spring框架中的应用</h3>
<h4> Spring Boot配置类</h4>
<p>记录类可以简化Spring Boot的配置类。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 数据访问层</h4>
<p>记录类也可以和Spring Data JPA结合。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：记录类和Spring框架结合，让你的代码更简洁、更高效。</p>
<h2> 七、总结与展望</h2>
<p>Java 16的记录类绝对是Java开发者的“减负神器”。它不仅减少了样板代码，还让代码更安全、更易读。不可变性、自动生成的方法、灵活的构造器……这些特性让记录类在数据传输、配置管理、日志记录等多个场景中都能大显身手。</p>
<p>未来，Java语言还会不断进化，记录类也可能会带来更多惊喜。如果你还在用Java 16及以上版本，不妨大胆尝试记录类，相信它会给你带来全新的编程体验！</p>
<p>最后，如果你在使用记录类时有任何有趣的经验，或者遇到过什么坑，欢迎在评论区分享哦！</p>
]]></content:encoded>
    </item>
    <item>
      <title>09.Java 16 密封类：代码安全与可维护性的新利器</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/09.Java16%EF%BC%9A%E5%AF%86%E5%B0%81%E7%B1%BB.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/09.Java16%EF%BC%9A%E5%AF%86%E5%B0%81%E7%B1%BB.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">09.Java 16 密封类：代码安全与可维护性的新利器</source>
      <description>解锁Java 16密封类：代码安全与可维护性的新利器 一、Java 16那些事儿 嘿，Java爱好者们！2021年3月16日，Java 16像是一位带着宝藏的探险家，突然闯进了我们的编程世界。它带来了17个新特性，从语言到库，从性能优化到各种小惊喜，每个都像是给开发者准备的礼物🎁。其中，密封类（Sealed Classes）作为第二次预览特性，特别亮眼，就像夜空中最闪亮的星星✨。 想象一下，你正在写代码，突然发现某个类被继承得乱七八糟，继承体系完全失控。是不是特别烦？Java 16的密封类就是来解决这个问题的。它能给类的继承体系“上锁”，让继承变得可控。接下来，咱们就一起看看这个“秩序守护者”到底有多厉害！</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 17:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 解锁Java 16密封类：代码安全与可维护性的新利器</h1>
<h2> 一、Java 16那些事儿</h2>
<p>嘿，Java爱好者们！2021年3月16日，Java 16像是一位带着宝藏的探险家，突然闯进了我们的编程世界。它带来了17个新特性，从语言到库，从性能优化到各种小惊喜，每个都像是给开发者准备的礼物🎁。其中，密封类（Sealed Classes）作为第二次预览特性，特别亮眼，就像夜空中最闪亮的星星✨。</p>
<p>想象一下，你正在写代码，突然发现某个类被继承得乱七八糟，继承体系完全失控。是不是特别烦？Java 16的密封类就是来解决这个问题的。它能给类的继承体系“上锁”，让继承变得可控。接下来，咱们就一起看看这个“秩序守护者”到底有多厉害！</p>
<h2> 二、密封类初印象</h2>
<h3> （一）密封类是啥</h3>
<p>在Java里，类的继承就像家族传承。但如果家族成员随便加入，就会乱成一团。密封类就是给这个家族传承加上“锁”的存在。它用<code>sealed</code>关键字修饰，通过<code>permits</code>子句列出允许继承的子类，从而控制继承体系。</p>
<p>举个栗子，假设你正在写一个图形绘制系统，有一个<code>Shape</code>类作为所有图形的基类。正常情况下，你只希望<code>Circle</code>（圆形）和<code>Rectangle</code>（矩形）能继承它。这时候，就可以把<code>Shape</code>类定义为密封类，并在<code>permits</code>子句中列出<code>Circle</code>和<code>Rectangle</code>。其他类就无法随意继承<code>Shape</code>类了，继承体系瞬间变得清晰又稳定。</p>
<h3> （二）密封类语法大揭秘</h3>
<p>密封类的语法其实很简单，就像给类加上了一个“允许继承名单”。定义一个密封类的语法如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>子类在继承密封类时，需要根据需求使用不同的关键字来声明：</p>
<ul>
<li><code>final</code>关键字修饰的子类：表示这个子类不能再被继承，就像家族的分支到这儿就结束了。比如：</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>sealed</code>关键字修饰的子类：表示这个子类仍然是密封的，还可以继续限制自己的子类。比如：</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>non - sealed</code>关键字修饰的子类：表示这个子类打破了密封限制，恢复成普通类，可以被任意类继承。比如：</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>小贴士</strong>：密封类的语法就像给类的继承体系画了一张“家谱图”，让你一眼就能看清楚谁可以继承谁。</p>
<h2> 三、密封类的超能力</h2>
<h3> （一）控制继承结构</h3>
<p>想象一下，你的代码就像一个精心规划的家族树，每个分支都清晰明确。密封类就像是家族树的规划师，能严格控制类的继承结构。</p>
<p>比如，在一个图形绘制系统中，<code>Shape</code>类作为所有图形的基类，定义了一些通用属性和方法。如果不使用密封类，任何类都可以继承<code>Shape</code>类，继承体系可能会变得混乱。但有了密封类，你可以明确指定哪些类可以继承它，比如<code>Circle</code>和<code>Rectangle</code>。这样一来，其他类就无法随意继承<code>Shape</code>类，继承体系瞬间变得清晰又稳定。</p>
<p><strong>小贴士</strong>：密封类让继承体系变得可控，就像给家族树画了一道“安全线”，防止乱七八糟的分支出现。</p>
<h3> （二）提升代码安全性</h3>
<p>密封类不仅能控制继承结构，还能提升代码的安全性。想象一下，你的代码就像一个城堡，而密封类就是坚固的城墙，能有效防止恶意子类的入侵。</p>
<p>比如，在一个权限管理系统中，有一个<code>Permission</code>类用于验证用户权限。如果不使用密封类，恶意子类可能会继承<code>Permission</code>类并重写验证方法，导致权限验证失效。但如果你把<code>Permission</code>类定义为密封类，并只允许一些受信任的子类继承它，就能防止恶意子类的出现，确保权限验证逻辑的安全性。</p>
<p><strong>小贴士</strong>：密封类就像给代码加了一把“安全锁”，只有经过授权的子类才能进入继承体系。</p>
<h3> （三）增强代码可维护性</h3>
<p>在大型项目中，代码的可维护性就像城市的交通规划一样重要。密封类就像是城市交通的指示牌，能让代码结构更清晰，便于理解和维护。</p>
<p>比如，在一个企业级应用中，有一个<code>BusinessObject</code>类作为业务对象的基类。如果你把它定义为密封类，并且只允许几个特定的业务对象类继承它，比如<code>Customer</code>和<code>Order</code>，其他开发者在查看代码时就能一眼明白这个继承体系的结构，快速定位和修改相关代码。</p>
<p><strong>小贴士</strong>：密封类让代码结构更清晰，就像一个整洁的书架，每本书都放在合适的位置，方便你快速找到需要的信息。</p>
<h2> 四、密封类实战演练</h2>
<h3> （一）简单示例走一波</h3>
<p>理论讲了这么多，是不是有点懵？别急，咱们来看一个简单的代码示例。</p>
<p>假设你正在写一个图形绘制系统，有一个<code>Shape</code>类作为所有图形的基类，它有两个子类：<code>Circle</code>（圆形）和<code>Rectangle</code>（矩形）。用密封类来实现，代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们可以在测试类中使用这些类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是特别简单？密封类让代码结构清晰，逻辑一目了然。</p>
<h3> （二）复杂场景也不怕</h3>
<p>在实际项目中，密封类的应用场景往往更复杂。比如，你正在开发一个2D游戏，游戏中有不同类型的角色，每个角色都有自己的行为和属性。可以用密封类来组织这些角色，代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在游戏场景中，可以这样使用这些角色类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是特别清晰？密封类让代码结构一目了然，逻辑清晰，维护起来也特别方便。</p>
<h2> 五、避坑指南</h2>
<h3> （一）常见错误及解决</h3>
<p>使用密封类时，可能会遇到一些常见的坑。别怕，咱们来一一解决！</p>
<h4> 子类未按规定修饰</h4>
<p>如果子类没有使用<code>final</code>、<code>sealed</code>或<code>non - sealed</code>关键字修饰，编译器会报错。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决方法：根据需求，为子类添加合适的修饰关键字。比如，如果<code>Circle</code>类不需要再被继承，可以用<code>final</code>修饰：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 未在permits子句中列出子类</h4>
<p>如果密封类的<code>permits</code>子句中没有列出允许继承的子类，其他类即使符合条件也无法继承该密封类。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决方法：在密封类的<code>permits</code>子句中明确列出允许继承的子类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 子类不在同一包中</h4>
<p>如果允许子类扩展密封类，那么子类必须和密封类定义在同一个包中。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决方法：将子类<code>Circle</code>移动到与密封类<code>Shape</code>相同的包中。</p>
<h3> （二）注意事项要牢记</h3>
<h4> 密封类与其他特性的结合使用</h4>
<p>密封类可以和Java的其他特性结合使用，比如模式匹配、泛型、注解等。但在结合使用时，需要注意它们之间的相互影响和兼容性。比如，泛型类型参数的声明和使用需要保持一致，否则可能会出现编译错误。</p>
<h4> 密封类的性能影响</h4>
<p>虽然密封类本身不会对性能产生显著的负面影响，但过度使用可能会让代码变得复杂，影响扩展性和灵活性。所以，使用密封类时，要根据具体需求合理权衡。</p>
<h2> 六、密封类与其他特性的梦幻联动</h2>
<h3> （一）和模式匹配的默契配合</h3>
<p>密封类和模式匹配就像是一对默契十足的搭档，能让代码变得更加简洁高效。</p>
<p>比如，在一个图形绘制系统中，你有一个密封类<code>Shape</code>和它的子类<code>Circle</code>、<code>Rectangle</code>和<code>Square</code>。现在需要一个方法来描述不同形状的信息。如果不使用密封类和模式匹配，代码可能是这样的：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码看起来特别繁琐，还容易出错。但如果使用密封类和模式匹配，代码就变得简洁明了：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是特别清爽？密封类和模式匹配的结合，让代码不仅简洁，还更安全。</p>
<h3> （二）与其他特性的协同作战</h3>
<p>密封类不仅能和模式匹配配合，还能和访问修饰符、泛型、注解等其他特性一起使用，打造出更强大的代码。</p>
<p>比如，你可以用自定义注解标记密封类的子类，然后在运行时通过反射读取这些注解信息，实现动态行为。或者，你可以定义一个泛型密封类，用于表示不同类型的数据集合，同时限制只有特定的子类可以继承它。</p>
<p><strong>小贴士</strong>：密封类和其他特性的结合，就像给你的代码加上了“超级外挂”，让代码更强大、更灵活。</p>
<h2> 七、总结与展望</h2>
<p>Java 16的密封类就像是一把“继承控制钥匙”，能让你在管理类的继承结构时更加得心应手。它不仅能控制继承体系，还能提升代码的安全性和可维护性。在实际项目中，密封类已经展现出了它的强大魅力，无论是在简单的图形绘制系统，还是复杂的游戏开发场景中，都能帮助你更好地组织代码。</p>
<p>如果你还在用Java 16及以上版本，不妨大胆尝试密封类，相信它会给你带来全新的编程体验。同时，也可以期待Java在未来的版本中，继续完善和扩展与密封类相关的特性。</p>
<p>最后，如果你在使用密封类时有任何有趣的经验，或者遇到过什么坑，欢迎在评论区分享哦！</p>
]]></content:encoded>
    </item>
    <item>
      <title>10.JDK 21新特性揭秘：字符串模板，Java编程的华丽升级</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/10.Java21%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/10.Java21%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">10.JDK 21新特性揭秘：字符串模板，Java编程的华丽升级</source>
      <description>嘿，各位Java开发者们！是不是每天都在和那些繁琐的代码打交道，感觉有点疲惫了？别担心，JDK 21带着它的新特性来拯救我们啦！今天，咱们就来聊聊其中最让人眼前一亮的字符串模板（String Templates）。这玩意儿可真是给Java字符串操作这块“老古董”注入了一股新鲜血液，让咱们处理字符串的时候能轻松不少。别着急，接下来我带你一起走进JDK 21字符串模板的奇妙世界，保证让你眼前一亮！ 传统字符串拼接的“囧境” 在深入了解字符串模板之前，咱们先来回顾一下传统字符串拼接方式的那些“囧事”，相信你在日常开发中肯定没少遇到。</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 18:01:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>嘿，各位Java开发者们！是不是每天都在和那些繁琐的代码打交道，感觉有点疲惫了？别担心，JDK 21带着它的新特性来拯救我们啦！今天，咱们就来聊聊其中最让人眼前一亮的字符串模板（<code>String Templates</code>）。这玩意儿可真是给Java字符串操作这块“老古董”注入了一股新鲜血液，让咱们处理字符串的时候能轻松不少。别着急，接下来我带你一起走进JDK 21字符串模板的奇妙世界，保证让你眼前一亮！</p>
<h2> 传统字符串拼接的“囧境”</h2>
<p>在深入了解字符串模板之前，咱们先来回顾一下传统字符串拼接方式的那些“囧事”，相信你在日常开发中肯定没少遇到。</p>
<h3> （一）繁琐的加号拼接</h3>
<p>在Java里，用<code>+</code>号拼接字符串是最基础的方式。可一旦拼接的变量多了，代码就像“面条”一样，又长又乱，读起来费劲得很。比如，我们要拼接用户的个人信息：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码虽然能实现功能，但你看看，这代码量，这可读性，简直让人头疼！而且，每用一次+号拼接，就会创建一个新的<code>String</code>对象，性能开销大得很，简直是在“拖累”程序。</p>
<h3> （二）StringBuilder的无奈</h3>
<p>为了解决<code>+</code>号拼接的性能问题，我们通常会用<code>StringBuilder</code>。它通过可变的字符序列来避免频繁创建新的字符串对象，从而提高性能。不过，<code>StringBuilder</code>的代码结构也比较复杂。还是上面的例子，用<code>StringBuilder</code>来实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看看，使用<code>StringBuilder</code>时，得先创建对象，再调用多次<code>append</code>方法，最后还得调用<code>toString</code>方法转换为<code>String</code>类型。对于简单的字符串拼接场景，这操作是不是太“繁琐”了？简直就是“小题大做”。</p>
<h3> （三）格式化方法的痛点</h3>
<p>除了上述两种方式，我们还会用<code>String.format</code>和<code>MessageFormat</code>来进行字符串格式化拼接。但它们也有问题，比如将格式字符串与参数分离，这导致代码理解和维护起来超级困难。以<code>String.format</code>为例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然代码看起来简洁一些，但格式字符串里的占位符和后面的参数对应关系不够直观。当参数多或者格式字符串复杂时，很容易出错，也不利于代码维护。这就好比是“盲人摸象”，一不小心就容易“摸错地方”。</p>
<h2> JDK 21字符串模板闪亮登场</h2>
<p>好啦，传统方式的问题咱们都清楚了，那JDK 21中的字符串模板到底能给我们带来哪些惊喜呢？别急，这就来揭开它的神秘面纱。</p>
<h3> （一）特性简介</h3>
<p>字符串模板是JDK 21引入的一个预览特性，它允许我们在字符串中直接嵌入变量和表达式，从而简化字符串的拼接过程，提高代码的可读性和可维护性。这有点类似于<code>Python中</code>的<code>f-string</code>和<code>JavaScript</code>中的模板字符串，熟悉这两种语言的小伙伴肯定能轻松上手。</p>
<h3> （二）基本语法展示</h3>
<p>在JDK 21中，字符串模板用STR处理器和反引号“`”来定义。基本语法如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，<code>STR</code>是模板处理器，<code>\{name}</code>是嵌入的表达式，<code>name</code>的值会在运行时被替换到字符串中。运行这段代码，输出结果就是<code>Hello, 张三!</code>。是不是感觉比传统的字符串拼接方式简洁多了？简直就是“清爽版”的代码。</p>
<h3> （三）多行字符串的优雅处理</h3>
<p>在处理多行字符串时，字符串模板的优势就更明显了。比如，我们要拼接一个<code>HTML</code>字符串：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用字符串模板，我们可以像写普通的<code>HTML</code>代码一样来拼接字符串，再也不用担心繁琐的<code>+</code>号和转义字符了。这就好比是从“手写时代”直接跨越到了“打印时代”，清晰又方便。</p>
<p>同样，在拼接<code>JSON</code>字符串时，字符串模板也能让代码更加简洁明了：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出的<code>json</code>字符串就是：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> （四）表达式嵌入的强大功能</h3>
<p>字符串模板不仅支持嵌入变量，还支持嵌入各种表达式，比如算术运算、方法调用等。这可真是太厉害了！比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果就是两数之和为：<code>30</code>。再比如，我们有一个获取当前时间的方法<code>getCurrentTime()</code>，可以这样在字符串模板中调用：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果类似于当前时间是：<code>2024-10-22T15:30:00.123</code>，具体时间根据实际运行情况而定。</p>
<p>通过这种方式，我们可以轻松地将方法的返回值嵌入到字符串中，让代码更加简洁高效。这就好比是给代码“插上了翅膀”，让它能更灵活地“飞翔”。</p>
<h2> 深入探索字符串模板的用法</h2>
<h3> （一）自定义处理器的实现</h3>
<p>除了<code>JDK 21</code>自带的<code>STR</code>、<code>FMT</code>等模板处理器，我们还可以通过实现<code>StringTemplate.Processor</code>接口来自定义模板处理器，以满足特定的业务需求。比如，我们想实现一个自定义处理器，把字符串里的所有字母都变成大写。实现步骤如下：</p>
<ol>
<li>实现<code>StringTemplate.Processor</code>接口，并重写<code>process</code>方法。</li>
<li>在<code>process</code>方法中，获取模板中的片段和值，进行自定义处理。</li>
<li>返回处理后的结果。</li>
</ol>
<p>示例代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用自定义处理器的示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行上述代码，输出结果就是学习 <code>JAVA 很有趣</code>。</p>
<p>通过自定义处理器，我们可以根据具体的业务需求对字符串模板进行灵活处理，大大提高了字符串处理的灵活性和扩展性。</p>
<p>这就好比是给代码“量身定制”了一套“外衣”，让它能更好地适应各种场景。</p>
<h3> （二）与其他Java特性的融合</h3>
<p>字符串模板还可以和<code>Java</code>的其他特性，比如<code>lambda</code>表达式、流操作等，结合使用，发挥出更强大的功能。</p>
<p><strong>1.与lambda表达式结合</strong></p>
<p>我们可以在字符串模板的表达式中使用<code>lambda</code>表达式，实现一些复杂的逻辑处理。比如，我们有一个列表，需要把列表里的元素拼接成一个字符串，而且每个元素之间用逗号隔开，同时对每个元素进行一些处理（比如首字母大写）：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们使用了流操作对列表里的每个元素进行首字母大写处理，然后用<code>Collectors.joining</code>方法把处理后的元素拼接成一个字符串，最后把结果嵌入到字符串模板中。运行结果就是水果列表：<code>Apple, Banana, Cherry</code>。通过这种方式，我们可以把<code>字符串模板</code>和<code>lambda表达式</code>、<code>流操作</code>结合起来，实现复杂的数据处理和字符串生成。这就好比是把不同的“食材”放在一起“烹饪”，做出了一道“美味大餐”。</p>
<p><strong>2.与流操作结合</strong></p>
<p>字符串模板和流操作的结合还体现在对字符串的分割和处理上。比如，我们有一个多行字符串，想把它按行分割，然后对每一行进行一些操作（比如去除行首空格），最后再拼接成一个新的字符串：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们使用<code>lines</code>方法把多行字符串转换为流，然后用<code>map</code>方法对每一行进行去除行首空格的操作，最后用<code>Collectors.joining</code>方法把处理后的行重新拼接成一个字符串，并嵌入到字符串模板中。</p>
<p>运行结果就是处理后的字符串：<code>line1\nline2\nline3</code>。</p>
<p>通过把字符串模板和流操作结合，我们可以更加高效地处理字符串数据，提高代码的可读性和可维护性。这就好比是给字符串做了一次“美容”，让它变得更加“整洁”。</p>
<h2> 使用字符串模板的注意事项</h2>
<h3> （一）预览特性的局限性</h3>
<p>需要注意的是，字符串模板在JDK 21中还是一个预览特性。</p>
<p>这意味着它可能会在未来的 Java 版本中发生变化，甚至有可能被移除。</p>
<p>在生产环境中使用时，一定要谨慎考虑兼容性问题。</p>
<p>如果你的项目需要长期稳定运行，并且对 JDK 版本的升级比较敏感，那么在使用字符串模板之前，要充分评估其潜在风险。</p>
<p>比如，某些依赖库可能不支持 JDK 21 的预览特性，这可能会导致项目在编译或运行时出现问题。</p>
<p>在编译和运行包含字符串模板的代码时，需要添加<code>--enable-preview</code>参数来启用预览特性。</p>
<p>例如，使用命令行编译时，要这样写：<code>javac --enable-preview --source 21 YourClass.java</code>；运行时则使用<code>java --enable-preview YourClass</code>。</p>
<h3> （二）性能与资源考量</h3>
<p>虽然字符串模板让代码看起来清爽多了，但在某些情况下，咱们也得注意它的“小脾气”。比如，在循环里频繁创建模板字符串，那可就有点“得不偿失”了。为啥呢？每次创建模板字符串，都要进行解析和求值操作，这可是要消耗<code>CPU</code>和内存资源的。要是循环次数太多，那性能可就“一落千丈”了。</p>
<p>举个例子，想象一下你在厨房里，每次做饭都要重新洗菜、切菜，那效率得多低啊！所以，如果在循环中用到字符串模板，建议把不变的部分提前准备好，放在循环外面。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>prefix</code>是不变的部分，放在循环外面，这样就避免了每次循环都重复解析和求值<code>prefix</code>，效率一下子就上来了。</p>
<p>另外，如果处理的字符串特别大，或者模板里嵌入的表达式特别复杂，那内存可就“吃不消”了。想象一下，你在一个小房间里堆满了杂物，很快就没地方站了。所以，处理大数据量的字符串时，一定要合理设计表达式，避免不必要的内存开销。</p>
<h3> （三）错误处理策略</h3>
<p>用字符串模板的时候，难免会遇到一些“小插曲”，比如表达式求值失败。这就像是你在做一道复杂的菜，突然发现某个调料用完了，那可就麻烦了。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>divide(10, 0)</code>会抛出<code>ArithmeticException</code>异常，因为除数不能为0。不过别担心，我们用<code>try-catch</code>块把它“抓住”，然后进行相应的错误处理，这样程序就不会因为异常而“崩溃”了。</p>
<p>要是模板字符串的语法不对，比如反引号不匹配、表达式格式错误，编译器会像“警察叔叔”一样，及时提醒你。所以在写代码的时候，一定要仔细检查模板字符串的语法，确保它“规规矩矩”的。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些错误在编译的时候就会被发现，所以一定要根据编译器的提示及时修改代码，不然程序可就“跑不起来”了。</p>
<p>通过这些注意事项，咱们就能更好地驾驭字符串模板这个“新伙伴”，让它在项目中发挥最大的作用，同时避免一些常见的“坑”。</p>
]]></content:encoded>
    </item>
    <item>
      <title>11.JDK 21虚拟线程：Java并发编程的革新利器</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/11.Java21%EF%BC%9A%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/11.Java21%EF%BC%9A%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">11.JDK 21虚拟线程：Java并发编程的革新利器</source>
      <description>一、引言：并发编程的新曙光 嘿，各位Java开发者！是不是每次面对高并发场景，都感觉像是在打一场硬仗？传统线程就像是一群“老炮儿”，虽然经验丰富，但在高并发的战场上，它们的“腿脚”越来越不灵便了。想象一下，你的服务器被成千上万的请求“围攻”，每个请求都要派一个线程去处理。传统线程的创建和销毁成本高得吓人，而且占用的内存资源比“吃货”还多！这就像是在战场上派出了大量装备沉重、行动迟缓的士兵，不仅耗费巨大，还容易陷入混乱。 别担心，JDK 21带着虚拟线程来“救场”啦！虚拟线程就像是从天而降的“超级英雄”，专门来解决传统线程在高并发场景下的“疲软”问题。接下来，咱们就一起揭开虚拟线程的神秘面纱，看看它是怎么在高并发的战场上大显身手的！</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 18:11:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 一、引言：并发编程的新曙光</h2>
<p>嘿，各位Java开发者！是不是每次面对高并发场景，都感觉像是在打一场硬仗？传统线程就像是一群“老炮儿”，虽然经验丰富，但在高并发的战场上，它们的“腿脚”越来越不灵便了。想象一下，你的服务器被成千上万的请求“围攻”，每个请求都要派一个线程去处理。传统线程的创建和销毁成本高得吓人，而且占用的内存资源比“吃货”还多！这就像是在战场上派出了大量装备沉重、行动迟缓的士兵，不仅耗费巨大，还容易陷入混乱。</p>
<p>别担心，JDK 21带着虚拟线程来“救场”啦！虚拟线程就像是从天而降的“超级英雄”，专门来解决传统线程在高并发场景下的“疲软”问题。接下来，咱们就一起揭开虚拟线程的神秘面纱，看看它是怎么在高并发的战场上大显身手的！</p>
<h2> 二、虚拟线程是什么</h2>
<p>虚拟线程的调度主要包含三个核心部分：虚拟线程（Virtual Threads）、平台线程（Platform Threads）和调度器（Scheduler）。</p>
<ol>
<li><strong>虚拟线程池：</strong></li>
</ol>
<ul>
<li>这是一个包含大量虚拟线程的集合。每个虚拟线程代表一个轻量级的执行单元，它们可以由用户代码创建并提交到执行器中等待执行。虚拟线程之间是平等的，它们的栈空间较小，创建和销毁的开销也很低。</li>
</ul>
<ol start="2">
<li><strong>平台线程池：</strong></li>
</ol>
<ul>
<li>平台线程是与操作系统内核线程一一对应的线程，数量相对较少。平台线程负责执行虚拟线程中的实际任务，它们是系统资源的实际使用者。</li>
</ul>
<ol start="3">
<li><strong>调度器：</strong></li>
</ol>
<ul>
<li>调度器是整个系统的核心，负责将虚拟线程分配到可用的平台线程上执行。</li>
<li>调度器会根据虚拟线程的状态（如就绪、阻塞等）和平台线程的负载情况进行智能调度。</li>
<li>当一个虚拟线程遇到阻塞操作（如 I/O 操作）时，调度器会将该虚拟线程暂停，并将平台线程分配给其他就绪的虚拟线程；当阻塞操作完成后，调度器会将该虚拟线程重新加入到就绪队列中，等待再次分配到平台线程执行。</li>
</ul>
<ol start="4">
<li><strong>阻塞与唤醒机制：</strong></li>
</ol>
<ul>
<li>当虚拟线程进行 I/O 等阻塞操作时，会触发阻塞信号，调度器将其标记为阻塞状态并让出平台线程；</li>
<li>当阻塞操作完成，会有唤醒信号，调度器将其重新标记为就绪状态等待调度。</li>
</ul>
<p><strong>虚拟线程调度的基本流程：</strong></p>
<p>虚拟线程进入调度器，调度器将其分配到平台线程执行，当平台线程上的虚拟线程遇到阻塞操作时通知调度器，调度器再去唤醒其他就绪的虚拟线程执行。</p>
<figure><img src="/imgs/column/java/jdk21_virtual_thread_00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>虚拟线程，简单来说，就是由JVM管理的轻量级线程。它就像是线程世界里的“小精灵”，和传统的平台线程（也就是我们平常用的普通线程，由操作系统管理）有着天壤之别。传统的平台线程和操作系统线程是一一对应的，就好比一个萝卜一个坑，每个平台线程都要占用操作系统的一套资源，包括内存空间、内核数据结构等。而虚拟线程则是一群“小精灵”共享少量的“坑位”（平台线程），它们的创建和销毁成本极低，几乎可以忽略不计，就像在游戏里创建和删除一个虚拟角色一样轻松。</p>
<p>在调度方面，平台线程由操作系统内核负责调度，每次上下文切换都要陷入内核态，这个过程复杂又耗时。而虚拟线程则由JVM在用户态进行调度，JVM就像一个聪明的“小管家”，能够高效地安排这些“小精灵”的工作，大大减少了上下文切换的开销。打个比方，平台线程的调度就像是大公司里层层汇报的工作流程，效率低下；而虚拟线程的调度则像是创业团队里的扁平化管理，沟通高效，决策迅速。</p>
<p>在资源占用上，一个平台线程通常需要占用1MB左右的栈空间，这在高并发场景下是一笔巨大的开销。而虚拟线程的栈空间非常小，只有几十KB甚至更小，这使得我们可以在一个JVM中轻松创建数百万个虚拟线程，极大地提升了系统的并发处理能力。可以想象，平台线程是豪华的独栋别墅，占用大量空间资源；而虚拟线程则是精致的公寓，小巧玲珑，能够在有限的空间里容纳更多的“住户”。</p>
<h2> 三、虚拟线程的优势</h2>
<h3> （一）资源高效利用</h3>
<p>虚拟线程在资源利用方面，就像是一个精打细算的“小管家”，有着独特的优势。传统线程创建时，需要向操作系统申请一系列资源，包括内存空间用于线程栈，这就好比为每个“大管家”分配一个豪华大别墅，开销巨大。而且，操作系统对线程数量的管理能力有限，当创建的传统线程数量过多时，系统资源会被迅速耗尽，就像一个城市里突然涌入过多需要豪华别墅的人，城市资源根本无法承受，最终导致系统崩溃。</p>
<p>而虚拟线程则截然不同，它的创建和管理开销极低，几乎可以忽略不计。因为虚拟线程并不直接对应操作系统线程，它们共享少量的操作系统线程（也就是前面提到的“坑位”），就像多个“小管家”合住在一个经济实惠的公寓里，大大节省了资源。这使得在Java应用中可以轻松创建数百万个虚拟线程，而不会对系统资源造成过大压力。例如，在一个高并发的电商系统中，每一个商品查询请求都可以分配一个虚拟线程来处理，即使在促销活动期间，大量请求涌入，系统也能轻松应对，不会因为线程资源不足而出现卡顿或崩溃的情况。</p>
<h3> （二）高并发性能提升</h3>
<p>当面对高并发场景时，虚拟线程的表现堪称惊艳，就像一位超级英雄，能够轻松应对各种挑战。我们以Web服务器处理大量并发请求为例，在传统线程模型下，每一个请求都需要创建一个传统线程来处理。随着并发请求数量的增加，线程数量也会急剧上升，线程之间的上下文切换变得频繁，这就好比一个繁忙的十字路口，车辆过多导致交通堵塞，每个线程真正用于处理任务的时间被大大压缩，系统的响应速度变慢，吞吐量也随之降低。</p>
<p>而虚拟线程采用的是用户态调度，由JVM高效管理。当一个虚拟线程执行I/O操作（比如读取数据库数据、接收网络请求数据等）时，它会暂时让出执行权，JVM调度器会立即安排其他可运行的虚拟线程执行任务，就像一个高效的交通调度员，能够合理安排车辆通行，避免交通堵塞。这样一来，在高并发场景下，虚拟线程能够充分利用CPU资源，大大提高了系统的并发处理能力和吞吐量。有研究表明，在处理大量I/O密集型任务时，使用虚拟线程的系统吞吐量相比传统线程可以提升数倍甚至数十倍。例如，在一个处理大量并发网络请求的Web服务器中，使用虚拟线程后，每秒能够处理的请求数量从原来的数千个提升到了数万个，响应时间也从几百毫秒缩短到了几十毫秒，极大地提升了用户体验。</p>
<h3> （三）简化编程模型</h3>
<p>虚拟线程的出现，还为开发者带来了一个巨大的福音——简化编程模型，就像为复杂的编程世界带来了一张简洁明了的地图。在传统的并发编程中，为了实现高效的并发处理，开发者常常需要使用复杂的异步编程模型，如回调机制、Future模式等。这些模型虽然能够实现并发功能，但代码结构复杂，可读性差，就像一个迷宫，让人容易迷失方向。而且，在异步编程中，处理多个任务之间的依赖关系和错误处理也非常棘手，需要开发者花费大量的时间和精力去调试和维护。</p>
<p>而虚拟线程支持同步编程模型，开发者可以像编写普通单线程代码一样编写并发代码，不需要过多地关注线程的创建、销毁和调度等细节，就像在熟悉的道路上行驶，轻松自在。例如，在使用虚拟线程处理多个数据库查询任务时，开发者可以依次编写每个查询操作，就像在单线程环境下一样，而不需要像传统异步编程那样，将每个查询操作封装成回调函数，然后处理回调之间的嵌套关系。这样不仅降低了编程的难度，还提高了代码的可读性和可维护性，让开发者能够更加专注于业务逻辑的实现，提高开发效率。</p>
<h3> (四) 对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>平台线程</th>
<th>虚拟线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建数量</td>
<td>数千级</td>
<td><strong>百万级</strong></td>
</tr>
<tr>
<td>内存消耗</td>
<td>默认1MB/线程</td>
<td><strong>~200字节/线程</strong></td>
</tr>
<tr>
<td>上下文切换</td>
<td>内核参与</td>
<td><strong>JVM优化</strong></td>
</tr>
<tr>
<td>编程模型</td>
<td>回调地狱风险</td>
<td><strong>同步代码风格</strong></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>高吞吐</strong>：轻松支撑10万+并发连接</li>
<li><strong>低资源消耗</strong>：创建百万虚拟线程仅需几百MB内存</li>
<li><strong>代码简化</strong>：用同步代码实现异步性能，避免回调地狱</li>
<li><strong>兼容性</strong>：与现有Thread API、调试工具（如jstack）完全兼容</li>
</ol>
<h2> 四、应用场景与示例</h2>
<h3> （零）基本使用示例</h3>
<p>基本使用姿势有下面两种</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如使用虚拟线程实现归并排序</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明：</strong></p>
<ul>
<li>使用虚拟线程并行化归并排序的递归任务。</li>
<li>每个子任务（<code>mergeSort</code>）都在独立的虚拟线程中执行。</li>
<li>通过<code>Future</code>获取子任务结果，并合并（<code>merge</code>）排序后的数组。</li>
</ul>
<h3> （一）高并发网络服务</h3>
<p>在高并发网络服务场景中，Web服务器是一个典型的例子。想象一下，你的Web服务器就像一个繁忙的接待大厅，每天要接待成千上万的访客（并发请求）。传统的做法是为每个访客安排一个专门的接待人员（传统线程），但随着访客数量的增加，接待人员的数量也需要不断增加，这不仅成本高昂，而且管理起来非常困难。而虚拟线程就像是一群训练有素的兼职接待员，他们可以迅速响应访客的需求，并且占用的资源极少。</p>
<p>下面是一个简单的Web服务器使用虚拟线程处理并发请求的代码示例，我们使用Java的HttpServer类来创建一个简单的Web服务器，并对比传统线程池的处理方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们创建了两个Web服务器，一个使用虚拟线程处理请求，另一个使用固定大小为10的传统线程池处理请求。通过模拟处理请求的耗时操作（<code>Thread.sleep(100)</code>），可以直观地感受到虚拟线程在高并发场景下的优势。</p>
<p>在实际测试中，如果使用工具（如Apache JMeter）模拟大量并发请求，可以发现使用虚拟线程的Web服务器能够处理更多的并发请求，响应速度更快，吞吐量更高。因为虚拟线程的创建和切换开销极低，能够迅速响应新的请求，而传统线程池由于线程数量有限，在高并发情况下容易出现线程阻塞，导致请求处理速度变慢。</p>
<h3> （二）I/O密集型任务</h3>
<p>在I/O密集型任务中，文件读取和数据库查询是常见的场景。以文件读取为例，假设你需要从一个大型文件中读取数据并进行处理，每个读取操作都可能需要等待磁盘I/O完成，这期间线程会被阻塞。</p>
<p>传统线程在这种情况下，会占用大量的系统资源，并且由于线程阻塞，CPU资源无法得到充分利用。而虚拟线程就像是一群聪明的小助手，它们在等待I/O操作完成的过程中，会主动让出CPU资源，让其他任务得以执行。</p>
<p>下面是一个文件读取的示例代码，展示虚拟线程在I/O密集型任务中的应用：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们分别使用虚拟线程和传统线程来读取一个大型文件，并模拟对每一行数据的处理（<code>Thread.sleep(10)</code>）。可以看到，使用虚拟线程时，由于它在I/O阻塞时能够迅速挂起并释放资源，使得系统能够同时处理多个文件读取任务，大大提高了资源利用率和处理效率。而传统线程在读取文件时，如果遇到I/O阻塞，整个线程就会被阻塞，无法进行其他操作，导致CPU资源浪费。</p>
<p>再以数据库查询为例，假设我们有一个电商系统，需要查询商品信息。在高并发情况下，传统线程池可能会因为线程阻塞而导致查询效率低下。而使用虚拟线程，每个查询请求都可以分配一个虚拟线程，在等待数据库响应的过程中，虚拟线程可以被挂起，JVM可以调度其他虚拟线程执行任务，从而提高系统的并发处理能力和响应速度。例如，使用JDBC进行数据库查询时，代码可以这样写：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们分别使用虚拟线程和传统线程进行数据库查询，并模拟对查询结果的处理（<code>Thread.sleep(10)</code>）。可以看出，虚拟线程在处理I/O密集型的数据库查询任务时，能够有效减少线程阻塞时间，提高系统的并发处理能力和资源利用率。</p>
<h2> 五、使用方法与注意事项</h2>
<h3> （一）创建和启动虚拟线程</h3>
<p>在Java中，创建和启动虚拟线程非常简单，就像搭建一个简易的积木模型。我们可以使用<code>Thread</code>和<code>Thread.Builder APIs</code>来创建虚拟线程，就像挑选合适的积木块。例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们通过<code>Thread.ofVirtual().start()</code>方法创建并启动了一个虚拟线程，该线程执行一个简单的打印任务，输出当前线程的信息。这里的<code>Thread.ofVirtual()</code>就像是一个特殊的积木挑选器，专门用于挑选虚拟线程这块“积木”，而<code>start()</code>方法则是将这块“积木”搭建起来，让它开始工作。</p>
<p>我们还可以使用Thread.Builder来设置虚拟线程的一些属性，比如线程名称，就像给积木涂上不同的颜色进行标记：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们创建了一个名为MyVirtualThread的虚拟线程，通过Thread.Builder设置了线程名称，使我们在调试和管理线程时更容易识别。</p>
<p>除了上述方法，我们还可以使用Executors来创建虚拟线程。Executors就像是一个专业的积木搭建工具，它提供了<code>newVirtualThreadPerTaskExecutor</code>方法，为每个任务启动一个新的虚拟线程：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们使用<code>Executors.newVirtualThreadPerTaskExecutor</code>创建了一个ExecutorService，然后通过<code>submit</code>方法提交了10个任务，每个任务都会在一个新的虚拟线程中执行。这里的<code>Executors.newVirtualThreadPerTaskExecutor</code>就像是一个自动化的积木搭建助手，它会自动为每个任务搭建一个虚拟线程“积木”，并让它们开始工作。</p>
<h3> （二）使用建议</h3>
<p>在使用虚拟线程时，我们有一些实用的建议，就像驾驶汽车时需要遵循的规则。</p>
<p>首先，<strong>无需池化虚拟线程。</strong></p>
<ul>
<li>因为虚拟线程的创建和销毁开销极低，就像使用一次性餐具一样，用完即弃也不会造成太大的浪费。如果对虚拟线程进行池化，反而会增加不必要的管理复杂度，就像在一个小房间里摆放过多的家具，显得杂乱无章。</li>
</ul>
<p>其次，<strong>要尽量避免阻塞虚拟线程。</strong></p>
<ul>
<li>虽然虚拟线程对阻塞操作进行了优化，但长时间阻塞虚拟线程仍然会影响系统的并发处理能力。这就像是在一条繁忙的道路上，如果有一辆车长时间停在路中间，就会导致交通堵塞。例如，在进行I/O操作时，应该尽量使用非阻塞的I/O API，或者将阻塞操作放在单独的线程池中处理，避免阻塞虚拟线程。</li>
</ul>
<p>另外，<strong>虽然虚拟线程很轻量级，但也不能无节制地创建。</strong></p>
<ul>
<li>大量创建虚拟线程仍然会消耗一定的系统资源，就像在一个仓库里堆放过多的货物，会占用大量的空间。因此，在使用虚拟线程时，应根据系统的实际情况，合理控制其数量，避免资源浪费。例如，在一个Web服务器中，根据服务器的硬件配置和预计的并发请求数量，设置一个合适的虚拟线程上限，既能充分利用虚拟线程的优势，又能保证系统的稳定运行。</li>
</ul>
<h3> （三）注意事项</h3>
<p>在享受虚拟线程带来的便利时，我们也不能忽视一些注意事项，就像在享受美食时要注意食物的卫生。虚拟线程虽然强大，但它并不适用于所有场景。</p>
<p>对于计算密集型任务，由于这类任务主要依赖CPU进行大量的计算，而虚拟线程的优势在于减少线程上下文切换开销，对于CPU计算能力的提升并没有帮助，所以传统线程池可能更适合。例如，在进行复杂的数学计算、图像渲染等任务时，使用传统线程池可以更好地利用CPU资源，提高计算效率。</p>
<p>同时，我们还需要关注第三方库的兼容性问题。有些第三方库可能没有对虚拟线程进行优化，或者直接依赖于操作系统线程的特性，在虚拟线程中使用时可能会出现意想不到的问题。这就像是在一辆改装过的汽车上安装不匹配的零件，可能会影响汽车的正常行驶。因此，在使用第三方库时，要查看其文档，确认是否支持虚拟线程，或者进行充分的测试，确保在虚拟线程环境下能够正常工作。</p>
<p>此外，由于虚拟线程数量庞大，传统的线程监控和调试工具可能难以管理大量的虚拟线程。在调试和监控时，我们需要更好的支持工具。这就像是在一个大城市里，传统的交通指挥方式可能无法应对大量的车辆，需要更先进的交通管理系统。例如，使用一些专门针对虚拟线程的监控工具，能够实时监控虚拟线程的运行状态、资源消耗等信息，帮助我们及时发现和解决问题。</p>
<h2> 六、展望与总结</h2>
<p>虚拟线程的出现，无疑是Java并发编程领域的一次重大飞跃，它为我们打开了一扇通往高效、便捷编程世界的大门。就像在黑暗中点亮了一盏明灯，为高并发场景下的Java开发指明了新的方向。</p>
<p>它以极低的资源消耗和出色的并发处理能力，让我们能够轻松应对海量并发请求，大大提升了系统的性能和稳定性。在Web服务、I/O密集型任务等众多场景中，虚拟线程都展现出了巨大的优势，为开发者提供了更强大的工具和更高效的解决方案。</p>
<p>随着Java 21的发布，虚拟线程将逐渐走进更多开发者的视野，成为Java开发中的重要利器。它不仅会改变我们编写并发代码的方式，还将推动Java生态系统的进一步发展和创新。无论是大型企业级应用，还是小型创业项目，都能从虚拟线程中受益。</p>
]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/java/jdk21_virtual_thread_00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>12.Java 21 结构化并发：开启并发编程新篇章</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/12.Java21%EF%BC%9A%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/12.Java21%EF%BC%9A%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">12.Java 21 结构化并发：开启并发编程新篇章</source>
      <description>Java 21结构化并发：开启并发编程新篇章 Java并发编程演进之路 嘿，Java开发者们！还记得刚学Java时写并发代码的痛苦吗？那时，我们得继承Thread类或实现Runnable接口，手动管理线程的创建与销毁。代码繁琐不说，一旦涉及大量线程，管理起来更是让人崩溃！比如，你可能写过这样的代码： class MyThread extends Thread { @Override public void run() { System.out.println(&amp;quot;MyThread is running&amp;quot;); } } class MyRunnable implements Runnable { @Override public void run() { System.out.println(&amp;quot;MyRunnable is running&amp;quot;); } } public class Main { public static void main(String[] args) { MyThread thread = new MyThread(); Thread runnableThread = new Thread(new MyRunnable()); thread.start(); runnableThread.start(); } }</description>
      <category>Java</category>
      <pubDate>Fri, 14 Feb 2025 18:21:09 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 21结构化并发：开启并发编程新篇章</h1>
<h2> Java并发编程演进之路</h2>
<p>嘿，Java开发者们！还记得刚学Java时写并发代码的痛苦吗？那时，我们得继承<code>Thread</code>类或实现<code>Runnable</code>接口，手动管理线程的创建与销毁。代码繁琐不说，一旦涉及大量线程，管理起来更是让人崩溃！比如，你可能写过这样的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是感觉特别复杂？每次写线程都得小心翼翼，生怕出错。</p>
<p>后来，Java引入了线程池，这无疑是一大进步！线程池可复用线程，降低了线程创建和销毁的开销，代码也简洁了许多。比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>线程池虽解决了不少问题，但在复杂并发场景下仍显不足。例如，线程的生命周期管理不够直观，错误处理繁琐。当同时发起多个网络请求时，手动管理每个线程的执行结果会让代码瞬间变得混乱。</p>
<p><strong>小贴士</strong>：传统并发编程中，线程管理如同“走钢丝”，稍有不慎就会出错。</p>
<h2> 结构化并发：概念与核心原理</h2>
<h3> 结构化并发是什么</h3>
<p>想象一下，你正在开发一个电商系统，需要同时处理多个任务，如查询商品信息、计算订单总价、验证用户支付信息等。这些任务相互独立，却又同属处理订单这个大任务。要是能有一种方式，将这些任务有序组织起来，那该多好？</p>
<p>Java 21的结构化并发正是为此而生！它把并发任务组织成清晰的层次结构，类似一棵树，每个任务都可有自己的子任务。如此一来，任务间的关系一目了然，管理也变得轻松便捷。</p>
<p>举个例子，假设开发一个电商订单处理系统，处理订单的任务可拆分为以下子任务：</p>
<ol>
<li>查询商品信息。</li>
<li>计算订单总价。</li>
<li>验证用户支付信息。</li>
</ol>
<p>这些子任务都隶属于处理订单这个父任务，形成清晰的任务层次结构，任务关系清晰，管理方便。</p>
<h3> 核心原理剖析</h3>
<h4> 任务层次结构</h4>
<p>结构化并发将任务构建成层次分明的结构，如同树状，每个任务可包含多个子任务，子任务又能有自己的子任务。这种结构让任务间的关系清晰明了，便于管理和调度。</p>
<h4> 结果处理规则</h4>
<p>在结构化并发里，子任务的结果只会返回给直接启动它们的父任务，不会随意传递给其他无关任务。这确保了任务间的数据流动有序且可预测。</p>
<h4> 生命周期绑定</h4>
<p>子任务的生命周期不能超过其父任务。一旦父任务结束，所有未完成的子任务会被自动取消，有效避免了线程泄漏和资源浪费。</p>
<h4> 任务的协作与控制</h4>
<p>父任务能依据子任务的执行情况，灵活决定是否继续执行其他子任务，或提前结束整个任务。这种协作与控制机制使并发任务的执行更高效、更智能。</p>
<p><strong>小贴士</strong>：结构化并发就像给并发任务戴上了“紧箍咒”，让它们的执行更可控、更可预测。</p>
<h2> Java 21结构化并发特性深度解析</h2>
<h3> 上下文关联的任务创建</h3>
<p>在Java 21的结构化并发中，上下文关联的任务创建是一项关键特性。它允许我们在特定代码块或作用域内创建并发任务，这些任务会自动与创建它们的上下文关联。当上下文结束时，相关任务会被自动清理，比如取消未完成的任务、收集任务执行结果等，极大地简化了任务管理的复杂性。</p>
<p>举个例子，假设开发一个Web应用程序，处理用户请求时需并发获取多个数据源的数据。使用Java 21的结构化并发，可这样实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此例中，我们在<code>try - with - resources</code>语句块中创建了<code>StructuredTaskScope.ShutdownOnFailure</code>对象<code>scope</code>，它定义了任务执行的上下文。在该上下文中，通过<code>scope.fork()</code>方法创建了<code>userTask</code>和<code>orderTask</code>两个并发任务，分别用于获取用户信息和订单信息。当<code>try - with - resources</code>语句块结束时，<code>scope</code>会自动清理所有相关任务，确保无任务遗漏或泄漏。</p>
<p><strong>小贴士</strong>：<code>StructuredTaskScope</code>是结构化并发的核心API之一，如同任务的“大管家”，帮你管理任务的生命周期和结果。</p>
<h3> 更好的异常传播机制</h3>
<p>在并发编程中，异常处理一直是个难题。传统并发编程里，当一个并发任务抛出异常时，异常的传播和处理较为复杂，尤其是任务在不同线程中执行时，很难确保异常能被正确捕获和处理。</p>
<p>Java 21的结构化并发提供了更优的异常传播机制，使并发任务中的异常能得到更有效的管理。若一个子任务抛出异常，该异常会自动传播到其父任务，且整个任务结构会根据异常情况进行相应处理。</p>
<p>举个例子：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此例中，<code>task1</code>有可能抛出<code>RuntimeException</code>。当<code>task1</code>抛出异常时，<code>task2</code>会被自动取消，异常会传播到<code>scope.join()</code>处，通过<code>throwIfFailed()</code>方法抛出，最终被<code>catch</code>块捕获并处理。这样，我们就能在统一的地方处理并发任务中的异常，大幅提升了代码的健壮性和可维护性。</p>
<p><strong>小贴士</strong>：结构化并发的异常处理机制就像给并发任务装上了“安全气囊”，让异常处理更简单、更可靠。</p>
<h3> 简化并发控制的API</h3>
<p>Java 21的结构化并发提供了一系列更高级别的API，这些API极大地简化了并发控制的复杂性，让我们能更便捷地协调并发任务，减少手动同步和锁的使用，使并发逻辑更简洁清晰。</p>
<p>举个例子：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此例中，我们使用<code>StructuredTaskScope</code>创建了5个并发任务。通过<code>scope.fork()</code>方法可轻松启动每个任务，无需手动管理线程的创建和启动。<code>scope.join()</code>方法会等待所有任务完成，<code>throwIfFailed()</code>方法会检查是否有任务失败并抛出异常。最后，通过<code>scope.subtasks()</code>方法可获取每个任务的执行结果。这种方式让并发任务的控制和管理变得简单直观，大大减少了手动编写同步和锁代码的工作量。</p>
<p><strong>小贴士</strong>：<code>StructuredTaskScope</code>的API就像并发任务的“瑞士军刀”，让并发控制更简单、更高效。</p>
<h3> 与虚拟线程的完美融合</h3>
<p>Java 21引入的虚拟线程是一种轻量级线程实现，其创建和销毁开销极小，能在一个操作系统线程上运行大量虚拟线程，显著提升系统的并发处理能力。结构化并发与虚拟线程的结合，充分发挥了两者的优势，为高效并发编程提供了强大支持。</p>
<p>举个例子，假设开发一个高并发的网络爬虫应用，需要并发访问大量网页。使用虚拟线程和结构化并发，可这样实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此例中，我们使用虚拟线程并发访问多个URL。每个URL的访问任务通过<code>scope.fork()</code>方法创建，这些任务在虚拟线程中执行。由于虚拟线程的轻量级特性，我们可轻松创建大量任务，而不会对系统资源造成过大压力。同时，借助结构化并发的<code>StructuredTaskScope</code>，我们能方便地管理这些任务的生命周期和结果，确保所有任务正确执行并返回结果。这种结合方式使我们能高效处理高并发网络请求，提升应用程序的性能和响应速度。</p>
<p><strong>小贴士</strong>：虚拟线程和结构化并发的结合，就像给并发编程装上了“超级加速器”，让高并发任务处理变得轻松自如。</p>
<h2> 代码示例：实战Java 21结构化并发</h2>
<h3> 简单任务并发执行</h3>
<p>下面通过一个简单示例展示如何使用Java 21的结构化并发实现多个任务的并发执行。假设我们有三个独立任务，每个任务模拟一个耗时操作并返回结果。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此示例中，我们创建了<code>StructuredTaskScope.ShutdownOnFailure</code>对象<code>scope</code>，定义了任务执行范围。在该范围内，使用<code>scope.fork()</code>方法创建了<code>task1</code>、<code>task2</code>和<code>task3</code>三个并发任务。每个任务在独立线程中执行，并模拟了不同的耗时操作。</p>
<p><code>scope.join()</code>方法会阻塞当前线程，直至所有子任务完成。<code>throwIfFailed()</code>方法会检查是否有任务执行失败，若有则抛出异常。最后，通过<code>task1.resultNow()</code>、<code>task2.resultNow()</code>和<code>task3.resultNow()</code>方法获取并打印每个任务的执行结果。</p>
<p><strong>小贴士</strong>：结构化并发让并发任务管理如同“搭积木”，任务间关系一目了然。</p>
<h3> 复杂任务场景应用</h3>
<p>在实际开发中，常遇到复杂任务场景，如多任务依赖、任务优先级控制等。下面通过一个示例展示如何在这些场景下使用Java 21的结构化并发。</p>
<p>假设开发一个电商数据分析系统，需要从多个数据源获取数据，然后进行汇总和分析。其中，获取用户数据和订单数据的任务相互独立，可并发执行，但生成报表的任务依赖于用户数据和订单数据的获取结果。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此示例中，我们先创建了<code>userDataTask</code>和<code>orderDataTask</code>两个并发任务，分别用于获取用户数据和订单数据。通过<code>scope.join().throwIfFailed()</code>等待这两个任务完成，并获取结果。</p>
<p>接着，创建<code>reportTask</code>任务，它依赖于<code>userDataTask</code>和<code>orderDataTask</code>的结果，用于生成报表。最后，再次通过<code>scope.join().throwIfFailed()</code>等待报表生成任务完成，并获取报表结果进行打印。</p>
<p>通过这种方式，我们能清晰管理任务间的依赖关系，使复杂的并发任务逻辑更易于理解和维护。</p>
<p><strong>小贴士</strong>：结构化并发就像并发任务的“指挥官”，让任务协作有条不紊。</p>
<h2> 结构化并发应用场景与优势</h2>
<h3> 常见应用场景</h3>
<ul>
<li><strong>Web开发</strong>：在处理用户请求时，经常需要并发地获取多个数据源的数据，然后进行整合和处理。结构化并发可以轻松地并发执行这些任务，提高页面的加载速度和用户体验。</li>
<li><strong>大数据处理</strong>：在大数据处理中，常常需要对大量的数据进行并行计算和分析。结构化并发可以将数据处理任务拆分成多个子任务，每个子任务在独立的线程中执行，然后将结果合并，从而实现高效的数据处理。</li>
<li><strong>分布式系统</strong>：在分布式系统中，各个节点之间的通信和协作往往是并发进行的。结构化并发可以更好地管理这些并发操作，确保数据的一致性和系统的稳定性。</li>
</ul>
<h3> 相比传统并发的显著优势</h3>
<ul>
<li><strong>避免线程泄漏</strong>：结构化并发中，子任务的生命周期与父任务紧密绑定，当父任务结束时，所有未完成的子任务都会被自动取消，从而有效地避免了线程泄漏的发生。</li>
<li><strong>降低死锁风险</strong>：结构化并发通过明确的任务层次结构和执行顺序，减少了死锁发生的可能性。</li>
<li><strong>提高代码可读性和可维护性</strong>：结构化并发将并发任务组织成一个清晰的结构，使得代码的逻辑更加直观，易于理解和维护。</li>
<li><strong>提升性能</strong>：通过与虚拟线程的结合，结构化并发能够充分利用虚拟线程的轻量级特性，在处理大量并发任务时，减少线程创建和上下文切换的开销，从而显著提升系统的性能和响应速度。</li>
</ul>
<p><strong>小贴士</strong>：结构化并发就像是并发编程的“升级版”，让代码不仅更简洁，还更安全、更高效。</p>
<h2> 总结与展望</h2>
<p>Java 21的结构化并发为并发编程带来了重大的变革，它通过清晰的任务层次结构、更好的异常传播机制、简化的并发控制API以及与虚拟线程的完美融合，使得并发编程变得更加简单、可靠和高效。</p>
<p>在Web开发、大数据处理、分布式系统等众多领域，结构化并发都展现出了巨大的优势，能够帮助开发者更轻松地应对复杂的并发场景。</p>
<p>随着Java的不断发展，结构化并发有望成为并发编程的主流范式，为Java应用的性能和可靠性提供更强大的支持。我鼓励各位开发者积极尝试Java 21的结构化并发，将其应用到实际项目中，体验它带来的便利和优势。</p>
<p>如果你在使用Java 21结构化并发的过程中有任何问题、心得或体会，欢迎在留言区分享交流，让我们一起学习，共同进步！</p>
]]></content:encoded>
    </item>
    <item>
      <title>00.jdk8+迭代记录</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk8_/</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">00.jdk8+迭代记录</source>
      <description>这里记录JDK8+之后的新的特性 Java 8（2014年发布）到 Java 21（2023年发布）经历了多次迭代，新增了大量特性和改进。以下是主要版本（Java 9 到 Java 21）中值得关注的新特性分类整理： 一、语言特性改进 模块化系统（Java 9） Jigsaw 项目：引入模块化（module-info.java），解决 JAR 依赖和封装问题，提升安全性和可维护性。 局部变量类型推断（Java 10） var 关键字：允许在局部变量声明时省略显式类型（如 var list = new ArrayList&amp;lt;String&amp;gt;();）。 文本块（Java 15 正式支持） 多行字符串：使用 &amp;quot;&amp;quot;&amp;quot; ... &amp;quot;&amp;quot;&amp;quot; 简化 HTML、JSON 等多行文本的编写。 模式匹配（逐步引入） instanceof 模式匹配（Java 16）：直接提取对象属性，如 if (obj instanceof String s) { ... }。 switch 表达式（Java 14）：支持箭头语法和返回值，避免 break 的繁琐。 模式匹配 switch（Java 21 正式）：支持类型匹配和复杂条件，例如：switch (obj) { case Integer i -&amp;gt; System.out.println(&amp;quot;Integer: &amp;quot; + i); case String s when s.length() &amp;gt; 5 -&amp;gt; System.out.println(&amp;quot;Long string&amp;quot;); default -&amp;gt; {} } 记录类（Record，Java 16 正式） 简化不可变数据类的定义，自动生成 equals()、hashCode() 等方法：record Point(int x, int y) {} 密封类（Sealed Classes，Java 17 正式） 限制类的继承关系，明确子类范围：public sealed class Shape permits Circle, Square {} 字符串模板（Java 21 预览） 类似其他语言的模板插值功能，例如：String name = &amp;quot;John&amp;quot;; String message = STR.&amp;quot;Hello \{name}!&amp;quot;;</description>
      <pubDate>Fri, 14 Feb 2025 10:52:18 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里记录JDK8+之后的新的特性</p>
</blockquote>
<p>Java 8（2014年发布）到 Java 21（2023年发布）经历了多次迭代，新增了大量特性和改进。以下是主要版本（Java 9 到 Java 21）中值得关注的新特性分类整理：</p>
<hr>
<h3> <strong>一、语言特性改进</strong></h3>
<ol>
<li>
<p><strong>模块化系统（Java 9）</strong></p>
<ul>
<li><strong>Jigsaw 项目</strong>：引入模块化（<code>module-info.java</code>），解决 JAR 依赖和封装问题，提升安全性和可维护性。</li>
</ul>
</li>
<li>
<p><strong>局部变量类型推断（Java 10）</strong></p>
<ul>
<li><strong><code>var</code> 关键字</strong>：允许在局部变量声明时省略显式类型（如 <code>var list = new ArrayList&lt;String&gt;();</code>）。</li>
</ul>
</li>
<li>
<p><strong>文本块（Java 15 正式支持）</strong></p>
<ul>
<li><strong>多行字符串</strong>：使用 <code>""" ... """</code> 简化 HTML、JSON 等多行文本的编写。</li>
</ul>
</li>
<li>
<p><strong>模式匹配（逐步引入）</strong></p>
<ul>
<li><strong><code>instanceof</code> 模式匹配（Java 16）</strong>：直接提取对象属性，如 <code>if (obj instanceof String s) { ... }</code>。</li>
<li><strong><code>switch</code> 表达式（Java 14）</strong>：支持箭头语法和返回值，避免 <code>break</code> 的繁琐。</li>
<li><strong>模式匹配 <code>switch</code>（Java 21 正式）</strong>：支持类型匹配和复杂条件，例如：<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p><strong>记录类（Record，Java 16 正式）</strong></p>
<ul>
<li>简化不可变数据类的定义，自动生成 <code>equals()</code>、<code>hashCode()</code> 等方法：<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p><strong>密封类（Sealed Classes，Java 17 正式）</strong></p>
<ul>
<li>限制类的继承关系，明确子类范围：<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p><strong>字符串模板（Java 21 预览）</strong></p>
<ul>
<li>类似其他语言的模板插值功能，例如：<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
</ol>
<hr>
<h3> <strong>二、API 增强</strong></h3>
<ol>
<li>
<p><strong>新的集合工厂方法（Java 9）</strong></p>
<ul>
<li>快速创建不可变集合：<code>List.of("a", "b")</code>、<code>Set.of(1, 2)</code>、<code>Map.of("k", "v")</code>。</li>
</ul>
</li>
<li>
<p><strong>Stream API 增强</strong></p>
<ul>
<li><strong><code>takeWhile</code>/<code>dropWhile</code>（Java 9）</strong>：根据条件截取流。</li>
<li><strong><code>Collectors.toUnmodifiableList()</code>（Java 10）</strong>：生成不可变集合。</li>
</ul>
</li>
<li>
<p><strong>HTTP/2 客户端（Java 11 正式）</strong></p>
<ul>
<li>支持异步请求的现代 HTTP 客户端（<code>java.net.http.HttpClient</code>）。</li>
</ul>
</li>
<li>
<p><strong>进程 API 改进（Java 9+）</strong></p>
<ul>
<li>管理操作系统进程（如获取 PID、直接执行命令）。</li>
</ul>
</li>
<li>
<p><strong>新的日期时间 API（Java 8 已有，后续优化）</strong></p>
<ul>
<li><code>java.time</code> 包优化，例如 <code>LocalDate</code>、<code>ZonedDateTime</code> 等。</li>
</ul>
</li>
</ol>
<hr>
<h3> <strong>三、并发与性能</strong></h3>
<ol>
<li>
<p><strong>虚拟线程（Virtual Threads，Java 21 正式）</strong></p>
<ul>
<li>轻量级线程（协程），显著提升高并发吞吐量，简化异步编程：<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p><strong>结构化并发（Java 21 预览）</strong></p>
<ul>
<li>通过 <code>StructuredTaskScope</code> 管理多个子任务的生命周期，避免资源泄漏。</li>
</ul>
</li>
<li>
<p><strong>分代 ZGC（Java 21）</strong></p>
<ul>
<li>低延迟垃圾收集器 ZGC 支持分代回收，减少内存占用。</li>
</ul>
</li>
<li>
<p><strong>Shenandoah GC（Java 12+）</strong></p>
<ul>
<li>另一种低停顿时间的垃圾收集器。</li>
</ul>
</li>
</ol>
<hr>
<h3> <strong>四、工具与 JVM 改进</strong></h3>
<ol>
<li>
<p><strong>JShell（Java 9）</strong></p>
<ul>
<li>交互式 REPL 工具，快速测试代码片段。</li>
</ul>
</li>
<li>
<p><strong>单文件源码运行（Java 11）</strong></p>
<ul>
<li>直接运行 <code>.java</code> 文件（无需手动编译）：<code>java HelloWorld.java</code>。</li>
</ul>
</li>
<li>
<p><strong>动态 CDS 存档（Java 13+）</strong></p>
<ul>
<li>提升启动速度，通过共享类数据减少内存占用。</li>
</ul>
</li>
<li>
<p><strong>Flight Recorder（JFR）开源（Java 11）</strong></p>
<ul>
<li>生产环境性能监控工具，低开销收集 JVM 数据。</li>
</ul>
</li>
</ol>
<hr>
<h3> <strong>五、其他重要特性</strong></h3>
<ol>
<li>
<p><strong><code>var</code> 支持 Lambda 参数（Java 11）</strong></p>
<ul>
<li>允许在 Lambda 表达式中使用 <code>var</code> 声明参数。</li>
</ul>
</li>
<li>
<p><strong><code>@Deprecated</code> 增强（Java 9）</strong></p>
<ul>
<li>标记 API 废弃状态和替代方案。</li>
</ul>
</li>
<li>
<p><strong>接口私有方法（Java 9）</strong></p>
<ul>
<li>在接口中定义私有方法，提升代码复用性。</li>
</ul>
</li>
<li>
<p><strong>移除过时功能</strong></p>
<ul>
<li>移除 Applet、Java Web Start、永久代（PermGen）等。</li>
</ul>
</li>
</ol>
<hr>
<h3> <strong>六、Java 21 核心特性总结</strong></h3>
<p>Java 21 作为 LTS（长期支持版本），整合了此前多个预览特性，并重点优化了并发和内存管理：</p>
<ul>
<li><strong>虚拟线程</strong>：彻底改变高并发编程模型。</li>
<li><strong>分代 ZGC</strong>：提升垃圾回收效率。</li>
<li><strong>模式匹配</strong>：简化条件分支代码。</li>
<li><strong>字符串模板</strong>：增强字符串处理能力。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>06.JDK21增强的模式匹配：更简洁、更强大的条件逻辑</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/06.%E5%A2%9E%E5%BC%BA%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/06.%E5%A2%9E%E5%BC%BA%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">06.JDK21增强的模式匹配：更简洁、更强大的条件逻辑</source>
      <description>1. 背景：为什么需要增强的模式匹配？ 在Java中，条件逻辑通常通过if-else或switch语句实现，但这些方式存在以下问题： 冗长：需要显式类型检查和类型转换 易错：手动类型转换可能导致ClassCastException 局限性：switch语句仅支持有限的数据类型 增强的模式匹配（Enhanced Pattern Matching）是Java模式匹配的进一步扩展，旨在简化条件逻辑的编写。它结合了类型检查、类型转换和模式匹配的特性，使开发者能够以声明式的方式处理复杂条件逻辑。</description>
      <category>Java</category>
      <category>JDK21</category>
      <pubDate>Thu, 13 Feb 2025 17:58:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. 背景：为什么需要增强的模式匹配？</h2>
<p>在Java中，条件逻辑通常通过<code>if-else</code>或<code>switch</code>语句实现，但这些方式存在以下问题：</p>
<ol>
<li><strong>冗长</strong>：需要显式类型检查和类型转换</li>
<li><strong>易错</strong>：手动类型转换可能导致<code>ClassCastException</code></li>
<li><strong>局限性</strong>：<code>switch</code>语句仅支持有限的数据类型</li>
</ol>
<p><strong>增强的模式匹配</strong>（Enhanced Pattern Matching）是Java模式匹配的进一步扩展，旨在简化条件逻辑的编写。它结合了<strong>类型检查</strong>、<strong>类型转换</strong>和<strong>模式匹配</strong>的特性，使开发者能够以声明式的方式处理复杂条件逻辑。</p>
<p>JDK16首次引入模式匹配<code>instanceof</code>，JDK17扩展了<code>switch</code>的模式匹配能力，JDK21进一步优化并正式发布。</p>
<h2> 2. 原理：增强的模式匹配如何工作？</h2>
<h3> 2.1 传统条件逻辑 vs 增强的模式匹配</h3>
<h4> 传统方式</h4>
<ul>
<li><strong>显式类型检查</strong>：使用<code>instanceof</code>检查类型</li>
<li><strong>显式类型转换</strong>：手动进行类型转换</li>
<li><strong>冗长代码</strong>：需要多行代码完成简单操作</li>
</ul>
<h4> 增强的模式匹配</h4>
<ul>
<li><strong>声明式匹配</strong>：直接匹配类型并绑定变量</li>
<li><strong>自动类型转换</strong>：编译器自动推断类型，无需显式类型转换</li>
<li><strong>简洁代码</strong>：减少样板代码，提升开发效率</li>
</ul>
<h3> 2.2 核心机制</h3>
<ol>
<li>
<p><strong>模式匹配<code>instanceof</code></strong><br>
在<code>instanceof</code>中直接绑定变量，例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>模式匹配<code>switch</code></strong><br>
在<code>switch</code>中支持类型匹配和模式解构，例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>嵌套模式匹配</strong><br>
支持嵌套模式匹配，简化复杂数据结构的处理。</p>
</li>
<li>
<p><strong>类型推断</strong><br>
编译器自动推断匹配类型，减少显式类型转换。</p>
</li>
</ol>
<h3> 2.3 优势：为什么选择增强的模式匹配？</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>传统方式</th>
<th>增强的模式匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td>代码简洁性</td>
<td>冗长</td>
<td><strong>简洁</strong></td>
</tr>
<tr>
<td>类型安全性</td>
<td>需显式类型转换</td>
<td><strong>自动推断</strong></td>
</tr>
<tr>
<td>嵌套支持</td>
<td>手动逐层匹配</td>
<td><strong>自动解构</strong></td>
</tr>
<tr>
<td>可读性</td>
<td>低</td>
<td><strong>高</strong></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>代码简洁</strong>：减少样板代码，提升开发效率</li>
<li><strong>类型安全</strong>：编译器自动检查类型，减少运行时错误</li>
<li><strong>嵌套支持</strong>：轻松处理复杂数据结构</li>
<li><strong>可读性高</strong>：声明式语法更符合直觉</li>
</ol>
<h2> 3. 使用示例</h2>
<h3> 示例1：模式匹配<code>instanceof</code></h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例2：模式匹配<code>switch</code></h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例3：嵌套模式匹配</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例4：结合<code>switch</code>表达式</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3.小结</h2>
<h3> 3.1 注意事项</h3>
<ol>
<li>
<p><strong>类型检查顺序</strong><br>
在<code>switch</code>中，更具体的模式应放在前面：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>空值处理</strong><br>
模式匹配不支持<code>null</code>值匹配，需额外检查：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p><strong>性能影响</strong><br>
模式匹配在运行时可能引入额外开销，需在性能敏感场景中测试。</p>
</li>
<li>
<p><strong>兼容性</strong><br>
增强的模式匹配需要JDK16及以上版本。</p>
</li>
</ol>
<h3> 3.2 总结</h3>
<p>JDK21增强的模式匹配通过以下革新提升Java条件逻辑的效率：</p>
<ul>
<li>✅ 简化条件逻辑代码</li>
<li>✅ 提升类型安全性和可读性</li>
<li>✅ 支持嵌套模式匹配</li>
<li>✅ 与<code>switch</code>表达式无缝集成</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>处理复杂条件逻辑</li>
<li>实现类型安全的模式匹配</li>
<li>简化数据验证和提取</li>
</ul>
<p>增强的模式匹配是Java模式匹配的重要扩展，有兴趣的小伙伴可以参考<a href="https://openjdk.org/jeps/406" target="_blank" rel="noopener noreferrer">官方文档</a>以掌握最佳实践。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>01.JDK21新特性及示例说明</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/01.JDK21%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/01.JDK21%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">01.JDK21新特性及示例说明</source>
      <description>JDK 21 在 JDK 8 的基础上引入了许多新特性，下面详细介绍一些主要特性并给出相应的示例代码： 1. 虚拟线程（Virtual Threads） 虚拟线程是 JDK 21 引入的轻量级线程，能够以较低的开销处理大量并发任务。与传统的平台线程相比，虚拟线程由 Java 运行时管理，不需要操作系统内核线程的支持，从而可以创建数百万个虚拟线程而不会耗尽系统资源。 示例代码： import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class VirtualThreadsExample { public static void main(String[] args) { // 创建一个虚拟线程执行器 try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) { for (int i = 0; i &amp;lt; 1000; i++) { final int taskId = i; // 提交任务到执行器 executor.submit(() -&amp;gt; { System.out.println(&amp;quot;Task &amp;quot; + taskId + &amp;quot; is running on thread: &amp;quot; + Thread.currentThread()); try { // 模拟任务执行 Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } System.out.println(&amp;quot;Task &amp;quot; + taskId + &amp;quot; is completed.&amp;quot;); }); } } } }</description>
      <category>Java</category>
      <category>JDK21</category>
      <pubDate>Thu, 13 Feb 2025 09:48:09 GMT</pubDate>
      <content:encoded><![CDATA[<p>JDK 21 在 JDK 8 的基础上引入了许多新特性，下面详细介绍一些主要特性并给出相应的示例代码：</p>
<h3> 1. 虚拟线程（Virtual Threads）</h3>
<p>虚拟线程是 JDK 21 引入的轻量级线程，能够以较低的开销处理大量并发任务。与传统的平台线程相比，虚拟线程由 Java 运行时管理，不需要操作系统内核线程的支持，从而可以创建数百万个虚拟线程而不会耗尽系统资源。</p>
<p><strong>示例代码</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 结构化并发（Structured Concurrency）</h3>
<p>结构化并发是一种新的并发编程模型，它将一组相关的任务视为一个单一的工作单元，使得任务的管理和错误处理更加简单和直观。通过使用 <code>StructuredTaskScope</code>，可以方便地启动和等待多个并发任务的完成。</p>
<p><strong>示例代码</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 记录模式（Record Patterns）</h3>
<p>记录模式允许在模式匹配中解构记录类型，使得代码更加简洁和易读。结合 <code>instanceof</code> 和 <code>switch</code> 表达式，可以更方便地处理记录类型的数据。</p>
<p><strong>示例代码</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 字符串模板（String Templates）</h3>
<p>字符串模板是一种新的字符串构建机制，它允许在字符串中嵌入表达式，使得字符串的拼接更加直观和方便。</p>
<p><strong>示例代码</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 增强的模式匹配（Enhanced Pattern Matching）</h3>
<p>JDK 21 进一步增强了模式匹配的功能，支持更复杂的模式匹配，如嵌套模式匹配和类型测试模式。</p>
<p><strong>示例代码</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>02.JDK21虚拟线程：重新定义Java高并发编程</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/02.%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/02.%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">02.JDK21虚拟线程：重新定义Java高并发编程</source>
      <description>1. 背景：为什么需要虚拟线程？ 在传统Java并发模型中，每个java.lang.Thread都直接对应一个操作系统线程（称为平台线程）。虽然这种1:1的模型保证了可靠的并发执行，但存在两个关键瓶颈： 资源限制：操作系统线程创建成本高（默认1MB栈空间），难以支持百万级并发 上下文切换开销：线程数量激增时，CPU时间大量消耗在切换线程上下文上 开发者通常通过线程池和异步编程（如CompletableFuture）缓解这些问题，但这导致了代码复杂度上升。Project Loom应运而生，其核心成果虚拟线程在JDK19中首次预览，最终在JDK21正式发布。</description>
      <category>Java</category>
      <category>JDK21</category>
      <pubDate>Thu, 13 Feb 2025 11:48:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. 背景：为什么需要虚拟线程？</h2>
<p>在传统Java并发模型中，每个<code>java.lang.Thread</code>都直接对应一个操作系统线程（称为<strong>平台线程</strong>）。虽然这种1:1的模型保证了可靠的并发执行，但存在两个关键瓶颈：</p>
<ol>
<li><strong>资源限制</strong>：操作系统线程创建成本高（默认1MB栈空间），难以支持百万级并发</li>
<li><strong>上下文切换开销</strong>：线程数量激增时，CPU时间大量消耗在切换线程上下文上</li>
</ol>
<p>开发者通常通过线程池和异步编程（如CompletableFuture）缓解这些问题，但这导致了代码复杂度上升。<strong>Project Loom</strong>应运而生，其核心成果<strong>虚拟线程</strong>在JDK19中首次预览，最终在JDK21正式发布。</p>
<h2> 2. 原理：虚拟线程如何工作？</h2>
<h3> 2.1 传统线程模型 vs 虚拟线程模型</h3>
<h4> 传统线程模型（平台线程）</h4>
<ul>
<li><strong>1:1 模型</strong>：每个Java线程直接映射到一个操作系统线程。</li>
<li><strong>资源开销大</strong>：每个线程默认占用1MB栈空间，创建和销毁成本高。</li>
<li><strong>上下文切换依赖内核</strong>：线程切换需要内核介入，开销较大。</li>
<li><strong>并发限制</strong>：受限于操作系统线程数（通常数千个）。</li>
</ul>
<h4> 虚拟线程模型</h4>
<ul>
<li><strong>M:N 模型</strong>：大量虚拟线程（M）复用在少量平台线程（N）上运行。</li>
<li><strong>轻量级</strong>：虚拟线程的栈空间按需分配，初始内存占用仅几百字节。</li>
<li><strong>协作式调度</strong>：虚拟线程在阻塞操作（如I/O）时自动让出执行权，由JVM调度器管理。</li>
<li><strong>高并发支持</strong>：可轻松创建数百万个虚拟线程。</li>
</ul>
<h3> 虚拟线程的核心机制</h3>
<ol>
<li>
<p><strong>Continuation（延续体）</strong></p>
<ul>
<li>虚拟线程的核心是一个可暂停和恢复的任务单元（Continuation）。</li>
<li>当虚拟线程执行阻塞操作时，JVM会保存当前状态并挂起任务，切换到其他虚拟线程。</li>
<li>阻塞操作完成后，JVM恢复任务状态并继续执行。</li>
</ul>
</li>
<li>
<p><strong>调度器</strong></p>
<ul>
<li>默认使用<code>ForkJoinPool</code>作为调度器，将虚拟线程分配到平台线程上执行。</li>
<li>调度器负责在虚拟线程阻塞时将其从平台线程上卸载，并在就绪时重新调度。</li>
</ul>
</li>
<li>
<p><strong>栈管理</strong></p>
<ul>
<li>虚拟线程的栈空间是动态分配的，按需增长和收缩。</li>
<li>通过<strong>Stack Chunk</strong>技术，JVM可以高效地管理虚拟线程的栈内存。</li>
</ul>
</li>
<li>
<p><strong>阻塞操作优化</strong></p>
<ul>
<li>虚拟线程在执行I/O、锁等待等阻塞操作时，会自动让出平台线程。</li>
<li>这种机制避免了平台线程的浪费，提高了资源利用率。</li>
</ul>
</li>
</ol>
<h4> 对比总结</h4>
<table>
<thead>
<tr>
<th>特性</th>
<th>平台线程</th>
<th>虚拟线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>线程模型</td>
<td>1:1（Java线程:OS线程）</td>
<td>M:N（虚拟线程:平台线程）</td>
</tr>
<tr>
<td>内存开销</td>
<td>默认1MB/线程</td>
<td><strong>~200字节/线程</strong></td>
</tr>
<tr>
<td>上下文切换</td>
<td>内核参与，开销大</td>
<td><strong>JVM管理，开销小</strong></td>
</tr>
<tr>
<td>阻塞操作</td>
<td>占用平台线程</td>
<td><strong>自动让出平台线程</strong></td>
</tr>
<tr>
<td>并发能力</td>
<td>数千级</td>
<td><strong>百万级</strong></td>
</tr>
</tbody>
</table>
<h3> 2.2 虚拟线程调度</h3>
<p>虚拟线程的调度主要包含三个核心部分：虚拟线程（Virtual Threads）、平台线程（Platform Threads）和调度器（Scheduler）。</p>
<ol>
<li><strong>虚拟线程池：</strong></li>
</ol>
<ul>
<li>这是一个包含大量虚拟线程的集合。每个虚拟线程代表一个轻量级的执行单元，它们可以由用户代码创建并提交到执行器中等待执行。虚拟线程之间是平等的，它们的栈空间较小，创建和销毁的开销也很低。</li>
</ul>
<ol start="2">
<li><strong>平台线程池：</strong></li>
</ol>
<ul>
<li>平台线程是与操作系统内核线程一一对应的线程，数量相对较少。平台线程负责执行虚拟线程中的实际任务，它们是系统资源的实际使用者。</li>
</ul>
<ol start="3">
<li><strong>调度器：</strong></li>
</ol>
<ul>
<li>调度器是整个系统的核心，负责将虚拟线程分配到可用的平台线程上执行。</li>
<li>调度器会根据虚拟线程的状态（如就绪、阻塞等）和平台线程的负载情况进行智能调度。</li>
<li>当一个虚拟线程遇到阻塞操作（如 I/O 操作）时，调度器会将该虚拟线程暂停，并将平台线程分配给其他就绪的虚拟线程；当阻塞操作完成后，调度器会将该虚拟线程重新加入到就绪队列中，等待再次分配到平台线程执行。</li>
</ul>
<ol start="4">
<li><strong>阻塞与唤醒机制：</strong></li>
</ol>
<ul>
<li>当虚拟线程进行 I/O 等阻塞操作时，会触发阻塞信号，调度器将其标记为阻塞状态并让出平台线程；</li>
<li>当阻塞操作完成，会有唤醒信号，调度器将其重新标记为就绪状态等待调度。</li>
</ul>
<p>虚拟线程调度的基本流程：</p>
<p>虚拟线程进入调度器，调度器将其分配到平台线程执行，当平台线程上的虚拟线程遇到阻塞操作时通知调度器，调度器再去唤醒其他就绪的虚拟线程执行。</p>
<figure><img src="/imgs/column/java/jdk21_virtual_thread_00.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2.3 优势：为什么选择虚拟线程？</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>平台线程</th>
<th>虚拟线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建数量</td>
<td>数千级</td>
<td><strong>百万级</strong></td>
</tr>
<tr>
<td>内存消耗</td>
<td>默认1MB/线程</td>
<td><strong>~200字节/线程</strong></td>
</tr>
<tr>
<td>上下文切换</td>
<td>内核参与</td>
<td><strong>JVM优化</strong></td>
</tr>
<tr>
<td>编程模型</td>
<td>回调地狱风险</td>
<td><strong>同步代码风格</strong></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>高吞吐</strong>：轻松支撑10万+并发连接</li>
<li><strong>低资源消耗</strong>：创建百万虚拟线程仅需几百MB内存</li>
<li><strong>代码简化</strong>：用同步代码实现异步性能，避免回调地狱</li>
<li><strong>兼容性</strong>：与现有Thread API、调试工具（如jstack）完全兼容</li>
</ol>
<h2> 3. 使用示例</h2>
<h3> 示例1：创建虚拟线程</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例2：HTTP服务器对比</h3>
<p><strong>传统线程池（20线程）：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>虚拟线程版：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例3：使用虚拟线程实现归并排序</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明：</strong></p>
<ul>
<li>使用虚拟线程并行化归并排序的递归任务。</li>
<li>每个子任务（<code>mergeSort</code>）都在独立的虚拟线程中执行。</li>
<li>通过<code>Future</code>获取子任务结果，并合并（<code>merge</code>）排序后的数组。</li>
</ul>
<h2> 4.小结</h2>
<h3> 4.1 注意事项</h3>
<ol>
<li><strong>阻塞操作仍影响平台线程</strong></li>
</ol>
<p>在<code>synchronized</code>块或native方法中阻塞会占用平台线程</p>
<ol start="2">
<li><strong>避免在虚拟线程中：</strong></li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li><strong>正确关闭ExecutorService</strong></li>
</ol>
<p>使用try-with-resources确保自动关闭</p>
<ol start="4">
<li><strong>不要池化虚拟线程</strong></li>
</ol>
<p>每个任务应新建虚拟线程（JVM已优化创建成本）</p>
<ol start="5">
<li><strong>性能考虑</strong></li>
</ol>
<p>虚拟线程适合处理 I/O 密集型任务，而传统线程更适合处理 CPU 密集型任务。在设计系统时，需要根据任务的特点合理分配线程类型，以充分发挥各自的优势。</p>
<ol start="6">
<li><strong>资源管理：</strong></li>
</ol>
<p>无论是虚拟线程还是传统线程，都需要注意资源的合理使用和释放，避免出现资源泄漏的问题。</p>
<h3> 4.2 小结</h3>
<p>JDK21虚拟线程通过以下革新重塑Java并发：</p>
<ul>
<li>✅ 使高并发应用的代码复杂度降低50%+</li>
<li>✅ 吞吐量提升10倍（Tomcat基准测试数据）</li>
<li>✅ 完全兼容现有代码和监控工具</li>
</ul>
<p><strong>适用场景</strong>：高并发服务、微服务架构、异步IO处理等</p>
<p>尽管虚拟线程并非万能（CPU密集型任务仍需平台线程），但它无疑是Java在云原生时代的重要进化。 有兴趣的小伙伴快尝试下吧，<a href="https://docs.oracle.com/en/java/javase/21/core/virtual-threads.html" target="_blank" rel="noopener noreferrer">更多使用相关推荐参考官方指导</a></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://liuyueyi.github.io/tutorial/imgs/column/java/jdk21_virtual_thread_00.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>03.JDK21结构化并发：重新定义并发任务的生命周期管理</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/03.%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/03.%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">03.JDK21结构化并发：重新定义并发任务的生命周期管理</source>
      <description>1. 背景：为什么需要结构化并发？ 在传统Java并发编程中，开发者通过ExecutorService、Future或CompletableFuture管理多线程任务。然而，这些方式存在显著问题： 生命周期管理困难：子任务可能脱离父任务独立运行，导致“线程泄漏” 错误处理复杂：异常可能被静默吞噬，难以追踪问题根源 资源浪费：未及时关闭的线程池可能持续占用系统资源</description>
      <category>Java</category>
      <category>JDK21</category>
      <pubDate>Thu, 13 Feb 2025 15:48:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. 背景：为什么需要结构化并发？</h2>
<p>在传统Java并发编程中，开发者通过<code>ExecutorService</code>、<code>Future</code>或<code>CompletableFuture</code>管理多线程任务。然而，这些方式存在显著问题：</p>
<ol>
<li><strong>生命周期管理困难</strong>：子任务可能脱离父任务独立运行，导致“线程泄漏”</li>
<li><strong>错误处理复杂</strong>：异常可能被静默吞噬，难以追踪问题根源</li>
<li><strong>资源浪费</strong>：未及时关闭的线程池可能持续占用系统资源</li>
</ol>
<p><strong>结构化并发</strong>（Structured Concurrency）的概念源自结构化编程，核心思想是<strong>任务的生命周期应与其创建者的作用域严格绑定</strong>。JDK21通过JEP 453引入结构化并发API（第二次预览），旨在以同步代码风格实现可靠的异步任务管理。</p>
<hr>
<h2> 2. 原理：结构化并发如何工作？</h2>
<h3> 2.1 传统并发 vs 结构化并发</h3>
<h4> 传统并发模型</h4>
<ul>
<li><strong>松散的任务关系</strong>：父任务与子任务之间无强制绑定</li>
<li><strong>手动管理关闭</strong>：需显式调用<code>shutdown()</code>或<code>cancel()</code></li>
<li><strong>错误传播困难</strong>：子任务异常无法自动传递到父任务</li>
</ul>
<h4> 结构化并发模型</h4>
<ul>
<li><strong>任务作用域</strong>：所有子任务必须在父任务的作用域内执行</li>
<li><strong>自动关闭保证</strong>：作用域退出时自动取消未完成子任务</li>
<li><strong>异常冒泡机制</strong>：子任务异常会直接中断父任务执行</li>
</ul>
<h3> 核心机制</h3>
<ol>
<li>
<p><strong>作用域（Scope）</strong><br>
通过<code>StructuredTaskScope</code>定义一个任务作用域，所有子任务必须在此作用域内创建和执行。作用域关闭时，自动清理所有子任务。</p>
</li>
<li>
<p><strong>关闭顺序控制</strong></p>
<ul>
<li>父任务作用域关闭时，首先取消所有未完成的子任务</li>
<li>等待所有子任务终止后才继续执行后续代码</li>
</ul>
</li>
<li>
<p><strong>错误传播</strong><br>
任一子任务抛出异常时，自动终止作用域内所有任务，并将异常传递给父任务。</p>
</li>
<li>
<p><strong>结果聚合</strong><br>
支持通过<code>ShutdownOnSuccess</code>（任一成功即返回）或<code>ShutdownOnFailure</code>（任一失败即终止）策略聚合结果。</p>
</li>
</ol>
<h3> 2.2 架构示意图</h3>
<div class="language-plaintext line-numbers-mode" data-ext="plaintext"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em>所有子任务的生命周期严格限定在父作用域内</em></p>
<hr>
<h2> 3. 优势：为什么选择结构化并发？</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>传统并发</th>
<th>结构化并发</th>
</tr>
</thead>
<tbody>
<tr>
<td>任务关系</td>
<td>松散</td>
<td><strong>严格层级化</strong></td>
</tr>
<tr>
<td>生命周期管理</td>
<td>手动</td>
<td><strong>自动管理</strong></td>
</tr>
<tr>
<td>异常传播</td>
<td>需显式处理</td>
<td><strong>自动冒泡</strong></td>
</tr>
<tr>
<td>代码可读性</td>
<td>回调嵌套复杂</td>
<td><strong>线性流程</strong></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>可靠性提升</strong>：避免线程泄漏，确保资源及时释放</li>
<li><strong>调试简化</strong>：通过线程转储（jstack）可清晰查看任务关系树</li>
<li><strong>错误处理统一</strong>：集中处理所有子任务的异常</li>
<li><strong>资源利用率优化</strong>：自动回收未完成任务占用的资源</li>
</ol>
<hr>
<h2> 4. 使用示例</h2>
<p>结构化并发的核心思想是将一组相关的并发任务视为一个单一的工作单元，这个工作单元有明确的开始和结束。在这个工作单元中，所有的子任务都在一个统一的作用域内执行，当工作单元完成或其中一个子任务失败时，整个工作单元会被正确地关闭，所有未完成的子任务也会被取消。这种方式使得并发代码的结构更加清晰，错误处理更加统一，从而提高了代码的可维护性和可靠性。</p>
<p>结构化并发通过 <code>StructuredTaskScope</code> 类来实现。<code>StructuredTaskScope</code> 提供了两种主要的模式：<code>ShutdownOnFailure</code> 和 <code>ShutdownOnSuccess</code></p>
<ul>
<li><code>ShutdownOnFailure：</code>当任何一个子任务失败时，会立即取消所有其他未完成的子任务，并抛出失败任务的异常。</li>
<li><code>ShutdownOnSuccess：</code>当任何一个子任务成功完成时，会立即取消所有其他未完成的子任务，并返回成功任务的结果。</li>
</ul>
<h3> 示例1：基本使用</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例2：订单处理（超时控制+异常处理）</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例3：并行聚合数据</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> 5. 小结</h2>
<h3> 5.1 注意事项</h3>
<ol>
<li>
<p><strong>作用域必须关闭</strong><br>
始终使用try-with-resources确保作用域关闭：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>避免跨作用域传递结果</strong><br>
子任务的结果应在同一作用域内消费：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>合理选择关闭策略</strong></p>
<ul>
<li><code>ShutdownOnSuccess</code>：适合快速获取首个成功结果（如多CDN择优）</li>
<li><code>ShutdownOnFailure</code>：适合所有子任务必须成功的场景（如支付验证）</li>
</ul>
</li>
<li>
<p><strong>与虚拟线程协同</strong><br>
结构化并发通常与虚拟线程配合使用：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h3> 5.2 小结</h3>
<p>JDK21结构化并发通过以下革新提升Java并发可靠性：</p>
<ul>
<li>✅ 将并发任务组织为可维护的树形结构</li>
<li>✅ 自动生命周期管理减少资源泄漏风险</li>
<li>✅ 异常传播机制提升调试效率</li>
<li>✅ 与虚拟线程协同实现高并发+高可靠</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>微服务中的并行API调用</li>
<li>批量数据处理任务</li>
<li>需要严格资源管理的长期运行任务</li>
</ul>
<p>目前结构化并发API仍处于预览阶段，可通过<code>--enable-preview</code>启用。 建议结合<a href="https://openjdk.org/jeps/453" target="_blank" rel="noopener noreferrer">官方指南</a>进行实践，这将为Java并发编程带来前所未有的代码清晰度与可靠性。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>04.JDK21记录模式：简化数据解构与模式匹配</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/04.%E8%AE%B0%E5%BD%95%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/04.%E8%AE%B0%E5%BD%95%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">04.JDK21记录模式：简化数据解构与模式匹配</source>
      <description>1. 背景：为什么需要记录模式？ 在Java中，处理复杂数据结构（如嵌套对象或记录类）时，通常需要编写大量样板代码来提取和验证数据。例如： 手动解构嵌套对象 使用instanceof和类型转换 编写冗长的条件分支 记录模式（Record Patterns）是Java模式匹配的进一步扩展，旨在简化数据解构和模式匹配的代码。它结合了记录类（Record）和模式匹配的特性，使开发者能够以声明式的方式提取和处理数据。</description>
      <category>Java</category>
      <category>JDK21</category>
      <pubDate>Thu, 13 Feb 2025 16:48:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. 背景：为什么需要记录模式？</h2>
<p>在Java中，处理复杂数据结构（如嵌套对象或记录类）时，通常需要编写大量样板代码来提取和验证数据。例如：</p>
<ul>
<li>手动解构嵌套对象</li>
<li>使用<code>instanceof</code>和类型转换</li>
<li>编写冗长的条件分支</li>
</ul>
<p><strong>记录模式</strong>（Record Patterns）是Java模式匹配的进一步扩展，旨在简化数据解构和模式匹配的代码。它结合了<strong>记录类</strong>（Record）和<strong>模式匹配</strong>的特性，使开发者能够以声明式的方式提取和处理数据。</p>
<p>JDK19首次引入记录模式作为预览特性，JDK21进一步优化并正式发布。</p>
<h2> 2. 原理：记录模式如何工作？</h2>
<p>记录类是一种特殊的类，它主要用于封装不可变的数据，自动生成构造函数、equals()、hashCode() 和 toString() 等方法。</p>
<p>记录模式利用记录类的这种特性，使得在进行类型检查和数据提取时可以一步完成，避免了传统方式下繁琐的属性访问操作</p>
<h3> 2.1 传统数据解构 vs 记录模式</h3>
<h4> 传统方式</h4>
<ul>
<li><strong>手动解构</strong>：通过getter方法或字段访问提取数据</li>
<li><strong>类型检查</strong>：使用<code>instanceof</code>和类型转换</li>
<li><strong>冗长代码</strong>：需要多行代码完成简单操作</li>
</ul>
<h4> 记录模式</h4>
<ul>
<li><strong>声明式解构</strong>：直接匹配记录类的结构并提取字段</li>
<li><strong>类型推断</strong>：自动推断字段类型，无需显式类型转换</li>
<li><strong>模式嵌套</strong>：支持嵌套记录类的解构</li>
</ul>
<h3> 核心机制</h3>
<ol>
<li>
<p><strong>模式匹配</strong><br>
记录模式扩展了<code>instanceof</code>和<code>switch</code>的模式匹配能力，允许直接匹配记录类的结构。</p>
</li>
<li>
<p><strong>解构绑定</strong><br>
在匹配成功后，自动将记录类的字段绑定到变量中。</p>
</li>
<li>
<p><strong>嵌套支持</strong><br>
支持嵌套记录类的解构，简化复杂数据结构的处理。</p>
</li>
<li>
<p><strong>类型推断</strong><br>
编译器自动推断字段类型，减少显式类型转换。</p>
</li>
</ol>
<h3> 2.2 架构示意图</h3>
<div class="language-plaintext line-numbers-mode" data-ext="plaintext"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 优势：为什么选择记录模式？</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>传统方式</th>
<th>记录模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>代码简洁性</td>
<td>冗长</td>
<td><strong>简洁</strong></td>
</tr>
<tr>
<td>类型安全性</td>
<td>需显式类型转换</td>
<td><strong>自动推断</strong></td>
</tr>
<tr>
<td>嵌套支持</td>
<td>手动逐层解构</td>
<td><strong>自动解构</strong></td>
</tr>
<tr>
<td>可读性</td>
<td>低</td>
<td><strong>高</strong></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>代码简洁</strong>：减少样板代码，提升开发效率</li>
<li><strong>类型安全</strong>：编译器自动检查类型，减少运行时错误</li>
<li><strong>嵌套解构</strong>：轻松处理复杂数据结构</li>
<li><strong>可读性高</strong>：声明式语法更符合直觉</li>
</ol>
<h2> 4. 使用示例</h2>
<p>记录模式的基本语法是在 instanceof 或 switch 表达式中使用记录类的名称，并在括号内指定要解构的组件变量。例如：</p>
<h3> 示例1：基本使用</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例2：嵌套记录类</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例3：在<code>switch</code>中使用记录模式</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例4：结合泛型使用</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5. 小结</h2>
<h3> 5.1 注意事项</h3>
<ol>
<li>
<p><strong>记录类要求</strong><br>
记录模式仅适用于记录类（Record），普通类需转换为记录类才能使用。</p>
</li>
<li>
<p><strong>模式顺序</strong><br>
在<code>switch</code>中，更具体的模式应放在前面：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>空值处理</strong><br>
记录模式不支持<code>null</code>值匹配，需额外检查：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p><strong>性能影响</strong><br>
记录模式在运行时可能引入额外开销，需在性能敏感场景中测试。</p>
</li>
</ol>
<h2> 5.2 总结</h2>
<p>JDK21记录模式通过以下革新提升Java数据处理的效率：</p>
<ul>
<li>✅ 简化数据解构代码</li>
<li>✅ 提升类型安全性和可读性</li>
<li>✅ 支持嵌套记录类的解构</li>
<li>✅ 与模式匹配无缝集成</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>处理复杂数据结构</li>
<li>实现模式匹配逻辑</li>
<li>简化数据验证和提取</li>
</ul>
<p>记录模式是Java模式匹配的重要扩展，建议有兴趣的小伙伴可以参考<a href="https://openjdk.org/jeps/440" target="_blank" rel="noopener noreferrer">官方文档</a>来实际体验一下它的魅力</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>05.JDK21字符串模板：更安全、更强大的字符串拼接</title>
      <link>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/05.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF.html</link>
      <guid>https://liuyueyi.github.io/tutorial/java/jdk/jdk21/05.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF.html</guid>
      <source url="https://liuyueyi.github.io/tutorial/rss.xml">05.JDK21字符串模板：更安全、更强大的字符串拼接</source>
      <description>1. 背景：为什么需要字符串模板？ 在Java中，字符串拼接是常见的操作，但传统方式存在诸多问题： 可读性差：使用+或StringBuilder拼接字符串时，代码冗长且难以维护 安全性低：直接拼接用户输入可能导致SQL注入或XSS攻击 性能开销：频繁拼接字符串可能产生大量临时对象，影响性能 字符串模板（String Templates）是JDK21引入的一项新特性（预览），旨在提供一种更安全、更直观的字符串构建方式。它结合了模板引擎的灵活性和Java类型系统的安全性。</description>
      <category>Java</category>
      <category>JDK21</category>
      <pubDate>Thu, 13 Feb 2025 17:48:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. 背景：为什么需要字符串模板？</h2>
<p>在Java中，字符串拼接是常见的操作，但传统方式存在诸多问题：</p>
<ol>
<li><strong>可读性差</strong>：使用<code>+</code>或<code>StringBuilder</code>拼接字符串时，代码冗长且难以维护</li>
<li><strong>安全性低</strong>：直接拼接用户输入可能导致SQL注入或XSS攻击</li>
<li><strong>性能开销</strong>：频繁拼接字符串可能产生大量临时对象，影响性能</li>
</ol>
<p><strong>字符串模板</strong>（String Templates）是JDK21引入的一项新特性（预览），旨在提供一种更安全、更直观的字符串构建方式。它结合了<strong>模板引擎</strong>的灵活性和<strong>Java类型系统</strong>的安全性。</p>
<p><strong>基本概念</strong></p>
<p>字符串模板是一种允许在字符串字面量中嵌入表达式的机制。传统的 Java 字符串拼接通常使用 + 运算符或 String.format 方法，这在处理复杂的字符串拼接时会使代码变得冗长且不易阅读。而字符串模板通过将表达式直接嵌入到字符串中，使代码更加简洁和直观。</p>
<h2> 2. 原理：字符串模板如何工作？</h2>
<h3> 2.1 传统字符串拼接 vs 字符串模板</h3>
<h4> 传统方式</h4>
<ul>
<li><strong><code>+</code>操作符</strong>：简单但性能较差，可读性低</li>
<li><strong><code>StringBuilder</code></strong>：性能较好，但代码冗长</li>
<li><strong><code>String.format</code></strong>：可读性较高，但类型安全性差</li>
</ul>
<h4> 字符串模板</h4>
<ul>
<li><strong>嵌入式表达式</strong>：在字符串中直接嵌入变量或表达式</li>
<li><strong>类型安全</strong>：编译器检查表达式类型，避免运行时错误</li>
<li><strong>自定义处理器</strong>：支持通过处理器（Processor）自定义字符串生成逻辑</li>
</ul>
<h3> 核心机制</h3>
<ol>
<li>
<p><strong>模板语法</strong><br>
使用<code>\{...}</code>嵌入表达式，例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>模板处理器</strong><br>
字符串模板支持自定义处理器，例如：</p>
<ul>
<li><code>STR</code>：标准处理器，直接拼接字符串</li>
<li><code>FMT</code>：格式化处理器，支持格式化字符串</li>
<li>自定义处理器：实现<code>StringTemplate.Processor</code>接口</li>
</ul>
</li>
<li>
<p><strong>类型安全</strong><br>
编译器会检查嵌入表达式的类型，确保其与模板兼容。</p>
</li>
<li>
<p><strong>性能优化</strong><br>
字符串模板在编译时生成高效的字节码，减少运行时开销。</p>
</li>
</ol>
<h3> 2.2 优势：为什么选择字符串模板？</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>传统方式</th>
<th>字符串模板</th>
</tr>
</thead>
<tbody>
<tr>
<td>可读性</td>
<td>低</td>
<td><strong>高</strong></td>
</tr>
<tr>
<td>类型安全性</td>
<td>无</td>
<td><strong>有</strong></td>
</tr>
<tr>
<td>性能</td>
<td>较差</td>
<td><strong>优化</strong></td>
</tr>
<tr>
<td>灵活性</td>
<td>有限</td>
<td><strong>高</strong></td>
</tr>
</tbody>
</table>
<ol>
<li><strong>代码简洁</strong>：减少样板代码，提升开发效率</li>
<li><strong>类型安全</strong>：编译器检查表达式类型，减少运行时错误</li>
<li><strong>性能优化</strong>：编译时生成高效字节码，减少运行时开销</li>
<li><strong>灵活扩展</strong>：支持自定义处理器，满足多样化需求</li>
</ol>
<h2> 3. 使用示例</h2>
<h3> 语法</h3>
<p>字符串模板主要有两种形式：简单字符串模板和带标签的字符串模板。</p>
<p><strong>简单字符串模板</strong></p>
<p>使用 STR 标签来标识字符串模板，在字符串中使用 <code>\{}</code> 语法嵌入表达式。</p>
<p><strong>带标签的字符串模板</strong></p>
<p>除了 STR 标签，我们还可以自定义标签来处理字符串模板。</p>
<ul>
<li>自定义标签是一个方法，它接收一个 TemplateContext 对象和一个 Object[] 数组作为参数。</li>
</ul>
<p>如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例1：基本使用</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例2：多行字符串</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例3：格式化字符串</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 示例4：自定义处理器</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4. 应用场景探索</h2>
<p>字符串模板的特性可以有效的应用在我们实际的业务场景中，如</p>
<h3> 4.1 构建动态消息</h3>
<p>在生成包含动态数据的消息时，字符串模板非常有用。比如生成用户欢迎消息、日志记录信息等。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.2 SQL拼接</h3>
<p>在构建 SQL 查询语句时，经常需要将变量值插入到 SQL 字符串中。使用字符串模板可以使代码更加清晰。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5. 小结</h2>
<h3> 4.1 注意事项</h3>
<ol>
<li>
<p><strong>语法兼容性</strong><br>
字符串模板使用<code>\{...}</code>语法，需确保与现有代码无冲突。</p>
</li>
<li>
<p><strong>处理器选择</strong><br>
根据需求选择合适的处理器，例如：</p>
<ul>
<li><code>STR</code>：普通字符串拼接</li>
<li><code>FMT</code>：格式化字符串</li>
<li>自定义处理器：复杂逻辑处理</li>
</ul>
</li>
<li>
<p><strong>性能测试</strong><br>
在性能敏感场景中，需测试字符串模板的性能表现。对于性能要求较高的场景，建议使用<code>StringBuilder</code>进行手动拼接</p>
</li>
<li>
<p><strong>安全性</strong><br>
使用自定义处理器时，确保对用户输入进行验证和转义，避免安全漏洞。</p>
</li>
<li>
<p><strong>表达式复杂度</strong>
嵌入的表达式应尽量保持简单，避免使用过于复杂的表达式，以免影响代码的可读性。</p>
</li>
<li>
<p><strong>转义字符</strong>
在字符串模板中，需要注意转义字符的使用。如果需要在字符串中包含 <code>\{</code> 或 <code>}</code>，需要进行适当的转义。</p>
</li>
</ol>
<h3> 4.2 总结</h3>
<p>JDK21字符串模板通过以下革新提升Java字符串处理的效率：</p>
<ul>
<li>✅ 简化字符串拼接代码</li>
<li>✅ 提升类型安全性和可读性</li>
<li>✅ 支持多行字符串和格式化</li>
<li>✅ 灵活扩展自定义处理器</li>
</ul>
<p>字符串模板是Java字符串处理的重要扩展，有兴趣的小伙伴可参考<a href="https://openjdk.org/jeps/430" target="_blank" rel="noopener noreferrer">官方文档</a>以掌握最佳实践。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
  </channel>
</rss>