---
order: 14
title: 14.创建一个Langgraph4j实例工程
tag:
  - Spring
  - SpringAI
category:
  - SpringAI
date: 2025-08-12 17:24:07
keywords: SpringAI
---

# 14.创建一个Langgraph4j实例工程

沿用阿里的智能体定义，我们将基于`SpringAI ChatClient`开发的AI应用叫做单智能体应用；对于更复杂的应用场景，比如需要多个工具辅助工作，存在工作流切换的场景（举一个例子：输入一段评价，判断是好评还是差评，如果是好评，则自动回复多谢好评；如果是差评，则提取关键信息，将评价信息转发给人工客服，进行后续的售后维护等）称为多智能体应用

对于多智能体应用，使用python开发的小伙伴，更常接触的是`LangGraph`；对于java的生态下，目前也有两个替代的选择项

- [LangGraphJ](https://github.com/langgraph4j/langgraph4j)
- [阿里智能体](https://java2ai.com/docs/1.0.0.2/get-started/agent/)

接下来我们来体验一下如何使用`LangGraph4J`来进行多智能体的开发

## 一、项目创建

### 1. 创建一个SpringAI项目

创建一个SpringAI项目，基本流程同 [创建一个SpringAI-Demo工程](01.创建一个SpringAI-Demo工程.md)

### 2. 添加Langgraph4j依赖

我们这里以智普大模型作为底层的LLM，因此对应的依赖除了langgraph4j之外就是智普的starter

```xml
<properties>
    <langgraph4j.version>1.6.0-rc4</langgraph4j.version>
</properties>

<dependencies>
    <dependency>
        <groupId>org.bsc.langgraph4j</groupId>
        <artifactId>langgraph4j-springai-agentexecutor</artifactId>
        <version>${langgraph4j.version}</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-starter-model-zhipuai</artifactId>
    </dependency>
</dependencies>
```

### 3. 参数配置

在配置文件中 `application.yml`，设置大模型的访问密钥

```yaml
spring:
  ai:
    zhipuai:
      # api-key 使用你自己申请的进行替换；如果为了安全考虑，可以通过启动参数进行设置
      api-key: ${zhipuai-api-key}
      chat: # 聊天模型
        options:
          model: GLM-4-Flash

# 修改日志级别
logging:
  level:
    org.springframework.ai.chat.client.advisor.SimpleLoggerAdvisor: debug
```

### 4. 创建工具

我们这里创建一个工具类，内部提供两个工具，分别获取当前的时间和天气

```java
/**
 * 根据时区，返回时间的工具
 *
 * @author YiHui
 * @date 2025/8/8
 */
public class TimeWeatherTools {
    @Tool(description = "传入时区，返回对应时区的当前时间给用户")
    public String getTimeByZoneId(@ToolParam(description = "需要查询时间的时区，如Asia/Shanghai, Europe/Paris") ZoneId area) {
        // 根据系统当前时间，获取指定时区的时间
        ZonedDateTime time = ZonedDateTime.now(area);

        // 格式化时间
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String ans = time.format(formatter);
        System.out.println("传入的时区是：" + area + "-" + ans);
        return ans;
    }

    @Tool(description = "传入地点，返回对应地点的当前天气给用户")
    public String getWeatherByZoneId(@ToolParam(description = "需要查询天气的地区，如北京、上海") String area) {
        List<String> weathers = List.of("晴", "阴", "雨", "雪", "雷", "雾");
        String ans = weathers.get((int) (Math.random() * weathers.size()));
        System.out.println("传入的地点是：" + area + "-" + ans);
        return ans;
    }
}
```

### 5. 创建智能体

我们直接沿用官方的demo示例，来创建一个采用`langGraph4j`实现的基于智普大模型的智能体

![](/imgs/column/springai/14-1.webp)

```java
@RestController
public class ChatController {
    private final CompiledGraph<AgentExecutor.State> workflow;

    public ChatController(ChatModel chatModel) throws GraphStateException {
        workflow = AgentExecutor.builder()
                .chatModel(chatModel)
                .toolsFromObject(new TimeWeatherTools())
                .build()
                .compile();
    }
}
```

### 6. 测试验证

在上面的Controller中，定义一个访问端点，实现智能体的访问

```java
@RestController
public class ChatController {
    /**
     * 通过agent方式访问大模型
     *
     * @param msg
     * @return
     */
    @GetMapping("/chat")
    public Object chat(String msg) {
        AgentExecutor.State last = null;
        int i = 0;
        for (NodeOutput<AgentExecutor.State> item : workflow.stream(Map.of("messages", new UserMessage(msg)))) {
            System.out.println(item);
            last = item.state();
            System.out.printf("%02d : %s%n", i++, toStr(last.messages()));
        }

        // 返回最后一条消息
        return last.lastMessage().map(Content::getText).orElse("NoData");
    }

    public String toStr(Object obj) {
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            return objectMapper.writeValueAsString(obj);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
    }
}
```
![](/imgs/column/springai/14-2.webp)

从上面的输出也可以看出，大模型有四次的工具调用，一次是获取北京当前时间，一次是获取北京当前天气，一次是获取伦敦当前时间，一次是获取伦敦当前天气

直接使用`langGraph4j`实现多轮对话，虽然效果是实现了，从直观感觉上和SpringAI的ChatClient好像没有太大的差别

对`langGraph4j`不太了解的小伙伴，可能会有很多疑问，工作流体现在什么地方呢，条件决策又该如何使用呢？这个框架是怎么工作的呢？又该如何使用它来开发Agent呢？

## 二、总结

`LangGraph4j` 是一个 Java 库，用于构建基于大型语言模型 (LLM) 的有状态多代理应用程序。它受 `Python` 库 `LangGraph` 的启发，旨在与 `Langchain4j` 和 `Spring AI` 等流行的 `Java LLM` 框架无缝协作。

LangGraph4j 的核心功能是定义循环图，使不同的组件（代理、工具或自定义逻辑）能够以有状态的方式进行交互

本文只能算是初步看了一眼`LangGraph4j`，演示了如何创建一个智能体开发的项目，接下来我们将逐渐深入探究一下这个框架的使用理念

文中所有涉及到的代码，可以到项目中获取 [https://github.com/liuyueyi/spring-ai-demo](https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects/A05-agent-langgraph-simple)
