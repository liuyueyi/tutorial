---
order: 2
title: LLM应用开发进阶大纲
tag:
  - LLM
category:
  - LLM
date: 2025-12-30 09:15:07
keywords: LLM应用开发
---

## 前言

### 为什么你“会用 LLM”，但做不出复杂应用？

* 为什么调得好 Prompt ≠ 系统就稳定？
* 为什么多数 Demo 无法上线？
* 本书解决什么问题、不解决什么问题

### 本书的学习路径说明

* 你需要什么基础？
* 每一模块学完你“能做什么”
* 推荐的学习与实践方式

---

# 第一部分｜重新认识 LLM：不是模型问题，而是系统问题

> **目标：建立“工程师视角”的 LLM 认知模型**

---

## 第 1 章：LLM 到底在做什么？（程序员版认知重建）

### 1.1 一个反直觉的问题：LLM 真的“理解”语言吗？

* 如果它不理解，为什么还能推理？
* “下一个 token 预测”到底意味着什么？

### 1.2 从函数视角理解 LLM

* LLM ≈ `f(context) → token`
* 为什么上下文就是一切？
* 为什么 prompt 是“代码”？

📊 **图：Token 预测与采样机制示意图（mermaid）**

---

### 1.3 你必须接受的事实：LLM 天生不可靠

* 什么是幻觉？为什么无法彻底消除？
* “不知道”为什么是最难的答案？

📊 **图：无约束生成 vs 受约束生成对比图**

---

### 1.4 第一性原理总结

* LLM 擅长什么？
* LLM 永远不该做什么？
* 哪些问题必须交给系统解决？

---

## 第 2 章：模型不是重点，参数才是你真正的控制面板

### 2.1 一个问题：为什么同一个 Prompt 效果忽好忽坏？

* 随机性从哪来？
* temperature / top_p 在“干什么”？

### 2.2 参数 ≠ 配置，而是策略

* 不同任务的参数决策逻辑
* 为什么大多数人“乱调参”？

📊 **图：任务类型 → 参数决策树**

---

### 2.3 API 调用的本质结构

* messages 是“状态机”
* system role 真正的权力边界

🧪 示例：最小多轮对话实现（伪代码）

---

# 第二部分｜Prompt 工程：让模型“稳定干活”的第一道防线

> **目标：从“写提示词”升级为“设计 Prompt 结构”**

---

## 第 3 章：Prompt 为什么会失败？

### 3.1 一个常见误区：Prompt 写得越长越好？

* 模糊 ≠ 自由
* 细节 ≠ 噪声

### 3.2 Prompt 的三条工程原则

* 清晰性
* 约束性
* 可复用性

📊 **图：坏 Prompt vs 好 Prompt 结构对比**

---

## 第 4 章：从 Zero-shot 到 Few-shot 的设计思维

### 4.1 什么时候你真的需要 Few-shot？

* 模型不会“猜你的规则”

### 4.2 示例驱动 Prompt 的本质

* 示例是在教模型“判题规则”

🧪 示例：文本分类 / 数据抽取 Prompt 演进过程

---

## 第 5 章：Prompt 模板化与工程落地

### 5.1 为什么 Prompt 必须版本化？

* Prompt 就是代码

### 5.2 通用 Prompt 模板结构

* Role
* Task
* Constraints
* Output Schema

📊 **图：Prompt 模板结构图**

---

# 第三部分｜上下文与记忆：对话为什么会“失忆”？

> **目标：掌握对话系统设计，而不是堆 messages**

---

## 第 6 章：上下文窗口的真实边界

### 6.1 上下文不是“无限内存”

* Token 成本、性能与遗忘

### 6.2 为什么长对话一定会崩？

📊 **图：上下文窗口滚动与信息丢失示意图**

---

## 第 7 章：三种记忆策略的工程取舍

### 7.1 短期记忆：直接塞上下文

### 7.2 摘要记忆：用 LLM 管 LLM

### 7.3 长期记忆：向量化存储历史

📊 **图：短 / 中 / 长期记忆系统架构对比**

🧪 示例：对话摘要生成伪代码

---

## 第 8 章：上下文工程（Context Engineering）

### 8.1 什么信息值得留下？

### 8.2 信息如何“压缩但不失真”？

### 8.3 结构化上下文设计模式

📊 **图：结构化上下文拼装流程图**

---

# 第四部分｜能力扩展：让 LLM 走出“纯聊天”

> **目标：让 LLM 接入真实世界，而不是只会说话**

---

## 第 9 章：为什么单靠 LLM 永远不够？

### 9.1 知识截止的问题

### 9.2 无状态的问题

### 9.3 无执行能力的问题

📊 **图：LLM 核心缺陷总览**

---

## 第 10 章：Function Calling —— LLM 的“决策大脑”

### 10.1 模型是如何“选择工具”的？

### 10.2 Schema 设计的关键原则

* 函数不是越多越好

📊 **图：Function Calling 全流程闭环**

🧪 示例：天气 / 数据库查询工具调用

---

## 第 11 章：RAG —— 企业级 LLM 的地基

### 11.1 为什么 RAG 不是“外挂知识库”？

### 11.2 RAG 解决的是哪一类问题？

📊 **图：RAG 离线 + 在线全流程图**

---

### 11.3 文档 → Chunk → Embedding 的关键设计点

* 切多大才合理？
* 为什么分割决定效果上限？

### 11.4 检索失败的真实原因

* 不是模型问题，而是数据问题

🧪 示例：最小 RAG 原型（伪代码）

---

# 第五部分｜Agent 思维：从调用模型到构建系统

> **目标：理解“智能体”不是框架，而是架构模式**

---

## 第 12 章：什么是 Agent？它和 Prompt 的本质区别

### 12.1 为什么 CoT ≠ Agent？

### 12.2 ReAct / Plan-Execute 的本质抽象

📊 **图：Agent 推理循环结构图**

---

## 第 13 章：一个 Agent 的最小系统结构

* 输入解析
* 状态管理
* 工具调度
* 结果评估

📊 **图：Agent 系统架构全景图**

---

## 第 14 章：失败的 Agent 都失败在哪？

* 无限循环
* 工具滥用
* 目标漂移

🧪 示例：Agent 失败案例拆解

---

# 第六部分｜实战：从 Demo 到“可上线系统”

> **目标：真正跑起来，而不是只在 Notebook 里成功**

---

## 第 15 章：实战一：可控的多轮对话助手

* Prompt + 记忆 + 参数策略

## 第 16 章：实战二：企业知识库问答系统（RAG）

* 文档接入
* 检索优化
* 引用溯源

## 第 17 章：实战三：工具驱动型 Agent

* Function Calling
* 状态管理
* 错误恢复

---

# 终章｜下一步你该学什么？

* 什么时候该微调？
* 什么时候该换模型？
* LLM 应用的长期演进方向

---

## 📌 附录

* Prompt 模板速查表
* RAG 参数调优清单
* Agent 架构设计 Checklist
* 常见坑位与反模式总结
